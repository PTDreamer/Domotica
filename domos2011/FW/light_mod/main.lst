CCS PCH C Compiler, Version 4.106, 32200               02-Jun-11 15:42

               Filename: C:\Users\Xapo\Documents\Electronica\domos2011\FW\light_mod\main.lst

               ROM used: 11914 bytes (12%)
                         Largest free fragment is 53618
               RAM used: 1016 (31%) at main() level
                         1144 (34%) worst case
               Stack:    7 worst case (3 in main + 4 for interrupts)

*
00000:  GOTO   294A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0D5E
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0D82
00074:  BTFSS  FF2.4
00076:  GOTO   0080
0007A:  BTFSC  FF2.1
0007C:  GOTO   0D8A
00080:  BTFSS  F9D.5
00082:  GOTO   008C
00086:  BTFSC  F9E.5
00088:  GOTO   0ED2
0008C:  BTFSS  F9D.4
0008E:  GOTO   0098
00092:  BTFSC  F9E.4
00094:  GOTO   0ED8
00098:  BTFSS  F9D.2
0009A:  GOTO   00A4
0009E:  BTFSC  F9E.2
000A0:  GOTO   18E6
000A4:  BTFSS  FA0.3
000A6:  GOTO   00B0
000AA:  BTFSC  FA1.3
000AC:  GOTO   0EDE
000B0:  BTFSS  FA3.7
000B2:  GOTO   00BC
000B6:  BTFSC  FA4.7
000B8:  GOTO   18DA
000BC:  BTFSS  FA3.5
000BE:  GOTO   00C8
000C2:  BTFSC  FA4.5
000C4:  GOTO   18E0
000C8:  BTFSS  FA3.4
000CA:  GOTO   00D4
000CE:  BTFSC  FA4.4
000D0:  GOTO   18D2
000D4:  BTFSS  FA3.3
000D6:  GOTO   00E0
000DA:  BTFSC  FA4.3
000DC:  GOTO   18CA
000E0:  BTFSS  FA3.2
000E2:  GOTO   00EC
000E6:  BTFSC  FA4.2
000E8:  GOTO   18C2
000EC:  BTFSS  FA3.1
000EE:  GOTO   00F8
000F2:  BTFSC  FA4.1
000F4:  GOTO   149A
000F8:  BTFSS  FA3.0
000FA:  GOTO   0104
000FE:  BTFSC  FA4.0
00100:  GOTO   1492
00104:  BTFSS  FA0.7
00106:  GOTO   0110
0010A:  BTFSC  FA1.7
0010C:  GOTO   0EE4
00110:  MOVFF  0E,00
00114:  MOVFF  0F,01
00118:  MOVFF  10,02
0011C:  MOVFF  11,03
00120:  MOVFF  0C,FE9
00124:  MOVFF  07,FEA
00128:  BSF    07.7
0012A:  MOVFF  08,FE1
0012E:  MOVFF  09,FE2
00132:  MOVFF  0A,FD9
00136:  MOVFF  0B,FDA
0013A:  MOVFF  12,FF3
0013E:  MOVFF  13,FF4
00142:  MOVFF  14,FFA
00146:  MOVFF  15,FF5
0014A:  MOVFF  16,FF6
0014E:  MOVFF  17,FF7
00152:  MOVFF  18,FF8
00156:  MOVFF  19,FFB
0015A:  MOVF   04,W
0015C:  MOVFF  06,FE0
00160:  MOVFF  05,FD8
00164:  RETFIE 0
....................  
.................... #include "main.h" 
.................... #include <18F4685.h> 
.................... //////// Standard Header file for the PIC18F4685 device //////////////// 
.................... #device PIC18F4685 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES H4                    	//High speed osc with HW enabled 4X PLL 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT              	//Reset when brownout detected 
.................... #FUSES BORV20                	//Brownout reset at 2.0V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES BBSIZ4K               	//4K words Boot Block size 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=40000000,RESTART_WDT) 
*
0260A:  MOVLW  03
0260C:  MOVWF  FEA
0260E:  MOVLW  F7
02610:  MOVWF  FE9
02612:  MOVF   FEF,W
02614:  BZ    2638
02616:  MOVLW  0C
02618:  MOVWF  01
0261A:  MOVLW  BF
0261C:  MOVWF  00
0261E:  CLRWDT
02620:  DECFSZ 00,F
02622:  BRA    261E
02624:  DECFSZ 01,F
02626:  BRA    261A
02628:  MOVLW  F7
0262A:  MOVWF  00
0262C:  DECFSZ 00,F
0262E:  BRA    262C
02630:  NOP   
02632:  CLRWDT
02634:  DECFSZ FEF,F
02636:  BRA    2616
02638:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B5,rcv=PIN_B4,bits=8,restart_wdt) 
*
01BEA:  BCF    F93.5
01BEC:  BCF    F8A.5
01BEE:  MOVLW  08
01BF0:  MOVWF  01
01BF2:  BRA    1BF4
01BF4:  NOP   
01BF6:  BSF    01.7
01BF8:  BRA    1C1A
01BFA:  BCF    01.7
01BFC:  MOVLB  4
01BFE:  RRCF   x4A,F
01C00:  MOVLB  0
01C02:  BTFSC  FD8.0
01C04:  BSF    F8A.5
01C06:  BTFSS  FD8.0
01C08:  BCF    F8A.5
01C0A:  BSF    01.6
01C0C:  BRA    1C1A
01C0E:  BCF    01.6
01C10:  DECFSZ 01,F
01C12:  BRA    1BFC
01C14:  BRA    1C16
01C16:  NOP   
01C18:  BSF    F8A.5
01C1A:  MOVLW  01
01C1C:  MOVWF  00
01C1E:  CLRF   FE9
01C20:  DECFSZ FE9,F
01C22:  BRA    1C20
01C24:  DECFSZ 00,F
01C26:  BRA    1C1E
01C28:  MOVLW  53
01C2A:  MOVWF  FE9
01C2C:  DECFSZ FE9,F
01C2E:  BRA    1C2C
01C30:  BRA    1C32
01C32:  CLRWDT
01C34:  BTFSC  01.7
01C36:  BRA    1BFA
01C38:  BTFSC  01.6
01C3A:  BRA    1C0E
01C3C:  RETLW  00
....................  
....................  
.................... #include "C:\Users\Programacao\Documents\CCS_Projects\18F\LightMod\global_defs.h" 
.................... #define  NUMBER_OF_SWITCHES 8 
.................... #define  LED PIN_E2 
.................... #define  OUT1  PIN_C0 
.................... #define  OUT2  PIN_C1 
.................... #define  OUT3  PIN_C2 
.................... #define  OUT4  PIN_C3 
.................... #define  OUT5  PIN_C4 
.................... #define  OUT6  PIN_C5 
.................... #define  OUT7  PIN_C6 
.................... #define  OUT8  PIN_C7 
.................... #define  OUT9  PIN_D1 
.................... #define  OUT10  PIN_D0 
.................... #define  OUT11  PIN_D2 
.................... #define  OUT12  PIN_D3 
.................... #define  OUT13  PIN_D7 
.................... #define  OUT14  PIN_D6 
.................... #define  OUT15  PIN_D5 
.................... #define  OUT16  PIN_D4 
.................... #define  INP1  PIN_A0 
.................... #define  INP2  PIN_A1 
.................... #define  INP3  PIN_A2 
.................... #define  INP4  PIN_A3 
.................... #define  INP5  PIN_A4 
.................... #define  INP6  PIN_A5 
.................... #define  INP7  PIN_E0 
.................... #define  INP8  PIN_E1 
....................  
.................... #byte porta=0xf80 
.................... #byte portb=0xf81 
.................... #byte portc=0xf82 
.................... #byte portd=0xf83 
.................... #byte porte=0xf84 
.................... #byte trisa=0xf92 
.................... #byte trisb=0xf93 
.................... #byte trisc=0xf94 
.................... #byte trisd=0xf95 
.................... #byte trise=0xf96 
....................  
.................... static int inputs[8]={INP1,INP2,INP3,INP4,INP5,INP6,INP7,INP8}; 
....................  
.................... #include "C:\Users\Programacao\Documents\CCS_Projects\18F\LightMod\can_functions.c" 
.................... #define CAN_USE_EXTENDED_ID FALSE 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = 0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = 0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT=0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1=0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2=0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3=0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive caputre 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON=0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON=0xF40 
.................... #byte   TXB1CON=0xF30 
.................... #byte   TXB2CON=0xF20 
.................... #byte TXBaCON=0xF60 //txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH=0xF41 
.................... #byte TXB0SIDL=0xF42 
.................... #byte TXB1SIDH=0xF31 
.................... #byte TXB1SIDL=0xF32 
.................... #byte TXB2SIDH=0xF21 
.................... #byte TXB2SIDL=0xF22 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH=0xF43 
.................... #byte TXB0EIDL=0xF44 
.................... #byte TXB1EIDH=0xF33 
.................... #byte TXB1EIDL=0xF34 
.................... #byte TXB2EIDH=0xF23 
.................... #byte TXB2EIDL=0xF24 
....................  
.................... #define RX0MASK      0xF1B    //rxm0eidl 
.................... #define RX1MASK      0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   0xF03    //rxf0eidl 
.................... #define RX0FILTER1   0xF07    //rxf1eidl 
.................... #define RX1FILTER2   0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   0xF13    //rxf4eidl 
.................... #define RX1FILTER5   0xF17    //rxf5eidl 
.................... #define RXB0ID       0xF64    //rxb0eidl 
.................... #define RXB1ID       0xF54    //rxb1eidl 
.................... #define TXB0ID       0xF44    //txb0eidl 
.................... #define TXB1ID       0xF34    //txb1eidl 
.................... #define TXB2ID       0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0=0xF46 
.................... #byte TXB0D7=0xF4D 
.................... #byte TXB1D0=0xF36 
.................... #byte TXB1D7=0xF3D 
.................... #byte TXB2D0=0xF26 
.................... #byte TXB2D7=0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC=0xF45 
.................... #byte TXB1DLC=0xF35 
.................... #byte TXB2DLC=0xF25 
.................... #byte TXBaDLC=0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON=0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON=0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH=0xF61 
.................... #byte   RXB0SIDL=0xF62 
.................... #byte   RXB1SIDH=0xF51 
.................... #byte   RXB1SIDL=0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH=0xF63 
.................... #byte   RXB0EIDL=0xF64 
.................... #byte   RXB1EIDH=0xF53 
.................... #byte   RXB1EIDL=0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC=0xF65 
.................... #byte   RXB1DLC=0xF55 
.................... #byte   RXBaDLC=0xF65 
....................  
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0=0xF66 
.................... #byte RXB0D7=0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT=0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH=0xF00 
.................... #byte RXF0SIDL=0xF01 
.................... #byte RXF1SIDH=0xF04 
.................... #byte RXF1SIDL=0xF05 
.................... #byte RXF2SIDH=0xF08 
.................... #byte RXF2SIDL=0xF09 
.................... #byte RXF3SIDH=0xF0C 
.................... #byte RXF3SIDL=0xF0D 
.................... #byte RXF4SIDH=0xF10 
.................... #byte RXF4SIDL=0xF11 
.................... #byte RXF5SIDH=0xF14 
.................... #byte RXF5SIDL=0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH=0xF02 
.................... #byte RXF0EIDL=0xF03 
.................... #byte RXF1EIDH=0xF06 
.................... #byte RXF1EIDL=0xF07 
.................... #byte RXF2EIDH=0xF0A 
.................... #byte RXF2EIDL=0xF0B 
.................... #byte RXF3EIDH=0xF0E 
.................... #byte RXF3EIDL=0xF0F 
.................... #byte RXF4EIDH=0xF12 
.................... #byte RXF4EIDL=0xF13 
.................... #byte RXF5EIDH=0xF16 
.................... #byte RXF5EIDL=0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH=0xF18 
.................... #byte RXM0SIDL=0xF19 
.................... #byte RXM1SIDH=0xF1C 
.................... #byte RXM1SIDL=0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH=0xF1A 
.................... #byte RXM0EIDL=0xF1B 
.................... #byte RXM1EIDH=0xF1E 
.................... #byte RXM1EIDL=0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = 0xFA4.7 
.................... #bit CAN_INT_WAKIF = 0xFA4.6 
.................... #bit CAN_INT_ERRIF = 0xFA4.5 
.................... #bit CAN_INT_TXB2IF = 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(int* addr, int32 id, int1 ext); 
.................... int32 can_get_id(int * addr, int1 ext); 
.................... int   can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(int32 & id, int * data, int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
01A96:  MOVLW  04
01A98:  MOVLB  3
01A9A:  MOVWF  xF6
01A9C:  MOVLB  0
01A9E:  RCALL  1A40
....................    can_set_baud(); 
01AA0:  BRA    1A66
....................  
....................    RXB0CON=0; 
01AA2:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
01AA4:  MOVLW  9F
01AA6:  ANDWF  F60,W
01AA8:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
01AAA:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
01AAC:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
01AB0:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
01AB2:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
01AB4:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
01AB6:  BCF    F73.6
01AB8:  CLRF   1B
01ABA:  BTFSC  FF2.7
01ABC:  BSF    1B.7
01ABE:  BCF    FF2.7
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
01AC0:  MOVLW  0F
01AC2:  MOVLB  4
01AC4:  MOVWF  x6C
01AC6:  MOVLW  1B
01AC8:  MOVWF  x6B
01ACA:  CLRF   x70
01ACC:  CLRF   x6F
01ACE:  CLRF   x6E
01AD0:  CLRF   x6D
01AD2:  CLRF   x71
01AD4:  MOVLB  0
01AD6:  RCALL  14A2
01AD8:  BTFSC  1B.7
01ADA:  BSF    FF2.7
01ADC:  CLRF   1B
01ADE:  BTFSC  FF2.7
01AE0:  BSF    1B.7
01AE2:  BCF    FF2.7
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
01AE4:  MOVLW  0F
01AE6:  MOVLB  4
01AE8:  MOVWF  x6C
01AEA:  MOVLW  03
01AEC:  MOVWF  x6B
01AEE:  CLRF   x70
01AF0:  CLRF   x6F
01AF2:  CLRF   x6E
01AF4:  CLRF   x6D
01AF6:  CLRF   x71
01AF8:  MOVLB  0
01AFA:  RCALL  14A2
01AFC:  BTFSC  1B.7
01AFE:  BSF    FF2.7
01B00:  CLRF   1B
01B02:  BTFSC  FF2.7
01B04:  BSF    1B.7
01B06:  BCF    FF2.7
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
01B08:  MOVLW  0F
01B0A:  MOVLB  4
01B0C:  MOVWF  x6C
01B0E:  MOVLW  07
01B10:  MOVWF  x6B
01B12:  CLRF   x70
01B14:  CLRF   x6F
01B16:  CLRF   x6E
01B18:  CLRF   x6D
01B1A:  CLRF   x71
01B1C:  MOVLB  0
01B1E:  RCALL  14A2
01B20:  BTFSC  1B.7
01B22:  BSF    FF2.7
01B24:  CLRF   1B
01B26:  BTFSC  FF2.7
01B28:  BSF    1B.7
01B2A:  BCF    FF2.7
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
01B2C:  MOVLW  0F
01B2E:  MOVLB  4
01B30:  MOVWF  x6C
01B32:  MOVLW  1F
01B34:  MOVWF  x6B
01B36:  CLRF   x70
01B38:  CLRF   x6F
01B3A:  CLRF   x6E
01B3C:  CLRF   x6D
01B3E:  CLRF   x71
01B40:  MOVLB  0
01B42:  RCALL  14A2
01B44:  BTFSC  1B.7
01B46:  BSF    FF2.7
01B48:  CLRF   1B
01B4A:  BTFSC  FF2.7
01B4C:  BSF    1B.7
01B4E:  BCF    FF2.7
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
01B50:  MOVLW  0F
01B52:  MOVLB  4
01B54:  MOVWF  x6C
01B56:  MOVLW  0B
01B58:  MOVWF  x6B
01B5A:  CLRF   x70
01B5C:  CLRF   x6F
01B5E:  CLRF   x6E
01B60:  CLRF   x6D
01B62:  CLRF   x71
01B64:  MOVLB  0
01B66:  RCALL  14A2
01B68:  BTFSC  1B.7
01B6A:  BSF    FF2.7
01B6C:  CLRF   1B
01B6E:  BTFSC  FF2.7
01B70:  BSF    1B.7
01B72:  BCF    FF2.7
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
01B74:  MOVLW  0F
01B76:  MOVLB  4
01B78:  MOVWF  x6C
01B7A:  MOVWF  x6B
01B7C:  CLRF   x70
01B7E:  CLRF   x6F
01B80:  CLRF   x6E
01B82:  CLRF   x6D
01B84:  CLRF   x71
01B86:  MOVLB  0
01B88:  RCALL  14A2
01B8A:  BTFSC  1B.7
01B8C:  BSF    FF2.7
01B8E:  CLRF   1B
01B90:  BTFSC  FF2.7
01B92:  BSF    1B.7
01B94:  BCF    FF2.7
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
01B96:  MOVLW  0F
01B98:  MOVLB  4
01B9A:  MOVWF  x6C
01B9C:  MOVLW  13
01B9E:  MOVWF  x6B
01BA0:  CLRF   x70
01BA2:  CLRF   x6F
01BA4:  CLRF   x6E
01BA6:  CLRF   x6D
01BA8:  CLRF   x71
01BAA:  MOVLB  0
01BAC:  RCALL  14A2
01BAE:  BTFSC  1B.7
01BB0:  BSF    FF2.7
01BB2:  CLRF   1B
01BB4:  BTFSC  FF2.7
01BB6:  BSF    1B.7
01BB8:  BCF    FF2.7
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
01BBA:  MOVLW  0F
01BBC:  MOVLB  4
01BBE:  MOVWF  x6C
01BC0:  MOVLW  17
01BC2:  MOVWF  x6B
01BC4:  CLRF   x70
01BC6:  CLRF   x6F
01BC8:  CLRF   x6E
01BCA:  CLRF   x6D
01BCC:  CLRF   x71
01BCE:  MOVLB  0
01BD0:  RCALL  14A2
01BD2:  BTFSC  1B.7
01BD4:  BSF    FF2.7
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
01BD6:  MOVF   F93,W
01BD8:  ANDLW  FB
01BDA:  IORLW  08
01BDC:  MOVLB  3
01BDE:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
01BE0:  CLRF   xF6
01BE2:  MOVLB  0
01BE4:  RCALL  1A40
.................... } 
01BE6:  GOTO   2B2C (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
01A66:  MOVLW  C0
01A68:  ANDWF  F70,W
01A6A:  IORLW  04
01A6C:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
01A6E:  MOVLW  3F
01A70:  ANDWF  F70,W
01A72:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
01A74:  MOVLW  F8
01A76:  ANDWF  F71,W
01A78:  IORLW  02
01A7A:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
01A7C:  MOVLW  C7
01A7E:  ANDWF  F71,W
01A80:  IORLW  28
01A82:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
01A84:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
01A86:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
01A88:  MOVLW  F8
01A8A:  ANDWF  F72,W
01A8C:  IORLW  05
01A8E:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
01A90:  BCF    F72.6
.................... } 
01A92:  GOTO   1AA2 (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
01A40:  MOVLB  3
01A42:  SWAPF  xF6,W
01A44:  ANDLW  70
01A46:  MOVWF  00
01A48:  BCF    FD8.0
01A4A:  RLCF   00,F
01A4C:  MOVLW  1F
01A4E:  ANDWF  F6F,W
01A50:  IORWF  00,W
01A52:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
01A54:  MOVFF  F6E,00
01A58:  SWAPF  00,F
01A5A:  RRCF   00,W
01A5C:  ANDLW  07
01A5E:  SUBWF  xF6,W
01A60:  BNZ   1A54
.................... } 
01A62:  MOVLB  0
01A64:  RETLW  00
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(int* addr, int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
014A2:  MOVFF  46C,473
014A6:  MOVFF  46B,472
....................  
....................    if (ext) {  //extended 
014AA:  MOVLB  4
014AC:  MOVF   x71,F
014AE:  BZ    1554
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
014B0:  MOVFF  472,FE9
014B4:  MOVFF  473,FEA
014B8:  MOVFF  46D,FEF
....................  
....................       //eidh 
....................       ptr--; 
014BC:  MOVF   x72,W
014BE:  BTFSC  FD8.2
014C0:  DECF   x73,F
014C2:  DECF   x72,F
....................       *ptr=make8(id,1); //8:15 
014C4:  MOVFF  472,FE9
014C8:  MOVFF  473,FEA
014CC:  MOVFF  46E,FEF
....................  
....................       //sidl 
....................       ptr--; 
014D0:  MOVF   x72,W
014D2:  BTFSC  FD8.2
014D4:  DECF   x73,F
014D6:  DECF   x72,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
014D8:  MOVFF  472,FE9
014DC:  MOVFF  473,FEA
014E0:  MOVF   x6F,W
014E2:  ANDLW  03
014E4:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
014E6:  MOVFF  472,FE9
014EA:  MOVFF  473,FEA
014EE:  MOVFF  46F,00
014F2:  RLCF   00,F
014F4:  RLCF   00,F
014F6:  RLCF   00,F
014F8:  MOVLW  F8
014FA:  ANDWF  00,F
014FC:  MOVF   00,W
014FE:  ANDLW  E0
01500:  IORWF  FEF,W
01502:  MOVWF  FEF
....................       *ptr|=0x08; 
01504:  MOVFF  472,FE9
01508:  MOVFF  473,FEA
0150C:  MOVF   FEF,W
0150E:  IORLW  08
01510:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
01512:  MOVF   x72,W
01514:  BTFSC  FD8.2
01516:  DECF   x73,F
01518:  DECF   x72,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
0151A:  MOVFF  472,FE9
0151E:  MOVFF  473,FEA
01522:  MOVFF  46F,00
01526:  SWAPF  00,F
01528:  RRCF   00,F
0152A:  MOVLW  07
0152C:  ANDWF  00,F
0152E:  MOVF   00,W
01530:  ANDLW  07
01532:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
01534:  MOVFF  472,FE9
01538:  MOVFF  473,FEA
0153C:  MOVFF  470,00
01540:  RLCF   00,F
01542:  RLCF   00,F
01544:  RLCF   00,F
01546:  MOVLW  F8
01548:  ANDWF  00,F
0154A:  MOVF   00,W
0154C:  ANDLW  F8
0154E:  IORWF  FEF,W
01550:  MOVWF  FEF
....................    } 
....................    else {   //standard 
01552:  BRA    15D2
....................       //eidl 
....................       *ptr=0; 
01554:  MOVFF  472,FE9
01558:  MOVFF  473,FEA
0155C:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
0155E:  MOVF   x72,W
01560:  BTFSC  FD8.2
01562:  DECF   x73,F
01564:  DECF   x72,F
....................       *ptr=0; 
01566:  MOVFF  472,FE9
0156A:  MOVFF  473,FEA
0156E:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
01570:  MOVF   x72,W
01572:  BTFSC  FD8.2
01574:  DECF   x73,F
01576:  DECF   x72,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
01578:  MOVFF  472,FE9
0157C:  MOVFF  473,FEA
01580:  MOVFF  46D,00
01584:  SWAPF  00,F
01586:  RLCF   00,F
01588:  MOVLW  E0
0158A:  ANDWF  00,F
0158C:  MOVF   00,W
0158E:  ANDLW  E0
01590:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
01592:  MOVF   x72,W
01594:  BTFSC  FD8.2
01596:  DECF   x73,F
01598:  DECF   x72,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
0159A:  MOVFF  472,FE9
0159E:  MOVFF  473,FEA
015A2:  MOVFF  46D,00
015A6:  RRCF   00,F
015A8:  RRCF   00,F
015AA:  RRCF   00,F
015AC:  MOVLW  1F
015AE:  ANDWF  00,F
015B0:  MOVF   00,W
015B2:  ANDLW  1F
015B4:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
015B6:  MOVFF  472,FE9
015BA:  MOVFF  473,FEA
015BE:  MOVFF  46E,00
015C2:  SWAPF  00,F
015C4:  RLCF   00,F
015C6:  MOVLW  E0
015C8:  ANDWF  00,F
015CA:  MOVF   00,W
015CC:  ANDLW  E0
015CE:  IORWF  FEF,W
015D0:  MOVWF  FEF
....................    } 
.................... } 
015D2:  MOVLB  0
015D4:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int32 can_get_id(int * addr, int1 ext) { 
....................    int32 ret; 
....................    int * ptr; 
....................  
....................    ret=0; 
*
00EEA:  MOVLB  4
00EEC:  CLRF   x6D
00EEE:  CLRF   x6C
00EF0:  CLRF   x6B
00EF2:  CLRF   x6A
....................    ptr=addr; 
00EF4:  MOVFF  468,46F
00EF8:  MOVFF  467,46E
....................  
....................    if (ext) { 
00EFC:  MOVF   x69,F
00EFE:  BTFSC  FD8.2
00F00:  BRA    1028
....................       ret=*ptr;  //eidl 
00F02:  MOVFF  46F,03
00F06:  MOVFF  46E,FE9
00F0A:  MOVFF  46F,FEA
00F0E:  MOVFF  FEF,00
00F12:  CLRF   01
00F14:  CLRF   02
00F16:  CLRF   03
00F18:  MOVFF  03,46D
00F1C:  MOVFF  02,46C
00F20:  MOVFF  01,46B
00F24:  MOVFF  00,46A
....................  
....................       ptr--;     //eidh 
00F28:  MOVF   x6E,W
00F2A:  BTFSC  FD8.2
00F2C:  DECF   x6F,F
00F2E:  DECF   x6E,F
....................       ret|=((int32)*ptr << 8); 
00F30:  MOVFF  46E,FE9
00F34:  MOVFF  46F,FEA
00F38:  MOVF   FEF,W
00F3A:  CLRF   x72
00F3C:  CLRF   x71
00F3E:  MOVWF  x70
00F40:  CLRF   00
00F42:  MOVF   00,W
00F44:  IORWF  x6A,F
00F46:  MOVF   x70,W
00F48:  IORWF  x6B,F
00F4A:  MOVF   x71,W
00F4C:  IORWF  x6C,F
00F4E:  MOVF   x72,W
00F50:  IORWF  x6D,F
....................  
....................       ptr--;     //sidl 
00F52:  MOVF   x6E,W
00F54:  BTFSC  FD8.2
00F56:  DECF   x6F,F
00F58:  DECF   x6E,F
....................       ret|=((int32)*ptr & 0x03) << 16; 
00F5A:  MOVFF  46E,FE9
00F5E:  MOVFF  46F,FEA
00F62:  MOVF   FEF,W
00F64:  CLRF   x73
00F66:  CLRF   x72
00F68:  CLRF   x71
00F6A:  MOVWF  x70
00F6C:  MOVLW  03
00F6E:  ANDWF  x70,F
00F70:  CLRF   x71
00F72:  CLRF   x72
00F74:  CLRF   x73
00F76:  CLRF   00
00F78:  CLRF   01
00F7A:  MOVF   00,W
00F7C:  IORWF  x6A,F
00F7E:  MOVF   01,W
00F80:  IORWF  x6B,F
00F82:  MOVF   x70,W
00F84:  IORWF  x6C,F
00F86:  MOVF   x71,W
00F88:  IORWF  x6D,F
....................       ret|=((int32)*ptr & 0xE0) << 13; 
00F8A:  MOVFF  46E,FE9
00F8E:  MOVFF  46F,FEA
00F92:  MOVF   FEF,W
00F94:  CLRF   x73
00F96:  CLRF   x72
00F98:  CLRF   x71
00F9A:  MOVWF  x70
00F9C:  MOVLW  E0
00F9E:  ANDWF  x70,F
00FA0:  CLRF   x71
00FA2:  CLRF   x72
00FA4:  CLRF   x73
00FA6:  CLRF   00
00FA8:  RLCF   x70,W
00FAA:  MOVWF  01
00FAC:  RLCF   x71,W
00FAE:  MOVWF  02
00FB0:  RLCF   x72,W
00FB2:  MOVWF  03
00FB4:  RLCF   01,F
00FB6:  RLCF   02,F
00FB8:  RLCF   03,F
00FBA:  RLCF   01,F
00FBC:  RLCF   02,F
00FBE:  RLCF   03,F
00FC0:  RLCF   01,F
00FC2:  RLCF   02,F
00FC4:  RLCF   03,F
00FC6:  RLCF   01,F
00FC8:  RLCF   02,F
00FCA:  RLCF   03,F
00FCC:  MOVLW  E0
00FCE:  ANDWF  01,F
00FD0:  MOVF   00,W
00FD2:  IORWF  x6A,F
00FD4:  MOVF   01,W
00FD6:  IORWF  x6B,F
00FD8:  MOVF   02,W
00FDA:  IORWF  x6C,F
00FDC:  MOVF   03,W
00FDE:  IORWF  x6D,F
....................  
....................       ptr--;     //sidh 
00FE0:  MOVF   x6E,W
00FE2:  BTFSC  FD8.2
00FE4:  DECF   x6F,F
00FE6:  DECF   x6E,F
....................       ret|=((int32)*ptr << 21); 
00FE8:  MOVFF  46E,FE9
00FEC:  MOVFF  46F,FEA
00FF0:  MOVF   FEF,W
00FF2:  CLRF   x71
00FF4:  MOVWF  x70
00FF6:  CLRF   00
00FF8:  CLRF   01
00FFA:  RLCF   x70,W
00FFC:  MOVWF  02
00FFE:  RLCF   x71,W
01000:  MOVWF  03
01002:  RLCF   02,F
01004:  RLCF   03,F
01006:  RLCF   02,F
01008:  RLCF   03,F
0100A:  RLCF   02,F
0100C:  RLCF   03,F
0100E:  RLCF   02,F
01010:  RLCF   03,F
01012:  MOVLW  E0
01014:  ANDWF  02,F
01016:  MOVF   00,W
01018:  IORWF  x6A,F
0101A:  MOVF   01,W
0101C:  IORWF  x6B,F
0101E:  MOVF   02,W
01020:  IORWF  x6C,F
01022:  MOVF   03,W
01024:  IORWF  x6D,F
....................  
....................    } 
....................    else { 
01026:  BRA    10CE
....................       ptr-=2;    //sidl 
01028:  MOVLW  02
0102A:  SUBWF  x6E,F
0102C:  MOVLW  00
0102E:  SUBWFB x6F,F
....................       ret=((int32)*ptr & 0xE0) >> 5; 
01030:  MOVFF  46E,FE9
01034:  MOVFF  46F,FEA
01038:  MOVF   FEF,W
0103A:  CLRF   x73
0103C:  CLRF   x72
0103E:  CLRF   x71
01040:  MOVWF  x70
01042:  MOVLW  E0
01044:  ANDWF  x70,F
01046:  CLRF   x71
01048:  CLRF   x72
0104A:  CLRF   x73
0104C:  RRCF   x73,W
0104E:  MOVWF  x6D
01050:  RRCF   x72,W
01052:  MOVWF  x6C
01054:  RRCF   x71,W
01056:  MOVWF  x6B
01058:  RRCF   x70,W
0105A:  MOVWF  x6A
0105C:  RRCF   x6D,F
0105E:  RRCF   x6C,F
01060:  RRCF   x6B,F
01062:  RRCF   x6A,F
01064:  RRCF   x6D,F
01066:  RRCF   x6C,F
01068:  RRCF   x6B,F
0106A:  RRCF   x6A,F
0106C:  RRCF   x6D,F
0106E:  RRCF   x6C,F
01070:  RRCF   x6B,F
01072:  RRCF   x6A,F
01074:  RRCF   x6D,F
01076:  RRCF   x6C,F
01078:  RRCF   x6B,F
0107A:  RRCF   x6A,F
0107C:  MOVLW  07
0107E:  ANDWF  x6D,F
....................  
....................       ptr--;     //sidh 
01080:  MOVF   x6E,W
01082:  BTFSC  FD8.2
01084:  DECF   x6F,F
01086:  DECF   x6E,F
....................       ret|=((int32)*ptr << 3); 
01088:  MOVFF  46E,FE9
0108C:  MOVFF  46F,FEA
01090:  MOVF   FEF,W
01092:  CLRF   x73
01094:  CLRF   x72
01096:  CLRF   x71
01098:  MOVWF  x70
0109A:  RLCF   x70,W
0109C:  MOVWF  00
0109E:  RLCF   x71,W
010A0:  MOVWF  01
010A2:  RLCF   x72,W
010A4:  MOVWF  02
010A6:  RLCF   x73,W
010A8:  MOVWF  03
010AA:  RLCF   00,F
010AC:  RLCF   01,F
010AE:  RLCF   02,F
010B0:  RLCF   03,F
010B2:  RLCF   00,F
010B4:  RLCF   01,F
010B6:  RLCF   02,F
010B8:  RLCF   03,F
010BA:  MOVLW  F8
010BC:  ANDWF  00,F
010BE:  MOVF   00,W
010C0:  IORWF  x6A,F
010C2:  MOVF   01,W
010C4:  IORWF  x6B,F
010C6:  MOVF   02,W
010C8:  IORWF  x6C,F
010CA:  MOVF   03,W
010CC:  IORWF  x6D,F
....................    } 
....................  
....................    return(ret); 
010CE:  MOVFF  46A,00
010D2:  MOVFF  46B,01
010D6:  MOVFF  46C,02
010DA:  MOVFF  46D,03
.................... } 
010DE:  MOVLB  0
010E0:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr) { 
....................    int i; 
....................    int * txd0; 
....................    int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
015D6:  MOVLW  0F
015D8:  MOVLB  4
015DA:  MOVWF  x69
015DC:  MOVLW  66
015DE:  MOVWF  x68
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
015E0:  MOVLB  F
015E2:  BTFSC  x40.3
015E4:  BRA    15F6
....................       CANCON.win=CAN_WIN_TX0; 
015E6:  MOVLW  F1
015E8:  ANDWF  F6F,W
015EA:  IORLW  08
015EC:  MOVWF  F6F
....................       port=0; 
015EE:  MOVLB  4
015F0:  CLRF   x6A
....................    } 
....................    else if (!TXB1CON.txreq) { 
015F2:  BRA    162A
015F4:  MOVLB  F
015F6:  BTFSC  x30.3
015F8:  BRA    160C
....................       CANCON.win=CAN_WIN_TX1; 
015FA:  MOVLW  F1
015FC:  ANDWF  F6F,W
015FE:  IORLW  06
01600:  MOVWF  F6F
....................       port=1; 
01602:  MOVLW  01
01604:  MOVLB  4
01606:  MOVWF  x6A
....................    } 
....................    else if (!TXB2CON.txreq) { 
01608:  BRA    162A
0160A:  MOVLB  F
0160C:  BTFSC  x20.3
0160E:  BRA    1622
....................       CANCON.win=CAN_WIN_TX2; 
01610:  MOVLW  F1
01612:  ANDWF  F6F,W
01614:  IORLW  04
01616:  MOVWF  F6F
....................       port=2; 
01618:  MOVLW  02
0161A:  MOVLB  4
0161C:  MOVWF  x6A
....................    } 
....................    else { 
0161E:  BRA    162A
01620:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
01622:  MOVLW  00
01624:  MOVWF  01
01626:  BRA    16A2
01628:  MOVLB  4
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
0162A:  MOVF   x64,W
0162C:  ANDLW  03
0162E:  MOVWF  00
01630:  MOVLW  FC
01632:  ANDWF  F60,W
01634:  IORWF  00,W
01636:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
01638:  MOVLW  0F
0163A:  MOVWF  x6C
0163C:  MOVLW  64
0163E:  MOVWF  x6B
01640:  MOVFF  460,470
01644:  MOVFF  45F,46F
01648:  MOVFF  45E,46E
0164C:  MOVFF  45D,46D
01650:  MOVFF  465,471
01654:  MOVLB  0
01656:  RCALL  14A2
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
01658:  MOVFF  463,F65
....................    TXBaDLC.rtr=rtr; 
0165C:  BCF    F65.6
0165E:  MOVLB  4
01660:  BTFSC  x66.0
01662:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
01664:  CLRF   x67
01666:  MOVF   x63,W
01668:  SUBWF  x67,W
0166A:  BC    1694
....................       *txd0=*data; 
0166C:  MOVFF  461,FE9
01670:  MOVFF  462,FEA
01674:  MOVFF  FEF,46D
01678:  MOVFF  469,FEA
0167C:  MOVFF  468,FE9
01680:  MOVFF  46D,FEF
....................       txd0++; 
01684:  INCF   x68,F
01686:  BTFSC  FD8.2
01688:  INCF   x69,F
....................       data++; 
0168A:  INCF   x61,F
0168C:  BTFSC  FD8.2
0168E:  INCF   x62,F
....................     } 
01690:  INCF   x67,F
01692:  BRA    1666
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
01694:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
01696:  MOVLW  F1
01698:  ANDWF  F6F,W
0169A:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
0169C:  MOVLW  01
0169E:  MOVWF  01
016A0:  MOVLB  F
.................... } 
016A2:  MOVLB  0
016A4:  GOTO   18BA (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(int32 & id, int * data, int & len, struct rx_stat & stat) 
.................... { 
....................     int i; 
....................     int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
010FC:  BTFSS  F60.7
010FE:  BRA    112E
*
01384:  BTFSS  F60.7
01386:  BRA    13B6
....................         CANCON.win=CAN_WIN_RX0; 
*
01100:  MOVLW  F1
01102:  ANDWF  F6F,W
01104:  MOVWF  F6F
*
01388:  MOVLW  F1
0138A:  ANDWF  F6F,W
0138C:  MOVWF  F6F
....................         stat.buffer=0; 
*
01106:  BCF    x50.4
*
0138E:  BCF    x50.4
....................  
....................         CAN_INT_RXB0IF=0; 
*
01108:  BCF    FA4.0
*
01390:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
*
0110A:  BCF    x50.0
0110C:  BTFSC  F74.7
0110E:  BSF    x50.0
*
01392:  BCF    x50.0
01394:  BTFSC  F74.7
01396:  BSF    x50.0
....................         COMSTAT.rx0ovfl=0; 
*
01110:  BCF    F74.7
*
01398:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
*
01112:  BTFSS  F60.2
01114:  BRA    112C
*
0139A:  BTFSS  F60.2
0139C:  BRA    13B4
....................          stat.filthit=RXB0CON.filthit0; 
*
01116:  MOVLW  00
01118:  BTFSC  F60.0
0111A:  MOVLW  01
0111C:  ANDLW  07
0111E:  MOVWF  00
01120:  BCF    FD8.0
01122:  RLCF   00,F
01124:  MOVLW  F1
01126:  ANDWF  x50,W
01128:  IORWF  00,W
0112A:  MOVWF  x50
*
0139E:  MOVLW  00
013A0:  BTFSC  F60.0
013A2:  MOVLW  01
013A4:  ANDLW  07
013A6:  MOVWF  00
013A8:  BCF    FD8.0
013AA:  RLCF   00,F
013AC:  MOVLW  F1
013AE:  ANDWF  x50,W
013B0:  IORWF  00,W
013B2:  MOVWF  x50
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
*
0112C:  BRA    116E
0112E:  MOVLB  F
01130:  BTFSS  x50.7
01132:  BRA    1166
*
013B4:  BRA    13F6
013B6:  MOVLB  F
013B8:  BTFSS  x50.7
013BA:  BRA    13EE
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
*
01134:  MOVLW  F1
01136:  ANDWF  F6F,W
01138:  IORLW  0A
0113A:  MOVWF  F6F
*
013BC:  MOVLW  F1
013BE:  ANDWF  F6F,W
013C0:  IORLW  0A
013C2:  MOVWF  F6F
....................         stat.buffer=1; 
*
0113C:  MOVLB  4
0113E:  BSF    x50.4
*
013C4:  MOVLB  4
013C6:  BSF    x50.4
....................  
....................         CAN_INT_RXB1IF=0; 
*
01140:  BCF    FA4.1
*
013C8:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
*
01142:  BCF    x50.0
01144:  BTFSC  F74.6
01146:  BSF    x50.0
*
013CA:  BCF    x50.0
013CC:  BTFSC  F74.6
013CE:  BSF    x50.0
....................         COMSTAT.rx1ovfl=0; 
*
01148:  BCF    F74.6
*
013D0:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
*
0114A:  MOVLB  F
0114C:  MOVF   x50,W
0114E:  ANDLW  07
01150:  ANDLW  07
01152:  MOVWF  00
01154:  BCF    FD8.0
01156:  RLCF   00,F
01158:  MOVLW  F1
0115A:  MOVLB  4
0115C:  ANDWF  x50,W
0115E:  IORWF  00,W
01160:  MOVWF  x50
*
013D2:  MOVLB  F
013D4:  MOVF   x50,W
013D6:  ANDLW  07
013D8:  ANDLW  07
013DA:  MOVWF  00
013DC:  BCF    FD8.0
013DE:  RLCF   00,F
013E0:  MOVLW  F1
013E2:  MOVLB  4
013E4:  ANDWF  x50,W
013E6:  IORWF  00,W
013E8:  MOVWF  x50
....................     } 
....................     else { 
*
01162:  BRA    116E
01164:  MOVLB  F
*
013EA:  BRA    13F6
013EC:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
01166:  MOVLW  00
01168:  MOVWF  01
0116A:  BRA    1204
0116C:  MOVLB  4
*
013EE:  MOVLW  00
013F0:  MOVWF  01
013F2:  BRA    148C
013F4:  MOVLB  4
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
*
0116E:  MOVF   F65,W
01170:  ANDLW  0F
01172:  MOVWF  x4F
*
013F6:  MOVF   F65,W
013F8:  ANDLW  0F
013FA:  MOVWF  x4F
....................     stat.rtr=RXBaDLC.rtr; 
*
01174:  BCF    x50.5
01176:  BTFSC  F65.6
01178:  BSF    x50.5
*
013FC:  BCF    x50.5
013FE:  BTFSC  F65.6
01400:  BSF    x50.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
*
0117A:  BCF    x50.6
0117C:  BTFSC  F62.3
0117E:  BSF    x50.6
*
01402:  BCF    x50.6
01404:  BTFSC  F62.3
01406:  BSF    x50.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
*
01180:  MOVLW  00
01182:  BTFSC  x50.6
01184:  MOVLW  01
01186:  MOVWF  x60
01188:  MOVLW  0F
0118A:  MOVWF  x68
0118C:  MOVLW  64
0118E:  MOVWF  x67
01190:  MOVFF  460,469
01194:  MOVLB  0
01196:  RCALL  0EEA
01198:  MOVFF  03,44E
0119C:  MOVFF  02,44D
011A0:  MOVFF  01,44C
011A4:  MOVFF  00,44B
*
01408:  MOVLW  00
0140A:  BTFSC  x50.6
0140C:  MOVLW  01
0140E:  MOVWF  x60
01410:  MOVLW  0F
01412:  MOVWF  x68
01414:  MOVLW  64
01416:  MOVWF  x67
01418:  MOVFF  460,469
0141C:  MOVLB  0
0141E:  RCALL  0EEA
01420:  MOVFF  03,44E
01424:  MOVFF  02,44D
01428:  MOVFF  01,44C
0142C:  MOVFF  00,44B
....................  
....................     ptr = &TXRXBaD0; 
*
011A8:  MOVLW  0F
011AA:  MOVLB  4
011AC:  MOVWF  x5F
011AE:  MOVLW  66
011B0:  MOVWF  x5E
*
01430:  MOVLW  0F
01432:  MOVLB  4
01434:  MOVWF  x5F
01436:  MOVLW  66
01438:  MOVWF  x5E
....................     for ( i = 0; i < len; i++ ) { 
*
011B2:  CLRF   x5D
011B4:  MOVF   x4F,W
011B6:  SUBWF  x5D,W
011B8:  BC    11E2
*
0143A:  CLRF   x5D
0143C:  MOVF   x4F,W
0143E:  SUBWF  x5D,W
01440:  BC    146A
....................         *data = *ptr; 
*
011BA:  MOVFF  45E,FE9
011BE:  MOVFF  45F,FEA
011C2:  MOVFF  FEF,462
011C6:  MOVFF  45C,FEA
011CA:  MOVFF  45B,FE9
011CE:  MOVFF  462,FEF
*
01442:  MOVFF  45E,FE9
01446:  MOVFF  45F,FEA
0144A:  MOVFF  FEF,462
0144E:  MOVFF  45C,FEA
01452:  MOVFF  45B,FE9
01456:  MOVFF  462,FEF
....................         data++; 
*
011D2:  INCF   x5B,F
011D4:  BTFSC  FD8.2
011D6:  INCF   x5C,F
*
0145A:  INCF   x5B,F
0145C:  BTFSC  FD8.2
0145E:  INCF   x5C,F
....................         ptr++; 
*
011D8:  INCF   x5E,F
011DA:  BTFSC  FD8.2
011DC:  INCF   x5F,F
*
01460:  INCF   x5E,F
01462:  BTFSC  FD8.2
01464:  INCF   x5F,F
....................     } 
*
011DE:  INCF   x5D,F
011E0:  BRA    11B4
*
01466:  INCF   x5D,F
01468:  BRA    143C
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
*
011E2:  MOVLW  F1
011E4:  ANDWF  F6F,W
011E6:  MOVWF  F6F
*
0146A:  MOVLW  F1
0146C:  ANDWF  F6F,W
0146E:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
*
011E8:  BCF    x50.7
011EA:  BTFSC  FA4.7
011EC:  BSF    x50.7
*
01470:  BCF    x50.7
01472:  BTFSC  FA4.7
01474:  BSF    x50.7
....................     CAN_INT_IRXIF = 0; 
*
011EE:  BCF    FA4.7
*
01476:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
*
011F0:  BTFSS  x50.4
011F2:  BRA    11FC
*
01478:  BTFSS  x50.4
0147A:  BRA    1484
....................       RXB1CON.rxful=0; 
*
011F4:  MOVLB  F
011F6:  BCF    x50.7
*
0147C:  MOVLB  F
0147E:  BCF    x50.7
....................     } 
....................     else { 
*
011F8:  BRA    1200
011FA:  MOVLB  4
*
01480:  BRA    1488
01482:  MOVLB  4
....................       RXB0CON.rxful=0; 
*
011FC:  BCF    F60.7
011FE:  MOVLB  F
*
01484:  BCF    F60.7
01486:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
*
01200:  MOVLW  01
01202:  MOVWF  01
*
01488:  MOVLW  01
0148A:  MOVWF  01
0148C:  MOVLB  4
.................... } 
....................  
....................  
....................  
....................  
.................... /** 
....................  * no comments 
....................  */ 
.................... #define dev1_ze 10 
....................  
.................... #define CAN_RECEIVE_STACK_SIZE 10 
.................... int can_rspoint=0; 
.................... int can_rstack [CAN_RECEIVE_STACK_SIZE] [14]; 
.................... int1 can_rsfull=FALSE; 
.................... #define can_receiver_full() can_rsfull 
.................... #define CAN_TRANSMIT_STACK_SIZE 10 
.................... int can_tspoint=0; 
.................... int can_tstack [CAN_TRANSMIT_STACK_SIZE] [13]; 
.................... int1 can_tsempty=TRUE; 
.................... #define can_transmitter_empty() can_tsempty 
.................... #define CAN_FILTER_SIZE 1 
.................... int32 can_filter [CAN_FILTER_SIZE] = {11}; 
....................  
....................  
.................... void canReceive ( ) 
.................... { 
....................    int32 rx_id; 
....................    int8  rx_len, rx_stat; 
....................    int8  buffer [8]; 
....................    int8  i; 
....................  
....................    if(can_rspoint==-1) 
*
010E2:  MOVF   24,W
010E4:  SUBLW  FF
010E6:  BNZ   10EA
....................       can_rspoint++; 
010E8:  INCF   24,F
....................  
....................    if(can_rspoint < CAN_RECEIVE_STACK_SIZE) 
010EA:  MOVF   24,W
010EC:  SUBLW  09
010EE:  BTFSS  FD8.0
010F0:  BRA    137A
....................    { 
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
010F2:  MOVLW  04
010F4:  MOVLB  4
010F6:  MOVWF  x5C
010F8:  MOVLW  51
010FA:  MOVWF  x5B
....................    { 
....................       int8 j; 
....................       for(j=0;j<CAN_FILTER_SIZE;j++) 
*
01204:  MOVLB  4
01206:  CLRF   x5A
01208:  MOVF   x5A,F
0120A:  BNZ   124C
....................          if(rx_id==can_filter[j]) 
0120C:  MOVF   x5A,W
0120E:  MULLW  04
01210:  MOVF   FF3,W
01212:  CLRF   03
01214:  ADDLW  35
01216:  MOVWF  FE9
01218:  MOVLW  01
0121A:  ADDWFC 03,W
0121C:  MOVWF  FEA
0121E:  MOVFF  FEF,00
01222:  MOVFF  FEC,01
01226:  MOVFF  FEC,02
0122A:  MOVFF  FEC,03
0122E:  MOVF   00,W
01230:  SUBWF  x4B,W
01232:  BNZ   1248
01234:  MOVF   01,W
01236:  SUBWF  x4C,W
01238:  BNZ   1248
0123A:  MOVF   02,W
0123C:  SUBWF  x4D,W
0123E:  BNZ   1248
01240:  MOVF   03,W
01242:  SUBWF  x4E,W
01244:  BNZ   1248
....................             return; 
01246:  BRA    148E
01248:  INCF   x5A,F
0124A:  BRA    1208
....................    } 
....................       can_rstack[can_rspoint][0]=make8(rx_id,3); 
0124C:  MOVF   24,W
0124E:  MULLW  0E
01250:  MOVF   FF3,W
01252:  CLRF   x5C
01254:  MOVWF  x5B
01256:  MOVLW  25
01258:  ADDWF  x5B,W
0125A:  MOVWF  FE9
0125C:  MOVLW  00
0125E:  ADDWFC x5C,W
01260:  MOVWF  FEA
01262:  MOVFF  44E,FEF
....................       can_rstack[can_rspoint][1]=make8(rx_id,2); 
01266:  MOVF   24,W
01268:  MULLW  0E
0126A:  MOVF   FF3,W
0126C:  CLRF   x5C
0126E:  MOVWF  x5B
01270:  MOVLW  01
01272:  ADDWF  x5B,W
01274:  MOVWF  01
01276:  MOVLW  00
01278:  ADDWFC x5C,W
0127A:  MOVWF  03
0127C:  MOVF   01,W
0127E:  ADDLW  25
01280:  MOVWF  FE9
01282:  MOVLW  00
01284:  ADDWFC 03,W
01286:  MOVWF  FEA
01288:  MOVFF  44D,FEF
....................       can_rstack[can_rspoint][2]=make8(rx_id,1); 
0128C:  MOVF   24,W
0128E:  MULLW  0E
01290:  MOVF   FF3,W
01292:  CLRF   x5C
01294:  MOVWF  x5B
01296:  MOVLW  02
01298:  ADDWF  x5B,W
0129A:  MOVWF  01
0129C:  MOVLW  00
0129E:  ADDWFC x5C,W
012A0:  MOVWF  03
012A2:  MOVF   01,W
012A4:  ADDLW  25
012A6:  MOVWF  FE9
012A8:  MOVLW  00
012AA:  ADDWFC 03,W
012AC:  MOVWF  FEA
012AE:  MOVFF  44C,FEF
....................       can_rstack[can_rspoint][3]=make8(rx_id,0); 
012B2:  MOVF   24,W
012B4:  MULLW  0E
012B6:  MOVF   FF3,W
012B8:  CLRF   x5C
012BA:  MOVWF  x5B
012BC:  MOVLW  03
012BE:  ADDWF  x5B,W
012C0:  MOVWF  01
012C2:  MOVLW  00
012C4:  ADDWFC x5C,W
012C6:  MOVWF  03
012C8:  MOVF   01,W
012CA:  ADDLW  25
012CC:  MOVWF  FE9
012CE:  MOVLW  00
012D0:  ADDWFC 03,W
012D2:  MOVWF  FEA
012D4:  MOVFF  44B,FEF
....................  
....................       can_rstack[can_rspoint][4]=rx_len; 
012D8:  MOVF   24,W
012DA:  MULLW  0E
012DC:  MOVF   FF3,W
012DE:  CLRF   x5C
012E0:  MOVWF  x5B
012E2:  MOVLW  04
012E4:  ADDWF  x5B,W
012E6:  MOVWF  01
012E8:  MOVLW  00
012EA:  ADDWFC x5C,W
012EC:  MOVWF  03
012EE:  MOVF   01,W
012F0:  ADDLW  25
012F2:  MOVWF  FE9
012F4:  MOVLW  00
012F6:  ADDWFC 03,W
012F8:  MOVWF  FEA
012FA:  MOVFF  44F,FEF
....................       can_rstack[can_rspoint][5]=rx_stat; 
012FE:  MOVF   24,W
01300:  MULLW  0E
01302:  MOVF   FF3,W
01304:  CLRF   x5C
01306:  MOVWF  x5B
01308:  MOVLW  05
0130A:  ADDWF  x5B,W
0130C:  MOVWF  01
0130E:  MOVLW  00
01310:  ADDWFC x5C,W
01312:  MOVWF  03
01314:  MOVF   01,W
01316:  ADDLW  25
01318:  MOVWF  FE9
0131A:  MOVLW  00
0131C:  ADDWFC 03,W
0131E:  MOVWF  FEA
01320:  MOVFF  450,FEF
....................  
....................       for(i=0;i<rx_len;i++) 
01324:  CLRF   x59
01326:  MOVF   x4F,W
01328:  SUBWF  x59,W
0132A:  BC    1374
....................       { 
....................          can_rstack[can_rspoint][i+6]=buffer[i]; 
0132C:  MOVF   24,W
0132E:  MULLW  0E
01330:  MOVF   FF3,W
01332:  CLRF   x5C
01334:  MOVWF  x5B
01336:  MOVLW  06
01338:  ADDWF  x59,W
0133A:  CLRF   03
0133C:  ADDWF  x5B,W
0133E:  MOVWF  01
01340:  MOVF   x5C,W
01342:  ADDWFC 03,F
01344:  MOVF   01,W
01346:  ADDLW  25
01348:  MOVWF  01
0134A:  MOVLW  00
0134C:  ADDWFC 03,F
0134E:  MOVFF  03,45C
01352:  CLRF   03
01354:  MOVF   x59,W
01356:  ADDLW  51
01358:  MOVWF  FE9
0135A:  MOVLW  04
0135C:  ADDWFC 03,W
0135E:  MOVWF  FEA
01360:  MOVFF  FEF,45D
01364:  MOVFF  45C,FEA
01368:  MOVFF  01,FE9
0136C:  MOVFF  45D,FEF
....................       } 
01370:  INCF   x59,F
01372:  BRA    1326
....................  
....................       can_rspoint++; 
01374:  INCF   24,F
....................    } 
....................    else 
01376:  BRA    148E
01378:  MOVLB  0
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
0137A:  MOVLW  04
0137C:  MOVLB  4
0137E:  MOVWF  x5C
01380:  MOVLW  51
01382:  MOVWF  x5B
.................... } 
*
0148E:  MOVLB  0
01490:  RETLW  00
....................  
....................  
.................... int1 can_Pop ( int32 & rx_id, int * buffer, int & rx_len, int & rx_stat ) 
.................... { 
....................    int i; 
....................  
....................    if(can_rspoint==CAN_RECEIVE_STACK_SIZE) 
....................       can_rspoint--; 
....................  
....................    if(can_rspoint!=-1) 
....................    { 
....................       rx_id=make32(can_rstack[can_rspoint][0], 
....................                   can_rstack[can_rspoint][1], 
....................                   can_rstack[can_rspoint][2], 
....................                   can_rstack[can_rspoint][3]); 
....................  
....................       rx_len=can_rstack[can_rspoint][4]; 
....................       rx_stat=can_rstack[can_rspoint][5]; 
....................  
....................       for(i=0;i<rx_len;i++) 
....................       { 
....................          buffer[i]=can_rstack[can_rspoint][i+6]; 
....................       } 
....................       can_rspoint--; 
....................  
....................       return TRUE; 
....................    }    
....................    else 
....................    return FALSE; 
.................... } 
....................  
.................... void canTransmit ( ) 
.................... { 
....................    int32 tx_id; 
....................    int8  tx_length; 
....................    int8  tx_priority; 
....................    int8  tx_buffer[8]; 
....................    int1  tx_extendedID; 
....................    int1  tx_emptyframe; 
....................    int8  i; 
....................  
....................    if(can_tspoint==CAN_TRANSMIT_STACK_SIZE) 
*
016A8:  MOVF   xB2,W
016AA:  SUBLW  0A
016AC:  BNZ   16B0
....................    { 
....................       can_tspoint--; 
016AE:  DECF   xB2,F
....................    } 
....................  
....................    if(can_tspoint!=-1) 
016B0:  MOVF   xB2,W
016B2:  SUBLW  FF
016B4:  BTFSC  FD8.2
016B6:  BRA    18BE
....................    { 
....................  
....................       tx_id=make32(can_tstack[can_tspoint][0], 
....................                   can_tstack[can_tspoint][1], 
....................                   can_tstack[can_tspoint][2], 
....................                   can_tstack[can_tspoint][3]); 
016B8:  MOVF   xB2,W
016BA:  MULLW  0D
016BC:  MOVF   FF3,W
016BE:  MOVLB  4
016C0:  CLRF   x5C
016C2:  MOVWF  x5B
016C4:  MOVLW  B3
016C6:  ADDWF  x5B,W
016C8:  MOVWF  FE9
016CA:  MOVLW  00
016CC:  ADDWFC x5C,W
016CE:  MOVWF  FEA
016D0:  MOVFF  FEF,45B
016D4:  MOVLB  0
016D6:  MOVF   xB2,W
016D8:  MULLW  0D
016DA:  MOVF   FF3,W
016DC:  MOVLB  4
016DE:  CLRF   x5D
016E0:  MOVWF  x5C
016E2:  MOVLW  01
016E4:  ADDWF  x5C,W
016E6:  MOVWF  01
016E8:  MOVLW  00
016EA:  ADDWFC x5D,W
016EC:  MOVWF  03
016EE:  MOVF   01,W
016F0:  ADDLW  B3
016F2:  MOVWF  FE9
016F4:  MOVLW  00
016F6:  ADDWFC 03,W
016F8:  MOVWF  FEA
016FA:  MOVFF  FEF,45C
016FE:  MOVLB  0
01700:  MOVF   xB2,W
01702:  MULLW  0D
01704:  MOVF   FF3,W
01706:  MOVLB  4
01708:  CLRF   x5E
0170A:  MOVWF  x5D
0170C:  MOVLW  02
0170E:  ADDWF  x5D,W
01710:  MOVWF  01
01712:  MOVLW  00
01714:  ADDWFC x5E,W
01716:  MOVWF  03
01718:  MOVF   01,W
0171A:  ADDLW  B3
0171C:  MOVWF  FE9
0171E:  MOVLW  00
01720:  ADDWFC 03,W
01722:  MOVWF  FEA
01724:  MOVFF  FEF,45D
01728:  MOVLB  0
0172A:  MOVF   xB2,W
0172C:  MULLW  0D
0172E:  MOVF   FF3,W
01730:  MOVLB  4
01732:  CLRF   x5F
01734:  MOVWF  x5E
01736:  MOVLW  03
01738:  ADDWF  x5E,W
0173A:  MOVWF  01
0173C:  MOVLW  00
0173E:  ADDWFC x5F,W
01740:  MOVWF  03
01742:  MOVF   01,W
01744:  ADDLW  B3
01746:  MOVWF  FE9
01748:  MOVLW  00
0174A:  ADDWFC 03,W
0174C:  MOVWF  FEA
0174E:  MOVFF  FEF,45E
01752:  MOVFF  45B,44E
01756:  MOVFF  45C,44D
0175A:  MOVFF  45D,44C
0175E:  MOVFF  45E,44B
....................  
....................       tx_length=can_tstack[can_tspoint][12]>>4; 
01762:  MOVLB  0
01764:  MOVF   xB2,W
01766:  MULLW  0D
01768:  MOVF   FF3,W
0176A:  MOVLB  4
0176C:  CLRF   x5C
0176E:  MOVWF  x5B
01770:  MOVLW  0C
01772:  ADDWF  x5B,W
01774:  MOVWF  01
01776:  MOVLW  00
01778:  ADDWFC x5C,W
0177A:  MOVWF  03
0177C:  MOVF   01,W
0177E:  ADDLW  B3
01780:  MOVWF  FE9
01782:  MOVLW  00
01784:  ADDWFC 03,W
01786:  MOVWF  FEA
01788:  SWAPF  FEF,W
0178A:  MOVWF  x4F
0178C:  MOVLW  0F
0178E:  ANDWF  x4F,F
....................       tx_priority=(can_tstack[can_tspoint][12]&0x0c)>>2; 
01790:  MOVLB  0
01792:  MOVF   xB2,W
01794:  MULLW  0D
01796:  MOVF   FF3,W
01798:  MOVLB  4
0179A:  CLRF   x5C
0179C:  MOVWF  x5B
0179E:  MOVLW  0C
017A0:  ADDWF  x5B,W
017A2:  MOVWF  01
017A4:  MOVLW  00
017A6:  ADDWFC x5C,W
017A8:  MOVWF  03
017AA:  MOVF   01,W
017AC:  ADDLW  B3
017AE:  MOVWF  FE9
017B0:  MOVLW  00
017B2:  ADDWFC 03,W
017B4:  MOVWF  FEA
017B6:  MOVF   FEF,W
017B8:  ANDLW  0C
017BA:  MOVWF  00
017BC:  RRCF   00,W
017BE:  MOVWF  x50
017C0:  RRCF   x50,F
017C2:  MOVLW  3F
017C4:  ANDWF  x50,F
....................       tx_extendedID=bit_test(can_tstack[can_tspoint][12],1); 
017C6:  MOVLB  0
017C8:  MOVF   xB2,W
017CA:  MULLW  0D
017CC:  MOVF   FF3,W
017CE:  MOVLB  4
017D0:  CLRF   x5C
017D2:  MOVWF  x5B
017D4:  MOVLW  0C
017D6:  ADDWF  x5B,W
017D8:  MOVWF  01
017DA:  MOVLW  00
017DC:  ADDWFC x5C,W
017DE:  MOVWF  03
017E0:  MOVF   01,W
017E2:  ADDLW  B3
017E4:  MOVWF  FE9
017E6:  MOVLW  00
017E8:  ADDWFC 03,W
017EA:  MOVWF  FEA
017EC:  MOVFF  FEF,45B
017F0:  BCF    x59.0
017F2:  BTFSC  x5B.1
017F4:  BSF    x59.0
....................       tx_emptyframe=bit_test(can_tstack[can_tspoint][12],0); 
017F6:  MOVLB  0
017F8:  MOVF   xB2,W
017FA:  MULLW  0D
017FC:  MOVF   FF3,W
017FE:  MOVLB  4
01800:  CLRF   x5C
01802:  MOVWF  x5B
01804:  MOVLW  0C
01806:  ADDWF  x5B,W
01808:  MOVWF  01
0180A:  MOVLW  00
0180C:  ADDWFC x5C,W
0180E:  MOVWF  03
01810:  MOVF   01,W
01812:  ADDLW  B3
01814:  MOVWF  FE9
01816:  MOVLW  00
01818:  ADDWFC 03,W
0181A:  MOVWF  FEA
0181C:  MOVFF  FEF,45B
01820:  BCF    x59.1
01822:  BTFSC  x5B.0
01824:  BSF    x59.1
....................  
....................       for(i=0;i<tx_length;i++) 
01826:  CLRF   x5A
01828:  MOVF   x4F,W
0182A:  SUBWF  x5A,W
0182C:  BC    187E
....................       { 
....................          tx_buffer[i]=can_tstack[can_tspoint][i+4]; 
0182E:  CLRF   03
01830:  MOVF   x5A,W
01832:  ADDLW  51
01834:  MOVWF  01
01836:  MOVLW  04
01838:  ADDWFC 03,F
0183A:  MOVFF  01,45B
0183E:  MOVFF  03,45C
01842:  MOVLB  0
01844:  MOVF   xB2,W
01846:  MULLW  0D
01848:  MOVF   FF3,W
0184A:  MOVLB  4
0184C:  CLRF   x5E
0184E:  MOVWF  x5D
01850:  MOVLW  04
01852:  ADDWF  x5A,W
01854:  CLRF   03
01856:  ADDWF  x5D,W
01858:  MOVWF  01
0185A:  MOVF   x5E,W
0185C:  ADDWFC 03,F
0185E:  MOVF   01,W
01860:  ADDLW  B3
01862:  MOVWF  FE9
01864:  MOVLW  00
01866:  ADDWFC 03,W
01868:  MOVWF  FEA
0186A:  MOVFF  FEF,45D
0186E:  MOVFF  45C,FEA
01872:  MOVFF  45B,FE9
01876:  MOVFF  45D,FEF
....................       } 
0187A:  INCF   x5A,F
0187C:  BRA    1828
....................  
....................       can_putd(tx_id,tx_buffer,tx_length,tx_priority,tx_extendedID,tx_emptyframe); 
0187E:  MOVLW  00
01880:  BTFSC  x59.0
01882:  MOVLW  01
01884:  MOVWF  x5B
01886:  MOVLW  00
01888:  BTFSC  x59.1
0188A:  MOVLW  01
0188C:  MOVWF  x5C
0188E:  MOVFF  44E,460
01892:  MOVFF  44D,45F
01896:  MOVFF  44C,45E
0189A:  MOVFF  44B,45D
0189E:  MOVLW  04
018A0:  MOVWF  x62
018A2:  MOVLW  51
018A4:  MOVWF  x61
018A6:  MOVFF  44F,463
018AA:  MOVFF  450,464
018AE:  MOVFF  45B,465
018B2:  MOVFF  45C,466
018B6:  MOVLB  0
018B8:  BRA    15D6
....................  
....................       can_tspoint--; 
018BA:  DECF   xB2,F
....................    } 
....................    else 
018BC:  BRA    18C0
....................       return; 
018BE:  BRA    18C0
.................... } 
018C0:  RETLW  00
....................  
....................  
.................... int1 can_push (int32 tx_id, int8 * tx_buffer, int8 tx_length, int8 tx_priority, int1 tx_extendedID, int1 tx_emptyframe) 
.................... { 
....................    int8  i; 
....................    if(can_tspoint==-1) 
....................       can_tspoint++; 
....................  
....................    if(can_tspoint < CAN_TRANSMIT_STACK_SIZE) 
....................    { 
....................       can_tstack[can_tspoint][0]=make8(tx_id,3); 
....................       can_tstack[can_tspoint][1]=make8(tx_id,2); 
....................       can_tstack[can_tspoint][2]=make8(tx_id,1); 
....................       can_tstack[can_tspoint][3]=make8(tx_id,0); 
....................  
....................       for(i=0;i<tx_length;i++) 
....................       { 
....................          can_tstack[can_tspoint][i+4]=tx_buffer[i]; 
....................       } 
....................  
....................       can_tstack[can_tspoint][12]=(tx_length<<4)|(tx_priority<<2)|((int8)tx_extendedID<<1)|((int8)tx_emptyframe); 
....................  
....................       can_tspoint++; 
....................    } 
.................... } 
....................  
.................... int temp; 
.................... #include "dimming_functions.c" 
.................... #define N_LUZES 16 //numero maximo de dimmers 
.................... int used_dimmers=16; 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
.................... int1 organizado;//flag que diz se os dimmings estao organizados 
.................... int1 actmat;//matriz em uso 
.................... int16 pointer;//apontador para matriz em uso 
.................... int vez;//indice da matriz de dimming corrente 
.................... int mnumluzes;//quantos valores de dimming diferentes temos 
.................... int ltlevel[N_LUZES]={10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10}; 
.................... int16 delays1[N_LUZES+1][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15}; 
.................... int16 delays2[N_LUZES+1][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15}; 
.................... const int16 lights[N_LUZES]={0b1111111011111111,0b1111110111111111,0b1111101111111111,0b1111011111111111,0b1110111111111111,0b1101111111111111,0b1011111111111111,0b0111111111111111, 
....................          /*<........................................................................portC..................................................................................>*/ 
.................... 0b1111111111111110,0b1111111111111101,0b1111111111111011,0b1111111111110111,0b1111111111101111,0b1111111111011111,0b1111111110111111,0b1111111101111111}; 
.................... /*<.................................................................................portD.............................................................>*/ 
.................... const long Matrizluz[128]={ 
.................... 38400,38731 , 38492 , 38253 , 38014 , 37775 , 37536 , 37297 , 37058 , 36819 , 36580 
.................... , 36341 , 36102 , 35863 , 35624 , 35385 , 35146 , 34907 , 34668 , 34429 , 34190 , 33951 
....................  , 33712 , 33473 , 33234 , 32995 , 32756 , 32517 , 32278 , 32039 , 31800 , 31561 , 31322 
....................  , 31083 , 30844 , 30605 , 30366 , 30127 , 29888 , 29649 , 29410 , 29171 , 28932 , 28693 
....................  , 28454 , 28215 , 27976 , 27737 , 27498 , 27259 , 27020 , 26781 , 26542 , 26303 , 26064 
....................  , 25825 , 25586 , 25347 , 25108 , 24869 , 24630 , 24391 , 24152 , 23913 , 23674 , 23435 
....................  , 23196 , 22957 , 22718 , 22479 , 22240 , 22001 , 21762 , 21523 , 21284 , 21045 , 20806 
....................  , 20567 , 20328 , 20089 , 19850 , 19611 , 19372 , 19133 , 18894 , 18655 , 18416 , 18177 
....................  , 17938 , 17699 , 17460 , 17221 , 16982 , 16743 , 16504 , 16265 , 16026 , 15787 , 15548 
....................  , 15309 , 15070 , 14831 , 14592 , 14353 , 14114 , 13875 , 13636 , 13397 , 13158 , 12919 
....................  , 12680 , 12441 , 12202 , 11963 , 11724 , 11485 , 11246 , 11007 , 10768 , 10529 , 10290 
....................  , 10051 , 9812 , 9573 , 9334 , 9095 , 8856 , 617 }; 
....................   
....................   
....................  #INLINE 
....................   INT16 fpointer(int ax,int ay) 
....................    { 
....................       int16 * p; 
....................       p=(pointer + 2* ax * 2 + 2*ay); 
*
00DC0:  BCF    FD8.0
00DC2:  RLCF   x4D,W
00DC4:  MOVWF  00
00DC6:  BCF    FD8.0
00DC8:  RLCF   00,F
00DCA:  MOVF   00,W
00DCC:  MOVLB  1
00DCE:  ADDWF  x3B,W
00DD0:  MOVLB  4
00DD2:  MOVWF  x51
00DD4:  MOVLW  00
00DD6:  MOVLB  1
00DD8:  ADDWFC x3C,W
00DDA:  MOVLB  4
00DDC:  MOVWF  x52
00DDE:  BCF    FD8.0
00DE0:  RLCF   x4E,W
00DE2:  ADDWF  x51,W
00DE4:  MOVWF  x4F
00DE6:  MOVLW  00
00DE8:  ADDWFC x52,W
00DEA:  MOVWF  x50
*
00E58:  BCF    FD8.0
00E5A:  RLCF   x4D,W
00E5C:  MOVWF  00
00E5E:  BCF    FD8.0
00E60:  RLCF   00,F
00E62:  MOVF   00,W
00E64:  MOVLB  1
00E66:  ADDWF  x3B,W
00E68:  MOVLB  4
00E6A:  MOVWF  x51
00E6C:  MOVLW  00
00E6E:  MOVLB  1
00E70:  ADDWFC x3C,W
00E72:  MOVLB  4
00E74:  MOVWF  x52
00E76:  BCF    FD8.0
00E78:  RLCF   x4E,W
00E7A:  ADDWF  x51,W
00E7C:  MOVWF  x4F
00E7E:  MOVLW  00
00E80:  ADDWFC x52,W
00E82:  MOVWF  x50
*
018FC:  BCF    FD8.0
018FE:  RLCF   x4D,W
01900:  MOVWF  00
01902:  BCF    FD8.0
01904:  RLCF   00,F
01906:  MOVF   00,W
01908:  MOVLB  1
0190A:  ADDWF  x3B,W
0190C:  MOVLB  4
0190E:  MOVWF  x51
01910:  MOVLW  00
01912:  MOVLB  1
01914:  ADDWFC x3C,W
01916:  MOVLB  4
01918:  MOVWF  x52
0191A:  BCF    FD8.0
0191C:  RLCF   x4E,W
0191E:  ADDWF  x51,W
01920:  MOVWF  x4F
01922:  MOVLW  00
01924:  ADDWFC x52,W
01926:  MOVWF  x50
*
01984:  BCF    FD8.0
01986:  RLCF   x4D,W
01988:  MOVWF  00
0198A:  BCF    FD8.0
0198C:  RLCF   00,F
0198E:  MOVF   00,W
01990:  MOVLB  1
01992:  ADDWF  x3B,W
01994:  MOVLB  4
01996:  MOVWF  x51
01998:  MOVLW  00
0199A:  MOVLB  1
0199C:  ADDWFC x3C,W
0199E:  MOVLB  4
019A0:  MOVWF  x52
019A2:  BCF    FD8.0
019A4:  RLCF   x4E,W
019A6:  ADDWF  x51,W
019A8:  MOVWF  x4F
019AA:  MOVLW  00
019AC:  ADDWFC x52,W
019AE:  MOVWF  x50
*
02C28:  BCF    FD8.0
02C2A:  RLCF   x4D,W
02C2C:  MOVWF  00
02C2E:  BCF    FD8.0
02C30:  RLCF   00,F
02C32:  MOVF   00,W
02C34:  MOVLB  1
02C36:  ADDWF  x3B,W
02C38:  MOVLB  4
02C3A:  MOVWF  x51
02C3C:  MOVLW  00
02C3E:  MOVLB  1
02C40:  ADDWFC x3C,W
02C42:  MOVLB  4
02C44:  MOVWF  x52
02C46:  BCF    FD8.0
02C48:  RLCF   x4E,W
02C4A:  ADDWF  x51,W
02C4C:  MOVWF  x4F
02C4E:  MOVLW  00
02C50:  ADDWFC x52,W
02C52:  MOVWF  x50
*
02CA2:  BCF    FD8.0
02CA4:  RLCF   x4D,W
02CA6:  MOVWF  00
02CA8:  BCF    FD8.0
02CAA:  RLCF   00,F
02CAC:  MOVF   00,W
02CAE:  MOVLB  1
02CB0:  ADDWF  x3B,W
02CB2:  MOVLB  4
02CB4:  MOVWF  x51
02CB6:  MOVLW  00
02CB8:  MOVLB  1
02CBA:  ADDWFC x3C,W
02CBC:  MOVLB  4
02CBE:  MOVWF  x52
02CC0:  BCF    FD8.0
02CC2:  RLCF   x4E,W
02CC4:  ADDWF  x51,W
02CC6:  MOVWF  x4F
02CC8:  MOVLW  00
02CCA:  ADDWFC x52,W
02CCC:  MOVWF  x50
*
02D74:  BCF    FD8.0
02D76:  RLCF   x4D,W
02D78:  MOVWF  00
02D7A:  BCF    FD8.0
02D7C:  RLCF   00,F
02D7E:  MOVF   00,W
02D80:  MOVLB  1
02D82:  ADDWF  x3B,W
02D84:  MOVLB  4
02D86:  MOVWF  x51
02D88:  MOVLW  00
02D8A:  MOVLB  1
02D8C:  ADDWFC x3C,W
02D8E:  MOVLB  4
02D90:  MOVWF  x52
02D92:  BCF    FD8.0
02D94:  RLCF   x4E,W
02D96:  ADDWF  x51,W
02D98:  MOVWF  x4F
02D9A:  MOVLW  00
02D9C:  ADDWFC x52,W
02D9E:  MOVWF  x50
....................      RETURN *(int16*)(pointer + 2* ax * 2 + 2*ay); 
*
00DEC:  BCF    FD8.0
00DEE:  RLCF   x4D,W
00DF0:  MOVWF  00
00DF2:  BCF    FD8.0
00DF4:  RLCF   00,F
00DF6:  MOVF   00,W
00DF8:  MOVLB  1
00DFA:  ADDWF  x3B,W
00DFC:  MOVLB  4
00DFE:  MOVWF  x51
00E00:  MOVLW  00
00E02:  MOVLB  1
00E04:  ADDWFC x3C,W
00E06:  MOVLB  4
00E08:  MOVWF  x52
00E0A:  BCF    FD8.0
00E0C:  RLCF   x4E,W
00E0E:  ADDWF  x51,W
00E10:  MOVWF  01
00E12:  MOVLW  00
00E14:  ADDWFC x52,W
00E16:  MOVWF  03
00E18:  MOVFF  01,FE9
00E1C:  MOVWF  FEA
00E1E:  MOVFF  FEF,01
00E22:  INCF   FE9,F
00E24:  MOVF   FEF,W
00E26:  DECF   FE9,F
00E28:  MOVWF  02
*
00E84:  BCF    FD8.0
00E86:  RLCF   x4D,W
00E88:  MOVWF  00
00E8A:  BCF    FD8.0
00E8C:  RLCF   00,F
00E8E:  MOVF   00,W
00E90:  MOVLB  1
00E92:  ADDWF  x3B,W
00E94:  MOVLB  4
00E96:  MOVWF  x51
00E98:  MOVLW  00
00E9A:  MOVLB  1
00E9C:  ADDWFC x3C,W
00E9E:  MOVLB  4
00EA0:  MOVWF  x52
00EA2:  BCF    FD8.0
00EA4:  RLCF   x4E,W
00EA6:  ADDWF  x51,W
00EA8:  MOVWF  01
00EAA:  MOVLW  00
00EAC:  ADDWFC x52,W
00EAE:  MOVWF  03
00EB0:  MOVFF  01,FE9
00EB4:  MOVWF  FEA
00EB6:  MOVFF  FEF,01
00EBA:  INCF   FE9,F
00EBC:  MOVF   FEF,W
00EBE:  DECF   FE9,F
00EC0:  MOVWF  02
*
01928:  BCF    FD8.0
0192A:  RLCF   x4D,W
0192C:  MOVWF  00
0192E:  BCF    FD8.0
01930:  RLCF   00,F
01932:  MOVF   00,W
01934:  MOVLB  1
01936:  ADDWF  x3B,W
01938:  MOVLB  4
0193A:  MOVWF  x51
0193C:  MOVLW  00
0193E:  MOVLB  1
01940:  ADDWFC x3C,W
01942:  MOVLB  4
01944:  MOVWF  x52
01946:  BCF    FD8.0
01948:  RLCF   x4E,W
0194A:  ADDWF  x51,W
0194C:  MOVWF  01
0194E:  MOVLW  00
01950:  ADDWFC x52,W
01952:  MOVWF  03
01954:  MOVFF  01,FE9
01958:  MOVWF  FEA
0195A:  MOVFF  FEF,01
0195E:  INCF   FE9,F
01960:  MOVF   FEF,W
01962:  DECF   FE9,F
01964:  MOVWF  02
*
019B0:  BCF    FD8.0
019B2:  RLCF   x4D,W
019B4:  MOVWF  00
019B6:  BCF    FD8.0
019B8:  RLCF   00,F
019BA:  MOVF   00,W
019BC:  MOVLB  1
019BE:  ADDWF  x3B,W
019C0:  MOVLB  4
019C2:  MOVWF  x51
019C4:  MOVLW  00
019C6:  MOVLB  1
019C8:  ADDWFC x3C,W
019CA:  MOVLB  4
019CC:  MOVWF  x52
019CE:  BCF    FD8.0
019D0:  RLCF   x4E,W
019D2:  ADDWF  x51,W
019D4:  MOVWF  01
019D6:  MOVLW  00
019D8:  ADDWFC x52,W
019DA:  MOVWF  03
019DC:  MOVFF  01,FE9
019E0:  MOVWF  FEA
019E2:  MOVFF  FEF,01
019E6:  INCF   FE9,F
019E8:  MOVF   FEF,W
019EA:  DECF   FE9,F
019EC:  MOVWF  02
*
02C54:  BCF    FD8.0
02C56:  RLCF   x4D,W
02C58:  MOVWF  00
02C5A:  BCF    FD8.0
02C5C:  RLCF   00,F
02C5E:  MOVF   00,W
02C60:  MOVLB  1
02C62:  ADDWF  x3B,W
02C64:  MOVLB  4
02C66:  MOVWF  x51
02C68:  MOVLW  00
02C6A:  MOVLB  1
02C6C:  ADDWFC x3C,W
02C6E:  MOVLB  4
02C70:  MOVWF  x52
02C72:  BCF    FD8.0
02C74:  RLCF   x4E,W
02C76:  ADDWF  x51,W
02C78:  MOVWF  01
02C7A:  MOVLW  00
02C7C:  ADDWFC x52,W
02C7E:  MOVWF  03
02C80:  MOVFF  01,FE9
02C84:  MOVWF  FEA
02C86:  MOVFF  FEF,01
02C8A:  INCF   FE9,F
02C8C:  MOVF   FEF,W
02C8E:  DECF   FE9,F
02C90:  MOVWF  02
*
02CCE:  BCF    FD8.0
02CD0:  RLCF   x4D,W
02CD2:  MOVWF  00
02CD4:  BCF    FD8.0
02CD6:  RLCF   00,F
02CD8:  MOVF   00,W
02CDA:  MOVLB  1
02CDC:  ADDWF  x3B,W
02CDE:  MOVLB  4
02CE0:  MOVWF  x51
02CE2:  MOVLW  00
02CE4:  MOVLB  1
02CE6:  ADDWFC x3C,W
02CE8:  MOVLB  4
02CEA:  MOVWF  x52
02CEC:  BCF    FD8.0
02CEE:  RLCF   x4E,W
02CF0:  ADDWF  x51,W
02CF2:  MOVWF  01
02CF4:  MOVLW  00
02CF6:  ADDWFC x52,W
02CF8:  MOVWF  03
02CFA:  MOVFF  01,FE9
02CFE:  MOVWF  FEA
02D00:  MOVFF  FEF,01
02D04:  INCF   FE9,F
02D06:  MOVF   FEF,W
02D08:  DECF   FE9,F
02D0A:  MOVWF  02
*
02DA0:  BCF    FD8.0
02DA2:  RLCF   x4D,W
02DA4:  MOVWF  00
02DA6:  BCF    FD8.0
02DA8:  RLCF   00,F
02DAA:  MOVF   00,W
02DAC:  MOVLB  1
02DAE:  ADDWF  x3B,W
02DB0:  MOVLB  4
02DB2:  MOVWF  x51
02DB4:  MOVLW  00
02DB6:  MOVLB  1
02DB8:  ADDWFC x3C,W
02DBA:  MOVLB  4
02DBC:  MOVWF  x52
02DBE:  BCF    FD8.0
02DC0:  RLCF   x4E,W
02DC2:  ADDWF  x51,W
02DC4:  MOVWF  01
02DC6:  MOVLW  00
02DC8:  ADDWFC x52,W
02DCA:  MOVWF  03
02DCC:  MOVFF  01,FE9
02DD0:  MOVWF  FEA
02DD2:  MOVFF  FEF,01
02DD6:  INCF   FE9,F
02DD8:  MOVF   FEF,W
02DDA:  DECF   FE9,F
02DDC:  MOVWF  02
....................    } 
....................  
....................    
....................   VOID org(void) 
....................   { 
*
01E36:  MOVLB  4
01E38:  BSF    x38.0
....................      INT clockorg; 
....................      INT16 tempd[N_LUZES][2]; 
....................      INT numluzes; 
....................      INT1 again = 1; 
....................      INT fa; 
....................      INT16 fl; 
....................      INT afa; 
....................      FOR(fa = 0;fa < used_dimmers;++fa) 
01E3A:  CLRF   x39
01E3C:  MOVLB  1
01E3E:  MOVF   x3A,W
01E40:  MOVLB  4
01E42:  SUBWF  x39,W
01E44:  BC    1EC0
....................      { 
....................         tempd[fa][0] = ltlevel[fa];//tempd[x][0] fica com o valor de dimming 0...127 
01E46:  MOVF   x39,W
01E48:  MULLW  04
01E4A:  MOVF   FF3,W
01E4C:  CLRF   x3E
01E4E:  MOVWF  x3D
01E50:  MOVLW  F7
01E52:  ADDWF  x3D,W
01E54:  MOVWF  01
01E56:  MOVLW  03
01E58:  ADDWFC x3E,W
01E5A:  MOVWF  03
01E5C:  MOVWF  x3E
01E5E:  CLRF   03
01E60:  MOVF   x39,W
01E62:  ADDLW  3F
01E64:  MOVWF  FE9
01E66:  MOVLW  01
01E68:  ADDWFC 03,W
01E6A:  MOVWF  FEA
01E6C:  MOVF   FEF,W
01E6E:  CLRF   03
01E70:  MOVFF  43E,FEA
01E74:  MOVFF  01,FE9
01E78:  MOVFF  03,FEC
01E7C:  MOVF   FED,F
01E7E:  MOVWF  FEF
....................         tempd[fa][1] = lights[fa];//tempd[x][1] fica com o valor binario DO porto de saida 
01E80:  MOVF   x39,W
01E82:  MULLW  04
01E84:  MOVF   FF3,W
01E86:  CLRF   x3E
01E88:  MOVWF  x3D
01E8A:  MOVLW  02
01E8C:  ADDWF  x3D,W
01E8E:  MOVWF  01
01E90:  MOVLW  00
01E92:  ADDWFC x3E,W
01E94:  MOVWF  03
01E96:  MOVF   01,W
01E98:  ADDLW  F7
01E9A:  MOVWF  FE9
01E9C:  MOVLW  03
01E9E:  ADDWFC 03,W
01EA0:  MOVWF  FEA
01EA2:  BCF    FD8.0
01EA4:  RLCF   x39,W
01EA6:  CLRF   03
01EA8:  MOVLB  0
01EAA:  CALL   0166
01EAE:  TBLRD*+
01EB0:  MOVFF  FF5,03
01EB4:  MOVWF  FEF
01EB6:  MOVFF  03,FEC
....................      } 
01EBA:  MOVLB  4
01EBC:  INCF   x39,F
01EBE:  BRA    1E3C
....................  
....................      WHILE(again) 
....................      { 
01EC0:  BTFSS  x38.0
01EC2:  BRA    208A
....................         again = 0; 
01EC4:  BCF    x38.0
....................         FOR(fa = 0;fa < used_dimmers-1;++fa) 
01EC6:  CLRF   x39
01EC8:  MOVLW  01
01ECA:  MOVLB  1
01ECC:  SUBWF  x3A,W
01ECE:  MOVLB  4
01ED0:  SUBWF  x39,W
01ED2:  BTFSC  FD8.0
01ED4:  BRA    2088
....................         { 
....................            //coloca valores por ordem tempd[0][0] o maior 
....................            IF(tempd[fa][0] < tempd[fa + 1][0]) 
01ED6:  MOVF   x39,W
01ED8:  MULLW  04
01EDA:  MOVF   FF3,W
01EDC:  CLRF   x3E
01EDE:  MOVWF  x3D
01EE0:  MOVLW  F7
01EE2:  ADDWF  x3D,W
01EE4:  MOVWF  FE9
01EE6:  MOVLW  03
01EE8:  ADDWFC x3E,W
01EEA:  MOVWF  FEA
01EEC:  MOVFF  FEC,43E
01EF0:  MOVF   FED,F
01EF2:  MOVFF  FEF,43D
01EF6:  MOVLW  01
01EF8:  ADDWF  x39,W
01EFA:  MULLW  04
01EFC:  MOVF   FF3,W
01EFE:  CLRF   x40
01F00:  MOVWF  x3F
01F02:  MOVLW  F7
01F04:  ADDWF  x3F,W
01F06:  MOVWF  FE9
01F08:  MOVLW  03
01F0A:  ADDWFC x40,W
01F0C:  MOVWF  FEA
01F0E:  MOVFF  FEC,03
01F12:  MOVF   FED,F
01F14:  MOVFF  FEF,01
01F18:  MOVF   x3E,W
01F1A:  SUBWF  03,W
01F1C:  BTFSS  FD8.0
01F1E:  BRA    2084
01F20:  BNZ   1F2A
01F22:  MOVF   01,W
01F24:  SUBWF  x3D,W
01F26:  BTFSC  FD8.0
01F28:  BRA    2084
....................            { 
....................               again = 1; 
01F2A:  BSF    x38.0
....................               fl = tempd[fa][0]; 
01F2C:  MOVF   x39,W
01F2E:  MULLW  04
01F30:  MOVF   FF3,W
01F32:  CLRF   x3E
01F34:  MOVWF  x3D
01F36:  MOVLW  F7
01F38:  ADDWF  x3D,W
01F3A:  MOVWF  FE9
01F3C:  MOVLW  03
01F3E:  ADDWFC x3E,W
01F40:  MOVWF  FEA
01F42:  MOVFF  FEC,03
01F46:  MOVF   FED,F
01F48:  MOVFF  FEF,43A
01F4C:  MOVFF  03,43B
....................               tempd[fa][0] = tempd[fa + 1][0]; 
01F50:  MOVF   x39,W
01F52:  MULLW  04
01F54:  MOVF   FF3,W
01F56:  CLRF   x3E
01F58:  MOVWF  x3D
01F5A:  MOVLW  F7
01F5C:  ADDWF  x3D,W
01F5E:  MOVWF  01
01F60:  MOVLW  03
01F62:  ADDWFC x3E,W
01F64:  MOVWF  03
01F66:  MOVWF  x3E
01F68:  MOVLW  01
01F6A:  ADDWF  x39,W
01F6C:  MULLW  04
01F6E:  MOVF   FF3,W
01F70:  CLRF   x40
01F72:  MOVWF  x3F
01F74:  MOVLW  F7
01F76:  ADDWF  x3F,W
01F78:  MOVWF  FE9
01F7A:  MOVLW  03
01F7C:  ADDWFC x40,W
01F7E:  MOVWF  FEA
01F80:  MOVFF  FEC,03
01F84:  MOVF   FED,F
01F86:  MOVFF  FEF,43F
01F8A:  MOVFF  43E,FEA
01F8E:  MOVFF  01,FE9
01F92:  MOVFF  03,FEC
01F96:  MOVF   FED,F
01F98:  MOVFF  43F,FEF
....................               tempd[fa + 1][0] = fl; 
01F9C:  MOVLW  01
01F9E:  ADDWF  x39,W
01FA0:  MULLW  04
01FA2:  MOVF   FF3,W
01FA4:  CLRF   x3E
01FA6:  MOVWF  x3D
01FA8:  MOVLW  F7
01FAA:  ADDWF  x3D,W
01FAC:  MOVWF  FE9
01FAE:  MOVLW  03
01FB0:  ADDWFC x3E,W
01FB2:  MOVWF  FEA
01FB4:  MOVFF  43B,FEC
01FB8:  MOVF   FED,F
01FBA:  MOVFF  43A,FEF
....................               fl = tempd[fa][1]; 
01FBE:  MOVF   x39,W
01FC0:  MULLW  04
01FC2:  MOVF   FF3,W
01FC4:  CLRF   x3E
01FC6:  MOVWF  x3D
01FC8:  MOVLW  02
01FCA:  ADDWF  x3D,W
01FCC:  MOVWF  01
01FCE:  MOVLW  00
01FD0:  ADDWFC x3E,W
01FD2:  MOVWF  03
01FD4:  MOVF   01,W
01FD6:  ADDLW  F7
01FD8:  MOVWF  FE9
01FDA:  MOVLW  03
01FDC:  ADDWFC 03,W
01FDE:  MOVWF  FEA
01FE0:  MOVFF  FEC,03
01FE4:  MOVF   FED,F
01FE6:  MOVFF  FEF,43A
01FEA:  MOVFF  03,43B
....................               tempd[fa][1] = tempd[fa + 1][1]; 
01FEE:  MOVF   x39,W
01FF0:  MULLW  04
01FF2:  MOVF   FF3,W
01FF4:  CLRF   x3E
01FF6:  MOVWF  x3D
01FF8:  MOVLW  02
01FFA:  ADDWF  x3D,W
01FFC:  MOVWF  01
01FFE:  MOVLW  00
02000:  ADDWFC x3E,W
02002:  MOVWF  03
02004:  MOVF   01,W
02006:  ADDLW  F7
02008:  MOVWF  01
0200A:  MOVLW  03
0200C:  ADDWFC 03,F
0200E:  MOVFF  01,43D
02012:  MOVFF  03,43E
02016:  MOVLW  01
02018:  ADDWF  x39,W
0201A:  MULLW  04
0201C:  MOVF   FF3,W
0201E:  CLRF   x40
02020:  MOVWF  x3F
02022:  MOVLW  02
02024:  ADDWF  x3F,W
02026:  MOVWF  01
02028:  MOVLW  00
0202A:  ADDWFC x40,W
0202C:  MOVWF  03
0202E:  MOVF   01,W
02030:  ADDLW  F7
02032:  MOVWF  FE9
02034:  MOVLW  03
02036:  ADDWFC 03,W
02038:  MOVWF  FEA
0203A:  MOVFF  FEC,03
0203E:  MOVF   FED,F
02040:  MOVFF  FEF,43F
02044:  MOVFF  43E,FEA
02048:  MOVFF  43D,FE9
0204C:  MOVFF  03,FEC
02050:  MOVF   FED,F
02052:  MOVFF  43F,FEF
....................               tempd[fa + 1][1] = fl; 
02056:  MOVLW  01
02058:  ADDWF  x39,W
0205A:  MULLW  04
0205C:  MOVF   FF3,W
0205E:  CLRF   x3E
02060:  MOVWF  x3D
02062:  MOVLW  02
02064:  ADDWF  x3D,W
02066:  MOVWF  01
02068:  MOVLW  00
0206A:  ADDWFC x3E,W
0206C:  MOVWF  03
0206E:  MOVF   01,W
02070:  ADDLW  F7
02072:  MOVWF  FE9
02074:  MOVLW  03
02076:  ADDWFC 03,W
02078:  MOVWF  FEA
0207A:  MOVFF  43B,FEC
0207E:  MOVF   FED,F
02080:  MOVFF  43A,FEF
....................            } 
....................         } 
02084:  INCF   x39,F
02086:  BRA    1EC8
....................      } 
02088:  BRA    1EC0
....................       for(temp=0;temp<17;++temp) 
0208A:  MOVLB  1
0208C:  CLRF   x39
0208E:  MOVF   x39,W
02090:  SUBLW  10
02092:  BNC   2134
....................    { 
....................       printf("%lu <-> %lu\n\r",tempd[temp][0],tempd[temp][1]); 
02094:  MOVF   x39,W
02096:  MULLW  04
02098:  MOVF   FF3,W
0209A:  MOVLB  4
0209C:  CLRF   x3E
0209E:  MOVWF  x3D
020A0:  MOVLW  F7
020A2:  ADDWF  x3D,W
020A4:  MOVWF  FE9
020A6:  MOVLW  03
020A8:  ADDWFC x3E,W
020AA:  MOVWF  FEA
020AC:  MOVFF  FEC,43E
020B0:  MOVF   FED,F
020B2:  MOVFF  FEF,43D
020B6:  MOVLB  1
020B8:  MOVF   x39,W
020BA:  MULLW  04
020BC:  MOVF   FF3,W
020BE:  MOVLB  4
020C0:  CLRF   x40
020C2:  MOVWF  x3F
020C4:  MOVLW  02
020C6:  ADDWF  x3F,W
020C8:  MOVWF  01
020CA:  MOVLW  00
020CC:  ADDWFC x40,W
020CE:  MOVWF  03
020D0:  MOVF   01,W
020D2:  ADDLW  F7
020D4:  MOVWF  FE9
020D6:  MOVLW  03
020D8:  ADDWFC 03,W
020DA:  MOVWF  FEA
020DC:  MOVFF  FEC,440
020E0:  MOVF   FED,F
020E2:  MOVFF  FEF,43F
020E6:  MOVLW  10
020E8:  MOVWF  FE9
020EA:  MOVFF  43E,442
020EE:  MOVFF  43D,441
020F2:  MOVLB  0
020F4:  RCALL  1C3E
020F6:  MOVLW  B1
020F8:  MOVWF  FF6
020FA:  MOVLW  02
020FC:  MOVWF  FF7
020FE:  MOVLW  00
02100:  MOVWF  FF8
02102:  MOVLW  05
02104:  MOVLB  4
02106:  MOVWF  x41
02108:  MOVLB  0
0210A:  RCALL  1CFA
0210C:  MOVLW  10
0210E:  MOVWF  FE9
02110:  MOVFF  440,442
02114:  MOVFF  43F,441
02118:  RCALL  1C3E
0211A:  MOVLW  0A
0211C:  MOVLB  4
0211E:  MOVWF  x4A
02120:  MOVLB  0
02122:  RCALL  1BEA
02124:  MOVLW  0D
02126:  MOVLB  4
02128:  MOVWF  x4A
0212A:  MOVLB  0
0212C:  RCALL  1BEA
....................    } 
0212E:  MOVLB  1
02130:  INCF   x39,F
02132:  BRA    208E
....................      IF(tempd[0][0] == 0)numluzes = 0;//luzes todas off 
02134:  MOVLB  3
02136:  MOVF   xF7,F
02138:  BNZ   2146
0213A:  MOVF   xF8,F
0213C:  BNZ   2146
0213E:  MOVLB  4
02140:  CLRF   x37
....................      ELSE 
02142:  BRA    24E8
02144:  MOVLB  3
....................      { 
....................         numluzes = 1; 
02146:  MOVLW  01
02148:  MOVLB  4
0214A:  MOVWF  x37
....................         afa = 0; 
0214C:  CLRF   x3C
....................         IF(actmat) 
0214E:  MOVLB  0
02150:  BTFSS  xB1.3
02152:  BRA    2166
....................         { 
....................            delays1[0][0] = tempd[0][0]; 
02154:  MOVFF  3F8,150
02158:  MOVFF  3F7,14F
....................            delays1[0][1] = tempd[0][1]; 
0215C:  MOVFF  3FA,152
02160:  MOVFF  3F9,151
....................         } 
....................  
....................         ELSE 
02164:  BRA    2176
....................         { 
....................            delays2[0][0] = tempd[0][0]; 
02166:  MOVFF  3F8,194
0216A:  MOVFF  3F7,193
....................            delays2[0][1] = tempd[0][1]; 
0216E:  MOVFF  3FA,196
02172:  MOVFF  3F9,195
....................         } 
....................  
....................         FOR(fa = 1;fa < used_dimmers;++fa) 
02176:  MOVLW  01
02178:  MOVLB  4
0217A:  MOVWF  x39
0217C:  MOVLB  1
0217E:  MOVF   x3A,W
02180:  MOVLB  4
02182:  SUBWF  x39,W
02184:  BTFSC  FD8.0
02186:  BRA    24E8
....................         { 
....................            IF((tempd[fa][0] == tempd[fa - 1][0])&( ! tempd[fa][0] == 0)) 
02188:  MOVF   x39,W
0218A:  MULLW  04
0218C:  MOVF   FF3,W
0218E:  CLRF   x3E
02190:  MOVWF  x3D
02192:  MOVLW  F7
02194:  ADDWF  x3D,W
02196:  MOVWF  FE9
02198:  MOVLW  03
0219A:  ADDWFC x3E,W
0219C:  MOVWF  FEA
0219E:  MOVFF  FEC,43E
021A2:  MOVF   FED,F
021A4:  MOVFF  FEF,43D
021A8:  MOVLW  01
021AA:  SUBWF  x39,W
021AC:  MULLW  04
021AE:  MOVF   FF3,W
021B0:  CLRF   x40
021B2:  MOVWF  x3F
021B4:  MOVLW  F7
021B6:  ADDWF  x3F,W
021B8:  MOVWF  FE9
021BA:  MOVLW  03
021BC:  ADDWFC x40,W
021BE:  MOVWF  FEA
021C0:  MOVFF  FEC,03
021C4:  MOVF   FED,F
021C6:  MOVF   FEF,W
021C8:  SUBWF  x3D,W
021CA:  BNZ   21D2
021CC:  MOVF   03,W
021CE:  SUBWF  x3E,W
021D0:  BZ    21D6
021D2:  MOVLW  00
021D4:  BRA    21D8
021D6:  MOVLW  01
021D8:  MOVWF  x3D
021DA:  MOVF   x39,W
021DC:  MULLW  04
021DE:  MOVF   FF3,W
021E0:  CLRF   x3F
021E2:  MOVWF  x3E
021E4:  MOVLW  F7
021E6:  ADDWF  x3E,W
021E8:  MOVWF  FE9
021EA:  MOVLW  03
021EC:  ADDWFC x3F,W
021EE:  MOVWF  FEA
021F0:  MOVF   FEF,F
021F2:  BNZ   21F8
021F4:  MOVF   FEC,F
021F6:  BZ    21FC
021F8:  MOVLW  00
021FA:  BRA    21FE
021FC:  MOVLW  01
021FE:  XORLW  00
02200:  BZ    2206
02202:  MOVLW  00
02204:  BRA    2208
02206:  MOVLW  01
02208:  ANDWF  x3D,W
0220A:  BTFSC  FD8.2
0220C:  BRA    2348
....................            { 
....................               IF(actmat)delays1[afa][1] = delays1[afa][1]&tempd[fa][1]; 
0220E:  MOVLB  0
02210:  BTFSS  xB1.3
02212:  BRA    22AE
02214:  MOVLB  4
02216:  MOVF   x3C,W
02218:  MULLW  04
0221A:  MOVF   FF3,W
0221C:  CLRF   x3E
0221E:  MOVWF  x3D
02220:  MOVLW  02
02222:  ADDWF  x3D,W
02224:  MOVWF  01
02226:  MOVLW  00
02228:  ADDWFC x3E,W
0222A:  MOVWF  03
0222C:  MOVF   01,W
0222E:  ADDLW  4F
02230:  MOVWF  01
02232:  MOVLW  01
02234:  ADDWFC 03,F
02236:  MOVFF  01,43D
0223A:  MOVFF  03,43E
0223E:  MOVF   x3C,W
02240:  MULLW  04
02242:  MOVF   FF3,W
02244:  CLRF   x40
02246:  MOVWF  x3F
02248:  MOVLW  02
0224A:  ADDWF  x3F,W
0224C:  MOVWF  01
0224E:  MOVLW  00
02250:  ADDWFC x40,W
02252:  MOVWF  03
02254:  MOVF   01,W
02256:  ADDLW  4F
02258:  MOVWF  FE9
0225A:  MOVLW  01
0225C:  ADDWFC 03,W
0225E:  MOVWF  FEA
02260:  MOVFF  FEC,440
02264:  MOVF   FED,F
02266:  MOVFF  FEF,43F
0226A:  MOVF   x39,W
0226C:  MULLW  04
0226E:  MOVF   FF3,W
02270:  CLRF   x42
02272:  MOVWF  x41
02274:  MOVLW  02
02276:  ADDWF  x41,W
02278:  MOVWF  01
0227A:  MOVLW  00
0227C:  ADDWFC x42,W
0227E:  MOVWF  03
02280:  MOVF   01,W
02282:  ADDLW  F7
02284:  MOVWF  FE9
02286:  MOVLW  03
02288:  ADDWFC 03,W
0228A:  MOVWF  FEA
0228C:  MOVFF  FEC,03
02290:  MOVF   FED,F
02292:  MOVF   FEF,W
02294:  ANDWF  x3F,W
02296:  MOVWF  00
02298:  MOVF   03,W
0229A:  ANDWF  x40,W
0229C:  MOVFF  43E,FEA
022A0:  MOVFF  43D,FE9
022A4:  MOVWF  FEC
022A6:  MOVF   FED,F
022A8:  MOVFF  00,FEF
....................               ELSE delays2[afa][1] = delays2[afa][1]&tempd[fa][1]; 
022AC:  BRA    2346
022AE:  MOVLB  4
022B0:  MOVF   x3C,W
022B2:  MULLW  04
022B4:  MOVF   FF3,W
022B6:  CLRF   x3E
022B8:  MOVWF  x3D
022BA:  MOVLW  02
022BC:  ADDWF  x3D,W
022BE:  MOVWF  01
022C0:  MOVLW  00
022C2:  ADDWFC x3E,W
022C4:  MOVWF  03
022C6:  MOVF   01,W
022C8:  ADDLW  93
022CA:  MOVWF  01
022CC:  MOVLW  01
022CE:  ADDWFC 03,F
022D0:  MOVFF  01,43D
022D4:  MOVFF  03,43E
022D8:  MOVF   x3C,W
022DA:  MULLW  04
022DC:  MOVF   FF3,W
022DE:  CLRF   x40
022E0:  MOVWF  x3F
022E2:  MOVLW  02
022E4:  ADDWF  x3F,W
022E6:  MOVWF  01
022E8:  MOVLW  00
022EA:  ADDWFC x40,W
022EC:  MOVWF  03
022EE:  MOVF   01,W
022F0:  ADDLW  93
022F2:  MOVWF  FE9
022F4:  MOVLW  01
022F6:  ADDWFC 03,W
022F8:  MOVWF  FEA
022FA:  MOVFF  FEC,440
022FE:  MOVF   FED,F
02300:  MOVFF  FEF,43F
02304:  MOVF   x39,W
02306:  MULLW  04
02308:  MOVF   FF3,W
0230A:  CLRF   x42
0230C:  MOVWF  x41
0230E:  MOVLW  02
02310:  ADDWF  x41,W
02312:  MOVWF  01
02314:  MOVLW  00
02316:  ADDWFC x42,W
02318:  MOVWF  03
0231A:  MOVF   01,W
0231C:  ADDLW  F7
0231E:  MOVWF  FE9
02320:  MOVLW  03
02322:  ADDWFC 03,W
02324:  MOVWF  FEA
02326:  MOVFF  FEC,03
0232A:  MOVF   FED,F
0232C:  MOVF   FEF,W
0232E:  ANDWF  x3F,W
02330:  MOVWF  00
02332:  MOVF   03,W
02334:  ANDWF  x40,W
02336:  MOVFF  43E,FEA
0233A:  MOVFF  43D,FE9
0233E:  MOVWF  FEC
02340:  MOVF   FED,F
02342:  MOVFF  00,FEF
....................            } 
....................  
....................            else IF( ! tempd[fa][0] == 0) 
02346:  BRA    24E4
02348:  MOVF   x39,W
0234A:  MULLW  04
0234C:  MOVF   FF3,W
0234E:  CLRF   x3E
02350:  MOVWF  x3D
02352:  MOVLW  F7
02354:  ADDWF  x3D,W
02356:  MOVWF  FE9
02358:  MOVLW  03
0235A:  ADDWFC x3E,W
0235C:  MOVWF  FEA
0235E:  MOVF   FEF,F
02360:  BNZ   2366
02362:  MOVF   FEC,F
02364:  BZ    236A
02366:  MOVLW  00
02368:  BRA    236C
0236A:  MOVLW  01
0236C:  XORLW  00
0236E:  BTFSS  FD8.2
02370:  BRA    24E4
....................            { 
....................               ++afa; 
02372:  INCF   x3C,F
....................               IF(actmat) 
02374:  MOVLB  0
02376:  BTFSS  xB1.3
02378:  BRA    2430
....................               { 
....................                  delays1[afa][0] = tempd[fa][0]; 
0237A:  MOVLB  4
0237C:  MOVF   x3C,W
0237E:  MULLW  04
02380:  MOVF   FF3,W
02382:  CLRF   x3E
02384:  MOVWF  x3D
02386:  MOVLW  4F
02388:  ADDWF  x3D,W
0238A:  MOVWF  01
0238C:  MOVLW  01
0238E:  ADDWFC x3E,W
02390:  MOVWF  03
02392:  MOVWF  x3E
02394:  MOVF   x39,W
02396:  MULLW  04
02398:  MOVF   FF3,W
0239A:  CLRF   x40
0239C:  MOVWF  x3F
0239E:  MOVLW  F7
023A0:  ADDWF  x3F,W
023A2:  MOVWF  FE9
023A4:  MOVLW  03
023A6:  ADDWFC x40,W
023A8:  MOVWF  FEA
023AA:  MOVFF  FEC,03
023AE:  MOVF   FED,F
023B0:  MOVFF  FEF,43F
023B4:  MOVFF  43E,FEA
023B8:  MOVFF  01,FE9
023BC:  MOVFF  03,FEC
023C0:  MOVF   FED,F
023C2:  MOVFF  43F,FEF
....................                  delays1[afa][1] = tempd[fa][1]; 
023C6:  MOVF   x3C,W
023C8:  MULLW  04
023CA:  MOVF   FF3,W
023CC:  CLRF   x3E
023CE:  MOVWF  x3D
023D0:  MOVLW  02
023D2:  ADDWF  x3D,W
023D4:  MOVWF  01
023D6:  MOVLW  00
023D8:  ADDWFC x3E,W
023DA:  MOVWF  03
023DC:  MOVF   01,W
023DE:  ADDLW  4F
023E0:  MOVWF  01
023E2:  MOVLW  01
023E4:  ADDWFC 03,F
023E6:  MOVFF  01,43D
023EA:  MOVFF  03,43E
023EE:  MOVF   x39,W
023F0:  MULLW  04
023F2:  MOVF   FF3,W
023F4:  CLRF   x40
023F6:  MOVWF  x3F
023F8:  MOVLW  02
023FA:  ADDWF  x3F,W
023FC:  MOVWF  01
023FE:  MOVLW  00
02400:  ADDWFC x40,W
02402:  MOVWF  03
02404:  MOVF   01,W
02406:  ADDLW  F7
02408:  MOVWF  FE9
0240A:  MOVLW  03
0240C:  ADDWFC 03,W
0240E:  MOVWF  FEA
02410:  MOVFF  FEC,03
02414:  MOVF   FED,F
02416:  MOVFF  FEF,43F
0241A:  MOVFF  43E,FEA
0241E:  MOVFF  43D,FE9
02422:  MOVFF  03,FEC
02426:  MOVF   FED,F
02428:  MOVFF  43F,FEF
....................               } 
....................  
....................               ELSE 
0242C:  BRA    24E2
0242E:  MOVLB  0
....................               { 
....................                  delays2[afa][0] = tempd[fa][0]; 
02430:  MOVLB  4
02432:  MOVF   x3C,W
02434:  MULLW  04
02436:  MOVF   FF3,W
02438:  CLRF   x3E
0243A:  MOVWF  x3D
0243C:  MOVLW  93
0243E:  ADDWF  x3D,W
02440:  MOVWF  01
02442:  MOVLW  01
02444:  ADDWFC x3E,W
02446:  MOVWF  03
02448:  MOVWF  x3E
0244A:  MOVF   x39,W
0244C:  MULLW  04
0244E:  MOVF   FF3,W
02450:  CLRF   x40
02452:  MOVWF  x3F
02454:  MOVLW  F7
02456:  ADDWF  x3F,W
02458:  MOVWF  FE9
0245A:  MOVLW  03
0245C:  ADDWFC x40,W
0245E:  MOVWF  FEA
02460:  MOVFF  FEC,03
02464:  MOVF   FED,F
02466:  MOVFF  FEF,43F
0246A:  MOVFF  43E,FEA
0246E:  MOVFF  01,FE9
02472:  MOVFF  03,FEC
02476:  MOVF   FED,F
02478:  MOVFF  43F,FEF
....................                  delays2[afa][1] = tempd[fa][1]; 
0247C:  MOVF   x3C,W
0247E:  MULLW  04
02480:  MOVF   FF3,W
02482:  CLRF   x3E
02484:  MOVWF  x3D
02486:  MOVLW  02
02488:  ADDWF  x3D,W
0248A:  MOVWF  01
0248C:  MOVLW  00
0248E:  ADDWFC x3E,W
02490:  MOVWF  03
02492:  MOVF   01,W
02494:  ADDLW  93
02496:  MOVWF  01
02498:  MOVLW  01
0249A:  ADDWFC 03,F
0249C:  MOVFF  01,43D
024A0:  MOVFF  03,43E
024A4:  MOVF   x39,W
024A6:  MULLW  04
024A8:  MOVF   FF3,W
024AA:  CLRF   x40
024AC:  MOVWF  x3F
024AE:  MOVLW  02
024B0:  ADDWF  x3F,W
024B2:  MOVWF  01
024B4:  MOVLW  00
024B6:  ADDWFC x40,W
024B8:  MOVWF  03
024BA:  MOVF   01,W
024BC:  ADDLW  F7
024BE:  MOVWF  FE9
024C0:  MOVLW  03
024C2:  ADDWFC 03,W
024C4:  MOVWF  FEA
024C6:  MOVFF  FEC,03
024CA:  MOVF   FED,F
024CC:  MOVFF  FEF,43F
024D0:  MOVFF  43E,FEA
024D4:  MOVFF  43D,FE9
024D8:  MOVFF  03,FEC
024DC:  MOVF   FED,F
024DE:  MOVFF  43F,FEF
....................               } 
....................  
....................               ++numluzes; 
024E2:  INCF   x37,F
....................            } 
....................         } 
024E4:  INCF   x39,F
024E6:  BRA    217C
....................      } 
....................  
....................      IF(actmat)delays1[N_LUZES][0] = numluzes; 
024E8:  MOVLB  0
024EA:  BTFSS  xB1.3
024EC:  BRA    24F8
024EE:  MOVLB  1
024F0:  CLRF   x90
024F2:  MOVFF  437,18F
....................      ELSE  delays2[N_LUZES][0] = numluzes; 
024F6:  BRA    2500
024F8:  MOVLB  1
024FA:  CLRF   xD4
024FC:  MOVFF  437,1D3
....................      printf("numluzes=%d %lu %lu\n\r",numluzes,delays1[0][0],delays1[0][1]); 
02500:  MOVLW  BC
02502:  MOVWF  FF6
02504:  MOVLW  02
02506:  MOVWF  FF7
02508:  MOVLW  00
0250A:  MOVWF  FF8
0250C:  MOVLW  09
0250E:  MOVLB  4
02510:  MOVWF  x41
02512:  MOVLB  0
02514:  CALL   1CFA
02518:  MOVFF  437,43D
0251C:  MOVLW  1F
0251E:  MOVLB  4
02520:  MOVWF  x3E
02522:  MOVLB  0
02524:  BRA    1D56
02526:  MOVLW  20
02528:  MOVLB  4
0252A:  MOVWF  x4A
0252C:  MOVLB  0
0252E:  CALL   1BEA
02532:  MOVLW  10
02534:  MOVWF  FE9
02536:  MOVFF  150,442
0253A:  MOVFF  14F,441
0253E:  CALL   1C3E
02542:  MOVLW  20
02544:  MOVLB  4
02546:  MOVWF  x4A
02548:  MOVLB  0
0254A:  CALL   1BEA
0254E:  MOVLW  10
02550:  MOVWF  FE9
02552:  MOVFF  152,442
02556:  MOVFF  151,441
0255A:  CALL   1C3E
0255E:  MOVLW  0A
02560:  MOVLB  4
02562:  MOVWF  x4A
02564:  MOVLB  0
02566:  CALL   1BEA
0256A:  MOVLW  0D
0256C:  MOVLB  4
0256E:  MOVWF  x4A
02570:  MOVLB  0
02572:  CALL   1BEA
....................       
....................      organizado=1; 
02576:  BSF    xB1.2
....................   } 
02578:  RETLW  00
....................  
....................  
....................  
.................... #include "struct_and_enums.c" 
.................... //enum switch_type {on_off,dimmer,button}; 
.................... enum switch_outstate {on, off, dimming, dimmed, maxed}; 
.................... enum switch_direction {up, down}; 
.................... enum switch_state {button_pressed, button_depressed}; 
.................... enum output_type {_on_off, _dimmer,shutter}; 
.................... enum output_state {_on, _off, _dimmed}; 
.................... enum timer_type {time_on, time_off, periodic_on}; 
.................... enum input_type {dimmer_switch,on_off_switch,button_switch,timer,none}; 
....................  
.................... void dimmer_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input); 
.................... typedef struct data_point_out 
.................... { 
....................    unsigned int adress; 
....................    unsigned int value; 
....................    int1 needs_update; 
.................... }; 
.................... typedef struct data_point_in 
.................... { 
....................    unsigned int adress[8]; 
....................    unsigned int value; 
....................    int1 needs_update; 
.................... }; 
.................... ///////////////////////INPUTS////////////////////////////////////// 
.................... typedef struct dimmer_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out dim_level; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    unsigned int current_level; 
....................    int32  timer; 
....................    switch_state current_state; 
....................    switch_state previous_state; 
....................    switch_direction direction; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
.................... typedef struct on_off_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................     switch_state current_state; 
....................    switch_state previous_state; 
....................    int32  timer; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
....................  
.................... typedef struct button_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................     switch_state current_state; 
....................    switch_state previous_state; 
....................    int32  timer; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
....................  
.................... typedef struct timer 
.................... { 
....................    timer_type type; 
....................    int32 timeToAct; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    int32  timer; 
.................... }; 
.................... union input 
.................... { 
....................    struct on_off_switch; 
....................    struct dimmer_switch; 
....................    struct timer; 
....................    struct button_switch; 
.................... }; 
....................  
.................... typedef struct inputs 
.................... { 
....................    enum input_type type; 
....................    union input device; 
.................... }; 
.................... ///////////////////////OUTPUTS////////////////////////////////////// 
.................... struct light 
.................... { 
....................    struct data_point_in on; 
....................    struct data_point_in off; 
....................    struct data_point_in dim_value; 
....................    unsigned int  out_value; 
....................    unsigned int  timer; 
....................    int1  needs_update; 
....................    output_state previous_state; 
.................... }; 
....................  
.................... union output 
.................... { 
....................    struct light; 
.................... }; 
....................  
.................... typedef struct outputs 
.................... { 
....................    enum output_type type; 
....................    union output device; 
.................... }; 
....................  
.................... typedef struct devices 
.................... { 
....................       unsigned int numberOfInputs; 
....................       unsigned int numberOfOutputs; 
....................       struct inputs myinputs[10]; 
....................       struct outputs myoutputs[10]; 
.................... }devicestype; 
....................  
.................... devicestype mydevices; 
.................... void dimmer_init(int dim_adr,int on_adr,int off_adr,struct inputs* input,int real_button) 
.................... { 
....................       struct dimmer_switch sw; 
....................       input->type=dimmer_switch; 
....................       sw.dim_level.adress=dim_adr; 
....................       sw.on.adress=on_adr; 
....................       sw.off.adress=off_adr; 
....................       sw.previous_state=button_depressed; 
....................       sw.outstate=off; 
....................       sw.current_level=0; 
....................       sw.direction=up; 
....................       sw.dim_level.needs_update=0; 
....................       sw.on.needs_update=0; 
....................       sw.off.needs_update=0; 
....................       sw.dim_level.value=0; 
....................       sw.on.value=0; 
....................       sw.off.value=0; 
....................       sw.realbutton=inputs[real_button]; 
....................       sw.timer=0; 
....................       input->device=sw; 
.................... } 
.................... void on_off_init(int dim_adr,int on_adr,int off_adr,struct inputs* input,int real_button) 
.................... { 
....................       struct on_off_switch sw; 
....................       input->type=on_off_switch; 
....................       sw.on.adress=on_adr; 
....................       sw.off.adress=off_adr; 
....................       sw.previous_state=button_depressed; 
....................       sw.outstate=off; 
....................       sw.on.needs_update=0; 
....................       sw.off.needs_update=0; 
....................       sw.on.value=0; 
....................       sw.off.value=0; 
....................       sw.realbutton=inputs[real_button]; 
....................       input->device=sw; 
.................... } 
.................... void button_init(int dim_adr,int on_adr,int off_adr,struct inputs* input,int real_button) 
.................... { 
....................       struct button_switch sw; 
....................       input->type=button_switch; 
0257A:  MOVLB  3
0257C:  MOVFF  3F9,FE9
02580:  MOVFF  3FA,FEA
02584:  MOVLW  02
02586:  MOVWF  FEF
....................       sw.on.adress=on_adr; 
02588:  MOVFF  3F7,3FC
....................       sw.off.adress=off_adr; 
0258C:  MOVFF  3F8,3FF
....................       sw.previous_state=button_depressed; 
02590:  MOVLB  4
02592:  BSF    x02.1
....................       sw.outstate=off; 
02594:  MOVLW  01
02596:  MOVWF  x07
....................       sw.on.needs_update=0; 
02598:  MOVLB  3
0259A:  BCF    xFE.0
....................       sw.off.needs_update=0; 
0259C:  MOVLB  4
0259E:  BCF    x01.0
....................       sw.on.value=0; 
025A0:  MOVLB  3
025A2:  CLRF   xFD
....................       sw.off.value=0; 
025A4:  MOVLB  4
025A6:  CLRF   x00
....................       sw.realbutton=inputs[real_button]; 
025A8:  CLRF   03
025AA:  MOVLB  3
025AC:  MOVF   xFB,W
025AE:  ADDLW  1C
025B0:  MOVWF  FE9
025B2:  MOVLW  00
025B4:  ADDWFC 03,W
025B6:  MOVWF  FEA
025B8:  MOVFF  FEF,408
025BC:  MOVLB  4
....................       input->device=sw; 
025BE:  MOVLW  01
025C0:  MOVLB  3
025C2:  ADDWF  xF9,W
025C4:  MOVWF  FE9
025C6:  MOVLW  00
025C8:  ADDWFC xFA,W
025CA:  MOVWF  FEA
025CC:  MOVLW  03
025CE:  MOVWF  FE2
025D0:  MOVLW  FC
025D2:  MOVWF  FE1
025D4:  MOVLW  11
025D6:  MOVWF  01
025D8:  MOVFF  FE6,FEE
025DC:  DECFSZ 01,F
025DE:  BRA    25D8
.................... } 
025E0:  MOVLB  0
025E2:  GOTO   2606 (RETURN)
....................  
....................  
.................... void test() 
.................... {     mydevices.numberOfInputs=1; 
025E6:  MOVLW  01
025E8:  MOVLB  1
025EA:  MOVWF  xD7
....................     //  struct dimmer_switch sw; 
....................     //  sw.dim_level.value=69; 
....................     //  mydevices.myinputs[0].device=sw; 
....................     //  printf("VALUE=%u\n\r",mydevices.myinputs[0].device.dim_level.value); 
....................     //  on_off_init(1,2,3,&mydevices.myinputs[0],0); 
....................     button_init(1,2,3,&mydevices.myinputs[0],0); 
025EC:  MOVLB  3
025EE:  MOVWF  xF6
025F0:  MOVLW  02
025F2:  MOVWF  xF7
025F4:  MOVLW  03
025F6:  MOVWF  xF8
025F8:  MOVLW  01
025FA:  MOVWF  xFA
025FC:  MOVLW  D9
025FE:  MOVWF  xF9
02600:  CLRF   xFB
02602:  MOVLB  0
02604:  BRA    257A
....................      // dimmer_init(1,2,3,&mydevices.myinputs[0],0); 
....................       //printf("VALUE=%u\n\r",mydevices.myinputs[0].device.dim_level.value); 
....................      // while(true){}; 
.................... } 
02606:  GOTO   2C08 (RETURN)
....................  
....................  
....................  
.................... #include "datapoints.c" 
.................... int1 array_contains(int * array,int & value) 
.................... { 
....................    int x; 
....................    for(x=0;x<8;++x) 
....................    { 
....................       if(&(array)==value) return true; 
....................       ++array; 
....................    } 
....................    return false; 
.................... } 
....................  
.................... void process_outpoint_answer(int adress,int value) 
.................... { 
....................     
.................... } 
....................  
.................... void process_inpoints(int &datapoint, int &value) 
.................... { 
....................    int x; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
....................    { 
....................       switch (mydevices.myoutputs[x].type) { 
....................  
....................     case _dimmer: 
....................            if (array_contains(mydevices.myoutputs[x].device.dim_value.adress,datapoint)) 
....................            { 
....................                mydevices.myoutputs[x].device.dim_value.value=value; 
....................                mydevices.myoutputs[x].device.dim_value.needs_update=true; 
....................            } 
....................            else if (array_contains(mydevices.myoutputs[x].device.on.adress,datapoint)) 
....................            { 
....................                mydevices.myoutputs[x].device.on.value=value; 
....................                mydevices.myoutputs[x].device.on.needs_update=true; 
....................            } 
....................            else if (array_contains(mydevices.myoutputs[x].device.off.adress,datapoint)) 
....................            { 
....................                mydevices.myoutputs[x].device.off.value=value; 
....................                mydevices.myoutputs[x].device.off.needs_update=true; 
....................            } 
....................            break; 
....................  
....................     case _on_off: 
....................  
....................            break; 
....................     case shutter: 
....................  
....................            break; 
....................     default: 
....................  
....................             break; } 
....................  
....................    } 
.................... } 
....................  
.................... void process_outpoints() 
.................... { 
....................     int x; 
....................    for(x=0;x<mydevices.numberOfInputs;++x) 
....................    { 
....................       switch (mydevices.myinputs[x].type) { 
....................     case dimmer_switch: 
....................                if(mydevices.myinputs[x].device.dim_level.needs_update) 
....................                { 
....................                   process_outpoint_answer(mydevices.myinputs[x].device.dim_level.adress,mydevices.myinputs[x].device.dim_level.value); 
....................                   mydevices.myinputs[x].device.dim_level.needs_update=false; 
....................                   mydevices.myinputs[x].device.dim_level.value=0; 
....................                } 
....................            if(mydevices.myinputs[x].device.on.needs_update) 
....................                { 
....................                   process_outpoint_answer(mydevices.myinputs[x].device.on.adress,mydevices.myinputs[x].device.on.value); 
....................                   mydevices.myinputs[x].device.on.needs_update=false; 
....................                   mydevices.myinputs[x].device.on.value=0; 
....................                } 
....................                if(mydevices.myinputs[x].device.off.needs_update) 
....................                { 
....................                   process_outpoint_answer(mydevices.myinputs[x].device.off.adress,mydevices.myinputs[x].device.off.value); 
....................                   mydevices.myinputs[x].device.off.needs_update=false; 
....................                   mydevices.myinputs[x].device.off.value=0; 
....................                } 
....................                break; 
....................     case timer: 
....................  
....................            break; 
....................     default: 
....................  
....................             break; } 
....................  
....................    } 
.................... } 
....................  
.................... ////////////////////////////////////////// 
.................... //apagar 
.................... int32 clock; 
....................  
.................... //dimmer constants 
.................... static int TimeBase=0; 
.................... static int32 reg=39; 
.................... //dimmer end 
....................  
.................... //struct switches msw; 
.................... #include "switch_functions.c" 
.................... void process_onOff(struct on_off_switch *sw) 
.................... { 
.................... //printf("AKI1"); 
....................    if((sw->current_state==button_pressed) && (sw-> previous_state == button_depressed)) 
*
00788:  MOVLW  06
0078A:  MOVLB  4
0078C:  ADDWF  x4E,W
0078E:  MOVWF  FE9
00790:  MOVLW  00
00792:  ADDWFC x4F,W
00794:  MOVWF  FEA
00796:  MOVLW  00
00798:  BTFSC  FEF.0
0079A:  MOVLW  01
0079C:  ANDLW  01
0079E:  BNZ   0844
007A0:  MOVLW  06
007A2:  ADDWF  x4E,W
007A4:  MOVWF  FE9
007A6:  MOVLW  00
007A8:  ADDWFC x4F,W
007AA:  MOVWF  FEA
007AC:  MOVLW  00
007AE:  BTFSC  FEF.1
007B0:  MOVLW  01
007B2:  ANDLW  01
007B4:  SUBLW  01
007B6:  BNZ   0844
....................    {    
....................       sw-> previous_state = button_pressed; 
007B8:  MOVLW  06
007BA:  ADDWF  x4E,W
007BC:  MOVWF  FE9
007BE:  MOVLW  00
007C0:  ADDWFC x4F,W
007C2:  MOVWF  FEA
007C4:  BCF    FEF.1
....................       if(sw->outstate==off) 
007C6:  MOVLW  0B
007C8:  ADDWF  x4E,W
007CA:  MOVWF  FE9
007CC:  MOVLW  00
007CE:  ADDWFC x4F,W
007D0:  MOVWF  FEA
007D2:  DECFSZ FEF,W
007D4:  BRA    0804
....................       { 
....................          sw->outstate=on; 
007D6:  MOVLW  0B
007D8:  ADDWF  x4E,W
007DA:  MOVWF  FE9
007DC:  MOVLW  00
007DE:  ADDWFC x4F,W
007E0:  MOVWF  FEA
007E2:  CLRF   FEF
....................          sw->on.value=1; 
007E4:  MOVLW  01
007E6:  ADDWF  x4E,W
007E8:  MOVWF  FE9
007EA:  MOVLW  00
007EC:  ADDWFC x4F,W
007EE:  MOVWF  FEA
007F0:  MOVLW  01
007F2:  MOVWF  FEF
....................          sw->on.needs_update=true; 
007F4:  MOVLW  02
007F6:  ADDWF  x4E,W
007F8:  MOVWF  FE9
007FA:  MOVLW  00
007FC:  ADDWFC x4F,W
007FE:  MOVWF  FEA
00800:  BSF    FEF.0
....................       } 
....................       else if(sw->outstate==on) 
00802:  BRA    0842
00804:  MOVLW  0B
00806:  ADDWF  x4E,W
00808:  MOVWF  FE9
0080A:  MOVLW  00
0080C:  ADDWFC x4F,W
0080E:  MOVWF  FEA
00810:  MOVF   FEF,F
00812:  BNZ   0842
....................       { 
....................          sw->outstate=off; 
00814:  MOVLW  0B
00816:  ADDWF  x4E,W
00818:  MOVWF  FE9
0081A:  MOVLW  00
0081C:  ADDWFC x4F,W
0081E:  MOVWF  FEA
00820:  MOVLW  01
00822:  MOVWF  FEF
....................          sw->off.value=1; 
00824:  MOVLW  04
00826:  ADDWF  x4E,W
00828:  MOVWF  FE9
0082A:  MOVLW  00
0082C:  ADDWFC x4F,W
0082E:  MOVWF  FEA
00830:  MOVLW  01
00832:  MOVWF  FEF
....................          sw->off.needs_update=true; 
00834:  MOVLW  05
00836:  ADDWF  x4E,W
00838:  MOVWF  FE9
0083A:  MOVLW  00
0083C:  ADDWFC x4F,W
0083E:  MOVWF  FEA
00840:  BSF    FEF.0
....................       } 
.................... } 
....................    else if(sw->current_state==button_depressed) 
00842:  BRA    086A
00844:  MOVLW  06
00846:  ADDWF  x4E,W
00848:  MOVWF  FE9
0084A:  MOVLW  00
0084C:  ADDWFC x4F,W
0084E:  MOVWF  FEA
00850:  MOVLW  00
00852:  BTFSC  FEF.0
00854:  MOVLW  01
00856:  ANDLW  01
00858:  SUBLW  01
0085A:  BNZ   086A
....................       sw-> previous_state = button_depressed; 
0085C:  MOVLW  06
0085E:  ADDWF  x4E,W
00860:  MOVWF  FE9
00862:  MOVLW  00
00864:  ADDWFC x4F,W
00866:  MOVWF  FEA
00868:  BSF    FEF.1
.................... } 
0086A:  MOVLB  0
0086C:  GOTO   0D52 (RETURN)
.................... void process_buttons(struct button_switch *sw) 
.................... { 
....................    if(sw->current_state==button_pressed && sw->outstate==off)  
00870:  MOVLW  06
00872:  MOVLB  4
00874:  ADDWF  x4E,W
00876:  MOVWF  FE9
00878:  MOVLW  00
0087A:  ADDWFC x4F,W
0087C:  MOVWF  FEA
0087E:  MOVLW  00
00880:  BTFSC  FEF.0
00882:  MOVLW  01
00884:  ANDLW  01
00886:  BNZ   08C6
00888:  MOVLW  0B
0088A:  ADDWF  x4E,W
0088C:  MOVWF  FE9
0088E:  MOVLW  00
00890:  ADDWFC x4F,W
00892:  MOVWF  FEA
00894:  DECFSZ FEF,W
00896:  BRA    08C6
....................    { 
....................          sw->outstate=on; 
00898:  MOVLW  0B
0089A:  ADDWF  x4E,W
0089C:  MOVWF  FE9
0089E:  MOVLW  00
008A0:  ADDWFC x4F,W
008A2:  MOVWF  FEA
008A4:  CLRF   FEF
....................          sw->on.value=1; 
008A6:  MOVLW  01
008A8:  ADDWF  x4E,W
008AA:  MOVWF  FE9
008AC:  MOVLW  00
008AE:  ADDWFC x4F,W
008B0:  MOVWF  FEA
008B2:  MOVLW  01
008B4:  MOVWF  FEF
....................          sw->on.needs_update=true; 
008B6:  MOVLW  02
008B8:  ADDWF  x4E,W
008BA:  MOVWF  FE9
008BC:  MOVLW  00
008BE:  ADDWFC x4F,W
008C0:  MOVWF  FEA
008C2:  BSF    FEF.0
....................    } 
....................    else if(sw->current_state==button_depressed && sw->outstate==on)   
008C4:  BRA    091C
008C6:  MOVLW  06
008C8:  ADDWF  x4E,W
008CA:  MOVWF  FE9
008CC:  MOVLW  00
008CE:  ADDWFC x4F,W
008D0:  MOVWF  FEA
008D2:  MOVLW  00
008D4:  BTFSC  FEF.0
008D6:  MOVLW  01
008D8:  ANDLW  01
008DA:  SUBLW  01
008DC:  BNZ   091C
008DE:  MOVLW  0B
008E0:  ADDWF  x4E,W
008E2:  MOVWF  FE9
008E4:  MOVLW  00
008E6:  ADDWFC x4F,W
008E8:  MOVWF  FEA
008EA:  MOVF   FEF,F
008EC:  BNZ   091C
....................    { 
....................          sw->outstate=off; 
008EE:  MOVLW  0B
008F0:  ADDWF  x4E,W
008F2:  MOVWF  FE9
008F4:  MOVLW  00
008F6:  ADDWFC x4F,W
008F8:  MOVWF  FEA
008FA:  MOVLW  01
008FC:  MOVWF  FEF
....................          sw->off.value=1; 
008FE:  MOVLW  04
00900:  ADDWF  x4E,W
00902:  MOVWF  FE9
00904:  MOVLW  00
00906:  ADDWFC x4F,W
00908:  MOVWF  FEA
0090A:  MOVLW  01
0090C:  MOVWF  FEF
....................          sw->off.needs_update=true; 
0090E:  MOVLW  05
00910:  ADDWF  x4E,W
00912:  MOVWF  FE9
00914:  MOVLW  00
00916:  ADDWFC x4F,W
00918:  MOVWF  FEA
0091A:  BSF    FEF.0
....................    } 
.................... } 
0091C:  MOVLB  0
0091E:  GOTO   0D52 (RETURN)
.................... void process_dimmers(struct dimmer_switch *sw) 
.................... { 
*
00396:  MOVLW  09
00398:  MOVLB  4
0039A:  ADDWF  x4E,W
0039C:  MOVWF  FE9
0039E:  MOVLW  00
003A0:  ADDWFC x4F,W
003A2:  MOVWF  FEA
003A4:  MOVFF  FEF,450
003A8:  MOVLW  01
003AA:  ADDWF  x4E,W
003AC:  MOVWF  FE9
003AE:  MOVLW  00
003B0:  ADDWFC x4F,W
003B2:  MOVWF  FEA
003B4:  MOVFF  FEF,451
....................    int last_level=sw->current_level; 
....................    int last_dim=sw->dim_level.value; 
....................    if(sw->current_state==button_pressed)//se o botao esta premido 
003B8:  MOVLW  0E
003BA:  ADDWF  x4E,W
003BC:  MOVWF  FE9
003BE:  MOVLW  00
003C0:  ADDWFC x4F,W
003C2:  MOVWF  FEA
003C4:  MOVLW  00
003C6:  BTFSC  FEF.0
003C8:  MOVLW  01
003CA:  ANDLW  01
003CC:  BTFSS  FD8.2
003CE:  BRA    05DA
....................    { 
....................     //  printf("STATE %u",sw->current_state); 
....................      // printf("DIF %LU",clock - sw->timer); 
....................       sw-> previous_state = button_pressed; 
003D0:  MOVLW  0E
003D2:  ADDWF  x4E,W
003D4:  MOVWF  FE9
003D6:  MOVLW  00
003D8:  ADDWFC x4F,W
003DA:  MOVWF  FEA
003DC:  BCF    FEF.1
....................       if ((clock - sw->timer > reg || sw->outstate == dimming) && sw->outstate!=maxed) 
003DE:  MOVLW  0A
003E0:  ADDWF  x4E,W
003E2:  MOVWF  FE9
003E4:  MOVLW  00
003E6:  ADDWFC x4F,W
003E8:  MOVWF  FEA
003EA:  MOVFF  FEF,00
003EE:  MOVFF  FEC,01
003F2:  MOVFF  FEC,02
003F6:  MOVFF  FEC,03
003FA:  MOVF   00,W
003FC:  MOVLB  3
003FE:  SUBWF  xEB,W
00400:  MOVLB  4
00402:  MOVWF  x52
00404:  MOVF   01,W
00406:  MOVLB  3
00408:  SUBWFB xEC,W
0040A:  MOVLB  4
0040C:  MOVWF  x53
0040E:  MOVF   02,W
00410:  MOVLB  3
00412:  SUBWFB xED,W
00414:  MOVLB  4
00416:  MOVWF  x54
00418:  MOVF   03,W
0041A:  MOVLB  3
0041C:  SUBWFB xEE,W
0041E:  MOVLB  4
00420:  MOVWF  x55
00422:  MOVLB  3
00424:  MOVF   xF3,W
00426:  MOVLB  4
00428:  SUBWF  x55,W
0042A:  BNC   0456
0042C:  BNZ   046A
0042E:  MOVLB  3
00430:  MOVF   xF2,W
00432:  MOVLB  4
00434:  SUBWF  x54,W
00436:  BNC   0456
00438:  BNZ   046A
0043A:  MOVLB  3
0043C:  MOVF   xF1,W
0043E:  MOVLB  4
00440:  SUBWF  x53,W
00442:  BNC   0456
00444:  BNZ   046A
00446:  MOVF   x52,W
00448:  MOVLB  3
0044A:  SUBWF  xF0,W
0044C:  BTFSC  FD8.0
0044E:  BRA    0454
00450:  MOVLB  4
00452:  BRA    046A
00454:  MOVLB  4
00456:  MOVLW  0F
00458:  ADDWF  x4E,W
0045A:  MOVWF  FE9
0045C:  MOVLW  00
0045E:  ADDWFC x4F,W
00460:  MOVWF  FEA
00462:  MOVF   FEF,W
00464:  SUBLW  02
00466:  BTFSS  FD8.2
00468:  BRA    05D8
0046A:  MOVLW  0F
0046C:  ADDWF  x4E,W
0046E:  MOVWF  FE9
00470:  MOVLW  00
00472:  ADDWFC x4F,W
00474:  MOVWF  FEA
00476:  MOVF   FEF,W
00478:  SUBLW  04
0047A:  BTFSC  FD8.2
0047C:  BRA    05D8
....................       {  
....................          if(sw->outstate==off) 
0047E:  MOVLW  0F
00480:  ADDWF  x4E,W
00482:  MOVWF  FE9
00484:  MOVLW  00
00486:  ADDWFC x4F,W
00488:  MOVWF  FEA
0048A:  DECFSZ FEF,W
0048C:  BRA    04CC
....................          { 
....................             sw->outstate=maxed; 
0048E:  MOVLW  0F
00490:  ADDWF  x4E,W
00492:  MOVWF  FE9
00494:  MOVLW  00
00496:  ADDWFC x4F,W
00498:  MOVWF  FEA
0049A:  MOVLW  04
0049C:  MOVWF  FEF
....................             sw->on.value=1; 
0049E:  ADDWF  x4E,W
004A0:  MOVWF  FE9
004A2:  MOVLW  00
004A4:  ADDWFC x4F,W
004A6:  MOVWF  FEA
004A8:  MOVLW  01
004AA:  MOVWF  FEF
....................             sw->current_level = 127; 
004AC:  MOVLW  09
004AE:  ADDWF  x4E,W
004B0:  MOVWF  FE9
004B2:  MOVLW  00
004B4:  ADDWFC x4F,W
004B6:  MOVWF  FEA
004B8:  MOVLW  7F
004BA:  MOVWF  FEF
....................             sw->on.needs_update=1; 
004BC:  MOVLW  05
004BE:  ADDWF  x4E,W
004C0:  MOVWF  FE9
004C2:  MOVLW  00
004C4:  ADDWFC x4F,W
004C6:  MOVWF  FEA
004C8:  BSF    FEF.0
....................          } 
....................         else 
004CA:  BRA    05D6
....................         { 
....................          sw->outstate = dimming; 
004CC:  MOVLW  0F
004CE:  ADDWF  x4E,W
004D0:  MOVWF  FE9
004D2:  MOVLW  00
004D4:  ADDWFC x4F,W
004D6:  MOVWF  FEA
004D8:  MOVLW  02
004DA:  MOVWF  FEF
....................          if (clock - sw->timer > TimeBase) //regula 
004DC:  MOVLW  0A
004DE:  ADDWF  x4E,W
004E0:  MOVWF  FE9
004E2:  MOVLW  00
004E4:  ADDWFC x4F,W
004E6:  MOVWF  FEA
004E8:  MOVFF  FEF,00
004EC:  MOVFF  FEC,01
004F0:  MOVFF  FEC,02
004F4:  MOVFF  FEC,03
004F8:  MOVF   00,W
004FA:  MOVLB  3
004FC:  SUBWF  xEB,W
004FE:  MOVLB  4
00500:  MOVWF  x52
00502:  MOVF   01,W
00504:  MOVLB  3
00506:  SUBWFB xEC,W
00508:  MOVLB  4
0050A:  MOVWF  x53
0050C:  MOVF   02,W
0050E:  MOVLB  3
00510:  SUBWFB xED,W
00512:  MOVLB  4
00514:  MOVWF  x54
00516:  MOVF   03,W
00518:  MOVLB  3
0051A:  SUBWFB xEE,W
0051C:  MOVLB  4
0051E:  MOVWF  x55
00520:  MOVF   x55,F
00522:  BNZ   0536
00524:  MOVF   x54,F
00526:  BNZ   0536
00528:  MOVF   x53,F
0052A:  BNZ   0536
0052C:  MOVF   x52,W
0052E:  MOVLB  3
00530:  SUBWF  xEF,W
00532:  BC    05B8
00534:  MOVLB  4
....................          { 
....................             if (sw->direction == up) //para cima 
00536:  MOVLW  0E
00538:  ADDWF  x4E,W
0053A:  MOVWF  FE9
0053C:  MOVLW  00
0053E:  ADDWFC x4F,W
00540:  MOVWF  FEA
00542:  MOVLW  00
00544:  BTFSC  FEF.2
00546:  MOVLW  01
00548:  ANDLW  01
0054A:  BNZ   057C
....................             { 
....................                ++sw->current_level; 
0054C:  MOVLW  09
0054E:  ADDWF  x4E,W
00550:  MOVWF  FE9
00552:  MOVLW  00
00554:  ADDWFC x4F,W
00556:  MOVWF  FEA
00558:  INCF   FEF,F
....................                if (sw->current_level == 127) sw->direction = down; 
0055A:  MOVLW  09
0055C:  ADDWF  x4E,W
0055E:  MOVWF  FE9
00560:  MOVLW  00
00562:  ADDWFC x4F,W
00564:  MOVWF  FEA
00566:  MOVF   FEF,W
00568:  SUBLW  7F
0056A:  BNZ   057A
0056C:  MOVLW  0E
0056E:  ADDWF  x4E,W
00570:  MOVWF  FE9
00572:  MOVLW  00
00574:  ADDWFC x4F,W
00576:  MOVWF  FEA
00578:  BSF    FEF.2
....................             } 
....................             else//para baixo 
0057A:  BRA    05B8
....................             { 
....................                --sw->current_level; 
0057C:  MOVLW  09
0057E:  ADDWF  x4E,W
00580:  MOVWF  FE9
00582:  MOVLW  00
00584:  ADDWFC x4F,W
00586:  MOVWF  FEA
00588:  DECF   FEF,F
....................                if (sw->current_level == 0)  
0058A:  MOVLW  09
0058C:  ADDWF  x4E,W
0058E:  MOVWF  FE9
00590:  MOVLW  00
00592:  ADDWFC x4F,W
00594:  MOVWF  FEA
00596:  MOVF   FEF,F
00598:  BNZ   05B8
....................                {   
....................                   sw->direction = up; 
0059A:  MOVLW  0E
0059C:  ADDWF  x4E,W
0059E:  MOVWF  FE9
005A0:  MOVLW  00
005A2:  ADDWFC x4F,W
005A4:  MOVWF  FEA
005A6:  BCF    FEF.2
....................                   sw->off.value=1; 
005A8:  MOVLW  07
005AA:  ADDWF  x4E,W
005AC:  MOVWF  FE9
005AE:  MOVLW  00
005B0:  ADDWFC x4F,W
005B2:  MOVWF  FEA
005B4:  MOVLW  01
005B6:  MOVWF  FEF
....................                } 
....................             } 
....................          } 
....................          sw->timer = clock; 
005B8:  MOVLW  0A
005BA:  MOVLB  4
005BC:  ADDWF  x4E,W
005BE:  MOVWF  FE9
005C0:  MOVLW  00
005C2:  ADDWFC x4F,W
005C4:  MOVWF  FEA
005C6:  MOVFF  3EB,FEF
005CA:  MOVFF  3EC,FEC
005CE:  MOVFF  3ED,FEC
005D2:  MOVFF  3EE,FEC
....................       } 
....................       } 
....................       else 
005D6:  BRA    05D8
....................       { 
....................          //sw - > timer = clock; 
....................       } 
....................    } 
....................    else//se o botao nao esta premido 
005D8:  BRA    073A
....................    { 
....................       if (sw->previous_state == button_pressed) //se o botao acabou de ser deslargado 
005DA:  MOVLW  0E
005DC:  ADDWF  x4E,W
005DE:  MOVWF  FE9
005E0:  MOVLW  00
005E2:  ADDWFC x4F,W
005E4:  MOVWF  FEA
005E6:  MOVLW  00
005E8:  BTFSC  FEF.1
005EA:  MOVLW  01
005EC:  ANDLW  01
005EE:  BTFSS  FD8.2
005F0:  BRA    071E
....................       { 
....................          sw->previous_state = button_depressed; 
005F2:  MOVLW  0E
005F4:  ADDWF  x4E,W
005F6:  MOVWF  FE9
005F8:  MOVLW  00
005FA:  ADDWFC x4F,W
005FC:  MOVWF  FEA
005FE:  BSF    FEF.1
....................          if (sw->outstate == dimming) //se esteve a regular 
00600:  MOVLW  0F
00602:  ADDWF  x4E,W
00604:  MOVWF  FE9
00606:  MOVLW  00
00608:  ADDWFC x4F,W
0060A:  MOVWF  FEA
0060C:  MOVF   FEF,W
0060E:  SUBLW  02
00610:  BNZ   0656
....................          { 
....................             sw-> outstate = on; 
00612:  MOVLW  0F
00614:  ADDWF  x4E,W
00616:  MOVWF  FE9
00618:  MOVLW  00
0061A:  ADDWFC x4F,W
0061C:  MOVWF  FEA
0061E:  CLRF   FEF
....................             if (sw->direction == up) sw->direction = down; //inverte direccao 
00620:  MOVLW  0E
00622:  ADDWF  x4E,W
00624:  MOVWF  FE9
00626:  MOVLW  00
00628:  ADDWFC x4F,W
0062A:  MOVWF  FEA
0062C:  MOVLW  00
0062E:  BTFSC  FEF.2
00630:  MOVLW  01
00632:  ANDLW  01
00634:  BNZ   0646
00636:  MOVLW  0E
00638:  ADDWF  x4E,W
0063A:  MOVWF  FE9
0063C:  MOVLW  00
0063E:  ADDWFC x4F,W
00640:  MOVWF  FEA
00642:  BSF    FEF.2
....................             else sw->direction = up; 
00644:  BRA    0654
00646:  MOVLW  0E
00648:  ADDWF  x4E,W
0064A:  MOVWF  FE9
0064C:  MOVLW  00
0064E:  ADDWFC x4F,W
00650:  MOVWF  FEA
00652:  BCF    FEF.2
....................          } 
....................          else//se nao esteve a regular 
00654:  BRA    071E
....................          { 
....................             if (sw->outstate == off) //se estava desligada 
00656:  MOVLW  0F
00658:  ADDWF  x4E,W
0065A:  MOVWF  FE9
0065C:  MOVLW  00
0065E:  ADDWFC x4F,W
00660:  MOVWF  FEA
00662:  DECFSZ FEF,W
00664:  BRA    06A2
....................             { 
....................               // printf("on"); 
....................                sw->outstate=on; 
00666:  MOVLW  0F
00668:  ADDWF  x4E,W
0066A:  MOVWF  FE9
0066C:  MOVLW  00
0066E:  ADDWFC x4F,W
00670:  MOVWF  FEA
00672:  CLRF   FEF
....................                sw->on.value=1; 
00674:  MOVLW  04
00676:  ADDWF  x4E,W
00678:  MOVWF  FE9
0067A:  MOVLW  00
0067C:  ADDWFC x4F,W
0067E:  MOVWF  FEA
00680:  MOVLW  01
00682:  MOVWF  FEF
....................                sw->direction = down; 
00684:  MOVLW  0E
00686:  ADDWF  x4E,W
00688:  MOVWF  FE9
0068A:  MOVLW  00
0068C:  ADDWFC x4F,W
0068E:  MOVWF  FEA
00690:  BSF    FEF.2
....................                sw->on.needs_update=true; 
00692:  MOVLW  05
00694:  ADDWF  x4E,W
00696:  MOVWF  FE9
00698:  MOVLW  00
0069A:  ADDWFC x4F,W
0069C:  MOVWF  FEA
0069E:  BSF    FEF.0
....................             } 
....................             else if (sw->outstate == on) 
006A0:  BRA    071E
006A2:  MOVLW  0F
006A4:  ADDWF  x4E,W
006A6:  MOVWF  FE9
006A8:  MOVLW  00
006AA:  ADDWFC x4F,W
006AC:  MOVWF  FEA
006AE:  MOVF   FEF,F
006B0:  BNZ   06F0
....................             { 
....................               // printf("off"); 
....................                //sw->current_level = 0; //senao desliga 
....................                sw->outstate=off; 
006B2:  MOVLW  0F
006B4:  ADDWF  x4E,W
006B6:  MOVWF  FE9
006B8:  MOVLW  00
006BA:  ADDWFC x4F,W
006BC:  MOVWF  FEA
006BE:  MOVLW  01
006C0:  MOVWF  FEF
....................                sw->off.value=1; 
006C2:  MOVLW  07
006C4:  ADDWF  x4E,W
006C6:  MOVWF  FE9
006C8:  MOVLW  00
006CA:  ADDWFC x4F,W
006CC:  MOVWF  FEA
006CE:  MOVLW  01
006D0:  MOVWF  FEF
....................                sw->direction = up; 
006D2:  MOVLW  0E
006D4:  ADDWF  x4E,W
006D6:  MOVWF  FE9
006D8:  MOVLW  00
006DA:  ADDWFC x4F,W
006DC:  MOVWF  FEA
006DE:  BCF    FEF.2
....................                sw->off.needs_update=true; 
006E0:  MOVLW  08
006E2:  ADDWF  x4E,W
006E4:  MOVWF  FE9
006E6:  MOVLW  00
006E8:  ADDWFC x4F,W
006EA:  MOVWF  FEA
006EC:  BSF    FEF.0
....................             } 
....................             else if(sw->outstate == maxed) 
006EE:  BRA    071E
006F0:  MOVLW  0F
006F2:  ADDWF  x4E,W
006F4:  MOVWF  FE9
006F6:  MOVLW  00
006F8:  ADDWFC x4F,W
006FA:  MOVWF  FEA
006FC:  MOVF   FEF,W
006FE:  SUBLW  04
00700:  BNZ   071E
....................             { 
....................                sw->outstate=on; 
00702:  MOVLW  0F
00704:  ADDWF  x4E,W
00706:  MOVWF  FE9
00708:  MOVLW  00
0070A:  ADDWFC x4F,W
0070C:  MOVWF  FEA
0070E:  CLRF   FEF
....................                sw->direction = down; 
00710:  MOVLW  0E
00712:  ADDWF  x4E,W
00714:  MOVWF  FE9
00716:  MOVLW  00
00718:  ADDWFC x4F,W
0071A:  MOVWF  FEA
0071C:  BSF    FEF.2
....................             } 
....................          } 
....................       } 
....................       sw->timer = clock; 
0071E:  MOVLW  0A
00720:  ADDWF  x4E,W
00722:  MOVWF  FE9
00724:  MOVLW  00
00726:  ADDWFC x4F,W
00728:  MOVWF  FEA
0072A:  MOVFF  3EB,FEF
0072E:  MOVFF  3EC,FEC
00732:  MOVFF  3ED,FEC
00736:  MOVFF  3EE,FEC
....................    } 
....................  //  onOffHelper(sw); 
....................    if (last_level!=sw->current_level)  
0073A:  MOVLW  09
0073C:  ADDWF  x4E,W
0073E:  MOVWF  FE9
00740:  MOVLW  00
00742:  ADDWFC x4F,W
00744:  MOVWF  FEA
00746:  MOVF   FEF,W
00748:  SUBWF  x50,W
0074A:  BZ    0782
....................    { 
....................       sw->dim_level.value=sw->current_level; 
0074C:  MOVLW  01
0074E:  ADDWF  x4E,W
00750:  MOVWF  01
00752:  MOVLW  00
00754:  ADDWFC x4F,W
00756:  MOVWF  03
00758:  MOVLW  09
0075A:  ADDWF  x4E,W
0075C:  MOVWF  FE9
0075E:  MOVLW  00
00760:  ADDWFC x4F,W
00762:  MOVWF  FEA
00764:  MOVFF  FEF,454
00768:  MOVFF  03,FEA
0076C:  MOVFF  01,FE9
00770:  MOVFF  454,FEF
....................       sw->dim_level.needs_update=true; 
00774:  MOVLW  02
00776:  ADDWF  x4E,W
00778:  MOVWF  FE9
0077A:  MOVLW  00
0077C:  ADDWFC x4F,W
0077E:  MOVWF  FEA
00780:  BSF    FEF.0
....................    } 
.................... } 
00782:  MOVLB  0
00784:  GOTO   0D52 (RETURN)
....................  
.................... void read_inputs() 
.................... { 
....................   int x; 
....................    for(x=0;x<mydevices.numberOfInputs;++x) 
*
00922:  MOVLB  4
00924:  CLRF   x4B
00926:  MOVLB  1
00928:  MOVF   xD7,W
0092A:  MOVLB  4
0092C:  SUBWF  x4B,W
0092E:  BTFSC  FD8.0
00930:  BRA    0D58
....................    { 
....................       switch (mydevices.myinputs[x].type) { 
00932:  CLRF   x4D
00934:  MOVFF  44B,44C
00938:  CLRF   x4F
0093A:  MOVLW  12
0093C:  MOVWF  x4E
0093E:  MOVLB  0
00940:  RCALL  0300
00942:  MOVFF  02,03
00946:  MOVF   01,W
00948:  ADDLW  D9
0094A:  MOVWF  FE9
0094C:  MOVLW  01
0094E:  ADDWFC 02,W
00950:  MOVWF  FEA
00952:  MOVF   FEF,W
00954:  BZ    096A
00956:  XORLW  03
00958:  BTFSC  FD8.2
0095A:  BRA    0AB0
0095C:  XORLW  02
0095E:  BTFSC  FD8.2
00960:  BRA    0AB2
00962:  XORLW  03
00964:  BTFSC  FD8.2
00966:  BRA    0BFE
00968:  BRA    0D50
....................     case dimmer_switch: 
....................            // printf("aki"); 
....................             if (input (((struct dimmer_switch)mydevices.myinputs[x].device).realbutton))  
0096A:  MOVLB  4
0096C:  CLRF   x4D
0096E:  MOVFF  44B,44C
00972:  CLRF   x4F
00974:  MOVLW  12
00976:  MOVWF  x4E
00978:  MOVLB  0
0097A:  RCALL  0300
0097C:  MOVF   01,W
0097E:  ADDLW  02
00980:  MOVLB  4
00982:  MOVWF  x4C
00984:  MOVLW  00
00986:  ADDWFC 02,W
00988:  MOVWF  x4D
0098A:  MOVLW  01
0098C:  ADDWF  x4C,W
0098E:  MOVWF  01
00990:  MOVLW  00
00992:  ADDWFC x4D,W
00994:  MOVWF  03
00996:  MOVF   01,W
00998:  ADDLW  D7
0099A:  MOVWF  01
0099C:  MOVLW  01
0099E:  ADDWFC 03,F
009A0:  MOVF   01,W
009A2:  ADDLW  10
009A4:  MOVWF  FE9
009A6:  MOVLW  00
009A8:  ADDWFC 03,W
009AA:  MOVWF  FEA
009AC:  MOVFF  FEF,44E
009B0:  MOVFF  44E,44F
009B4:  MOVLW  01
009B6:  MOVWF  x50
009B8:  MOVLW  0F
009BA:  MOVWF  x52
009BC:  MOVLW  92
009BE:  MOVWF  x51
009C0:  MOVLB  0
009C2:  RCALL  0322
009C4:  MOVFF  44E,44F
009C8:  MOVLW  0F
009CA:  MOVLB  4
009CC:  MOVWF  x51
009CE:  MOVLW  80
009D0:  MOVWF  x50
009D2:  MOVLB  0
009D4:  RCALL  0364
009D6:  BTFSS  01.0
009D8:  BRA    0A22
....................             { 
....................                ((struct dimmer_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
009DA:  MOVLB  4
009DC:  CLRF   x4D
009DE:  MOVFF  44B,44C
009E2:  CLRF   x4F
009E4:  MOVLW  12
009E6:  MOVWF  x4E
009E8:  MOVLB  0
009EA:  RCALL  0300
009EC:  MOVF   01,W
009EE:  ADDLW  02
009F0:  MOVLB  4
009F2:  MOVWF  x4C
009F4:  MOVLW  00
009F6:  ADDWFC 02,W
009F8:  MOVWF  x4D
009FA:  MOVLW  01
009FC:  ADDWF  x4C,W
009FE:  MOVWF  01
00A00:  MOVLW  00
00A02:  ADDWFC x4D,W
00A04:  MOVWF  03
00A06:  MOVF   01,W
00A08:  ADDLW  D7
00A0A:  MOVWF  01
00A0C:  MOVLW  01
00A0E:  ADDWFC 03,F
00A10:  MOVF   01,W
00A12:  ADDLW  0E
00A14:  MOVWF  FE9
00A16:  MOVLW  00
00A18:  ADDWFC 03,W
00A1A:  MOVWF  FEA
00A1C:  BSF    FEF.0
....................             } 
....................             else  
00A1E:  BRA    0A66
00A20:  MOVLB  0
....................             { 
....................                ((struct dimmer_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
00A22:  MOVLB  4
00A24:  CLRF   x4D
00A26:  MOVFF  44B,44C
00A2A:  CLRF   x4F
00A2C:  MOVLW  12
00A2E:  MOVWF  x4E
00A30:  MOVLB  0
00A32:  RCALL  0300
00A34:  MOVF   01,W
00A36:  ADDLW  02
00A38:  MOVLB  4
00A3A:  MOVWF  x4C
00A3C:  MOVLW  00
00A3E:  ADDWFC 02,W
00A40:  MOVWF  x4D
00A42:  MOVLW  01
00A44:  ADDWF  x4C,W
00A46:  MOVWF  01
00A48:  MOVLW  00
00A4A:  ADDWFC x4D,W
00A4C:  MOVWF  03
00A4E:  MOVF   01,W
00A50:  ADDLW  D7
00A52:  MOVWF  01
00A54:  MOVLW  01
00A56:  ADDWFC 03,F
00A58:  MOVF   01,W
00A5A:  ADDLW  0E
00A5C:  MOVWF  FE9
00A5E:  MOVLW  00
00A60:  ADDWFC 03,W
00A62:  MOVWF  FEA
00A64:  BCF    FEF.0
....................             } 
....................             process_dimmers(&mydevices.myinputs[x].device); 
00A66:  CLRF   x4D
00A68:  MOVFF  44B,44C
00A6C:  CLRF   x4F
00A6E:  MOVLW  12
00A70:  MOVWF  x4E
00A72:  MOVLB  0
00A74:  RCALL  0300
00A76:  MOVF   01,W
00A78:  ADDLW  02
00A7A:  MOVLB  4
00A7C:  MOVWF  x4C
00A7E:  MOVLW  00
00A80:  ADDWFC 02,W
00A82:  MOVWF  x4D
00A84:  MOVLW  01
00A86:  ADDWF  x4C,W
00A88:  MOVWF  01
00A8A:  MOVLW  00
00A8C:  ADDWFC x4D,W
00A8E:  MOVWF  03
00A90:  MOVF   01,W
00A92:  ADDLW  D7
00A94:  MOVWF  01
00A96:  MOVLW  01
00A98:  ADDWFC 03,F
00A9A:  MOVFF  01,44C
00A9E:  MOVFF  03,44D
00AA2:  MOVFF  03,44F
00AA6:  MOVFF  01,44E
00AAA:  MOVLB  0
00AAC:  BRA    0396
....................             break; 
00AAE:  BRA    0D52
....................     case timer: 
....................  
....................            break; 
00AB0:  BRA    0D52
....................     case on_off_switch: 
....................            // printf("aki"); 
....................             if (input (((struct on_off_switch)mydevices.myinputs[x].device).realbutton))  
00AB2:  MOVLB  4
00AB4:  CLRF   x4D
00AB6:  MOVFF  44B,44C
00ABA:  CLRF   x4F
00ABC:  MOVLW  12
00ABE:  MOVWF  x4E
00AC0:  MOVLB  0
00AC2:  RCALL  0300
00AC4:  MOVF   01,W
00AC6:  ADDLW  02
00AC8:  MOVLB  4
00ACA:  MOVWF  x4C
00ACC:  MOVLW  00
00ACE:  ADDWFC 02,W
00AD0:  MOVWF  x4D
00AD2:  MOVLW  01
00AD4:  ADDWF  x4C,W
00AD6:  MOVWF  01
00AD8:  MOVLW  00
00ADA:  ADDWFC x4D,W
00ADC:  MOVWF  03
00ADE:  MOVF   01,W
00AE0:  ADDLW  D7
00AE2:  MOVWF  01
00AE4:  MOVLW  01
00AE6:  ADDWFC 03,F
00AE8:  MOVF   01,W
00AEA:  ADDLW  0C
00AEC:  MOVWF  FE9
00AEE:  MOVLW  00
00AF0:  ADDWFC 03,W
00AF2:  MOVWF  FEA
00AF4:  MOVFF  FEF,44E
00AF8:  MOVFF  44E,44F
00AFC:  MOVLW  01
00AFE:  MOVWF  x50
00B00:  MOVLW  0F
00B02:  MOVWF  x52
00B04:  MOVLW  92
00B06:  MOVWF  x51
00B08:  MOVLB  0
00B0A:  RCALL  0322
00B0C:  MOVFF  44E,44F
00B10:  MOVLW  0F
00B12:  MOVLB  4
00B14:  MOVWF  x51
00B16:  MOVLW  80
00B18:  MOVWF  x50
00B1A:  MOVLB  0
00B1C:  RCALL  0364
00B1E:  BTFSS  01.0
00B20:  BRA    0B6C
....................             { 
....................                ((struct on_off_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
00B22:  MOVLB  4
00B24:  CLRF   x4D
00B26:  MOVFF  44B,44C
00B2A:  CLRF   x4F
00B2C:  MOVLW  12
00B2E:  MOVWF  x4E
00B30:  MOVLB  0
00B32:  CALL   0300
00B36:  MOVF   01,W
00B38:  ADDLW  02
00B3A:  MOVLB  4
00B3C:  MOVWF  x4C
00B3E:  MOVLW  00
00B40:  ADDWFC 02,W
00B42:  MOVWF  x4D
00B44:  MOVLW  01
00B46:  ADDWF  x4C,W
00B48:  MOVWF  01
00B4A:  MOVLW  00
00B4C:  ADDWFC x4D,W
00B4E:  MOVWF  03
00B50:  MOVF   01,W
00B52:  ADDLW  D7
00B54:  MOVWF  01
00B56:  MOVLW  01
00B58:  ADDWFC 03,F
00B5A:  MOVF   01,W
00B5C:  ADDLW  06
00B5E:  MOVWF  FE9
00B60:  MOVLW  00
00B62:  ADDWFC 03,W
00B64:  MOVWF  FEA
00B66:  BSF    FEF.0
....................             } 
....................             else  
00B68:  BRA    0BB2
00B6A:  MOVLB  0
....................             { 
....................                ((struct on_off_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
00B6C:  MOVLB  4
00B6E:  CLRF   x4D
00B70:  MOVFF  44B,44C
00B74:  CLRF   x4F
00B76:  MOVLW  12
00B78:  MOVWF  x4E
00B7A:  MOVLB  0
00B7C:  CALL   0300
00B80:  MOVF   01,W
00B82:  ADDLW  02
00B84:  MOVLB  4
00B86:  MOVWF  x4C
00B88:  MOVLW  00
00B8A:  ADDWFC 02,W
00B8C:  MOVWF  x4D
00B8E:  MOVLW  01
00B90:  ADDWF  x4C,W
00B92:  MOVWF  01
00B94:  MOVLW  00
00B96:  ADDWFC x4D,W
00B98:  MOVWF  03
00B9A:  MOVF   01,W
00B9C:  ADDLW  D7
00B9E:  MOVWF  01
00BA0:  MOVLW  01
00BA2:  ADDWFC 03,F
00BA4:  MOVF   01,W
00BA6:  ADDLW  06
00BA8:  MOVWF  FE9
00BAA:  MOVLW  00
00BAC:  ADDWFC 03,W
00BAE:  MOVWF  FEA
00BB0:  BCF    FEF.0
....................             } 
....................             process_onOff(&mydevices.myinputs[x].device); 
00BB2:  CLRF   x4D
00BB4:  MOVFF  44B,44C
00BB8:  CLRF   x4F
00BBA:  MOVLW  12
00BBC:  MOVWF  x4E
00BBE:  MOVLB  0
00BC0:  CALL   0300
00BC4:  MOVF   01,W
00BC6:  ADDLW  02
00BC8:  MOVLB  4
00BCA:  MOVWF  x4C
00BCC:  MOVLW  00
00BCE:  ADDWFC 02,W
00BD0:  MOVWF  x4D
00BD2:  MOVLW  01
00BD4:  ADDWF  x4C,W
00BD6:  MOVWF  01
00BD8:  MOVLW  00
00BDA:  ADDWFC x4D,W
00BDC:  MOVWF  03
00BDE:  MOVF   01,W
00BE0:  ADDLW  D7
00BE2:  MOVWF  01
00BE4:  MOVLW  01
00BE6:  ADDWFC 03,F
00BE8:  MOVFF  01,44C
00BEC:  MOVFF  03,44D
00BF0:  MOVFF  03,44F
00BF4:  MOVFF  01,44E
00BF8:  MOVLB  0
00BFA:  BRA    0788
....................     break; 
00BFC:  BRA    0D52
....................     case button_switch: 
....................            // printf("aki"); 
....................             if (input (((struct button_switch)mydevices.myinputs[x].device).realbutton))  
00BFE:  MOVLB  4
00C00:  CLRF   x4D
00C02:  MOVFF  44B,44C
00C06:  CLRF   x4F
00C08:  MOVLW  12
00C0A:  MOVWF  x4E
00C0C:  MOVLB  0
00C0E:  CALL   0300
00C12:  MOVF   01,W
00C14:  ADDLW  02
00C16:  MOVLB  4
00C18:  MOVWF  x4C
00C1A:  MOVLW  00
00C1C:  ADDWFC 02,W
00C1E:  MOVWF  x4D
00C20:  MOVLW  01
00C22:  ADDWF  x4C,W
00C24:  MOVWF  01
00C26:  MOVLW  00
00C28:  ADDWFC x4D,W
00C2A:  MOVWF  03
00C2C:  MOVF   01,W
00C2E:  ADDLW  D7
00C30:  MOVWF  01
00C32:  MOVLW  01
00C34:  ADDWFC 03,F
00C36:  MOVF   01,W
00C38:  ADDLW  0C
00C3A:  MOVWF  FE9
00C3C:  MOVLW  00
00C3E:  ADDWFC 03,W
00C40:  MOVWF  FEA
00C42:  MOVFF  FEF,44E
00C46:  MOVFF  44E,44F
00C4A:  MOVLW  01
00C4C:  MOVWF  x50
00C4E:  MOVLW  0F
00C50:  MOVWF  x52
00C52:  MOVLW  92
00C54:  MOVWF  x51
00C56:  MOVLB  0
00C58:  CALL   0322
00C5C:  MOVFF  44E,44F
00C60:  MOVLW  0F
00C62:  MOVLB  4
00C64:  MOVWF  x51
00C66:  MOVLW  80
00C68:  MOVWF  x50
00C6A:  MOVLB  0
00C6C:  CALL   0364
00C70:  BTFSS  01.0
00C72:  BRA    0CBE
....................             { 
....................                ((struct button_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
00C74:  MOVLB  4
00C76:  CLRF   x4D
00C78:  MOVFF  44B,44C
00C7C:  CLRF   x4F
00C7E:  MOVLW  12
00C80:  MOVWF  x4E
00C82:  MOVLB  0
00C84:  CALL   0300
00C88:  MOVF   01,W
00C8A:  ADDLW  02
00C8C:  MOVLB  4
00C8E:  MOVWF  x4C
00C90:  MOVLW  00
00C92:  ADDWFC 02,W
00C94:  MOVWF  x4D
00C96:  MOVLW  01
00C98:  ADDWF  x4C,W
00C9A:  MOVWF  01
00C9C:  MOVLW  00
00C9E:  ADDWFC x4D,W
00CA0:  MOVWF  03
00CA2:  MOVF   01,W
00CA4:  ADDLW  D7
00CA6:  MOVWF  01
00CA8:  MOVLW  01
00CAA:  ADDWFC 03,F
00CAC:  MOVF   01,W
00CAE:  ADDLW  06
00CB0:  MOVWF  FE9
00CB2:  MOVLW  00
00CB4:  ADDWFC 03,W
00CB6:  MOVWF  FEA
00CB8:  BSF    FEF.0
....................             } 
....................             else  
00CBA:  BRA    0D04
00CBC:  MOVLB  0
....................             { 
....................                ((struct button_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
00CBE:  MOVLB  4
00CC0:  CLRF   x4D
00CC2:  MOVFF  44B,44C
00CC6:  CLRF   x4F
00CC8:  MOVLW  12
00CCA:  MOVWF  x4E
00CCC:  MOVLB  0
00CCE:  CALL   0300
00CD2:  MOVF   01,W
00CD4:  ADDLW  02
00CD6:  MOVLB  4
00CD8:  MOVWF  x4C
00CDA:  MOVLW  00
00CDC:  ADDWFC 02,W
00CDE:  MOVWF  x4D
00CE0:  MOVLW  01
00CE2:  ADDWF  x4C,W
00CE4:  MOVWF  01
00CE6:  MOVLW  00
00CE8:  ADDWFC x4D,W
00CEA:  MOVWF  03
00CEC:  MOVF   01,W
00CEE:  ADDLW  D7
00CF0:  MOVWF  01
00CF2:  MOVLW  01
00CF4:  ADDWFC 03,F
00CF6:  MOVF   01,W
00CF8:  ADDLW  06
00CFA:  MOVWF  FE9
00CFC:  MOVLW  00
00CFE:  ADDWFC 03,W
00D00:  MOVWF  FEA
00D02:  BCF    FEF.0
....................             } 
....................             process_buttons(&mydevices.myinputs[x].device); 
00D04:  CLRF   x4D
00D06:  MOVFF  44B,44C
00D0A:  CLRF   x4F
00D0C:  MOVLW  12
00D0E:  MOVWF  x4E
00D10:  MOVLB  0
00D12:  CALL   0300
00D16:  MOVF   01,W
00D18:  ADDLW  02
00D1A:  MOVLB  4
00D1C:  MOVWF  x4C
00D1E:  MOVLW  00
00D20:  ADDWFC 02,W
00D22:  MOVWF  x4D
00D24:  MOVLW  01
00D26:  ADDWF  x4C,W
00D28:  MOVWF  01
00D2A:  MOVLW  00
00D2C:  ADDWFC x4D,W
00D2E:  MOVWF  03
00D30:  MOVF   01,W
00D32:  ADDLW  D7
00D34:  MOVWF  01
00D36:  MOVLW  01
00D38:  ADDWFC 03,F
00D3A:  MOVFF  01,44C
00D3E:  MOVFF  03,44D
00D42:  MOVFF  03,44F
00D46:  MOVFF  01,44E
00D4A:  MOVLB  0
00D4C:  BRA    0870
....................     break; 
00D4E:  BRA    0D52
....................     default: 
....................  
....................             break;  
00D50:  BRA    0D52
....................             } 
....................  
....................    } 
00D52:  MOVLB  4
00D54:  INCF   x4B,F
00D56:  BRA    0926
.................... } 
00D58:  MOVLB  0
00D5A:  GOTO   0D78 (RETURN)
.................... void print_inputs() 
.................... { 
....................    int x; 
....................    while(true) 
....................    { 
....................       delay_ms (200) ; 
*
026C0:  MOVLW  C8
026C2:  MOVLB  3
026C4:  MOVWF  xF7
026C6:  MOVLB  0
026C8:  RCALL  260A
....................       for(x=0;x<mydevices.numberOfInputs;++x) 
026CA:  MOVLB  3
026CC:  CLRF   xF6
026CE:  MOVLB  1
026D0:  MOVF   xD7,W
026D2:  MOVLB  3
026D4:  SUBWF  xF6,W
026D6:  BTFSC  FD8.0
026D8:  BRA    2942
026DA:  CLRF   1B
026DC:  BTFSC  FF2.7
026DE:  BSF    1B.7
026E0:  BCF    FF2.7
....................       { 
....................          switch (mydevices.myinputs[x].type) { 
026E2:  MOVLB  4
026E4:  CLRF   x4D
026E6:  MOVFF  3F6,44C
026EA:  CLRF   x4F
026EC:  MOVLW  12
026EE:  MOVWF  x4E
026F0:  MOVLB  0
026F2:  CALL   0300
026F6:  BTFSC  1B.7
026F8:  BSF    FF2.7
026FA:  MOVFF  02,03
026FE:  MOVF   01,W
02700:  ADDLW  D9
02702:  MOVWF  FE9
02704:  MOVLW  01
02706:  ADDWFC 02,W
02708:  MOVWF  FEA
0270A:  MOVF   FEF,W
0270C:  BZ    271C
0270E:  XORLW  01
02710:  BTFSC  FD8.2
02712:  BRA    2800
02714:  XORLW  03
02716:  BTFSC  FD8.2
02718:  BRA    289E
0271A:  BRA    293C
....................             case dimmer_switch: 
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.needs_update) 
0271C:  MOVLB  1
0271E:  BTFSS  xDC.0
02720:  BRA    2764
....................                { 
....................                   printf("dim_level %u\n\r"((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.value); 
02722:  MOVLW  D2
02724:  MOVWF  FF6
02726:  MOVLW  02
02728:  MOVWF  FF7
0272A:  MOVLW  00
0272C:  MOVWF  FF8
0272E:  MOVLW  0A
02730:  MOVLB  4
02732:  MOVWF  x41
02734:  MOVLB  0
02736:  CALL   1CFA
0273A:  MOVFF  1DB,3F8
0273E:  MOVLW  1B
02740:  MOVLB  3
02742:  MOVWF  xF9
02744:  MOVLB  0
02746:  RCALL  263A
02748:  MOVLW  0A
0274A:  MOVLB  4
0274C:  MOVWF  x4A
0274E:  MOVLB  0
02750:  CALL   1BEA
02754:  MOVLW  0D
02756:  MOVLB  4
02758:  MOVWF  x4A
0275A:  MOVLB  0
0275C:  CALL   1BEA
....................                   ((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.needs_update=false; 
02760:  MOVLB  1
02762:  BCF    xDC.0
....................                } 
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).on.needs_update) 
02764:  BTFSS  xDF.0
02766:  BRA    27B6
....................                { 
....................                   printf("on %u\n\r",((struct dimmer_switch)mydevices.myinputs[0].device).on.value); 
02768:  MOVLW  6F
0276A:  MOVLB  4
0276C:  MOVWF  x4A
0276E:  MOVLB  0
02770:  CALL   1BEA
02774:  MOVLW  6E
02776:  MOVLB  4
02778:  MOVWF  x4A
0277A:  MOVLB  0
0277C:  CALL   1BEA
02780:  MOVLW  20
02782:  MOVLB  4
02784:  MOVWF  x4A
02786:  MOVLB  0
02788:  CALL   1BEA
0278C:  MOVFF  1DE,3F8
02790:  MOVLW  1B
02792:  MOVLB  3
02794:  MOVWF  xF9
02796:  MOVLB  0
02798:  RCALL  263A
0279A:  MOVLW  0A
0279C:  MOVLB  4
0279E:  MOVWF  x4A
027A0:  MOVLB  0
027A2:  CALL   1BEA
027A6:  MOVLW  0D
027A8:  MOVLB  4
027AA:  MOVWF  x4A
027AC:  MOVLB  0
027AE:  CALL   1BEA
....................                   ((struct dimmer_switch)mydevices.myinputs[0].device).on.needs_update=false; 
027B2:  MOVLB  1
027B4:  BCF    xDF.0
....................                }            
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).off.needs_update) 
027B6:  BTFSS  xE2.0
027B8:  BRA    27FC
....................                { 
....................                   printf("off %u\n\r",((struct dimmer_switch)mydevices.myinputs[0].device).off.value); 
027BA:  MOVLW  E2
027BC:  MOVWF  FF6
027BE:  MOVLW  02
027C0:  MOVWF  FF7
027C2:  MOVLW  00
027C4:  MOVWF  FF8
027C6:  MOVLW  04
027C8:  MOVLB  4
027CA:  MOVWF  x41
027CC:  MOVLB  0
027CE:  CALL   1CFA
027D2:  MOVFF  1E1,3F8
027D6:  MOVLW  1B
027D8:  MOVLB  3
027DA:  MOVWF  xF9
027DC:  MOVLB  0
027DE:  RCALL  263A
027E0:  MOVLW  0A
027E2:  MOVLB  4
027E4:  MOVWF  x4A
027E6:  MOVLB  0
027E8:  CALL   1BEA
027EC:  MOVLW  0D
027EE:  MOVLB  4
027F0:  MOVWF  x4A
027F2:  MOVLB  0
027F4:  CALL   1BEA
....................                   ((struct dimmer_switch)mydevices.myinputs[0].device).off.needs_update=false; 
027F8:  MOVLB  1
027FA:  BCF    xE2.0
....................                } 
....................                break; 
027FC:  MOVLB  0
027FE:  BRA    293C
....................             case on_off_switch: 
....................                if(((struct on_off_switch)mydevices.myinputs[0].device).on.needs_update) 
02800:  MOVLB  1
02802:  BTFSS  xDC.0
02804:  BRA    2854
....................                { 
....................                   printf("on %u\n\r",((struct on_off_switch)mydevices.myinputs[0].device).on.value); 
02806:  MOVLW  6F
02808:  MOVLB  4
0280A:  MOVWF  x4A
0280C:  MOVLB  0
0280E:  CALL   1BEA
02812:  MOVLW  6E
02814:  MOVLB  4
02816:  MOVWF  x4A
02818:  MOVLB  0
0281A:  CALL   1BEA
0281E:  MOVLW  20
02820:  MOVLB  4
02822:  MOVWF  x4A
02824:  MOVLB  0
02826:  CALL   1BEA
0282A:  MOVFF  1DB,3F8
0282E:  MOVLW  1B
02830:  MOVLB  3
02832:  MOVWF  xF9
02834:  MOVLB  0
02836:  RCALL  263A
02838:  MOVLW  0A
0283A:  MOVLB  4
0283C:  MOVWF  x4A
0283E:  MOVLB  0
02840:  CALL   1BEA
02844:  MOVLW  0D
02846:  MOVLB  4
02848:  MOVWF  x4A
0284A:  MOVLB  0
0284C:  CALL   1BEA
....................                   ((struct on_off_switch)mydevices.myinputs[0].device).on.needs_update=false; 
02850:  MOVLB  1
02852:  BCF    xDC.0
....................                }            
....................                if(((struct on_off_switch)mydevices.myinputs[0].device).off.needs_update) 
02854:  BTFSS  xDF.0
02856:  BRA    289A
....................                { 
....................                   printf("off %u\n\r",((struct on_off_switch)mydevices.myinputs[0].device).off.value); 
02858:  MOVLW  EC
0285A:  MOVWF  FF6
0285C:  MOVLW  02
0285E:  MOVWF  FF7
02860:  MOVLW  00
02862:  MOVWF  FF8
02864:  MOVLW  04
02866:  MOVLB  4
02868:  MOVWF  x41
0286A:  MOVLB  0
0286C:  CALL   1CFA
02870:  MOVFF  1DE,3F8
02874:  MOVLW  1B
02876:  MOVLB  3
02878:  MOVWF  xF9
0287A:  MOVLB  0
0287C:  RCALL  263A
0287E:  MOVLW  0A
02880:  MOVLB  4
02882:  MOVWF  x4A
02884:  MOVLB  0
02886:  CALL   1BEA
0288A:  MOVLW  0D
0288C:  MOVLB  4
0288E:  MOVWF  x4A
02890:  MOVLB  0
02892:  CALL   1BEA
....................                   ((struct on_off_switch)mydevices.myinputs[0].device).off.needs_update=false; 
02896:  MOVLB  1
02898:  BCF    xDF.0
....................                } 
....................             break; 
0289A:  MOVLB  0
0289C:  BRA    293C
....................             case button_switch: 
....................                if(((struct button_switch)mydevices.myinputs[0].device).on.needs_update) 
0289E:  MOVLB  1
028A0:  BTFSS  xDC.0
028A2:  BRA    28F2
....................                { 
....................                   printf("on %u\n\r",((struct button_switch)mydevices.myinputs[0].device).on.value); 
028A4:  MOVLW  6F
028A6:  MOVLB  4
028A8:  MOVWF  x4A
028AA:  MOVLB  0
028AC:  CALL   1BEA
028B0:  MOVLW  6E
028B2:  MOVLB  4
028B4:  MOVWF  x4A
028B6:  MOVLB  0
028B8:  CALL   1BEA
028BC:  MOVLW  20
028BE:  MOVLB  4
028C0:  MOVWF  x4A
028C2:  MOVLB  0
028C4:  CALL   1BEA
028C8:  MOVFF  1DB,3F8
028CC:  MOVLW  1B
028CE:  MOVLB  3
028D0:  MOVWF  xF9
028D2:  MOVLB  0
028D4:  RCALL  263A
028D6:  MOVLW  0A
028D8:  MOVLB  4
028DA:  MOVWF  x4A
028DC:  MOVLB  0
028DE:  CALL   1BEA
028E2:  MOVLW  0D
028E4:  MOVLB  4
028E6:  MOVWF  x4A
028E8:  MOVLB  0
028EA:  CALL   1BEA
....................                   ((struct button_switch)mydevices.myinputs[0].device).on.needs_update=false; 
028EE:  MOVLB  1
028F0:  BCF    xDC.0
....................                }            
....................                if(((struct button_switch)mydevices.myinputs[0].device).off.needs_update) 
028F2:  BTFSS  xDF.0
028F4:  BRA    2938
....................                { 
....................                   printf("off %u\n\r",((struct button_switch)mydevices.myinputs[0].device).off.value); 
028F6:  MOVLW  F6
028F8:  MOVWF  FF6
028FA:  MOVLW  02
028FC:  MOVWF  FF7
028FE:  MOVLW  00
02900:  MOVWF  FF8
02902:  MOVLW  04
02904:  MOVLB  4
02906:  MOVWF  x41
02908:  MOVLB  0
0290A:  CALL   1CFA
0290E:  MOVFF  1DE,3F8
02912:  MOVLW  1B
02914:  MOVLB  3
02916:  MOVWF  xF9
02918:  MOVLB  0
0291A:  RCALL  263A
0291C:  MOVLW  0A
0291E:  MOVLB  4
02920:  MOVWF  x4A
02922:  MOVLB  0
02924:  CALL   1BEA
02928:  MOVLW  0D
0292A:  MOVLB  4
0292C:  MOVWF  x4A
0292E:  MOVLB  0
02930:  CALL   1BEA
....................                   ((struct button_switch)mydevices.myinputs[0].device).off.needs_update=false; 
02934:  MOVLB  1
02936:  BCF    xDF.0
....................                } 
....................             break; 
02938:  MOVLB  0
0293A:  BRA    293C
....................          } 
....................       } 
0293C:  MOVLB  3
0293E:  INCF   xF6,F
02940:  BRA    26CE
....................    } 
02942:  MOVLB  0
02944:  BRA    26C0
.................... } 
02946:  GOTO   2C0E (RETURN)
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... int1 flag=0;//mains not detected flag 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  
.................... { 
....................    ++clock; 
*
00D5E:  MOVLW  01
00D60:  MOVLB  3
00D62:  ADDWF  xEB,F
00D64:  BTFSC  FD8.0
00D66:  INCF   xEC,F
00D68:  BTFSC  FD8.2
00D6A:  INCF   xED,F
00D6C:  BTFSC  FD8.2
00D6E:  INCF   xEE,F
....................    if (bit_test (clock, 1)) read_inputs(); 
00D70:  BTFSS  xEB.1
00D72:  BRA    0D7A
00D74:  MOVLB  0
00D76:  BRA    0922
00D78:  MOVLB  3
.................... } 
....................  
00D7A:  BCF    FF2.2
00D7C:  MOVLB  0
00D7E:  GOTO   0110
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................    flag = 1; 
00D82:  BSF    xB1.4
.................... } 
....................  
00D84:  BCF    F9E.0
00D86:  GOTO   0110
.................... #int_EXT 
.................... void  EXT_isr(void)  
.................... { 
....................  
....................   // set_timer1 (0) ; 
....................          portc=0xFF; 
00D8A:  MOVLW  FF
00D8C:  MOVWF  F82
....................          portd=0xFF; 
00D8E:  MOVWF  F83
....................          if (organizado)  
00D90:  BTFSS  xB1.2
00D92:  BRA    0DB6
....................          { 
....................             organizado=0; 
00D94:  BCF    xB1.2
....................             if (actmat)  
00D96:  BTFSS  xB1.3
00D98:  BRA    0DAA
....................             { 
....................                actmat=0; 
00D9A:  BCF    xB1.3
....................                pointer=delays1; 
00D9C:  MOVLW  01
00D9E:  MOVLB  1
00DA0:  MOVWF  x3C
00DA2:  MOVLW  4F
00DA4:  MOVWF  x3B
....................             } 
....................             else 
00DA6:  BRA    0DB6
00DA8:  MOVLB  0
....................             { 
....................                actmat=1; 
00DAA:  BSF    xB1.3
....................                pointer=delays2; 
00DAC:  MOVLW  01
00DAE:  MOVLB  1
00DB0:  MOVWF  x3C
00DB2:  MOVLW  93
00DB4:  MOVWF  x3B
....................             } 
....................          } 
....................          vez=0; 
00DB6:  MOVLB  1
00DB8:  CLRF   x3D
....................          CCP_1=matrizluz[fpointer(0,0)]; 
00DBA:  MOVLB  4
00DBC:  CLRF   x4D
00DBE:  CLRF   x4E
*
00E2A:  MOVFF  02,44C
00E2E:  MOVFF  01,44B
00E32:  BCF    FD8.0
00E34:  RLCF   01,W
00E36:  MOVWF  02
00E38:  RLCF   x4C,W
00E3A:  MOVWF  03
00E3C:  MOVF   02,W
00E3E:  MOVLB  0
00E40:  CALL   019A
00E44:  TBLRD*+
00E46:  MOVFF  FF5,03
00E4A:  MOVWF  FBE
00E4C:  MOVFF  03,FBF
....................          mnumluzes=fpointer(N_LUZES,0); 
00E50:  MOVLW  10
00E52:  MOVLB  4
00E54:  MOVWF  x4D
00E56:  CLRF   x4E
*
00EC2:  MOVFF  01,13E
....................          set_timer1(0); 
00EC6:  CLRF   FCF
00EC8:  CLRF   FCE
.................... } 
....................  
00ECA:  BCF    FF2.1
00ECC:  MOVLB  0
00ECE:  GOTO   0110
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
.................... } 
....................  
00ED2:  BCF    F9E.5
00ED4:  GOTO   0110
.................... #int_TBE 
.................... void  TBE_isr(void)  
.................... { 
.................... } 
....................  
00ED8:  BCF    F9E.4
00EDA:  GOTO   0110
.................... #int_BUSCOL 
.................... void  BUSCOL_isr(void)  
.................... { 
.................... } 
....................  
00EDE:  BCF    FA1.3
00EE0:  GOTO   0110
.................... #int_OSCF 
.................... void  OSCF_isr(void)  
.................... { 
.................... } 
....................  
00EE4:  BCF    FA1.7
00EE6:  GOTO   0110
.................... #int_canrx0 
.................... void canrx0_int ( )  
.................... { 
....................    canReceive (); 
*
01492:  RCALL  10E2
....................    // TODO: add CAN recieve code here 
.................... } 
....................  
01494:  BCF    FA4.0
01496:  GOTO   0110
.................... #int_canrx1 
.................... void canrx1_int ( )  
.................... { 
....................    canReceive (); 
0149A:  RCALL  10E2
....................    // TODO: add CAN recieve code here 
.................... } 
....................  
0149C:  BCF    FA4.1
0149E:  GOTO   0110
.................... #int_cantx0 
.................... void cantx0_int ( )  
.................... { 
....................    canTransmit (); 
*
018C2:  RCALL  16A8
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
018C4:  BCF    FA4.2
018C6:  GOTO   0110
.................... #int_cantx1 
.................... void cantx1_int ( )  
.................... { 
....................    canTransmit (); 
018CA:  RCALL  16A8
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
018CC:  BCF    FA4.3
018CE:  GOTO   0110
.................... #int_cantx2 
.................... void cantx2_int ( )  
.................... { 
....................    canTransmit (); 
018D2:  RCALL  16A8
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
018D4:  BCF    FA4.4
018D6:  GOTO   0110
.................... #int_canirx 
.................... void canirx_int ( )  
.................... { 
....................    // TODO: add CAN IRX handling code here 
.................... } 
....................  
018DA:  BCF    FA4.7
018DC:  GOTO   0110
.................... #int_canerr 
.................... void canerr_int ( )  
.................... { 
....................    // TODO: add CAN error handling code here 
.................... } 
....................  
018E0:  BCF    FA4.5
018E2:  GOTO   0110
.................... #int_CCP1 
.................... void CCP1_isr(void)  
.................... { 
....................    if(mnumluzes!=0) 
018E6:  MOVLB  1
018E8:  MOVF   x3E,F
018EA:  BTFSC  FD8.2
018EC:  BRA    1A16
....................    { 
....................    output_low (LED) ; 
018EE:  BCF    F96.2
018F0:  BCF    F8D.2
....................       int16 auxccp=fpointer(vez,1); 
018F2:  MOVFF  13D,44D
018F6:  MOVLW  01
018F8:  MOVLB  4
018FA:  MOVWF  x4E
*
01966:  MOVFF  02,44C
0196A:  MOVFF  01,44B
....................       portc=(portc & MAKE8(auxccp,1)); 
0196E:  MOVF   x4C,W
01970:  ANDWF  F82,F
....................       portd=(portd & MAKE8(auxccp,0)); 
01972:  MOVF   x4B,W
01974:  ANDWF  F83,F
....................       ++vez; 
01976:  MOVLB  1
01978:  INCF   x3D,F
....................       --mnumluzes; 
0197A:  DECF   x3E,F
....................       CCP_1=matrizluz[fpointer(vez,0)]; 
0197C:  MOVFF  13D,44D
01980:  MOVLB  4
01982:  CLRF   x4E
*
019EE:  MOVFF  02,44E
019F2:  MOVFF  01,44D
019F6:  BCF    FD8.0
019F8:  RLCF   01,W
019FA:  MOVWF  02
019FC:  RLCF   x4E,W
019FE:  MOVWF  03
01A00:  MOVF   02,W
01A02:  MOVLB  0
01A04:  CALL   019A
01A08:  TBLRD*+
01A0A:  MOVFF  FF5,03
01A0E:  MOVWF  FBE
01A10:  MOVFF  03,FBF
01A14:  MOVLB  1
....................    } 
.................... } 
01A16:  BCF    F9E.2
01A18:  MOVLB  0
01A1A:  GOTO   0110
.................... void main() 
.................... { 
*
0294A:  CLRF   FF8
0294C:  BCF    FD0.7
0294E:  BSF    07.7
02950:  CLRF   FEA
02952:  CLRF   FE9
02954:  BCF    F93.5
02956:  BSF    F8A.5
02958:  CLRF   24
0295A:  BCF    xB1.0
0295C:  CLRF   xB2
0295E:  BSF    xB1.1
02960:  MOVLW  10
02962:  MOVLB  1
02964:  MOVWF  x3A
02966:  MOVLB  3
02968:  CLRF   xEF
0296A:  CLRF   xF3
0296C:  CLRF   xF2
0296E:  CLRF   xF1
02970:  MOVLW  27
02972:  MOVWF  xF0
02974:  MOVLB  0
02976:  BCF    xB1.4
02978:  MOVF   FC1,W
0297A:  ANDLW  C0
0297C:  IORLW  0F
0297E:  MOVWF  FC1
02980:  MOVLW  07
02982:  MOVWF  FB4
02984:  CLRF   1C
02986:  MOVLW  01
02988:  MOVWF  1D
0298A:  MOVLW  02
0298C:  MOVWF  1E
0298E:  MOVLW  03
02990:  MOVWF  1F
02992:  MOVLW  04
02994:  MOVWF  20
02996:  MOVLW  05
02998:  MOVWF  21
0299A:  MOVLW  20
0299C:  MOVWF  22
0299E:  MOVLW  21
029A0:  MOVWF  23
029A2:  MOVLW  0B
029A4:  MOVLB  1
029A6:  MOVWF  x35
029A8:  CLRF   x36
029AA:  CLRF   x37
029AC:  CLRF   x38
029AE:  MOVLW  0A
029B0:  MOVWF  x3F
029B2:  MOVWF  x40
029B4:  MOVWF  x41
029B6:  MOVWF  x42
029B8:  MOVWF  x43
029BA:  MOVWF  x44
029BC:  MOVWF  x45
029BE:  MOVWF  x46
029C0:  MOVWF  x47
029C2:  MOVWF  x48
029C4:  MOVWF  x49
029C6:  MOVWF  x4A
029C8:  MOVWF  x4B
029CA:  MOVWF  x4C
029CC:  MOVWF  x4D
029CE:  MOVWF  x4E
029D0:  CLRF   x4F
029D2:  CLRF   x50
029D4:  CLRF   x51
029D6:  CLRF   x52
029D8:  CLRF   x53
029DA:  CLRF   x54
029DC:  MOVLW  01
029DE:  MOVWF  x55
029E0:  CLRF   x56
029E2:  CLRF   x57
029E4:  CLRF   x58
029E6:  MOVLW  02
029E8:  MOVWF  x59
029EA:  CLRF   x5A
029EC:  CLRF   x5B
029EE:  CLRF   x5C
029F0:  MOVLW  03
029F2:  MOVWF  x5D
029F4:  CLRF   x5E
029F6:  CLRF   x5F
029F8:  CLRF   x60
029FA:  MOVLW  04
029FC:  MOVWF  x61
029FE:  CLRF   x62
02A00:  CLRF   x63
02A02:  CLRF   x64
02A04:  MOVLW  05
02A06:  MOVWF  x65
02A08:  CLRF   x66
02A0A:  CLRF   x67
02A0C:  CLRF   x68
02A0E:  MOVLW  06
02A10:  MOVWF  x69
02A12:  CLRF   x6A
02A14:  CLRF   x6B
02A16:  CLRF   x6C
02A18:  MOVLW  07
02A1A:  MOVWF  x6D
02A1C:  CLRF   x6E
02A1E:  CLRF   x6F
02A20:  CLRF   x70
02A22:  MOVLW  08
02A24:  MOVWF  x71
02A26:  CLRF   x72
02A28:  CLRF   x73
02A2A:  CLRF   x74
02A2C:  MOVLW  09
02A2E:  MOVWF  x75
02A30:  CLRF   x76
02A32:  CLRF   x77
02A34:  CLRF   x78
02A36:  MOVLW  0A
02A38:  MOVWF  x79
02A3A:  CLRF   x7A
02A3C:  CLRF   x7B
02A3E:  CLRF   x7C
02A40:  MOVLW  0B
02A42:  MOVWF  x7D
02A44:  CLRF   x7E
02A46:  CLRF   x7F
02A48:  CLRF   x80
02A4A:  MOVLW  0C
02A4C:  MOVWF  x81
02A4E:  CLRF   x82
02A50:  CLRF   x83
02A52:  CLRF   x84
02A54:  MOVLW  0D
02A56:  MOVWF  x85
02A58:  CLRF   x86
02A5A:  CLRF   x87
02A5C:  CLRF   x88
02A5E:  MOVLW  0E
02A60:  MOVWF  x89
02A62:  CLRF   x8A
02A64:  CLRF   x8B
02A66:  CLRF   x8C
02A68:  MOVLW  0F
02A6A:  MOVWF  x8D
02A6C:  CLRF   x8E
02A6E:  CLRF   x8F
02A70:  CLRF   x90
02A72:  CLRF   x91
02A74:  CLRF   x92
02A76:  CLRF   x93
02A78:  CLRF   x94
02A7A:  CLRF   x95
02A7C:  CLRF   x96
02A7E:  CLRF   x97
02A80:  CLRF   x98
02A82:  MOVLW  01
02A84:  MOVWF  x99
02A86:  CLRF   x9A
02A88:  CLRF   x9B
02A8A:  CLRF   x9C
02A8C:  MOVLW  02
02A8E:  MOVWF  x9D
02A90:  CLRF   x9E
02A92:  CLRF   x9F
02A94:  CLRF   xA0
02A96:  MOVLW  03
02A98:  MOVWF  xA1
02A9A:  CLRF   xA2
02A9C:  CLRF   xA3
02A9E:  CLRF   xA4
02AA0:  MOVLW  04
02AA2:  MOVWF  xA5
02AA4:  CLRF   xA6
02AA6:  CLRF   xA7
02AA8:  CLRF   xA8
02AAA:  MOVLW  05
02AAC:  MOVWF  xA9
02AAE:  CLRF   xAA
02AB0:  CLRF   xAB
02AB2:  CLRF   xAC
02AB4:  MOVLW  06
02AB6:  MOVWF  xAD
02AB8:  CLRF   xAE
02ABA:  CLRF   xAF
02ABC:  CLRF   xB0
02ABE:  MOVLW  07
02AC0:  MOVWF  xB1
02AC2:  CLRF   xB2
02AC4:  CLRF   xB3
02AC6:  CLRF   xB4
02AC8:  MOVLW  08
02ACA:  MOVWF  xB5
02ACC:  CLRF   xB6
02ACE:  CLRF   xB7
02AD0:  CLRF   xB8
02AD2:  MOVLW  09
02AD4:  MOVWF  xB9
02AD6:  CLRF   xBA
02AD8:  CLRF   xBB
02ADA:  CLRF   xBC
02ADC:  MOVLW  0A
02ADE:  MOVWF  xBD
02AE0:  CLRF   xBE
02AE2:  CLRF   xBF
02AE4:  CLRF   xC0
02AE6:  MOVLW  0B
02AE8:  MOVWF  xC1
02AEA:  CLRF   xC2
02AEC:  CLRF   xC3
02AEE:  CLRF   xC4
02AF0:  MOVLW  0C
02AF2:  MOVWF  xC5
02AF4:  CLRF   xC6
02AF6:  CLRF   xC7
02AF8:  CLRF   xC8
02AFA:  MOVLW  0D
02AFC:  MOVWF  xC9
02AFE:  CLRF   xCA
02B00:  CLRF   xCB
02B02:  CLRF   xCC
02B04:  MOVLW  0E
02B06:  MOVWF  xCD
02B08:  CLRF   xCE
02B0A:  CLRF   xCF
02B0C:  CLRF   xD0
02B0E:  MOVLW  0F
02B10:  MOVWF  xD1
02B12:  CLRF   xD2
02B14:  CLRF   xD3
02B16:  CLRF   xD4
02B18:  CLRF   xD5
02B1A:  CLRF   xD6
....................    clock = 0; 
02B1C:  MOVLB  3
02B1E:  CLRF   xEE
02B20:  CLRF   xED
02B22:  CLRF   xEC
02B24:  CLRF   xEB
....................    can_init () ; 
02B26:  MOVLB  0
02B28:  GOTO   1A96
....................    can_set_mode (CAN_OP_CONFIG) ; 
02B2C:  MOVLW  04
02B2E:  MOVLB  3
02B30:  MOVWF  xF6
02B32:  MOVLB  0
02B34:  CALL   1A40
....................     
....................    BRGCON1.brp = 4; 
02B38:  MOVLW  C0
02B3A:  ANDWF  F70,W
02B3C:  IORLW  04
02B3E:  MOVWF  F70
....................    BRGCON1.sjw = 0; 
02B40:  MOVLW  3F
02B42:  ANDWF  F70,W
02B44:  MOVWF  F70
....................    BRGCON2.prseg = 2; 
02B46:  MOVLW  F8
02B48:  ANDWF  F71,W
02B4A:  IORLW  02
02B4C:  MOVWF  F71
....................    BRGCON2.seg1ph = 5; 
02B4E:  MOVLW  C7
02B50:  ANDWF  F71,W
02B52:  IORLW  28
02B54:  MOVWF  F71
....................    BRGCON2.sam = FALSE; 
02B56:  BCF    F71.6
....................    BRGCON2.seg2phts = FALSE; 
02B58:  BCF    F71.7
....................    BRGCON3.seg2ph = 5; 
02B5A:  MOVLW  F8
02B5C:  ANDWF  F72,W
02B5E:  IORLW  05
02B60:  MOVWF  F72
....................    BRGCON3.wakfil = TRUE; 
02B62:  BSF    F72.6
....................    can_set_mode (CAN_OP_NORMAL) ; 
02B64:  MOVLB  3
02B66:  CLRF   xF6
02B68:  MOVLB  0
02B6A:  CALL   1A40
....................     
....................    enable_interrupts (int_canrx0); 
02B6E:  BSF    FA3.0
....................    enable_interrupts (int_canrx1); 
02B70:  BSF    FA3.1
....................    enable_interrupts (int_cantx0); 
02B72:  BSF    FA3.2
....................    enable_interrupts (int_cantx1); 
02B74:  BSF    FA3.3
....................    enable_interrupts (int_cantx2); 
02B76:  BSF    FA3.4
....................    enable_interrupts (int_canirx); 
02B78:  BSF    FA3.7
....................    enable_interrupts (int_canerr); 
02B7A:  BSF    FA3.5
....................    setup_adc_ports (NO_ANALOGS | VSS_VDD) ; 
02B7C:  MOVF   FC1,W
02B7E:  ANDLW  C0
02B80:  IORLW  0F
02B82:  MOVWF  FC1
....................    setup_adc (ADC_CLOCK_DIV_2 | ADC_TAD_MUL_0) ; 
02B84:  MOVF   FC0,W
02B86:  ANDLW  C0
02B88:  MOVWF  FC0
02B8A:  BCF    FC0.7
02B8C:  BSF    FC2.0
....................    setup_psp (PSP_DISABLED) ; 
02B8E:  BCF    F96.4
....................    setup_spi (SPI_SS_DISABLED) ; 
02B90:  BCF    FC6.5
02B92:  MOVLW  01
02B94:  MOVWF  FC6
02B96:  MOVLW  00
02B98:  MOVWF  FC7
....................    //setup_wdt (WDT_ON) ; 
....................    setup_timer_0 (RTCC_INTERNAL | RTCC_DIV_4); //div16 1.6us thick 104ms overflow 
02B9A:  MOVLW  81
02B9C:  MOVWF  FD5
....................     
....................    //setup_timer_1 (T1_INTERNAL | T1_DIV_BY_2); //div2 0.2us thick overflow 13.1ms 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_2); 
02B9E:  MOVLW  95
02BA0:  MOVWF  FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
02BA2:  MOVLW  00
02BA4:  MOVWF  FCA
02BA6:  MOVLW  00
02BA8:  MOVWF  FCB
....................    setup_ccp1(CCP_COMPARE_INT); 
02BAA:  MOVLW  0A
02BAC:  MOVWF  FBD
....................    enable_interrupts(INT_CCP1); 
02BAE:  BSF    F9D.2
....................    ext_int_edge(l_to_h); 
02BB0:  BSF    FF1.6
....................     
....................    setup_timer_2 (T2_DISABLED, 0, 1) ; 
02BB2:  MOVLW  00
02BB4:  MOVWF  FCA
02BB6:  MOVLW  00
02BB8:  MOVWF  FCB
....................    setup_timer_3 (T3_DISABLED | T3_DIV_BY_1) ; 
02BBA:  CLRF   FB1
....................     
....................   // setup_ccp1 (CCP_OFF) ; 
....................    setup_comparator (NC_NC_NC_NC) ; 
02BBC:  MOVLW  07
02BBE:  MOVWF  FB4
02BC0:  MOVF   F95,W
02BC2:  MOVWF  F95
02BC4:  MOVF   F96,W
02BC6:  MOVWF  F96
02BC8:  CLRWDT
02BCA:  MOVLW  20
02BCC:  MOVWF  00
02BCE:  DECFSZ 00,F
02BD0:  BRA    2BCE
02BD2:  BRA    2BD4
02BD4:  MOVF   FB4,W
02BD6:  BCF    FA1.6
....................    setup_vref (FALSE) ; 
02BD8:  CLRF   FB5
....................     
....................    enable_interrupts (int_TIMER0) ; 
02BDA:  BSF    FF2.5
....................    enable_interrupts (int_EXT) ; 
02BDC:  BSF    FF2.4
....................    //enable_interrupts (int_TBE) ; 
....................    //enable_interrupts (int_BUSCOL) ; 
....................    //enable_interrupts (int_CANIRX) ; 
....................    //enable_interrupts (int_CANERR) ; 
....................    //enable_interrupts (int_CANTX2) ; 
....................    //enable_interrupts (int_CANTX1) ; 
....................    //enable_interrupts (int_CANTX0) ; 
....................    //enable_interrupts (int_CANRX1) ; 
....................    //enable_interrupts (int_CANRX0) ; 
....................    //enable_interrupts (int_OSCF) ; 
....................    
....................    //TODO: User Code 
....................    //struct switches array[NUMBER_OF_SWITCHES]; 
....................    
....................  
....................    trisc=0x00; //tudo saidas 
02BDE:  CLRF   F94
....................    trisd=0x00; //tudo saidas 
02BE0:  CLRF   F95
....................    actmat=0; 
02BE2:  BCF    xB1.3
....................    pointer=delays1; 
02BE4:  MOVLW  01
02BE6:  MOVLB  1
02BE8:  MOVWF  x3C
02BEA:  MOVLW  4F
02BEC:  MOVWF  x3B
....................    org(); 
02BEE:  MOVLB  0
02BF0:  CALL   1E36
....................    pointer=delays2; 
02BF4:  MOVLW  01
02BF6:  MOVLB  1
02BF8:  MOVWF  x3C
02BFA:  MOVLW  93
02BFC:  MOVWF  x3B
....................    actmat=1; 
02BFE:  MOVLB  0
02C00:  BSF    xB1.3
....................    org(); 
02C02:  CALL   1E36
....................     
....................    test(); 
02C06:  BRA    25E6
....................     
....................    enable_interrupts (GLOBAL) ; 
02C08:  MOVLW  C0
02C0A:  IORWF  FF2,F
....................     
....................     
....................    print_inputs(); 
02C0C:  BRA    26C0
....................    while(organizado==0){} 
02C0E:  BTFSC  xB1.2
02C10:  BRA    2C14
02C12:  BRA    2C0E
....................    for(temp=0;temp<17;++temp) 
02C14:  MOVLB  1
02C16:  CLRF   x39
02C18:  MOVF   x39,W
02C1A:  SUBLW  10
02C1C:  BTFSS  FD8.0
02C1E:  BRA    2D6C
....................    { 
....................       printf("%lu <-> %lu\n\r",fpointer(temp,0),fpointer(temp,1)); 
02C20:  MOVFF  139,44D
02C24:  MOVLB  4
02C26:  CLRF   x4E
*
02C92:  MOVFF  02,3F7
02C96:  MOVFF  01,3F6
02C9A:  MOVFF  139,44D
02C9E:  MOVLW  01
02CA0:  MOVWF  x4E
*
02D0C:  MOVFF  02,3F9
02D10:  MOVFF  01,3F8
02D14:  MOVLW  10
02D16:  MOVWF  FE9
02D18:  MOVFF  3F7,442
02D1C:  MOVFF  3F6,441
02D20:  MOVLB  0
02D22:  CALL   1C3E
02D26:  MOVLW  21
02D28:  MOVWF  FF6
02D2A:  MOVLW  1A
02D2C:  MOVWF  FF7
02D2E:  MOVLW  00
02D30:  MOVWF  FF8
02D32:  MOVLW  05
02D34:  MOVLB  4
02D36:  MOVWF  x41
02D38:  MOVLB  0
02D3A:  CALL   1CFA
02D3E:  MOVLW  10
02D40:  MOVWF  FE9
02D42:  MOVFF  3F9,442
02D46:  MOVFF  3F8,441
02D4A:  CALL   1C3E
02D4E:  MOVLW  0A
02D50:  MOVLB  4
02D52:  MOVWF  x4A
02D54:  MOVLB  0
02D56:  CALL   1BEA
02D5A:  MOVLW  0D
02D5C:  MOVLB  4
02D5E:  MOVWF  x4A
02D60:  MOVLB  0
02D62:  CALL   1BEA
....................    } 
02D66:  MOVLB  1
02D68:  INCF   x39,F
02D6A:  BRA    2C18
....................     int16 auxccp=fpointer(0,1); 
02D6C:  MOVLB  4
02D6E:  CLRF   x4D
02D70:  MOVLW  01
02D72:  MOVWF  x4E
*
02DDE:  MOVFF  02,3F5
02DE2:  MOVFF  01,3F4
....................       printf("%lu <-> %u <-> %u\n\r",auxccp,MAKE8(auxccp,1),MAKE8(auxccp,0)); 
02DE6:  MOVFF  3F5,3F6
02DEA:  MOVFF  3F4,3F7
02DEE:  MOVLW  10
02DF0:  MOVWF  FE9
02DF2:  MOVFF  3F5,442
02DF6:  MOVFF  3F4,441
02DFA:  MOVLB  0
02DFC:  CALL   1C3E
02E00:  MOVLW  2F
02E02:  MOVWF  FF6
02E04:  MOVLW  1A
02E06:  MOVWF  FF7
02E08:  MOVLW  00
02E0A:  MOVWF  FF8
02E0C:  MOVLW  05
02E0E:  MOVLB  4
02E10:  MOVWF  x41
02E12:  MOVLB  0
02E14:  CALL   1CFA
02E18:  MOVFF  3F6,3F8
02E1C:  MOVLW  1B
02E1E:  MOVLB  3
02E20:  MOVWF  xF9
02E22:  MOVLB  0
02E24:  RCALL  263A
02E26:  MOVLW  36
02E28:  MOVWF  FF6
02E2A:  MOVLW  1A
02E2C:  MOVWF  FF7
02E2E:  MOVLW  00
02E30:  MOVWF  FF8
02E32:  MOVLW  05
02E34:  MOVLB  4
02E36:  MOVWF  x41
02E38:  MOVLB  0
02E3A:  CALL   1CFA
02E3E:  MOVFF  3F7,3F8
02E42:  MOVLW  1B
02E44:  MOVLB  3
02E46:  MOVWF  xF9
02E48:  MOVLB  0
02E4A:  CALL   263A
02E4E:  MOVLW  0A
02E50:  MOVLB  4
02E52:  MOVWF  x4A
02E54:  MOVLB  0
02E56:  CALL   1BEA
02E5A:  MOVLW  0D
02E5C:  MOVLB  4
02E5E:  MOVWF  x4A
02E60:  MOVLB  0
02E62:  CALL   1BEA
....................    for (;; ) 
....................    {    
....................        
....................       output_high (LED) ; 
02E66:  BCF    F96.2
02E68:  BSF    F8D.2
....................        delay_ms (1000) ; 
02E6A:  MOVLW  04
02E6C:  MOVLB  3
02E6E:  MOVWF  xF6
02E70:  MOVLW  FA
02E72:  MOVWF  xF7
02E74:  MOVLB  0
02E76:  CALL   260A
02E7A:  MOVLB  3
02E7C:  DECFSZ xF6,F
02E7E:  BRA    2E70
....................        
....................      // output_low (LED) ; 
....................        
....................        
....................       delay_ms (200) ; 
02E80:  MOVLW  C8
02E82:  MOVWF  xF7
02E84:  MOVLB  0
02E86:  CALL   260A
....................       //   printf("%LX\n\r",temp); 
....................      // printf (" %d %lX\n\r", msw.dim_level.value,porta) ; 
....................    } 
02E8A:  BRA    2E66
.................... } 
....................  
....................  
02E8C:  BRA    2E8C

Configuration Fuses:
   Word  1: C600   H4 IESO FCMEN
   Word  2: 0E19   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0030   NOSTVREN DEBUG NOLVP NOXINST BBSIZ4K
   Word  5: C03F   NOPROTECT NOCPD NOCPB
   Word  6: E03F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 403F   NOEBTR NOEBTRB
