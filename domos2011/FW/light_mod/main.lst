CCS PCH C Compiler, Version 4.106, 32200               29-Ago-11 17:31

               Filename: C:\Users\Xapo\Documents\Electronica\domos2011\FW\light_mod\main.lst

               ROM used: 17650 bytes (18%)
                         Largest free fragment is 47882
               RAM used: 1057 (32%) at main() level
                         1178 (36%) worst case
               Stack:    8 worst case (4 in main + 4 for interrupts)

*
00000:  GOTO   407A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0DA8
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0DCC
00074:  BTFSS  F9D.1
00076:  GOTO   0080
0007A:  BTFSC  F9E.1
0007C:  GOTO   0DD4
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0DFC
0008C:  BTFSS  F9D.5
0008E:  GOTO   0098
00092:  BTFSC  F9E.5
00094:  GOTO   1090
00098:  BTFSS  F9D.4
0009A:  GOTO   00A4
0009E:  BTFSC  F9E.4
000A0:  GOTO   1096
000A4:  BTFSS  F9D.2
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.2
000AC:  GOTO   0F5C
000B0:  BTFSS  FA0.3
000B2:  GOTO   00BC
000B6:  BTFSC  FA1.3
000B8:  GOTO   109C
000BC:  BTFSS  FA3.7
000BE:  GOTO   00C8
000C2:  BTFSC  FA4.7
000C4:  GOTO   1A98
000C8:  BTFSS  FA3.5
000CA:  GOTO   00D4
000CE:  BTFSC  FA4.5
000D0:  GOTO   1A9E
000D4:  BTFSS  FA3.4
000D6:  GOTO   00E0
000DA:  BTFSC  FA4.4
000DC:  GOTO   1A90
000E0:  BTFSS  FA3.3
000E2:  GOTO   00EC
000E6:  BTFSC  FA4.3
000E8:  GOTO   1A88
000EC:  BTFSS  FA3.2
000EE:  GOTO   00F8
000F2:  BTFSC  FA4.2
000F4:  GOTO   1A80
000F8:  BTFSS  FA3.1
000FA:  GOTO   0104
000FE:  BTFSC  FA4.1
00100:  GOTO   1658
00104:  BTFSS  FA3.0
00106:  GOTO   0110
0010A:  BTFSC  FA4.0
0010C:  GOTO   1650
00110:  BTFSS  FA0.7
00112:  GOTO   011C
00116:  BTFSC  FA1.7
00118:  GOTO   10A2
0011C:  MOVFF  0E,00
00120:  MOVFF  0F,01
00124:  MOVFF  10,02
00128:  MOVFF  11,03
0012C:  MOVFF  0C,FE9
00130:  MOVFF  07,FEA
00134:  BSF    07.7
00136:  MOVFF  08,FE1
0013A:  MOVFF  09,FE2
0013E:  MOVFF  0A,FD9
00142:  MOVFF  0B,FDA
00146:  MOVFF  12,FF3
0014A:  MOVFF  13,FF4
0014E:  MOVFF  14,FFA
00152:  MOVFF  15,FF5
00156:  MOVFF  16,FF6
0015A:  MOVFF  17,FF7
0015E:  MOVFF  18,FF8
00162:  MOVFF  19,FFB
00166:  MOVF   04,W
00168:  MOVFF  06,FE0
0016C:  MOVFF  05,FD8
00170:  RETFIE 0
....................  
.................... #include "main.h" 
.................... #include <18F4685.h> 
.................... //////// Standard Header file for the PIC18F4685 device //////////////// 
.................... #device PIC18F4685 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES H4                       //High speed osc with HW enabled 4X PLL 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES BBSIZ4K                  //4K words Boot Block size 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=40000000,RESTART_WDT) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_B5,rcv=PIN_B4,bits=8,restart_wdt) 
*
02914:  BCF    F93.5
02916:  BCF    F8A.5
02918:  MOVLW  08
0291A:  MOVWF  01
0291C:  BRA    291E
0291E:  NOP   
02920:  BSF    01.7
02922:  BRA    2944
02924:  BCF    01.7
02926:  MOVLB  4
02928:  RRCF   x2C,F
0292A:  MOVLB  0
0292C:  BTFSC  FD8.0
0292E:  BSF    F8A.5
02930:  BTFSS  FD8.0
02932:  BCF    F8A.5
02934:  BSF    01.6
02936:  BRA    2944
02938:  BCF    01.6
0293A:  DECFSZ 01,F
0293C:  BRA    2926
0293E:  BRA    2940
02940:  NOP   
02942:  BSF    F8A.5
02944:  MOVLW  16
02946:  MOVWF  FE9
02948:  DECFSZ FE9,F
0294A:  BRA    2948
0294C:  BRA    294E
0294E:  CLRWDT
02950:  BTFSC  01.7
02952:  BRA    2924
02954:  BTFSC  01.6
02956:  BRA    2938
02958:  RETLW  00
....................  
....................  
.................... #include "C:\Users\Programacao\Documents\CCS_Projects\18F\LightMod\global_defs.h" 
.................... #define  NUMBER_OF_SWITCHES 8 
.................... #define  LED PIN_E2 
.................... #define  OUT1  PIN_C0   //16 
.................... #define  OUT2  PIN_C1   //15 
.................... #define  OUT3  PIN_C2   //14 
.................... #define  OUT4  PIN_C3   //13 
.................... #define  OUT5  PIN_C4   //12 
.................... #define  OUT6  PIN_C5   //11 
.................... #define  OUT7  PIN_C6   //10 
.................... #define  OUT8  PIN_C7   //9 
.................... #define  OUT9  PIN_D1   //8 
.................... #define  OUT10  PIN_D0  //7 
.................... #define  OUT11  PIN_D2  //6 
.................... #define  OUT12  PIN_D3  //5 
.................... #define  OUT13  PIN_D7  //4 
.................... #define  OUT14  PIN_D6  //3 
.................... #define  OUT15  PIN_D5  //2 
.................... #define  OUT16  PIN_D4  //1 
....................  
.................... #define  INP1  PIN_A0 
.................... #define  INP2  PIN_A1 
.................... #define  INP3  PIN_A2 
.................... #define  INP4  PIN_A3 
.................... #define  INP5  PIN_A4 
.................... #define  INP6  PIN_A5 
.................... #define  INP7  PIN_E0 
.................... #define  INP8  PIN_E1 
....................  
.................... #byte porta=0xf80 
.................... #byte portb=0xf81 
.................... #byte portc=0xf82 
.................... #byte portd=0xf83 
.................... #byte porte=0xf84 
.................... #byte trisa=0xf92 
.................... #byte trisb=0xf93 
.................... #byte trisc=0xf94 
.................... #byte trisd=0xf95 
.................... #byte trise=0xf96 
....................  
.................... static int inputs[8]={INP1,INP2,INP3,INP4,INP5,INP6,INP7,INP8}; 
....................  
.................... #include "C:\Users\Programacao\Documents\CCS_Projects\18F\LightMod\can_functions.c" 
.................... #define CAN_USE_EXTENDED_ID FALSE 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = 0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = 0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT=0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1=0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2=0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3=0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive caputre 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON=0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON=0xF40 
.................... #byte   TXB1CON=0xF30 
.................... #byte   TXB2CON=0xF20 
.................... #byte TXBaCON=0xF60 //txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH=0xF41 
.................... #byte TXB0SIDL=0xF42 
.................... #byte TXB1SIDH=0xF31 
.................... #byte TXB1SIDL=0xF32 
.................... #byte TXB2SIDH=0xF21 
.................... #byte TXB2SIDL=0xF22 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH=0xF43 
.................... #byte TXB0EIDL=0xF44 
.................... #byte TXB1EIDH=0xF33 
.................... #byte TXB1EIDL=0xF34 
.................... #byte TXB2EIDH=0xF23 
.................... #byte TXB2EIDL=0xF24 
....................  
.................... #define RX0MASK      0xF1B    //rxm0eidl 
.................... #define RX1MASK      0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   0xF03    //rxf0eidl 
.................... #define RX0FILTER1   0xF07    //rxf1eidl 
.................... #define RX1FILTER2   0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   0xF13    //rxf4eidl 
.................... #define RX1FILTER5   0xF17    //rxf5eidl 
.................... #define RXB0ID       0xF64    //rxb0eidl 
.................... #define RXB1ID       0xF54    //rxb1eidl 
.................... #define TXB0ID       0xF44    //txb0eidl 
.................... #define TXB1ID       0xF34    //txb1eidl 
.................... #define TXB2ID       0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0=0xF46 
.................... #byte TXB0D7=0xF4D 
.................... #byte TXB1D0=0xF36 
.................... #byte TXB1D7=0xF3D 
.................... #byte TXB2D0=0xF26 
.................... #byte TXB2D7=0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC=0xF45 
.................... #byte TXB1DLC=0xF35 
.................... #byte TXB2DLC=0xF25 
.................... #byte TXBaDLC=0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON=0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON=0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH=0xF61 
.................... #byte   RXB0SIDL=0xF62 
.................... #byte   RXB1SIDH=0xF51 
.................... #byte   RXB1SIDL=0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH=0xF63 
.................... #byte   RXB0EIDL=0xF64 
.................... #byte   RXB1EIDH=0xF53 
.................... #byte   RXB1EIDL=0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC=0xF65 
.................... #byte   RXB1DLC=0xF55 
.................... #byte   RXBaDLC=0xF65 
....................  
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0=0xF66 
.................... #byte RXB0D7=0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT=0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH=0xF00 
.................... #byte RXF0SIDL=0xF01 
.................... #byte RXF1SIDH=0xF04 
.................... #byte RXF1SIDL=0xF05 
.................... #byte RXF2SIDH=0xF08 
.................... #byte RXF2SIDL=0xF09 
.................... #byte RXF3SIDH=0xF0C 
.................... #byte RXF3SIDL=0xF0D 
.................... #byte RXF4SIDH=0xF10 
.................... #byte RXF4SIDL=0xF11 
.................... #byte RXF5SIDH=0xF14 
.................... #byte RXF5SIDL=0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH=0xF02 
.................... #byte RXF0EIDL=0xF03 
.................... #byte RXF1EIDH=0xF06 
.................... #byte RXF1EIDL=0xF07 
.................... #byte RXF2EIDH=0xF0A 
.................... #byte RXF2EIDL=0xF0B 
.................... #byte RXF3EIDH=0xF0E 
.................... #byte RXF3EIDL=0xF0F 
.................... #byte RXF4EIDH=0xF12 
.................... #byte RXF4EIDL=0xF13 
.................... #byte RXF5EIDH=0xF16 
.................... #byte RXF5EIDL=0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH=0xF18 
.................... #byte RXM0SIDL=0xF19 
.................... #byte RXM1SIDH=0xF1C 
.................... #byte RXM1SIDL=0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH=0xF1A 
.................... #byte RXM0EIDL=0xF1B 
.................... #byte RXM1EIDH=0xF1E 
.................... #byte RXM1EIDL=0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = 0xFA4.7 
.................... #bit CAN_INT_WAKIF = 0xFA4.6 
.................... #bit CAN_INT_ERRIF = 0xFA4.5 
.................... #bit CAN_INT_TXB2IF = 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(int* addr, int32 id, int1 ext); 
.................... int32 can_get_id(int * addr, int1 ext); 
.................... int   can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(int32 & id, int * data, int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
01B24:  MOVLW  04
01B26:  MOVLB  4
01B28:  MOVWF  x1F
01B2A:  MOVLB  0
01B2C:  RCALL  1ACE
....................    can_set_baud(); 
01B2E:  BRA    1AF4
....................  
....................    RXB0CON=0; 
01B30:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
01B32:  MOVLW  9F
01B34:  ANDWF  F60,W
01B36:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
01B38:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
01B3A:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
01B3E:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
01B40:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
01B42:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
01B44:  BCF    F73.6
01B46:  CLRF   1B
01B48:  BTFSC  FF2.7
01B4A:  BSF    1B.7
01B4C:  BCF    FF2.7
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
01B4E:  MOVLW  0F
01B50:  MOVLB  4
01B52:  MOVWF  x8E
01B54:  MOVLW  1B
01B56:  MOVWF  x8D
01B58:  CLRF   x92
01B5A:  CLRF   x91
01B5C:  CLRF   x90
01B5E:  CLRF   x8F
01B60:  CLRF   x93
01B62:  MOVLB  0
01B64:  RCALL  1660
01B66:  BTFSC  1B.7
01B68:  BSF    FF2.7
01B6A:  CLRF   1B
01B6C:  BTFSC  FF2.7
01B6E:  BSF    1B.7
01B70:  BCF    FF2.7
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
01B72:  MOVLW  0F
01B74:  MOVLB  4
01B76:  MOVWF  x8E
01B78:  MOVLW  03
01B7A:  MOVWF  x8D
01B7C:  CLRF   x92
01B7E:  CLRF   x91
01B80:  CLRF   x90
01B82:  CLRF   x8F
01B84:  CLRF   x93
01B86:  MOVLB  0
01B88:  RCALL  1660
01B8A:  BTFSC  1B.7
01B8C:  BSF    FF2.7
01B8E:  CLRF   1B
01B90:  BTFSC  FF2.7
01B92:  BSF    1B.7
01B94:  BCF    FF2.7
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
01B96:  MOVLW  0F
01B98:  MOVLB  4
01B9A:  MOVWF  x8E
01B9C:  MOVLW  07
01B9E:  MOVWF  x8D
01BA0:  CLRF   x92
01BA2:  CLRF   x91
01BA4:  CLRF   x90
01BA6:  CLRF   x8F
01BA8:  CLRF   x93
01BAA:  MOVLB  0
01BAC:  RCALL  1660
01BAE:  BTFSC  1B.7
01BB0:  BSF    FF2.7
01BB2:  CLRF   1B
01BB4:  BTFSC  FF2.7
01BB6:  BSF    1B.7
01BB8:  BCF    FF2.7
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
01BBA:  MOVLW  0F
01BBC:  MOVLB  4
01BBE:  MOVWF  x8E
01BC0:  MOVLW  1F
01BC2:  MOVWF  x8D
01BC4:  CLRF   x92
01BC6:  CLRF   x91
01BC8:  CLRF   x90
01BCA:  CLRF   x8F
01BCC:  CLRF   x93
01BCE:  MOVLB  0
01BD0:  RCALL  1660
01BD2:  BTFSC  1B.7
01BD4:  BSF    FF2.7
01BD6:  CLRF   1B
01BD8:  BTFSC  FF2.7
01BDA:  BSF    1B.7
01BDC:  BCF    FF2.7
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
01BDE:  MOVLW  0F
01BE0:  MOVLB  4
01BE2:  MOVWF  x8E
01BE4:  MOVLW  0B
01BE6:  MOVWF  x8D
01BE8:  CLRF   x92
01BEA:  CLRF   x91
01BEC:  CLRF   x90
01BEE:  CLRF   x8F
01BF0:  CLRF   x93
01BF2:  MOVLB  0
01BF4:  RCALL  1660
01BF6:  BTFSC  1B.7
01BF8:  BSF    FF2.7
01BFA:  CLRF   1B
01BFC:  BTFSC  FF2.7
01BFE:  BSF    1B.7
01C00:  BCF    FF2.7
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
01C02:  MOVLW  0F
01C04:  MOVLB  4
01C06:  MOVWF  x8E
01C08:  MOVWF  x8D
01C0A:  CLRF   x92
01C0C:  CLRF   x91
01C0E:  CLRF   x90
01C10:  CLRF   x8F
01C12:  CLRF   x93
01C14:  MOVLB  0
01C16:  RCALL  1660
01C18:  BTFSC  1B.7
01C1A:  BSF    FF2.7
01C1C:  CLRF   1B
01C1E:  BTFSC  FF2.7
01C20:  BSF    1B.7
01C22:  BCF    FF2.7
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
01C24:  MOVLW  0F
01C26:  MOVLB  4
01C28:  MOVWF  x8E
01C2A:  MOVLW  13
01C2C:  MOVWF  x8D
01C2E:  CLRF   x92
01C30:  CLRF   x91
01C32:  CLRF   x90
01C34:  CLRF   x8F
01C36:  CLRF   x93
01C38:  MOVLB  0
01C3A:  RCALL  1660
01C3C:  BTFSC  1B.7
01C3E:  BSF    FF2.7
01C40:  CLRF   1B
01C42:  BTFSC  FF2.7
01C44:  BSF    1B.7
01C46:  BCF    FF2.7
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
01C48:  MOVLW  0F
01C4A:  MOVLB  4
01C4C:  MOVWF  x8E
01C4E:  MOVLW  17
01C50:  MOVWF  x8D
01C52:  CLRF   x92
01C54:  CLRF   x91
01C56:  CLRF   x90
01C58:  CLRF   x8F
01C5A:  CLRF   x93
01C5C:  MOVLB  0
01C5E:  RCALL  1660
01C60:  BTFSC  1B.7
01C62:  BSF    FF2.7
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
01C64:  MOVF   F93,W
01C66:  ANDLW  FB
01C68:  IORLW  08
01C6A:  MOVLB  4
01C6C:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
01C6E:  CLRF   x1F
01C70:  MOVLB  0
01C72:  RCALL  1ACE
.................... } 
01C74:  GOTO   1C7A (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
01AF4:  MOVLW  C0
01AF6:  ANDWF  F70,W
01AF8:  IORLW  04
01AFA:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
01AFC:  MOVLW  3F
01AFE:  ANDWF  F70,W
01B00:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
01B02:  MOVLW  F8
01B04:  ANDWF  F71,W
01B06:  IORLW  02
01B08:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
01B0A:  MOVLW  C7
01B0C:  ANDWF  F71,W
01B0E:  IORLW  28
01B10:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
01B12:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
01B14:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
01B16:  MOVLW  F8
01B18:  ANDWF  F72,W
01B1A:  IORLW  05
01B1C:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
01B1E:  BCF    F72.6
.................... } 
01B20:  GOTO   1B30 (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
01ACE:  MOVLB  4
01AD0:  SWAPF  x1F,W
01AD2:  ANDLW  70
01AD4:  MOVWF  00
01AD6:  BCF    FD8.0
01AD8:  RLCF   00,F
01ADA:  MOVLW  1F
01ADC:  ANDWF  F6F,W
01ADE:  IORWF  00,W
01AE0:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
01AE2:  MOVFF  F6E,00
01AE6:  SWAPF  00,F
01AE8:  RRCF   00,W
01AEA:  ANDLW  07
01AEC:  SUBWF  x1F,W
01AEE:  BNZ   1AE2
.................... } 
01AF0:  MOVLB  0
01AF2:  RETLW  00
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(int* addr, int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
01660:  MOVFF  48E,495
01664:  MOVFF  48D,494
....................  
....................    if (ext) {  //extended 
01668:  MOVLB  4
0166A:  MOVF   x93,F
0166C:  BZ    1712
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
0166E:  MOVFF  494,FE9
01672:  MOVFF  495,FEA
01676:  MOVFF  48F,FEF
....................  
....................       //eidh 
....................       ptr--; 
0167A:  MOVF   x94,W
0167C:  BTFSC  FD8.2
0167E:  DECF   x95,F
01680:  DECF   x94,F
....................       *ptr=make8(id,1); //8:15 
01682:  MOVFF  494,FE9
01686:  MOVFF  495,FEA
0168A:  MOVFF  490,FEF
....................  
....................       //sidl 
....................       ptr--; 
0168E:  MOVF   x94,W
01690:  BTFSC  FD8.2
01692:  DECF   x95,F
01694:  DECF   x94,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
01696:  MOVFF  494,FE9
0169A:  MOVFF  495,FEA
0169E:  MOVF   x91,W
016A0:  ANDLW  03
016A2:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
016A4:  MOVFF  494,FE9
016A8:  MOVFF  495,FEA
016AC:  MOVFF  491,00
016B0:  RLCF   00,F
016B2:  RLCF   00,F
016B4:  RLCF   00,F
016B6:  MOVLW  F8
016B8:  ANDWF  00,F
016BA:  MOVF   00,W
016BC:  ANDLW  E0
016BE:  IORWF  FEF,W
016C0:  MOVWF  FEF
....................       *ptr|=0x08; 
016C2:  MOVFF  494,FE9
016C6:  MOVFF  495,FEA
016CA:  MOVF   FEF,W
016CC:  IORLW  08
016CE:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
016D0:  MOVF   x94,W
016D2:  BTFSC  FD8.2
016D4:  DECF   x95,F
016D6:  DECF   x94,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
016D8:  MOVFF  494,FE9
016DC:  MOVFF  495,FEA
016E0:  MOVFF  491,00
016E4:  SWAPF  00,F
016E6:  RRCF   00,F
016E8:  MOVLW  07
016EA:  ANDWF  00,F
016EC:  MOVF   00,W
016EE:  ANDLW  07
016F0:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
016F2:  MOVFF  494,FE9
016F6:  MOVFF  495,FEA
016FA:  MOVFF  492,00
016FE:  RLCF   00,F
01700:  RLCF   00,F
01702:  RLCF   00,F
01704:  MOVLW  F8
01706:  ANDWF  00,F
01708:  MOVF   00,W
0170A:  ANDLW  F8
0170C:  IORWF  FEF,W
0170E:  MOVWF  FEF
....................    } 
....................    else {   //standard 
01710:  BRA    1790
....................       //eidl 
....................       *ptr=0; 
01712:  MOVFF  494,FE9
01716:  MOVFF  495,FEA
0171A:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
0171C:  MOVF   x94,W
0171E:  BTFSC  FD8.2
01720:  DECF   x95,F
01722:  DECF   x94,F
....................       *ptr=0; 
01724:  MOVFF  494,FE9
01728:  MOVFF  495,FEA
0172C:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
0172E:  MOVF   x94,W
01730:  BTFSC  FD8.2
01732:  DECF   x95,F
01734:  DECF   x94,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
01736:  MOVFF  494,FE9
0173A:  MOVFF  495,FEA
0173E:  MOVFF  48F,00
01742:  SWAPF  00,F
01744:  RLCF   00,F
01746:  MOVLW  E0
01748:  ANDWF  00,F
0174A:  MOVF   00,W
0174C:  ANDLW  E0
0174E:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
01750:  MOVF   x94,W
01752:  BTFSC  FD8.2
01754:  DECF   x95,F
01756:  DECF   x94,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
01758:  MOVFF  494,FE9
0175C:  MOVFF  495,FEA
01760:  MOVFF  48F,00
01764:  RRCF   00,F
01766:  RRCF   00,F
01768:  RRCF   00,F
0176A:  MOVLW  1F
0176C:  ANDWF  00,F
0176E:  MOVF   00,W
01770:  ANDLW  1F
01772:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
01774:  MOVFF  494,FE9
01778:  MOVFF  495,FEA
0177C:  MOVFF  490,00
01780:  SWAPF  00,F
01782:  RLCF   00,F
01784:  MOVLW  E0
01786:  ANDWF  00,F
01788:  MOVF   00,W
0178A:  ANDLW  E0
0178C:  IORWF  FEF,W
0178E:  MOVWF  FEF
....................    } 
.................... } 
01790:  MOVLB  0
01792:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int32 can_get_id(int * addr, int1 ext) { 
....................    int32 ret; 
....................    int * ptr; 
....................  
....................    ret=0; 
*
010A8:  MOVLB  4
010AA:  CLRF   x8F
010AC:  CLRF   x8E
010AE:  CLRF   x8D
010B0:  CLRF   x8C
....................    ptr=addr; 
010B2:  MOVFF  48A,491
010B6:  MOVFF  489,490
....................  
....................    if (ext) { 
010BA:  MOVF   x8B,F
010BC:  BTFSC  FD8.2
010BE:  BRA    11E6
....................       ret=*ptr;  //eidl 
010C0:  MOVFF  491,03
010C4:  MOVFF  490,FE9
010C8:  MOVFF  491,FEA
010CC:  MOVFF  FEF,00
010D0:  CLRF   01
010D2:  CLRF   02
010D4:  CLRF   03
010D6:  MOVFF  03,48F
010DA:  MOVFF  02,48E
010DE:  MOVFF  01,48D
010E2:  MOVFF  00,48C
....................  
....................       ptr--;     //eidh 
010E6:  MOVF   x90,W
010E8:  BTFSC  FD8.2
010EA:  DECF   x91,F
010EC:  DECF   x90,F
....................       ret|=((int32)*ptr << 8); 
010EE:  MOVFF  490,FE9
010F2:  MOVFF  491,FEA
010F6:  MOVF   FEF,W
010F8:  CLRF   x94
010FA:  CLRF   x93
010FC:  MOVWF  x92
010FE:  CLRF   00
01100:  MOVF   00,W
01102:  IORWF  x8C,F
01104:  MOVF   x92,W
01106:  IORWF  x8D,F
01108:  MOVF   x93,W
0110A:  IORWF  x8E,F
0110C:  MOVF   x94,W
0110E:  IORWF  x8F,F
....................  
....................       ptr--;     //sidl 
01110:  MOVF   x90,W
01112:  BTFSC  FD8.2
01114:  DECF   x91,F
01116:  DECF   x90,F
....................       ret|=((int32)*ptr & 0x03) << 16; 
01118:  MOVFF  490,FE9
0111C:  MOVFF  491,FEA
01120:  MOVF   FEF,W
01122:  CLRF   x95
01124:  CLRF   x94
01126:  CLRF   x93
01128:  MOVWF  x92
0112A:  MOVLW  03
0112C:  ANDWF  x92,F
0112E:  CLRF   x93
01130:  CLRF   x94
01132:  CLRF   x95
01134:  CLRF   00
01136:  CLRF   01
01138:  MOVF   00,W
0113A:  IORWF  x8C,F
0113C:  MOVF   01,W
0113E:  IORWF  x8D,F
01140:  MOVF   x92,W
01142:  IORWF  x8E,F
01144:  MOVF   x93,W
01146:  IORWF  x8F,F
....................       ret|=((int32)*ptr & 0xE0) << 13; 
01148:  MOVFF  490,FE9
0114C:  MOVFF  491,FEA
01150:  MOVF   FEF,W
01152:  CLRF   x95
01154:  CLRF   x94
01156:  CLRF   x93
01158:  MOVWF  x92
0115A:  MOVLW  E0
0115C:  ANDWF  x92,F
0115E:  CLRF   x93
01160:  CLRF   x94
01162:  CLRF   x95
01164:  CLRF   00
01166:  RLCF   x92,W
01168:  MOVWF  01
0116A:  RLCF   x93,W
0116C:  MOVWF  02
0116E:  RLCF   x94,W
01170:  MOVWF  03
01172:  RLCF   01,F
01174:  RLCF   02,F
01176:  RLCF   03,F
01178:  RLCF   01,F
0117A:  RLCF   02,F
0117C:  RLCF   03,F
0117E:  RLCF   01,F
01180:  RLCF   02,F
01182:  RLCF   03,F
01184:  RLCF   01,F
01186:  RLCF   02,F
01188:  RLCF   03,F
0118A:  MOVLW  E0
0118C:  ANDWF  01,F
0118E:  MOVF   00,W
01190:  IORWF  x8C,F
01192:  MOVF   01,W
01194:  IORWF  x8D,F
01196:  MOVF   02,W
01198:  IORWF  x8E,F
0119A:  MOVF   03,W
0119C:  IORWF  x8F,F
....................  
....................       ptr--;     //sidh 
0119E:  MOVF   x90,W
011A0:  BTFSC  FD8.2
011A2:  DECF   x91,F
011A4:  DECF   x90,F
....................       ret|=((int32)*ptr << 21); 
011A6:  MOVFF  490,FE9
011AA:  MOVFF  491,FEA
011AE:  MOVF   FEF,W
011B0:  CLRF   x93
011B2:  MOVWF  x92
011B4:  CLRF   00
011B6:  CLRF   01
011B8:  RLCF   x92,W
011BA:  MOVWF  02
011BC:  RLCF   x93,W
011BE:  MOVWF  03
011C0:  RLCF   02,F
011C2:  RLCF   03,F
011C4:  RLCF   02,F
011C6:  RLCF   03,F
011C8:  RLCF   02,F
011CA:  RLCF   03,F
011CC:  RLCF   02,F
011CE:  RLCF   03,F
011D0:  MOVLW  E0
011D2:  ANDWF  02,F
011D4:  MOVF   00,W
011D6:  IORWF  x8C,F
011D8:  MOVF   01,W
011DA:  IORWF  x8D,F
011DC:  MOVF   02,W
011DE:  IORWF  x8E,F
011E0:  MOVF   03,W
011E2:  IORWF  x8F,F
....................  
....................    } 
....................    else { 
011E4:  BRA    128C
....................       ptr-=2;    //sidl 
011E6:  MOVLW  02
011E8:  SUBWF  x90,F
011EA:  MOVLW  00
011EC:  SUBWFB x91,F
....................       ret=((int32)*ptr & 0xE0) >> 5; 
011EE:  MOVFF  490,FE9
011F2:  MOVFF  491,FEA
011F6:  MOVF   FEF,W
011F8:  CLRF   x95
011FA:  CLRF   x94
011FC:  CLRF   x93
011FE:  MOVWF  x92
01200:  MOVLW  E0
01202:  ANDWF  x92,F
01204:  CLRF   x93
01206:  CLRF   x94
01208:  CLRF   x95
0120A:  RRCF   x95,W
0120C:  MOVWF  x8F
0120E:  RRCF   x94,W
01210:  MOVWF  x8E
01212:  RRCF   x93,W
01214:  MOVWF  x8D
01216:  RRCF   x92,W
01218:  MOVWF  x8C
0121A:  RRCF   x8F,F
0121C:  RRCF   x8E,F
0121E:  RRCF   x8D,F
01220:  RRCF   x8C,F
01222:  RRCF   x8F,F
01224:  RRCF   x8E,F
01226:  RRCF   x8D,F
01228:  RRCF   x8C,F
0122A:  RRCF   x8F,F
0122C:  RRCF   x8E,F
0122E:  RRCF   x8D,F
01230:  RRCF   x8C,F
01232:  RRCF   x8F,F
01234:  RRCF   x8E,F
01236:  RRCF   x8D,F
01238:  RRCF   x8C,F
0123A:  MOVLW  07
0123C:  ANDWF  x8F,F
....................  
....................       ptr--;     //sidh 
0123E:  MOVF   x90,W
01240:  BTFSC  FD8.2
01242:  DECF   x91,F
01244:  DECF   x90,F
....................       ret|=((int32)*ptr << 3); 
01246:  MOVFF  490,FE9
0124A:  MOVFF  491,FEA
0124E:  MOVF   FEF,W
01250:  CLRF   x95
01252:  CLRF   x94
01254:  CLRF   x93
01256:  MOVWF  x92
01258:  RLCF   x92,W
0125A:  MOVWF  00
0125C:  RLCF   x93,W
0125E:  MOVWF  01
01260:  RLCF   x94,W
01262:  MOVWF  02
01264:  RLCF   x95,W
01266:  MOVWF  03
01268:  RLCF   00,F
0126A:  RLCF   01,F
0126C:  RLCF   02,F
0126E:  RLCF   03,F
01270:  RLCF   00,F
01272:  RLCF   01,F
01274:  RLCF   02,F
01276:  RLCF   03,F
01278:  MOVLW  F8
0127A:  ANDWF  00,F
0127C:  MOVF   00,W
0127E:  IORWF  x8C,F
01280:  MOVF   01,W
01282:  IORWF  x8D,F
01284:  MOVF   02,W
01286:  IORWF  x8E,F
01288:  MOVF   03,W
0128A:  IORWF  x8F,F
....................    } 
....................  
....................    return(ret); 
0128C:  MOVFF  48C,00
01290:  MOVFF  48D,01
01294:  MOVFF  48E,02
01298:  MOVFF  48F,03
.................... } 
0129C:  MOVLB  0
0129E:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr) { 
....................    int i; 
....................    int * txd0; 
....................    int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
01794:  MOVLW  0F
01796:  MOVLB  4
01798:  MOVWF  x8B
0179A:  MOVLW  66
0179C:  MOVWF  x8A
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
0179E:  MOVLB  F
017A0:  BTFSC  x40.3
017A2:  BRA    17B4
....................       CANCON.win=CAN_WIN_TX0; 
017A4:  MOVLW  F1
017A6:  ANDWF  F6F,W
017A8:  IORLW  08
017AA:  MOVWF  F6F
....................       port=0; 
017AC:  MOVLB  4
017AE:  CLRF   x8C
....................    } 
....................    else if (!TXB1CON.txreq) { 
017B0:  BRA    17E8
017B2:  MOVLB  F
017B4:  BTFSC  x30.3
017B6:  BRA    17CA
....................       CANCON.win=CAN_WIN_TX1; 
017B8:  MOVLW  F1
017BA:  ANDWF  F6F,W
017BC:  IORLW  06
017BE:  MOVWF  F6F
....................       port=1; 
017C0:  MOVLW  01
017C2:  MOVLB  4
017C4:  MOVWF  x8C
....................    } 
....................    else if (!TXB2CON.txreq) { 
017C6:  BRA    17E8
017C8:  MOVLB  F
017CA:  BTFSC  x20.3
017CC:  BRA    17E0
....................       CANCON.win=CAN_WIN_TX2; 
017CE:  MOVLW  F1
017D0:  ANDWF  F6F,W
017D2:  IORLW  04
017D4:  MOVWF  F6F
....................       port=2; 
017D6:  MOVLW  02
017D8:  MOVLB  4
017DA:  MOVWF  x8C
....................    } 
....................    else { 
017DC:  BRA    17E8
017DE:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
017E0:  MOVLW  00
017E2:  MOVWF  01
017E4:  BRA    1860
017E6:  MOVLB  4
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
017E8:  MOVF   x86,W
017EA:  ANDLW  03
017EC:  MOVWF  00
017EE:  MOVLW  FC
017F0:  ANDWF  F60,W
017F2:  IORWF  00,W
017F4:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
017F6:  MOVLW  0F
017F8:  MOVWF  x8E
017FA:  MOVLW  64
017FC:  MOVWF  x8D
017FE:  MOVFF  482,492
01802:  MOVFF  481,491
01806:  MOVFF  480,490
0180A:  MOVFF  47F,48F
0180E:  MOVFF  487,493
01812:  MOVLB  0
01814:  RCALL  1660
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
01816:  MOVFF  485,F65
....................    TXBaDLC.rtr=rtr; 
0181A:  BCF    F65.6
0181C:  MOVLB  4
0181E:  BTFSC  x88.0
01820:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
01822:  CLRF   x89
01824:  MOVF   x85,W
01826:  SUBWF  x89,W
01828:  BC    1852
....................       *txd0=*data; 
0182A:  MOVFF  483,FE9
0182E:  MOVFF  484,FEA
01832:  MOVFF  FEF,48F
01836:  MOVFF  48B,FEA
0183A:  MOVFF  48A,FE9
0183E:  MOVFF  48F,FEF
....................       txd0++; 
01842:  INCF   x8A,F
01844:  BTFSC  FD8.2
01846:  INCF   x8B,F
....................       data++; 
01848:  INCF   x83,F
0184A:  BTFSC  FD8.2
0184C:  INCF   x84,F
....................     } 
0184E:  INCF   x89,F
01850:  BRA    1824
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
01852:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
01854:  MOVLW  F1
01856:  ANDWF  F6F,W
01858:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
0185A:  MOVLW  01
0185C:  MOVWF  01
0185E:  MOVLB  F
.................... } 
01860:  MOVLB  0
01862:  GOTO   1A78 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(int32 & id, int * data, int & len, struct rx_stat & stat) 
.................... { 
....................     int i; 
....................     int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
012BA:  BTFSS  F60.7
012BC:  BRA    12EC
*
01542:  BTFSS  F60.7
01544:  BRA    1574
....................         CANCON.win=CAN_WIN_RX0; 
*
012BE:  MOVLW  F1
012C0:  ANDWF  F6F,W
012C2:  MOVWF  F6F
*
01546:  MOVLW  F1
01548:  ANDWF  F6F,W
0154A:  MOVWF  F6F
....................         stat.buffer=0; 
*
012C4:  BCF    x72.4
*
0154C:  BCF    x72.4
....................  
....................         CAN_INT_RXB0IF=0; 
*
012C6:  BCF    FA4.0
*
0154E:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
*
012C8:  BCF    x72.0
012CA:  BTFSC  F74.7
012CC:  BSF    x72.0
*
01550:  BCF    x72.0
01552:  BTFSC  F74.7
01554:  BSF    x72.0
....................         COMSTAT.rx0ovfl=0; 
*
012CE:  BCF    F74.7
*
01556:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
*
012D0:  BTFSS  F60.2
012D2:  BRA    12EA
*
01558:  BTFSS  F60.2
0155A:  BRA    1572
....................          stat.filthit=RXB0CON.filthit0; 
*
012D4:  MOVLW  00
012D6:  BTFSC  F60.0
012D8:  MOVLW  01
012DA:  ANDLW  07
012DC:  MOVWF  00
012DE:  BCF    FD8.0
012E0:  RLCF   00,F
012E2:  MOVLW  F1
012E4:  ANDWF  x72,W
012E6:  IORWF  00,W
012E8:  MOVWF  x72
*
0155C:  MOVLW  00
0155E:  BTFSC  F60.0
01560:  MOVLW  01
01562:  ANDLW  07
01564:  MOVWF  00
01566:  BCF    FD8.0
01568:  RLCF   00,F
0156A:  MOVLW  F1
0156C:  ANDWF  x72,W
0156E:  IORWF  00,W
01570:  MOVWF  x72
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
*
012EA:  BRA    132C
012EC:  MOVLB  F
012EE:  BTFSS  x50.7
012F0:  BRA    1324
*
01572:  BRA    15B4
01574:  MOVLB  F
01576:  BTFSS  x50.7
01578:  BRA    15AC
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
*
012F2:  MOVLW  F1
012F4:  ANDWF  F6F,W
012F6:  IORLW  0A
012F8:  MOVWF  F6F
*
0157A:  MOVLW  F1
0157C:  ANDWF  F6F,W
0157E:  IORLW  0A
01580:  MOVWF  F6F
....................         stat.buffer=1; 
*
012FA:  MOVLB  4
012FC:  BSF    x72.4
*
01582:  MOVLB  4
01584:  BSF    x72.4
....................  
....................         CAN_INT_RXB1IF=0; 
*
012FE:  BCF    FA4.1
*
01586:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
*
01300:  BCF    x72.0
01302:  BTFSC  F74.6
01304:  BSF    x72.0
*
01588:  BCF    x72.0
0158A:  BTFSC  F74.6
0158C:  BSF    x72.0
....................         COMSTAT.rx1ovfl=0; 
*
01306:  BCF    F74.6
*
0158E:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
*
01308:  MOVLB  F
0130A:  MOVF   x50,W
0130C:  ANDLW  07
0130E:  ANDLW  07
01310:  MOVWF  00
01312:  BCF    FD8.0
01314:  RLCF   00,F
01316:  MOVLW  F1
01318:  MOVLB  4
0131A:  ANDWF  x72,W
0131C:  IORWF  00,W
0131E:  MOVWF  x72
*
01590:  MOVLB  F
01592:  MOVF   x50,W
01594:  ANDLW  07
01596:  ANDLW  07
01598:  MOVWF  00
0159A:  BCF    FD8.0
0159C:  RLCF   00,F
0159E:  MOVLW  F1
015A0:  MOVLB  4
015A2:  ANDWF  x72,W
015A4:  IORWF  00,W
015A6:  MOVWF  x72
....................     } 
....................     else { 
*
01320:  BRA    132C
01322:  MOVLB  F
*
015A8:  BRA    15B4
015AA:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
01324:  MOVLW  00
01326:  MOVWF  01
01328:  BRA    13C2
0132A:  MOVLB  4
*
015AC:  MOVLW  00
015AE:  MOVWF  01
015B0:  BRA    164A
015B2:  MOVLB  4
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
*
0132C:  MOVF   F65,W
0132E:  ANDLW  0F
01330:  MOVWF  x71
*
015B4:  MOVF   F65,W
015B6:  ANDLW  0F
015B8:  MOVWF  x71
....................     stat.rtr=RXBaDLC.rtr; 
*
01332:  BCF    x72.5
01334:  BTFSC  F65.6
01336:  BSF    x72.5
*
015BA:  BCF    x72.5
015BC:  BTFSC  F65.6
015BE:  BSF    x72.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
*
01338:  BCF    x72.6
0133A:  BTFSC  F62.3
0133C:  BSF    x72.6
*
015C0:  BCF    x72.6
015C2:  BTFSC  F62.3
015C4:  BSF    x72.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
*
0133E:  MOVLW  00
01340:  BTFSC  x72.6
01342:  MOVLW  01
01344:  MOVWF  x82
01346:  MOVLW  0F
01348:  MOVWF  x8A
0134A:  MOVLW  64
0134C:  MOVWF  x89
0134E:  MOVFF  482,48B
01352:  MOVLB  0
01354:  RCALL  10A8
01356:  MOVFF  03,470
0135A:  MOVFF  02,46F
0135E:  MOVFF  01,46E
01362:  MOVFF  00,46D
*
015C6:  MOVLW  00
015C8:  BTFSC  x72.6
015CA:  MOVLW  01
015CC:  MOVWF  x82
015CE:  MOVLW  0F
015D0:  MOVWF  x8A
015D2:  MOVLW  64
015D4:  MOVWF  x89
015D6:  MOVFF  482,48B
015DA:  MOVLB  0
015DC:  RCALL  10A8
015DE:  MOVFF  03,470
015E2:  MOVFF  02,46F
015E6:  MOVFF  01,46E
015EA:  MOVFF  00,46D
....................  
....................     ptr = &TXRXBaD0; 
*
01366:  MOVLW  0F
01368:  MOVLB  4
0136A:  MOVWF  x81
0136C:  MOVLW  66
0136E:  MOVWF  x80
*
015EE:  MOVLW  0F
015F0:  MOVLB  4
015F2:  MOVWF  x81
015F4:  MOVLW  66
015F6:  MOVWF  x80
....................     for ( i = 0; i < len; i++ ) { 
*
01370:  CLRF   x7F
01372:  MOVF   x71,W
01374:  SUBWF  x7F,W
01376:  BC    13A0
*
015F8:  CLRF   x7F
015FA:  MOVF   x71,W
015FC:  SUBWF  x7F,W
015FE:  BC    1628
....................         *data = *ptr; 
*
01378:  MOVFF  480,FE9
0137C:  MOVFF  481,FEA
01380:  MOVFF  FEF,484
01384:  MOVFF  47E,FEA
01388:  MOVFF  47D,FE9
0138C:  MOVFF  484,FEF
*
01600:  MOVFF  480,FE9
01604:  MOVFF  481,FEA
01608:  MOVFF  FEF,484
0160C:  MOVFF  47E,FEA
01610:  MOVFF  47D,FE9
01614:  MOVFF  484,FEF
....................         data++; 
*
01390:  INCF   x7D,F
01392:  BTFSC  FD8.2
01394:  INCF   x7E,F
*
01618:  INCF   x7D,F
0161A:  BTFSC  FD8.2
0161C:  INCF   x7E,F
....................         ptr++; 
*
01396:  INCF   x80,F
01398:  BTFSC  FD8.2
0139A:  INCF   x81,F
*
0161E:  INCF   x80,F
01620:  BTFSC  FD8.2
01622:  INCF   x81,F
....................     } 
*
0139C:  INCF   x7F,F
0139E:  BRA    1372
*
01624:  INCF   x7F,F
01626:  BRA    15FA
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
*
013A0:  MOVLW  F1
013A2:  ANDWF  F6F,W
013A4:  MOVWF  F6F
*
01628:  MOVLW  F1
0162A:  ANDWF  F6F,W
0162C:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
*
013A6:  BCF    x72.7
013A8:  BTFSC  FA4.7
013AA:  BSF    x72.7
*
0162E:  BCF    x72.7
01630:  BTFSC  FA4.7
01632:  BSF    x72.7
....................     CAN_INT_IRXIF = 0; 
*
013AC:  BCF    FA4.7
*
01634:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
*
013AE:  BTFSS  x72.4
013B0:  BRA    13BA
*
01636:  BTFSS  x72.4
01638:  BRA    1642
....................       RXB1CON.rxful=0; 
*
013B2:  MOVLB  F
013B4:  BCF    x50.7
*
0163A:  MOVLB  F
0163C:  BCF    x50.7
....................     } 
....................     else { 
*
013B6:  BRA    13BE
013B8:  MOVLB  4
*
0163E:  BRA    1646
01640:  MOVLB  4
....................       RXB0CON.rxful=0; 
*
013BA:  BCF    F60.7
013BC:  MOVLB  F
*
01642:  BCF    F60.7
01644:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
*
013BE:  MOVLW  01
013C0:  MOVWF  01
*
01646:  MOVLW  01
01648:  MOVWF  01
0164A:  MOVLB  4
.................... } 
....................  
....................  
....................  
....................  
.................... /** 
....................  * no comments 
....................  */ 
.................... #define dev1_ze 10 
....................  
.................... #define CAN_RECEIVE_STACK_SIZE 10 
.................... int can_rspoint=0; 
.................... int can_rstack [CAN_RECEIVE_STACK_SIZE] [14]; 
.................... int1 can_rsfull=FALSE; 
.................... #define can_receiver_full() can_rsfull 
.................... #define CAN_TRANSMIT_STACK_SIZE 10 
.................... int can_tspoint=0; 
.................... int can_tstack [CAN_TRANSMIT_STACK_SIZE] [13]; 
.................... int1 can_tsempty=TRUE; 
.................... #define can_transmitter_empty() can_tsempty 
.................... #define CAN_FILTER_SIZE 1 
.................... int32 can_filter [CAN_FILTER_SIZE] = {11}; 
....................  
....................  
.................... void canReceive ( ) 
.................... { 
....................    int32 rx_id; 
....................    int8  rx_len, rx_stat; 
....................    int8  buffer [8]; 
....................    int8  i; 
....................  
....................    if(can_rspoint==-1) 
*
012A0:  MOVF   24,W
012A2:  SUBLW  FF
012A4:  BNZ   12A8
....................       can_rspoint++; 
012A6:  INCF   24,F
....................  
....................    if(can_rspoint < CAN_RECEIVE_STACK_SIZE) 
012A8:  MOVF   24,W
012AA:  SUBLW  09
012AC:  BTFSS  FD8.0
012AE:  BRA    1538
....................    { 
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
012B0:  MOVLW  04
012B2:  MOVLB  4
012B4:  MOVWF  x7E
012B6:  MOVLW  73
012B8:  MOVWF  x7D
....................    { 
....................       int8 j; 
....................       for(j=0;j<CAN_FILTER_SIZE;j++) 
*
013C2:  MOVLB  4
013C4:  CLRF   x7C
013C6:  MOVF   x7C,F
013C8:  BNZ   140A
....................          if(rx_id==can_filter[j]) 
013CA:  MOVF   x7C,W
013CC:  MULLW  04
013CE:  MOVF   FF3,W
013D0:  CLRF   03
013D2:  ADDLW  35
013D4:  MOVWF  FE9
013D6:  MOVLW  01
013D8:  ADDWFC 03,W
013DA:  MOVWF  FEA
013DC:  MOVFF  FEF,00
013E0:  MOVFF  FEC,01
013E4:  MOVFF  FEC,02
013E8:  MOVFF  FEC,03
013EC:  MOVF   00,W
013EE:  SUBWF  x6D,W
013F0:  BNZ   1406
013F2:  MOVF   01,W
013F4:  SUBWF  x6E,W
013F6:  BNZ   1406
013F8:  MOVF   02,W
013FA:  SUBWF  x6F,W
013FC:  BNZ   1406
013FE:  MOVF   03,W
01400:  SUBWF  x70,W
01402:  BNZ   1406
....................             return; 
01404:  BRA    164C
01406:  INCF   x7C,F
01408:  BRA    13C6
....................    } 
....................       can_rstack[can_rspoint][0]=make8(rx_id,3); 
0140A:  MOVF   24,W
0140C:  MULLW  0E
0140E:  MOVF   FF3,W
01410:  CLRF   x7E
01412:  MOVWF  x7D
01414:  MOVLW  25
01416:  ADDWF  x7D,W
01418:  MOVWF  FE9
0141A:  MOVLW  00
0141C:  ADDWFC x7E,W
0141E:  MOVWF  FEA
01420:  MOVFF  470,FEF
....................       can_rstack[can_rspoint][1]=make8(rx_id,2); 
01424:  MOVF   24,W
01426:  MULLW  0E
01428:  MOVF   FF3,W
0142A:  CLRF   x7E
0142C:  MOVWF  x7D
0142E:  MOVLW  01
01430:  ADDWF  x7D,W
01432:  MOVWF  01
01434:  MOVLW  00
01436:  ADDWFC x7E,W
01438:  MOVWF  03
0143A:  MOVF   01,W
0143C:  ADDLW  25
0143E:  MOVWF  FE9
01440:  MOVLW  00
01442:  ADDWFC 03,W
01444:  MOVWF  FEA
01446:  MOVFF  46F,FEF
....................       can_rstack[can_rspoint][2]=make8(rx_id,1); 
0144A:  MOVF   24,W
0144C:  MULLW  0E
0144E:  MOVF   FF3,W
01450:  CLRF   x7E
01452:  MOVWF  x7D
01454:  MOVLW  02
01456:  ADDWF  x7D,W
01458:  MOVWF  01
0145A:  MOVLW  00
0145C:  ADDWFC x7E,W
0145E:  MOVWF  03
01460:  MOVF   01,W
01462:  ADDLW  25
01464:  MOVWF  FE9
01466:  MOVLW  00
01468:  ADDWFC 03,W
0146A:  MOVWF  FEA
0146C:  MOVFF  46E,FEF
....................       can_rstack[can_rspoint][3]=make8(rx_id,0); 
01470:  MOVF   24,W
01472:  MULLW  0E
01474:  MOVF   FF3,W
01476:  CLRF   x7E
01478:  MOVWF  x7D
0147A:  MOVLW  03
0147C:  ADDWF  x7D,W
0147E:  MOVWF  01
01480:  MOVLW  00
01482:  ADDWFC x7E,W
01484:  MOVWF  03
01486:  MOVF   01,W
01488:  ADDLW  25
0148A:  MOVWF  FE9
0148C:  MOVLW  00
0148E:  ADDWFC 03,W
01490:  MOVWF  FEA
01492:  MOVFF  46D,FEF
....................  
....................       can_rstack[can_rspoint][4]=rx_len; 
01496:  MOVF   24,W
01498:  MULLW  0E
0149A:  MOVF   FF3,W
0149C:  CLRF   x7E
0149E:  MOVWF  x7D
014A0:  MOVLW  04
014A2:  ADDWF  x7D,W
014A4:  MOVWF  01
014A6:  MOVLW  00
014A8:  ADDWFC x7E,W
014AA:  MOVWF  03
014AC:  MOVF   01,W
014AE:  ADDLW  25
014B0:  MOVWF  FE9
014B2:  MOVLW  00
014B4:  ADDWFC 03,W
014B6:  MOVWF  FEA
014B8:  MOVFF  471,FEF
....................       can_rstack[can_rspoint][5]=rx_stat; 
014BC:  MOVF   24,W
014BE:  MULLW  0E
014C0:  MOVF   FF3,W
014C2:  CLRF   x7E
014C4:  MOVWF  x7D
014C6:  MOVLW  05
014C8:  ADDWF  x7D,W
014CA:  MOVWF  01
014CC:  MOVLW  00
014CE:  ADDWFC x7E,W
014D0:  MOVWF  03
014D2:  MOVF   01,W
014D4:  ADDLW  25
014D6:  MOVWF  FE9
014D8:  MOVLW  00
014DA:  ADDWFC 03,W
014DC:  MOVWF  FEA
014DE:  MOVFF  472,FEF
....................  
....................       for(i=0;i<rx_len;i++) 
014E2:  CLRF   x7B
014E4:  MOVF   x71,W
014E6:  SUBWF  x7B,W
014E8:  BC    1532
....................       { 
....................          can_rstack[can_rspoint][i+6]=buffer[i]; 
014EA:  MOVF   24,W
014EC:  MULLW  0E
014EE:  MOVF   FF3,W
014F0:  CLRF   x7E
014F2:  MOVWF  x7D
014F4:  MOVLW  06
014F6:  ADDWF  x7B,W
014F8:  CLRF   03
014FA:  ADDWF  x7D,W
014FC:  MOVWF  01
014FE:  MOVF   x7E,W
01500:  ADDWFC 03,F
01502:  MOVF   01,W
01504:  ADDLW  25
01506:  MOVWF  01
01508:  MOVLW  00
0150A:  ADDWFC 03,F
0150C:  MOVFF  03,47E
01510:  CLRF   03
01512:  MOVF   x7B,W
01514:  ADDLW  73
01516:  MOVWF  FE9
01518:  MOVLW  04
0151A:  ADDWFC 03,W
0151C:  MOVWF  FEA
0151E:  MOVFF  FEF,47F
01522:  MOVFF  47E,FEA
01526:  MOVFF  01,FE9
0152A:  MOVFF  47F,FEF
....................       } 
0152E:  INCF   x7B,F
01530:  BRA    14E4
....................  
....................       can_rspoint++; 
01532:  INCF   24,F
....................    } 
....................    else 
01534:  BRA    164C
01536:  MOVLB  0
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
01538:  MOVLW  04
0153A:  MOVLB  4
0153C:  MOVWF  x7E
0153E:  MOVLW  73
01540:  MOVWF  x7D
.................... } 
*
0164C:  MOVLB  0
0164E:  RETLW  00
....................  
....................  
.................... int1 can_Pop ( int32 & rx_id, int * buffer, int & rx_len, int & rx_stat ) 
.................... { 
....................    int i; 
....................  
....................    if(can_rspoint==CAN_RECEIVE_STACK_SIZE) 
....................       can_rspoint--; 
....................  
....................    if(can_rspoint!=-1) 
....................    { 
....................       rx_id=make32(can_rstack[can_rspoint][0], 
....................                   can_rstack[can_rspoint][1], 
....................                   can_rstack[can_rspoint][2], 
....................                   can_rstack[can_rspoint][3]); 
....................  
....................       rx_len=can_rstack[can_rspoint][4]; 
....................       rx_stat=can_rstack[can_rspoint][5]; 
....................  
....................       for(i=0;i<rx_len;i++) 
....................       { 
....................          buffer[i]=can_rstack[can_rspoint][i+6]; 
....................       } 
....................       can_rspoint--; 
....................  
....................       return TRUE; 
....................    }    
....................    else 
....................    return FALSE; 
.................... } 
....................  
.................... void canTransmit ( ) 
.................... { 
....................    int32 tx_id; 
....................    int8  tx_length; 
....................    int8  tx_priority; 
....................    int8  tx_buffer[8]; 
....................    int1  tx_extendedID; 
....................    int1  tx_emptyframe; 
....................    int8  i; 
....................  
....................    if(can_tspoint==CAN_TRANSMIT_STACK_SIZE) 
*
01866:  MOVF   xB2,W
01868:  SUBLW  0A
0186A:  BNZ   186E
....................    { 
....................       can_tspoint--; 
0186C:  DECF   xB2,F
....................    } 
....................  
....................    if(can_tspoint!=-1) 
0186E:  MOVF   xB2,W
01870:  SUBLW  FF
01872:  BTFSC  FD8.2
01874:  BRA    1A7C
....................    { 
....................  
....................       tx_id=make32(can_tstack[can_tspoint][0], 
....................                   can_tstack[can_tspoint][1], 
....................                   can_tstack[can_tspoint][2], 
....................                   can_tstack[can_tspoint][3]); 
01876:  MOVF   xB2,W
01878:  MULLW  0D
0187A:  MOVF   FF3,W
0187C:  MOVLB  4
0187E:  CLRF   x7E
01880:  MOVWF  x7D
01882:  MOVLW  B3
01884:  ADDWF  x7D,W
01886:  MOVWF  FE9
01888:  MOVLW  00
0188A:  ADDWFC x7E,W
0188C:  MOVWF  FEA
0188E:  MOVFF  FEF,47D
01892:  MOVLB  0
01894:  MOVF   xB2,W
01896:  MULLW  0D
01898:  MOVF   FF3,W
0189A:  MOVLB  4
0189C:  CLRF   x7F
0189E:  MOVWF  x7E
018A0:  MOVLW  01
018A2:  ADDWF  x7E,W
018A4:  MOVWF  01
018A6:  MOVLW  00
018A8:  ADDWFC x7F,W
018AA:  MOVWF  03
018AC:  MOVF   01,W
018AE:  ADDLW  B3
018B0:  MOVWF  FE9
018B2:  MOVLW  00
018B4:  ADDWFC 03,W
018B6:  MOVWF  FEA
018B8:  MOVFF  FEF,47E
018BC:  MOVLB  0
018BE:  MOVF   xB2,W
018C0:  MULLW  0D
018C2:  MOVF   FF3,W
018C4:  MOVLB  4
018C6:  CLRF   x80
018C8:  MOVWF  x7F
018CA:  MOVLW  02
018CC:  ADDWF  x7F,W
018CE:  MOVWF  01
018D0:  MOVLW  00
018D2:  ADDWFC x80,W
018D4:  MOVWF  03
018D6:  MOVF   01,W
018D8:  ADDLW  B3
018DA:  MOVWF  FE9
018DC:  MOVLW  00
018DE:  ADDWFC 03,W
018E0:  MOVWF  FEA
018E2:  MOVFF  FEF,47F
018E6:  MOVLB  0
018E8:  MOVF   xB2,W
018EA:  MULLW  0D
018EC:  MOVF   FF3,W
018EE:  MOVLB  4
018F0:  CLRF   x81
018F2:  MOVWF  x80
018F4:  MOVLW  03
018F6:  ADDWF  x80,W
018F8:  MOVWF  01
018FA:  MOVLW  00
018FC:  ADDWFC x81,W
018FE:  MOVWF  03
01900:  MOVF   01,W
01902:  ADDLW  B3
01904:  MOVWF  FE9
01906:  MOVLW  00
01908:  ADDWFC 03,W
0190A:  MOVWF  FEA
0190C:  MOVFF  FEF,480
01910:  MOVFF  47D,470
01914:  MOVFF  47E,46F
01918:  MOVFF  47F,46E
0191C:  MOVFF  480,46D
....................  
....................       tx_length=can_tstack[can_tspoint][12]>>4; 
01920:  MOVLB  0
01922:  MOVF   xB2,W
01924:  MULLW  0D
01926:  MOVF   FF3,W
01928:  MOVLB  4
0192A:  CLRF   x7E
0192C:  MOVWF  x7D
0192E:  MOVLW  0C
01930:  ADDWF  x7D,W
01932:  MOVWF  01
01934:  MOVLW  00
01936:  ADDWFC x7E,W
01938:  MOVWF  03
0193A:  MOVF   01,W
0193C:  ADDLW  B3
0193E:  MOVWF  FE9
01940:  MOVLW  00
01942:  ADDWFC 03,W
01944:  MOVWF  FEA
01946:  SWAPF  FEF,W
01948:  MOVWF  x71
0194A:  MOVLW  0F
0194C:  ANDWF  x71,F
....................       tx_priority=(can_tstack[can_tspoint][12]&0x0c)>>2; 
0194E:  MOVLB  0
01950:  MOVF   xB2,W
01952:  MULLW  0D
01954:  MOVF   FF3,W
01956:  MOVLB  4
01958:  CLRF   x7E
0195A:  MOVWF  x7D
0195C:  MOVLW  0C
0195E:  ADDWF  x7D,W
01960:  MOVWF  01
01962:  MOVLW  00
01964:  ADDWFC x7E,W
01966:  MOVWF  03
01968:  MOVF   01,W
0196A:  ADDLW  B3
0196C:  MOVWF  FE9
0196E:  MOVLW  00
01970:  ADDWFC 03,W
01972:  MOVWF  FEA
01974:  MOVF   FEF,W
01976:  ANDLW  0C
01978:  MOVWF  00
0197A:  RRCF   00,W
0197C:  MOVWF  x72
0197E:  RRCF   x72,F
01980:  MOVLW  3F
01982:  ANDWF  x72,F
....................       tx_extendedID=bit_test(can_tstack[can_tspoint][12],1); 
01984:  MOVLB  0
01986:  MOVF   xB2,W
01988:  MULLW  0D
0198A:  MOVF   FF3,W
0198C:  MOVLB  4
0198E:  CLRF   x7E
01990:  MOVWF  x7D
01992:  MOVLW  0C
01994:  ADDWF  x7D,W
01996:  MOVWF  01
01998:  MOVLW  00
0199A:  ADDWFC x7E,W
0199C:  MOVWF  03
0199E:  MOVF   01,W
019A0:  ADDLW  B3
019A2:  MOVWF  FE9
019A4:  MOVLW  00
019A6:  ADDWFC 03,W
019A8:  MOVWF  FEA
019AA:  MOVFF  FEF,47D
019AE:  BCF    x7B.0
019B0:  BTFSC  x7D.1
019B2:  BSF    x7B.0
....................       tx_emptyframe=bit_test(can_tstack[can_tspoint][12],0); 
019B4:  MOVLB  0
019B6:  MOVF   xB2,W
019B8:  MULLW  0D
019BA:  MOVF   FF3,W
019BC:  MOVLB  4
019BE:  CLRF   x7E
019C0:  MOVWF  x7D
019C2:  MOVLW  0C
019C4:  ADDWF  x7D,W
019C6:  MOVWF  01
019C8:  MOVLW  00
019CA:  ADDWFC x7E,W
019CC:  MOVWF  03
019CE:  MOVF   01,W
019D0:  ADDLW  B3
019D2:  MOVWF  FE9
019D4:  MOVLW  00
019D6:  ADDWFC 03,W
019D8:  MOVWF  FEA
019DA:  MOVFF  FEF,47D
019DE:  BCF    x7B.1
019E0:  BTFSC  x7D.0
019E2:  BSF    x7B.1
....................  
....................       for(i=0;i<tx_length;i++) 
019E4:  CLRF   x7C
019E6:  MOVF   x71,W
019E8:  SUBWF  x7C,W
019EA:  BC    1A3C
....................       { 
....................          tx_buffer[i]=can_tstack[can_tspoint][i+4]; 
019EC:  CLRF   03
019EE:  MOVF   x7C,W
019F0:  ADDLW  73
019F2:  MOVWF  01
019F4:  MOVLW  04
019F6:  ADDWFC 03,F
019F8:  MOVFF  01,47D
019FC:  MOVFF  03,47E
01A00:  MOVLB  0
01A02:  MOVF   xB2,W
01A04:  MULLW  0D
01A06:  MOVF   FF3,W
01A08:  MOVLB  4
01A0A:  CLRF   x80
01A0C:  MOVWF  x7F
01A0E:  MOVLW  04
01A10:  ADDWF  x7C,W
01A12:  CLRF   03
01A14:  ADDWF  x7F,W
01A16:  MOVWF  01
01A18:  MOVF   x80,W
01A1A:  ADDWFC 03,F
01A1C:  MOVF   01,W
01A1E:  ADDLW  B3
01A20:  MOVWF  FE9
01A22:  MOVLW  00
01A24:  ADDWFC 03,W
01A26:  MOVWF  FEA
01A28:  MOVFF  FEF,47F
01A2C:  MOVFF  47E,FEA
01A30:  MOVFF  47D,FE9
01A34:  MOVFF  47F,FEF
....................       } 
01A38:  INCF   x7C,F
01A3A:  BRA    19E6
....................  
....................       can_putd(tx_id,tx_buffer,tx_length,tx_priority,tx_extendedID,tx_emptyframe); 
01A3C:  MOVLW  00
01A3E:  BTFSC  x7B.0
01A40:  MOVLW  01
01A42:  MOVWF  x7D
01A44:  MOVLW  00
01A46:  BTFSC  x7B.1
01A48:  MOVLW  01
01A4A:  MOVWF  x7E
01A4C:  MOVFF  470,482
01A50:  MOVFF  46F,481
01A54:  MOVFF  46E,480
01A58:  MOVFF  46D,47F
01A5C:  MOVLW  04
01A5E:  MOVWF  x84
01A60:  MOVLW  73
01A62:  MOVWF  x83
01A64:  MOVFF  471,485
01A68:  MOVFF  472,486
01A6C:  MOVFF  47D,487
01A70:  MOVFF  47E,488
01A74:  MOVLB  0
01A76:  BRA    1794
....................  
....................       can_tspoint--; 
01A78:  DECF   xB2,F
....................    } 
....................    else 
01A7A:  BRA    1A7E
....................       return; 
01A7C:  BRA    1A7E
.................... } 
01A7E:  RETLW  00
....................  
....................  
.................... int1 can_push (int32 tx_id, int8 * tx_buffer, int8 tx_length, int8 tx_priority, int1 tx_extendedID, int1 tx_emptyframe) 
.................... { 
....................    int8  i; 
....................    if(can_tspoint==-1) 
....................       can_tspoint++; 
....................  
....................    if(can_tspoint < CAN_TRANSMIT_STACK_SIZE) 
....................    { 
....................       can_tstack[can_tspoint][0]=make8(tx_id,3); 
....................       can_tstack[can_tspoint][1]=make8(tx_id,2); 
....................       can_tstack[can_tspoint][2]=make8(tx_id,1); 
....................       can_tstack[can_tspoint][3]=make8(tx_id,0); 
....................  
....................       for(i=0;i<tx_length;i++) 
....................       { 
....................          can_tstack[can_tspoint][i+4]=tx_buffer[i]; 
....................       } 
....................  
....................       can_tstack[can_tspoint][12]=(tx_length<<4)|(tx_priority<<2)|((int8)tx_extendedID<<1)|((int8)tx_emptyframe); 
....................  
....................       can_tspoint++; 
....................    } 
.................... } 
....................  
.................... int temp; 
.................... #include "struct_and_enums.c" 
....................  
.................... enum switch_outstate {on, off, dimming, dimmed, maxed}; 
.................... enum switch_direction {up, down}; 
.................... enum switch_state {button_pressed, button_depressed}; 
.................... enum output_type {_on_off, dimmer,shutter}; 
.................... enum output_state {_on, _off, _dimmed}; 
.................... enum timer_type {time_on, time_off, periodic_on}; 
.................... enum input_type {dimmer_switch,on_off_switch,button_switch,timer,none}; 
....................  
.................... void dimmer_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input); 
.................... typedef struct data_point_out 
.................... { 
....................    unsigned int adress; 
....................    unsigned int value; 
....................    int1 needs_update; 
.................... }; 
.................... typedef struct data_point_in 
.................... { 
....................    unsigned int adress[8]; 
....................    unsigned int value; 
....................    int1 needs_update; 
.................... }; 
.................... ///////////////////////INPUTS////////////////////////////////////// 
.................... typedef struct dimmer_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out dim_level; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    unsigned int current_level; 
....................    int32  timer; 
....................    switch_state current_state; 
....................    switch_state previous_state; 
....................    switch_direction direction; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
.................... typedef struct on_off_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................     switch_state current_state; 
....................    switch_state previous_state; 
....................    int32  timer; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
....................  
.................... typedef struct button_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    switch_state current_state; 
....................    switch_state previous_state; 
....................    int32  timer; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
....................  
.................... typedef struct timer 
.................... { 
....................    timer_type type; 
....................    int32 timeToAct; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    int32  timer; 
.................... }; 
.................... union input 
.................... { 
....................    struct on_off_switch; 
....................    struct dimmer_switch; 
....................    struct timer; 
....................    struct button_switch; 
.................... }; 
....................  
.................... typedef struct inputs 
.................... { 
....................    enum input_type type; 
....................    union input device; 
.................... }; 
.................... ///////////////////////OUTPUTS////////////////////////////////////// 
.................... struct light 
.................... { 
....................    struct data_point_in on; 
....................    struct data_point_in off; 
....................    struct data_point_in dim_value; 
....................    enum output_state out_state; 
....................    unsigned int output_pin; 
....................    int internal_order; 
....................    int1  needs_update; 
.................... }; 
.................... struct oNoFF 
.................... { 
....................    struct data_point_in on; 
....................    struct data_point_in off; 
....................    unsigned int output_pin; 
....................    int1  needs_update; 
.................... }; 
.................... union output 
.................... { 
....................    struct light; 
....................    struct oNoFF; 
.................... }; 
....................  
.................... typedef struct outputs 
.................... { 
....................    enum output_type type; 
....................    union output device; 
.................... }; 
....................  
.................... typedef struct devices 
.................... { 
....................       unsigned int numberOfInputs; 
....................       unsigned int numberOfOutputs; 
....................       struct inputs myinputs[10]; 
....................       struct outputs myoutputs[10]; 
.................... }devicestype; 
....................  
.................... devicestype mydevices; 
....................  
.................... void copy_array(unsigned int *origin,struct data_point_in* destination , unsigned int n_elements) 
.................... { 
....................    int x; 
....................    for (x=0;x<n_elements;++x) 
*
01EFA:  MOVLB  4
01EFC:  CLRF   x49
01EFE:  MOVF   x48,W
01F00:  SUBWF  x49,W
01F02:  BC    1F36
....................    { 
....................       ((struct data_point_in*)destination)->adress[x]=*origin; 
01F04:  CLRF   03
01F06:  MOVF   x49,W
01F08:  ADDWF  x46,W
01F0A:  MOVWF  01
01F0C:  MOVF   x47,W
01F0E:  ADDWFC 03,F
01F10:  MOVFF  03,44B
01F14:  MOVFF  444,FE9
01F18:  MOVFF  445,FEA
01F1C:  MOVFF  FEF,44C
01F20:  MOVFF  44B,FEA
01F24:  MOVFF  01,FE9
01F28:  MOVFF  44C,FEF
....................       ++origin; 
01F2C:  INCF   x44,F
01F2E:  BTFSC  FD8.2
01F30:  INCF   x45,F
....................    } 
01F32:  INCF   x49,F
01F34:  BRA    1EFE
.................... } 
01F36:  MOVLB  0
01F38:  RETLW  00
....................  
....................  
.................... ///////INPUTS INITIALIZATION////////////////////////////////////////////////// 
.................... void dimmer_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input,unsigned int real_button) 
.................... { 
....................       input->type=dimmer_switch; 
*
01D12:  MOVLB  4
01D14:  MOVFF  422,FE9
01D18:  MOVFF  423,FEA
01D1C:  CLRF   FEF
....................       ((struct dimmer_switch)input->device).dim_level.adress=dim_adr; 
01D1E:  MOVLW  01
01D20:  ADDWF  x22,W
01D22:  MOVWF  01
01D24:  MOVLW  00
01D26:  ADDWFC x23,W
01D28:  MOVFF  01,FE9
01D2C:  MOVWF  FEA
01D2E:  MOVFF  41F,FEF
....................       ((struct dimmer_switch)input->device).on.adress=on_adr; 
01D32:  MOVLW  01
01D34:  ADDWF  x22,W
01D36:  MOVWF  01
01D38:  MOVLW  00
01D3A:  ADDWFC x23,W
01D3C:  MOVWF  03
01D3E:  MOVF   01,W
01D40:  ADDLW  03
01D42:  MOVWF  FE9
01D44:  MOVLW  00
01D46:  ADDWFC 03,W
01D48:  MOVWF  FEA
01D4A:  MOVFF  420,FEF
....................       ((struct dimmer_switch)input->device).off.adress=off_adr; 
01D4E:  MOVLW  01
01D50:  ADDWF  x22,W
01D52:  MOVWF  01
01D54:  MOVLW  00
01D56:  ADDWFC x23,W
01D58:  MOVWF  03
01D5A:  MOVF   01,W
01D5C:  ADDLW  06
01D5E:  MOVWF  FE9
01D60:  MOVLW  00
01D62:  ADDWFC 03,W
01D64:  MOVWF  FEA
01D66:  MOVFF  421,FEF
....................       ((struct dimmer_switch)input->device).previous_state=button_depressed; 
01D6A:  MOVLW  01
01D6C:  ADDWF  x22,W
01D6E:  MOVWF  01
01D70:  MOVLW  00
01D72:  ADDWFC x23,W
01D74:  MOVWF  03
01D76:  MOVF   01,W
01D78:  ADDLW  0E
01D7A:  MOVWF  FE9
01D7C:  MOVLW  00
01D7E:  ADDWFC 03,W
01D80:  MOVWF  FEA
01D82:  BSF    FEF.1
....................       ((struct dimmer_switch)input->device).outstate=off; 
01D84:  MOVLW  01
01D86:  ADDWF  x22,W
01D88:  MOVWF  01
01D8A:  MOVLW  00
01D8C:  ADDWFC x23,W
01D8E:  MOVWF  03
01D90:  MOVF   01,W
01D92:  ADDLW  0F
01D94:  MOVWF  FE9
01D96:  MOVLW  00
01D98:  ADDWFC 03,W
01D9A:  MOVWF  FEA
01D9C:  MOVLW  01
01D9E:  MOVWF  FEF
....................       ((struct dimmer_switch)input->device).current_level=0; 
01DA0:  ADDWF  x22,W
01DA2:  MOVWF  01
01DA4:  MOVLW  00
01DA6:  ADDWFC x23,W
01DA8:  MOVWF  03
01DAA:  MOVF   01,W
01DAC:  ADDLW  09
01DAE:  MOVWF  FE9
01DB0:  MOVLW  00
01DB2:  ADDWFC 03,W
01DB4:  MOVWF  FEA
01DB6:  CLRF   FEF
....................       ((struct dimmer_switch)input->device).direction=up; 
01DB8:  MOVLW  01
01DBA:  ADDWF  x22,W
01DBC:  MOVWF  01
01DBE:  MOVLW  00
01DC0:  ADDWFC x23,W
01DC2:  MOVWF  03
01DC4:  MOVF   01,W
01DC6:  ADDLW  0E
01DC8:  MOVWF  FE9
01DCA:  MOVLW  00
01DCC:  ADDWFC 03,W
01DCE:  MOVWF  FEA
01DD0:  BCF    FEF.2
....................       ((struct dimmer_switch)input->device).dim_level.needs_update=0; 
01DD2:  MOVLW  01
01DD4:  ADDWF  x22,W
01DD6:  MOVWF  01
01DD8:  MOVLW  00
01DDA:  ADDWFC x23,W
01DDC:  MOVWF  03
01DDE:  MOVF   01,W
01DE0:  ADDLW  02
01DE2:  MOVWF  FE9
01DE4:  MOVLW  00
01DE6:  ADDWFC 03,W
01DE8:  MOVWF  FEA
01DEA:  BCF    FEF.0
....................       ((struct dimmer_switch)input->device).on.needs_update=0; 
01DEC:  MOVLW  01
01DEE:  ADDWF  x22,W
01DF0:  MOVWF  01
01DF2:  MOVLW  00
01DF4:  ADDWFC x23,W
01DF6:  MOVWF  03
01DF8:  MOVF   01,W
01DFA:  ADDLW  05
01DFC:  MOVWF  FE9
01DFE:  MOVLW  00
01E00:  ADDWFC 03,W
01E02:  MOVWF  FEA
01E04:  BCF    FEF.0
....................       ((struct dimmer_switch)input->device).off.needs_update=1; 
01E06:  MOVLW  01
01E08:  ADDWF  x22,W
01E0A:  MOVWF  01
01E0C:  MOVLW  00
01E0E:  ADDWFC x23,W
01E10:  MOVWF  03
01E12:  MOVF   01,W
01E14:  ADDLW  08
01E16:  MOVWF  FE9
01E18:  MOVLW  00
01E1A:  ADDWFC 03,W
01E1C:  MOVWF  FEA
01E1E:  BSF    FEF.0
....................       ((struct dimmer_switch)input->device).dim_level.value=0; 
01E20:  MOVLW  01
01E22:  ADDWF  x22,W
01E24:  MOVWF  01
01E26:  MOVLW  00
01E28:  ADDWFC x23,W
01E2A:  MOVWF  03
01E2C:  MOVF   01,W
01E2E:  ADDLW  01
01E30:  MOVWF  FE9
01E32:  MOVLW  00
01E34:  ADDWFC 03,W
01E36:  MOVWF  FEA
01E38:  CLRF   FEF
....................       ((struct dimmer_switch)input->device).on.value=0; 
01E3A:  MOVLW  01
01E3C:  ADDWF  x22,W
01E3E:  MOVWF  01
01E40:  MOVLW  00
01E42:  ADDWFC x23,W
01E44:  MOVWF  03
01E46:  MOVF   01,W
01E48:  ADDLW  04
01E4A:  MOVWF  FE9
01E4C:  MOVLW  00
01E4E:  ADDWFC 03,W
01E50:  MOVWF  FEA
01E52:  CLRF   FEF
....................       ((struct dimmer_switch)input->device).off.value=1; 
01E54:  MOVLW  01
01E56:  ADDWF  x22,W
01E58:  MOVWF  01
01E5A:  MOVLW  00
01E5C:  ADDWFC x23,W
01E5E:  MOVWF  03
01E60:  MOVF   01,W
01E62:  ADDLW  07
01E64:  MOVWF  FE9
01E66:  MOVLW  00
01E68:  ADDWFC 03,W
01E6A:  MOVWF  FEA
01E6C:  MOVLW  01
01E6E:  MOVWF  FEF
....................       ((struct dimmer_switch)input->device).realbutton=inputs[real_button]; 
01E70:  ADDWF  x22,W
01E72:  MOVWF  01
01E74:  MOVLW  00
01E76:  ADDWFC x23,W
01E78:  MOVWF  03
01E7A:  MOVF   01,W
01E7C:  ADDLW  10
01E7E:  MOVWF  01
01E80:  MOVLW  00
01E82:  ADDWFC 03,F
01E84:  MOVFF  03,428
01E88:  CLRF   03
01E8A:  MOVF   x24,W
01E8C:  ADDLW  1C
01E8E:  MOVWF  FE9
01E90:  MOVLW  00
01E92:  ADDWFC 03,W
01E94:  MOVWF  FEA
01E96:  MOVFF  FEF,429
01E9A:  MOVFF  428,FEA
01E9E:  MOVFF  01,FE9
01EA2:  MOVFF  429,FEF
....................       ((struct dimmer_switch)input->device).timer=0; 
01EA6:  MOVLW  01
01EA8:  ADDWF  x22,W
01EAA:  MOVWF  01
01EAC:  MOVLW  00
01EAE:  ADDWFC x23,W
01EB0:  MOVWF  03
01EB2:  MOVF   01,W
01EB4:  ADDLW  0A
01EB6:  MOVWF  FE9
01EB8:  MOVLW  00
01EBA:  ADDWFC 03,W
01EBC:  MOVWF  FEA
01EBE:  MOVF   FEE,F
01EC0:  MOVF   FEE,F
01EC2:  CLRF   FEC
01EC4:  MOVF   FED,F
01EC6:  CLRF   FEF
01EC8:  MOVF   FED,F
01ECA:  CLRF   FEF
01ECC:  MOVF   FED,F
01ECE:  CLRF   FEF
.................... } 
01ED0:  MOVLB  0
01ED2:  GOTO   1EF6 (RETURN)
.................... void on_off_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input,unsigned int real_button) 
.................... { 
....................       struct on_off_switch sw; 
....................       input->type=on_off_switch; 
....................       sw.on.adress=on_adr; 
....................       sw.off.adress=off_adr; 
....................       sw.previous_state=button_depressed; 
....................       sw.outstate=off; 
....................       sw.on.needs_update=0; 
....................       sw.off.needs_update=0; 
....................       sw.on.value=0; 
....................       sw.off.value=0; 
....................       sw.realbutton=inputs[real_button]; 
....................       input->device=sw; 
.................... } 
.................... void button_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input,unsigned int real_button) 
.................... { 
....................       struct button_switch sw; 
....................       input->type=button_switch; 
....................       sw.on.adress=on_adr; 
....................       sw.off.adress=off_adr; 
....................       sw.previous_state=button_depressed; 
....................       sw.outstate=off; 
....................       sw.on.needs_update=0; 
....................       sw.off.needs_update=0; 
....................       sw.on.value=0; 
....................       sw.off.value=0; 
....................       sw.realbutton=inputs[real_button]; 
....................       input->device=sw; 
.................... } 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... ///////OUTPUTS INITIALIZATION////////////////////////////////////////////////// 
.................... void dimmer_out_init(unsigned int *dim_adr,unsigned int *on_adr,unsigned int *off_adr,struct outputs* output,unsigned int output_pin) 
.................... { 
....................    ((struct outputs *)output)->type=dimmer; 
*
01F3A:  MOVLB  4
01F3C:  MOVFF  43D,FE9
01F40:  MOVFF  43E,FEA
01F44:  MOVLW  01
01F46:  MOVWF  FEF
....................    ((struct light)output->device).dim_value.needs_update=0; 
01F48:  ADDWF  x3D,W
01F4A:  MOVWF  01
01F4C:  MOVLW  00
01F4E:  ADDWFC x3E,W
01F50:  MOVWF  03
01F52:  MOVF   01,W
01F54:  ADDLW  1D
01F56:  MOVWF  FE9
01F58:  MOVLW  00
01F5A:  ADDWFC 03,W
01F5C:  MOVWF  FEA
01F5E:  BCF    FEF.0
....................    ((struct light)output->device).on.needs_update=0; 
01F60:  MOVLW  01
01F62:  ADDWF  x3D,W
01F64:  MOVWF  01
01F66:  MOVLW  00
01F68:  ADDWFC x3E,W
01F6A:  MOVWF  03
01F6C:  MOVF   01,W
01F6E:  ADDLW  09
01F70:  MOVWF  FE9
01F72:  MOVLW  00
01F74:  ADDWFC 03,W
01F76:  MOVWF  FEA
01F78:  BCF    FEF.0
....................    ((struct light)output->device).off.needs_update=0; 
01F7A:  MOVLW  01
01F7C:  ADDWF  x3D,W
01F7E:  MOVWF  01
01F80:  MOVLW  00
01F82:  ADDWFC x3E,W
01F84:  MOVWF  03
01F86:  MOVF   01,W
01F88:  ADDLW  13
01F8A:  MOVWF  FE9
01F8C:  MOVLW  00
01F8E:  ADDWFC 03,W
01F90:  MOVWF  FEA
01F92:  BCF    FEF.0
....................    ((struct light)output->device).dim_value.value=127; 
01F94:  MOVLW  01
01F96:  ADDWF  x3D,W
01F98:  MOVWF  01
01F9A:  MOVLW  00
01F9C:  ADDWFC x3E,W
01F9E:  MOVWF  03
01FA0:  MOVF   01,W
01FA2:  ADDLW  1C
01FA4:  MOVWF  FE9
01FA6:  MOVLW  00
01FA8:  ADDWFC 03,W
01FAA:  MOVWF  FEA
01FAC:  MOVLW  7F
01FAE:  MOVWF  FEF
....................    ((struct light)output->device).on.value=0; 
01FB0:  MOVLW  01
01FB2:  ADDWF  x3D,W
01FB4:  MOVWF  01
01FB6:  MOVLW  00
01FB8:  ADDWFC x3E,W
01FBA:  MOVWF  03
01FBC:  MOVF   01,W
01FBE:  ADDLW  08
01FC0:  MOVWF  FE9
01FC2:  MOVLW  00
01FC4:  ADDWFC 03,W
01FC6:  MOVWF  FEA
01FC8:  CLRF   FEF
....................    ((struct light)output->device).off.value=0; 
01FCA:  MOVLW  01
01FCC:  ADDWF  x3D,W
01FCE:  MOVWF  01
01FD0:  MOVLW  00
01FD2:  ADDWFC x3E,W
01FD4:  MOVWF  03
01FD6:  MOVF   01,W
01FD8:  ADDLW  12
01FDA:  MOVWF  FE9
01FDC:  MOVLW  00
01FDE:  ADDWFC 03,W
01FE0:  MOVWF  FEA
01FE2:  CLRF   FEF
....................    ((struct light)output->device).output_pin=output_pin; 
01FE4:  MOVLW  01
01FE6:  ADDWF  x3D,W
01FE8:  MOVWF  01
01FEA:  MOVLW  00
01FEC:  ADDWFC x3E,W
01FEE:  MOVWF  03
01FF0:  MOVF   01,W
01FF2:  ADDLW  1F
01FF4:  MOVWF  FE9
01FF6:  MOVLW  00
01FF8:  ADDWFC 03,W
01FFA:  MOVWF  FEA
01FFC:  MOVFF  43F,FEF
....................    copy_array(dim_adr,&((struct light)output->device).dim_value,8); 
02000:  MOVLW  01
02002:  ADDWF  x3D,W
02004:  MOVWF  01
02006:  MOVLW  00
02008:  ADDWFC x3E,W
0200A:  MOVWF  03
0200C:  MOVF   01,W
0200E:  ADDLW  14
02010:  MOVWF  01
02012:  MOVLW  00
02014:  ADDWFC 03,F
02016:  MOVFF  01,442
0201A:  MOVFF  03,443
0201E:  MOVFF  438,445
02022:  MOVFF  437,444
02026:  MOVFF  03,447
0202A:  MOVFF  01,446
0202E:  MOVLW  08
02030:  MOVWF  x48
02032:  MOVLB  0
02034:  RCALL  1EFA
....................    copy_array(on_adr,&((struct light)output->device).on,8); 
02036:  MOVLW  01
02038:  MOVLB  4
0203A:  ADDWF  x3D,W
0203C:  MOVWF  01
0203E:  MOVLW  00
02040:  ADDWFC x3E,W
02042:  MOVWF  03
02044:  MOVFF  01,442
02048:  MOVWF  x43
0204A:  MOVFF  43A,445
0204E:  MOVFF  439,444
02052:  MOVWF  x47
02054:  MOVFF  01,446
02058:  MOVLW  08
0205A:  MOVWF  x48
0205C:  MOVLB  0
0205E:  RCALL  1EFA
....................    copy_array(off_adr,&((struct light)output->device).off,8); 
02060:  MOVLW  01
02062:  MOVLB  4
02064:  ADDWF  x3D,W
02066:  MOVWF  01
02068:  MOVLW  00
0206A:  ADDWFC x3E,W
0206C:  MOVWF  03
0206E:  MOVF   01,W
02070:  ADDLW  0A
02072:  MOVWF  01
02074:  MOVLW  00
02076:  ADDWFC 03,F
02078:  MOVFF  01,442
0207C:  MOVFF  03,443
02080:  MOVFF  43C,445
02084:  MOVFF  43B,444
02088:  MOVFF  03,447
0208C:  MOVFF  01,446
02090:  MOVLW  08
02092:  MOVWF  x48
02094:  MOVLB  0
02096:  RCALL  1EFA
....................    ((struct light)output->device).out_state=_off; 
02098:  MOVLW  01
0209A:  MOVLB  4
0209C:  ADDWF  x3D,W
0209E:  MOVWF  01
020A0:  MOVLW  00
020A2:  ADDWFC x3E,W
020A4:  MOVWF  03
020A6:  MOVF   01,W
020A8:  ADDLW  1E
020AA:  MOVWF  FE9
020AC:  MOVLW  00
020AE:  ADDWFC 03,W
020B0:  MOVWF  FEA
020B2:  MOVLW  01
020B4:  MOVWF  FEF
.................... } 
020B6:  MOVLB  0
020B8:  GOTO   2130 (RETURN)
.................... void onOff_out_init(unsigned int *on_adr,unsigned int *off_adr,struct outputs* output,unsigned int output_pin) 
.................... { 
....................    ((struct outputs *)output)->type=_on_off; 
....................    ((struct oNoFF)output->device).on.needs_update=0; 
....................    ((struct oNoFF)output->device).off.needs_update=0; 
....................    ((struct oNoFF)output->device).on.value=0; 
....................    ((struct oNoFF)output->device).off.value=0; 
....................    ((struct oNoFF)output->device).output_pin=output_pin; 
....................    copy_array(on_adr,&((struct oNoFF)output->device).on,8); 
....................    copy_array(off_adr,&((struct oNoFF)output->device).off,8); 
.................... } 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void button_test() 
.................... {     mydevices.numberOfInputs=1; 
*
01ED6:  MOVLW  01
01ED8:  MOVLB  1
01EDA:  MOVWF  x3A
....................     //  struct dimmer_switch sw; 
....................     //  sw.dim_level.value=69; 
....................     //  mydevices.myinputs[0].device=sw; 
....................     //  printf("VALUE=%u\n\r",mydevices.myinputs[0].device.dim_level.value); 
....................     //  on_off_init(1,2,3,&mydevices.myinputs[0],0); 
....................     //button_init(1,2,3,&mydevices.myinputs[0],0); 
....................       dimmer_init(1,2,3,&mydevices.myinputs[0],0); 
01EDC:  MOVLB  4
01EDE:  MOVWF  x1F
01EE0:  MOVLW  02
01EE2:  MOVWF  x20
01EE4:  MOVLW  03
01EE6:  MOVWF  x21
01EE8:  MOVLW  01
01EEA:  MOVWF  x23
01EEC:  MOVLW  3C
01EEE:  MOVWF  x22
01EF0:  CLRF   x24
01EF2:  MOVLB  0
01EF4:  BRA    1D12
....................       //printf("VALUE=%u\n\r",mydevices.myinputs[0].device.dim_level.value); 
....................      // while(true){}; 
.................... } 
01EF6:  GOTO   427A (RETURN)
....................  
....................  
....................  
.................... #include "dimming_functions.c" 
.................... #define N_LUZES 16 //numero maximo de dimmers 
.................... int used_dimmers=0; 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
....................  
.................... int1 organizado;//flag que diz se os dimmings estao organizados 
.................... int1 actmat=0;//matriz em uso 
.................... int16 pointer;//apontador para matriz em uso 
.................... int vez;//indice da matriz de dimming corrente 
.................... int mnumluzes;//quantos valores de dimming diferentes temos 
.................... unsigned int16 dimmers_off_value=0; 
.................... unsigned int16 onoffsvalue=0xFFFF; 
.................... int ltlevel[N_LUZES]={10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10}; 
.................... int16 delays1[N_LUZES+1][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15}; 
.................... int16 delays2[N_LUZES+1][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15}; 
.................... const unsigned int16 light_pins[N_LUZES]={ 
.................... 0b1111111111101111,0b1111111111011111,0b1111111110111111,0b1111111101111111,0b1111111111110111,0b1111111111111011,0b1111111111111110,0b1111111111111101, 
.................... /*<........................................................................portD..................................................................................>*/ 
.................... 0b0111111111111111,0b1011111111111111,0b1101111111111111,0b1110111111111111,0b1111011111111111,0b1111101111111111,0b1111110111111111,0b1111111011111111}; 
.................... /*<.................................................................................portC.............................................................>*/ 
....................  
.................... unsigned int16 lights[N_LUZES]; 
.................... const long Matrizluz[128]={ 
.................... 38400,38731 , 38492 , 38253 , 38014 , 37775 , 37536 , 37297 , 37058 , 36819 , 36580 
.................... , 36341 , 36102 , 35863 , 35624 , 35385 , 35146 , 34907 , 34668 , 34429 , 34190 , 33951 
....................  , 33712 , 33473 , 33234 , 32995 , 32756 , 32517 , 32278 , 32039 , 31800 , 31561 , 31322 
....................  , 31083 , 30844 , 30605 , 30366 , 30127 , 29888 , 29649 , 29410 , 29171 , 28932 , 28693 
....................  , 28454 , 28215 , 27976 , 27737 , 27498 , 27259 , 27020 , 26781 , 26542 , 26303 , 26064 
....................  , 25825 , 25586 , 25347 , 25108 , 24869 , 24630 , 24391 , 24152 , 23913 , 23674 , 23435 
....................  , 23196 , 22957 , 22718 , 22479 , 22240 , 22001 , 21762 , 21523 , 21284 , 21045 , 20806 
....................  , 20567 , 20328 , 20089 , 19850 , 19611 , 19372 , 19133 , 18894 , 18655 , 18416 , 18177 
....................  , 17938 , 17699 , 17460 , 17221 , 16982 , 16743 , 16504 , 16265 , 16026 , 15787 , 15548 
....................  , 15309 , 15070 , 14831 , 14592 , 14353 , 14114 , 13875 , 13636 , 13397 , 13158 , 12919 
....................  , 12680 , 12441 , 12202 , 11963 , 11724 , 11485 , 11246 , 11007 , 10768 , 10529 , 10290 
....................  , 10051 , 9812 , 9573 , 9334 , 9095 , 8856 , 617 }; 
....................   
....................   
....................  #INLINE 
....................   INT16 fpointer(int ax,int ay) 
....................    { 
....................       int16 * p; 
....................       p=(pointer + 2* ax * 2 + 2*ay); 
*
00E4A:  BCF    FD8.0
00E4C:  RLCF   x6F,W
00E4E:  MOVWF  00
00E50:  BCF    FD8.0
00E52:  RLCF   00,F
00E54:  MOVF   00,W
00E56:  MOVLB  3
00E58:  ADDWF  x4F,W
00E5A:  MOVLB  4
00E5C:  MOVWF  x73
00E5E:  MOVLW  00
00E60:  MOVLB  3
00E62:  ADDWFC x50,W
00E64:  MOVLB  4
00E66:  MOVWF  x74
00E68:  BCF    FD8.0
00E6A:  RLCF   x70,W
00E6C:  ADDWF  x73,W
00E6E:  MOVWF  x71
00E70:  MOVLW  00
00E72:  ADDWFC x74,W
00E74:  MOVWF  x72
*
00EE2:  BCF    FD8.0
00EE4:  RLCF   x6F,W
00EE6:  MOVWF  00
00EE8:  BCF    FD8.0
00EEA:  RLCF   00,F
00EEC:  MOVF   00,W
00EEE:  MOVLB  3
00EF0:  ADDWF  x4F,W
00EF2:  MOVLB  4
00EF4:  MOVWF  x73
00EF6:  MOVLW  00
00EF8:  MOVLB  3
00EFA:  ADDWFC x50,W
00EFC:  MOVLB  4
00EFE:  MOVWF  x74
00F00:  BCF    FD8.0
00F02:  RLCF   x70,W
00F04:  ADDWF  x73,W
00F06:  MOVWF  x71
00F08:  MOVLW  00
00F0A:  ADDWFC x74,W
00F0C:  MOVWF  x72
*
00F6E:  BCF    FD8.0
00F70:  RLCF   x6F,W
00F72:  MOVWF  00
00F74:  BCF    FD8.0
00F76:  RLCF   00,F
00F78:  MOVF   00,W
00F7A:  MOVLB  3
00F7C:  ADDWF  x4F,W
00F7E:  MOVLB  4
00F80:  MOVWF  x73
00F82:  MOVLW  00
00F84:  MOVLB  3
00F86:  ADDWFC x50,W
00F88:  MOVLB  4
00F8A:  MOVWF  x74
00F8C:  BCF    FD8.0
00F8E:  RLCF   x70,W
00F90:  ADDWF  x73,W
00F92:  MOVWF  x71
00F94:  MOVLW  00
00F96:  ADDWFC x74,W
00F98:  MOVWF  x72
*
00FF6:  BCF    FD8.0
00FF8:  RLCF   x6F,W
00FFA:  MOVWF  00
00FFC:  BCF    FD8.0
00FFE:  RLCF   00,F
01000:  MOVF   00,W
01002:  MOVLB  3
01004:  ADDWF  x4F,W
01006:  MOVLB  4
01008:  MOVWF  x73
0100A:  MOVLW  00
0100C:  MOVLB  3
0100E:  ADDWFC x50,W
01010:  MOVLB  4
01012:  MOVWF  x74
01014:  BCF    FD8.0
01016:  RLCF   x70,W
01018:  ADDWF  x73,W
0101A:  MOVWF  x71
0101C:  MOVLW  00
0101E:  ADDWFC x74,W
01020:  MOVWF  x72
*
042BE:  BCF    FD8.0
042C0:  RLCF   x6F,W
042C2:  MOVWF  00
042C4:  BCF    FD8.0
042C6:  RLCF   00,F
042C8:  MOVF   00,W
042CA:  MOVLB  3
042CC:  ADDWF  x4F,W
042CE:  MOVLB  4
042D0:  MOVWF  x73
042D2:  MOVLW  00
042D4:  MOVLB  3
042D6:  ADDWFC x50,W
042D8:  MOVLB  4
042DA:  MOVWF  x74
042DC:  BCF    FD8.0
042DE:  RLCF   x70,W
042E0:  ADDWF  x73,W
042E2:  MOVWF  x71
042E4:  MOVLW  00
042E6:  ADDWFC x74,W
042E8:  MOVWF  x72
*
04338:  BCF    FD8.0
0433A:  RLCF   x6F,W
0433C:  MOVWF  00
0433E:  BCF    FD8.0
04340:  RLCF   00,F
04342:  MOVF   00,W
04344:  MOVLB  3
04346:  ADDWF  x4F,W
04348:  MOVLB  4
0434A:  MOVWF  x73
0434C:  MOVLW  00
0434E:  MOVLB  3
04350:  ADDWFC x50,W
04352:  MOVLB  4
04354:  MOVWF  x74
04356:  BCF    FD8.0
04358:  RLCF   x70,W
0435A:  ADDWF  x73,W
0435C:  MOVWF  x71
0435E:  MOVLW  00
04360:  ADDWFC x74,W
04362:  MOVWF  x72
*
04406:  BCF    FD8.0
04408:  RLCF   x6F,W
0440A:  MOVWF  00
0440C:  BCF    FD8.0
0440E:  RLCF   00,F
04410:  MOVF   00,W
04412:  MOVLB  3
04414:  ADDWF  x4F,W
04416:  MOVLB  4
04418:  MOVWF  x73
0441A:  MOVLW  00
0441C:  MOVLB  3
0441E:  ADDWFC x50,W
04420:  MOVLB  4
04422:  MOVWF  x74
04424:  BCF    FD8.0
04426:  RLCF   x70,W
04428:  ADDWF  x73,W
0442A:  MOVWF  x71
0442C:  MOVLW  00
0442E:  ADDWFC x74,W
04430:  MOVWF  x72
....................      RETURN *(int16*)(pointer + 2* ax * 2 + 2*ay); 
*
00E76:  BCF    FD8.0
00E78:  RLCF   x6F,W
00E7A:  MOVWF  00
00E7C:  BCF    FD8.0
00E7E:  RLCF   00,F
00E80:  MOVF   00,W
00E82:  MOVLB  3
00E84:  ADDWF  x4F,W
00E86:  MOVLB  4
00E88:  MOVWF  x73
00E8A:  MOVLW  00
00E8C:  MOVLB  3
00E8E:  ADDWFC x50,W
00E90:  MOVLB  4
00E92:  MOVWF  x74
00E94:  BCF    FD8.0
00E96:  RLCF   x70,W
00E98:  ADDWF  x73,W
00E9A:  MOVWF  01
00E9C:  MOVLW  00
00E9E:  ADDWFC x74,W
00EA0:  MOVWF  03
00EA2:  MOVFF  01,FE9
00EA6:  MOVWF  FEA
00EA8:  MOVFF  FEF,01
00EAC:  INCF   FE9,F
00EAE:  MOVF   FEF,W
00EB0:  DECF   FE9,F
00EB2:  MOVWF  02
*
00F0E:  BCF    FD8.0
00F10:  RLCF   x6F,W
00F12:  MOVWF  00
00F14:  BCF    FD8.0
00F16:  RLCF   00,F
00F18:  MOVF   00,W
00F1A:  MOVLB  3
00F1C:  ADDWF  x4F,W
00F1E:  MOVLB  4
00F20:  MOVWF  x73
00F22:  MOVLW  00
00F24:  MOVLB  3
00F26:  ADDWFC x50,W
00F28:  MOVLB  4
00F2A:  MOVWF  x74
00F2C:  BCF    FD8.0
00F2E:  RLCF   x70,W
00F30:  ADDWF  x73,W
00F32:  MOVWF  01
00F34:  MOVLW  00
00F36:  ADDWFC x74,W
00F38:  MOVWF  03
00F3A:  MOVFF  01,FE9
00F3E:  MOVWF  FEA
00F40:  MOVFF  FEF,01
00F44:  INCF   FE9,F
00F46:  MOVF   FEF,W
00F48:  DECF   FE9,F
00F4A:  MOVWF  02
*
00F9A:  BCF    FD8.0
00F9C:  RLCF   x6F,W
00F9E:  MOVWF  00
00FA0:  BCF    FD8.0
00FA2:  RLCF   00,F
00FA4:  MOVF   00,W
00FA6:  MOVLB  3
00FA8:  ADDWF  x4F,W
00FAA:  MOVLB  4
00FAC:  MOVWF  x73
00FAE:  MOVLW  00
00FB0:  MOVLB  3
00FB2:  ADDWFC x50,W
00FB4:  MOVLB  4
00FB6:  MOVWF  x74
00FB8:  BCF    FD8.0
00FBA:  RLCF   x70,W
00FBC:  ADDWF  x73,W
00FBE:  MOVWF  01
00FC0:  MOVLW  00
00FC2:  ADDWFC x74,W
00FC4:  MOVWF  03
00FC6:  MOVFF  01,FE9
00FCA:  MOVWF  FEA
00FCC:  MOVFF  FEF,01
00FD0:  INCF   FE9,F
00FD2:  MOVF   FEF,W
00FD4:  DECF   FE9,F
00FD6:  MOVWF  02
*
01022:  BCF    FD8.0
01024:  RLCF   x6F,W
01026:  MOVWF  00
01028:  BCF    FD8.0
0102A:  RLCF   00,F
0102C:  MOVF   00,W
0102E:  MOVLB  3
01030:  ADDWF  x4F,W
01032:  MOVLB  4
01034:  MOVWF  x73
01036:  MOVLW  00
01038:  MOVLB  3
0103A:  ADDWFC x50,W
0103C:  MOVLB  4
0103E:  MOVWF  x74
01040:  BCF    FD8.0
01042:  RLCF   x70,W
01044:  ADDWF  x73,W
01046:  MOVWF  01
01048:  MOVLW  00
0104A:  ADDWFC x74,W
0104C:  MOVWF  03
0104E:  MOVFF  01,FE9
01052:  MOVWF  FEA
01054:  MOVFF  FEF,01
01058:  INCF   FE9,F
0105A:  MOVF   FEF,W
0105C:  DECF   FE9,F
0105E:  MOVWF  02
*
042EA:  BCF    FD8.0
042EC:  RLCF   x6F,W
042EE:  MOVWF  00
042F0:  BCF    FD8.0
042F2:  RLCF   00,F
042F4:  MOVF   00,W
042F6:  MOVLB  3
042F8:  ADDWF  x4F,W
042FA:  MOVLB  4
042FC:  MOVWF  x73
042FE:  MOVLW  00
04300:  MOVLB  3
04302:  ADDWFC x50,W
04304:  MOVLB  4
04306:  MOVWF  x74
04308:  BCF    FD8.0
0430A:  RLCF   x70,W
0430C:  ADDWF  x73,W
0430E:  MOVWF  01
04310:  MOVLW  00
04312:  ADDWFC x74,W
04314:  MOVWF  03
04316:  MOVFF  01,FE9
0431A:  MOVWF  FEA
0431C:  MOVFF  FEF,01
04320:  INCF   FE9,F
04322:  MOVF   FEF,W
04324:  DECF   FE9,F
04326:  MOVWF  02
*
04364:  BCF    FD8.0
04366:  RLCF   x6F,W
04368:  MOVWF  00
0436A:  BCF    FD8.0
0436C:  RLCF   00,F
0436E:  MOVF   00,W
04370:  MOVLB  3
04372:  ADDWF  x4F,W
04374:  MOVLB  4
04376:  MOVWF  x73
04378:  MOVLW  00
0437A:  MOVLB  3
0437C:  ADDWFC x50,W
0437E:  MOVLB  4
04380:  MOVWF  x74
04382:  BCF    FD8.0
04384:  RLCF   x70,W
04386:  ADDWF  x73,W
04388:  MOVWF  01
0438A:  MOVLW  00
0438C:  ADDWFC x74,W
0438E:  MOVWF  03
04390:  MOVFF  01,FE9
04394:  MOVWF  FEA
04396:  MOVFF  FEF,01
0439A:  INCF   FE9,F
0439C:  MOVF   FEF,W
0439E:  DECF   FE9,F
043A0:  MOVWF  02
*
04432:  BCF    FD8.0
04434:  RLCF   x6F,W
04436:  MOVWF  00
04438:  BCF    FD8.0
0443A:  RLCF   00,F
0443C:  MOVF   00,W
0443E:  MOVLB  3
04440:  ADDWF  x4F,W
04442:  MOVLB  4
04444:  MOVWF  x73
04446:  MOVLW  00
04448:  MOVLB  3
0444A:  ADDWFC x50,W
0444C:  MOVLB  4
0444E:  MOVWF  x74
04450:  BCF    FD8.0
04452:  RLCF   x70,W
04454:  ADDWF  x73,W
04456:  MOVWF  01
04458:  MOVLW  00
0445A:  ADDWFC x74,W
0445C:  MOVWF  03
0445E:  MOVFF  01,FE9
04462:  MOVWF  FEA
04464:  MOVFF  FEF,01
04468:  INCF   FE9,F
0446A:  MOVF   FEF,W
0446C:  DECF   FE9,F
0446E:  MOVWF  02
....................    } 
....................  
....................    
....................   VOID org(void) 
....................   { 
*
02134:  MOVLB  4
02136:  BSF    x62.0
....................      INT16 tempd[N_LUZES][2]; 
....................      INT numluzes; 
....................      INT1 again = 1; 
....................      INT fa; 
....................      INT16 fl; 
....................      INT afa; 
....................      FOR(fa = 0;fa < used_dimmers;++fa) 
02138:  CLRF   x63
0213A:  MOVLB  3
0213C:  MOVF   x4E,W
0213E:  MOVLB  4
02140:  SUBWF  x63,W
02142:  BC    21D2
....................      { 
....................         tempd[fa][0] = ltlevel[fa];//tempd[x][0] fica com o valor de dimming 0...127 
02144:  MOVF   x63,W
02146:  MULLW  04
02148:  MOVF   FF3,W
0214A:  CLRF   x68
0214C:  MOVWF  x67
0214E:  MOVLW  21
02150:  ADDWF  x67,W
02152:  MOVWF  01
02154:  MOVLW  04
02156:  ADDWFC x68,W
02158:  MOVWF  03
0215A:  MOVWF  x68
0215C:  CLRF   03
0215E:  MOVF   x63,W
02160:  ADDLW  57
02162:  MOVWF  FE9
02164:  MOVLW  03
02166:  ADDWFC 03,W
02168:  MOVWF  FEA
0216A:  MOVF   FEF,W
0216C:  CLRF   03
0216E:  MOVFF  468,FEA
02172:  MOVFF  01,FE9
02176:  MOVFF  03,FEC
0217A:  MOVF   FED,F
0217C:  MOVWF  FEF
....................         tempd[fa][1] = lights[fa];//tempd[x][1] fica com o valor binario DO porto de saida 
0217E:  MOVF   x63,W
02180:  MULLW  04
02182:  MOVF   FF3,W
02184:  CLRF   x68
02186:  MOVWF  x67
02188:  MOVLW  02
0218A:  ADDWF  x67,W
0218C:  MOVWF  01
0218E:  MOVLW  00
02190:  ADDWFC x68,W
02192:  MOVWF  03
02194:  MOVF   01,W
02196:  ADDLW  21
02198:  MOVWF  01
0219A:  MOVLW  04
0219C:  ADDWFC 03,F
0219E:  MOVFF  03,468
021A2:  BCF    FD8.0
021A4:  RLCF   x63,W
021A6:  CLRF   03
021A8:  ADDLW  EF
021AA:  MOVWF  FE9
021AC:  MOVLW  03
021AE:  ADDWFC 03,W
021B0:  MOVWF  FEA
021B2:  MOVFF  FEC,03
021B6:  MOVF   FED,F
021B8:  MOVFF  FEF,469
021BC:  MOVFF  468,FEA
021C0:  MOVFF  01,FE9
021C4:  MOVFF  03,FEC
021C8:  MOVF   FED,F
021CA:  MOVFF  469,FEF
....................      } 
021CE:  INCF   x63,F
021D0:  BRA    213A
....................  
....................      WHILE(again) 
....................      { 
021D2:  BTFSS  x62.0
021D4:  BRA    239C
....................         again = 0; 
021D6:  BCF    x62.0
....................         FOR(fa = 0;fa < used_dimmers-1;++fa) 
021D8:  CLRF   x63
021DA:  MOVLW  01
021DC:  MOVLB  3
021DE:  SUBWF  x4E,W
021E0:  MOVLB  4
021E2:  SUBWF  x63,W
021E4:  BTFSC  FD8.0
021E6:  BRA    239A
....................         { 
....................            //coloca valores por ordem tempd[0][0] o maior 
....................            IF(tempd[fa][0] < tempd[fa + 1][0]) 
021E8:  MOVF   x63,W
021EA:  MULLW  04
021EC:  MOVF   FF3,W
021EE:  CLRF   x68
021F0:  MOVWF  x67
021F2:  MOVLW  21
021F4:  ADDWF  x67,W
021F6:  MOVWF  FE9
021F8:  MOVLW  04
021FA:  ADDWFC x68,W
021FC:  MOVWF  FEA
021FE:  MOVFF  FEC,468
02202:  MOVF   FED,F
02204:  MOVFF  FEF,467
02208:  MOVLW  01
0220A:  ADDWF  x63,W
0220C:  MULLW  04
0220E:  MOVF   FF3,W
02210:  CLRF   x6A
02212:  MOVWF  x69
02214:  MOVLW  21
02216:  ADDWF  x69,W
02218:  MOVWF  FE9
0221A:  MOVLW  04
0221C:  ADDWFC x6A,W
0221E:  MOVWF  FEA
02220:  MOVFF  FEC,03
02224:  MOVF   FED,F
02226:  MOVFF  FEF,01
0222A:  MOVF   x68,W
0222C:  SUBWF  03,W
0222E:  BTFSS  FD8.0
02230:  BRA    2396
02232:  BNZ   223C
02234:  MOVF   01,W
02236:  SUBWF  x67,W
02238:  BTFSC  FD8.0
0223A:  BRA    2396
....................            { 
....................               again = 1; 
0223C:  BSF    x62.0
....................               fl = tempd[fa][0]; 
0223E:  MOVF   x63,W
02240:  MULLW  04
02242:  MOVF   FF3,W
02244:  CLRF   x68
02246:  MOVWF  x67
02248:  MOVLW  21
0224A:  ADDWF  x67,W
0224C:  MOVWF  FE9
0224E:  MOVLW  04
02250:  ADDWFC x68,W
02252:  MOVWF  FEA
02254:  MOVFF  FEC,03
02258:  MOVF   FED,F
0225A:  MOVFF  FEF,464
0225E:  MOVFF  03,465
....................               tempd[fa][0] = tempd[fa + 1][0]; 
02262:  MOVF   x63,W
02264:  MULLW  04
02266:  MOVF   FF3,W
02268:  CLRF   x68
0226A:  MOVWF  x67
0226C:  MOVLW  21
0226E:  ADDWF  x67,W
02270:  MOVWF  01
02272:  MOVLW  04
02274:  ADDWFC x68,W
02276:  MOVWF  03
02278:  MOVWF  x68
0227A:  MOVLW  01
0227C:  ADDWF  x63,W
0227E:  MULLW  04
02280:  MOVF   FF3,W
02282:  CLRF   x6A
02284:  MOVWF  x69
02286:  MOVLW  21
02288:  ADDWF  x69,W
0228A:  MOVWF  FE9
0228C:  MOVLW  04
0228E:  ADDWFC x6A,W
02290:  MOVWF  FEA
02292:  MOVFF  FEC,03
02296:  MOVF   FED,F
02298:  MOVFF  FEF,469
0229C:  MOVFF  468,FEA
022A0:  MOVFF  01,FE9
022A4:  MOVFF  03,FEC
022A8:  MOVF   FED,F
022AA:  MOVFF  469,FEF
....................               tempd[fa + 1][0] = fl; 
022AE:  MOVLW  01
022B0:  ADDWF  x63,W
022B2:  MULLW  04
022B4:  MOVF   FF3,W
022B6:  CLRF   x68
022B8:  MOVWF  x67
022BA:  MOVLW  21
022BC:  ADDWF  x67,W
022BE:  MOVWF  FE9
022C0:  MOVLW  04
022C2:  ADDWFC x68,W
022C4:  MOVWF  FEA
022C6:  MOVFF  465,FEC
022CA:  MOVF   FED,F
022CC:  MOVFF  464,FEF
....................               fl = tempd[fa][1]; 
022D0:  MOVF   x63,W
022D2:  MULLW  04
022D4:  MOVF   FF3,W
022D6:  CLRF   x68
022D8:  MOVWF  x67
022DA:  MOVLW  02
022DC:  ADDWF  x67,W
022DE:  MOVWF  01
022E0:  MOVLW  00
022E2:  ADDWFC x68,W
022E4:  MOVWF  03
022E6:  MOVF   01,W
022E8:  ADDLW  21
022EA:  MOVWF  FE9
022EC:  MOVLW  04
022EE:  ADDWFC 03,W
022F0:  MOVWF  FEA
022F2:  MOVFF  FEC,03
022F6:  MOVF   FED,F
022F8:  MOVFF  FEF,464
022FC:  MOVFF  03,465
....................               tempd[fa][1] = tempd[fa + 1][1]; 
02300:  MOVF   x63,W
02302:  MULLW  04
02304:  MOVF   FF3,W
02306:  CLRF   x68
02308:  MOVWF  x67
0230A:  MOVLW  02
0230C:  ADDWF  x67,W
0230E:  MOVWF  01
02310:  MOVLW  00
02312:  ADDWFC x68,W
02314:  MOVWF  03
02316:  MOVF   01,W
02318:  ADDLW  21
0231A:  MOVWF  01
0231C:  MOVLW  04
0231E:  ADDWFC 03,F
02320:  MOVFF  01,467
02324:  MOVFF  03,468
02328:  MOVLW  01
0232A:  ADDWF  x63,W
0232C:  MULLW  04
0232E:  MOVF   FF3,W
02330:  CLRF   x6A
02332:  MOVWF  x69
02334:  MOVLW  02
02336:  ADDWF  x69,W
02338:  MOVWF  01
0233A:  MOVLW  00
0233C:  ADDWFC x6A,W
0233E:  MOVWF  03
02340:  MOVF   01,W
02342:  ADDLW  21
02344:  MOVWF  FE9
02346:  MOVLW  04
02348:  ADDWFC 03,W
0234A:  MOVWF  FEA
0234C:  MOVFF  FEC,03
02350:  MOVF   FED,F
02352:  MOVFF  FEF,469
02356:  MOVFF  468,FEA
0235A:  MOVFF  467,FE9
0235E:  MOVFF  03,FEC
02362:  MOVF   FED,F
02364:  MOVFF  469,FEF
....................               tempd[fa + 1][1] = fl; 
02368:  MOVLW  01
0236A:  ADDWF  x63,W
0236C:  MULLW  04
0236E:  MOVF   FF3,W
02370:  CLRF   x68
02372:  MOVWF  x67
02374:  MOVLW  02
02376:  ADDWF  x67,W
02378:  MOVWF  01
0237A:  MOVLW  00
0237C:  ADDWFC x68,W
0237E:  MOVWF  03
02380:  MOVF   01,W
02382:  ADDLW  21
02384:  MOVWF  FE9
02386:  MOVLW  04
02388:  ADDWFC 03,W
0238A:  MOVWF  FEA
0238C:  MOVFF  465,FEC
02390:  MOVF   FED,F
02392:  MOVFF  464,FEF
....................            } 
....................         } 
02396:  INCF   x63,F
02398:  BRA    21DA
....................      } 
0239A:  BRA    21D2
....................      /* for(temp=0;temp<used_dimmers;++temp) 
....................    { 
....................       printf("DIMMER:%u value=%lu <-> portWrite=%lu\n\r",temp,tempd[temp][0],tempd[temp][1]); 
....................    }*/ 
....................      IF(tempd[0][0] == 0)numluzes = 0;//luzes todas off 
0239C:  MOVF   x21,F
0239E:  BNZ   23A8
023A0:  MOVF   x22,F
023A2:  BNZ   23A8
023A4:  CLRF   x61
....................      ELSE 
023A6:  BRA    2748
....................      { 
....................         numluzes = 1; 
023A8:  MOVLW  01
023AA:  MOVWF  x61
....................         afa = 0; 
023AC:  CLRF   x66
....................         IF(actmat) 
023AE:  MOVLB  0
023B0:  BTFSS  xB1.3
023B2:  BRA    23C6
....................         { 
....................            delays1[0][0] = tempd[0][0]; 
023B4:  MOVFF  422,368
023B8:  MOVFF  421,367
....................            delays1[0][1] = tempd[0][1]; 
023BC:  MOVFF  424,36A
023C0:  MOVFF  423,369
....................         } 
....................  
....................         ELSE 
023C4:  BRA    23D6
....................         { 
....................            delays2[0][0] = tempd[0][0]; 
023C6:  MOVFF  422,3AC
023CA:  MOVFF  421,3AB
....................            delays2[0][1] = tempd[0][1]; 
023CE:  MOVFF  424,3AE
023D2:  MOVFF  423,3AD
....................         } 
....................  
....................         FOR(fa = 1;fa < used_dimmers;++fa) 
023D6:  MOVLW  01
023D8:  MOVLB  4
023DA:  MOVWF  x63
023DC:  MOVLB  3
023DE:  MOVF   x4E,W
023E0:  MOVLB  4
023E2:  SUBWF  x63,W
023E4:  BTFSC  FD8.0
023E6:  BRA    2748
....................         { 
....................            IF((tempd[fa][0] == tempd[fa - 1][0])&( ! tempd[fa][0] == 0)) 
023E8:  MOVF   x63,W
023EA:  MULLW  04
023EC:  MOVF   FF3,W
023EE:  CLRF   x68
023F0:  MOVWF  x67
023F2:  MOVLW  21
023F4:  ADDWF  x67,W
023F6:  MOVWF  FE9
023F8:  MOVLW  04
023FA:  ADDWFC x68,W
023FC:  MOVWF  FEA
023FE:  MOVFF  FEC,468
02402:  MOVF   FED,F
02404:  MOVFF  FEF,467
02408:  MOVLW  01
0240A:  SUBWF  x63,W
0240C:  MULLW  04
0240E:  MOVF   FF3,W
02410:  CLRF   x6A
02412:  MOVWF  x69
02414:  MOVLW  21
02416:  ADDWF  x69,W
02418:  MOVWF  FE9
0241A:  MOVLW  04
0241C:  ADDWFC x6A,W
0241E:  MOVWF  FEA
02420:  MOVFF  FEC,03
02424:  MOVF   FED,F
02426:  MOVF   FEF,W
02428:  SUBWF  x67,W
0242A:  BNZ   2432
0242C:  MOVF   03,W
0242E:  SUBWF  x68,W
02430:  BZ    2436
02432:  MOVLW  00
02434:  BRA    2438
02436:  MOVLW  01
02438:  MOVWF  x67
0243A:  MOVF   x63,W
0243C:  MULLW  04
0243E:  MOVF   FF3,W
02440:  CLRF   x69
02442:  MOVWF  x68
02444:  MOVLW  21
02446:  ADDWF  x68,W
02448:  MOVWF  FE9
0244A:  MOVLW  04
0244C:  ADDWFC x69,W
0244E:  MOVWF  FEA
02450:  MOVF   FEF,F
02452:  BNZ   2458
02454:  MOVF   FEC,F
02456:  BZ    245C
02458:  MOVLW  00
0245A:  BRA    245E
0245C:  MOVLW  01
0245E:  XORLW  00
02460:  BZ    2466
02462:  MOVLW  00
02464:  BRA    2468
02466:  MOVLW  01
02468:  ANDWF  x67,W
0246A:  BTFSC  FD8.2
0246C:  BRA    25A8
....................            { 
....................               IF(actmat)delays1[afa][1] = delays1[afa][1]&tempd[fa][1]; 
0246E:  MOVLB  0
02470:  BTFSS  xB1.3
02472:  BRA    250E
02474:  MOVLB  4
02476:  MOVF   x66,W
02478:  MULLW  04
0247A:  MOVF   FF3,W
0247C:  CLRF   x68
0247E:  MOVWF  x67
02480:  MOVLW  02
02482:  ADDWF  x67,W
02484:  MOVWF  01
02486:  MOVLW  00
02488:  ADDWFC x68,W
0248A:  MOVWF  03
0248C:  MOVF   01,W
0248E:  ADDLW  67
02490:  MOVWF  01
02492:  MOVLW  03
02494:  ADDWFC 03,F
02496:  MOVFF  01,467
0249A:  MOVFF  03,468
0249E:  MOVF   x66,W
024A0:  MULLW  04
024A2:  MOVF   FF3,W
024A4:  CLRF   x6A
024A6:  MOVWF  x69
024A8:  MOVLW  02
024AA:  ADDWF  x69,W
024AC:  MOVWF  01
024AE:  MOVLW  00
024B0:  ADDWFC x6A,W
024B2:  MOVWF  03
024B4:  MOVF   01,W
024B6:  ADDLW  67
024B8:  MOVWF  FE9
024BA:  MOVLW  03
024BC:  ADDWFC 03,W
024BE:  MOVWF  FEA
024C0:  MOVFF  FEC,46A
024C4:  MOVF   FED,F
024C6:  MOVFF  FEF,469
024CA:  MOVF   x63,W
024CC:  MULLW  04
024CE:  MOVF   FF3,W
024D0:  CLRF   x6C
024D2:  MOVWF  x6B
024D4:  MOVLW  02
024D6:  ADDWF  x6B,W
024D8:  MOVWF  01
024DA:  MOVLW  00
024DC:  ADDWFC x6C,W
024DE:  MOVWF  03
024E0:  MOVF   01,W
024E2:  ADDLW  21
024E4:  MOVWF  FE9
024E6:  MOVLW  04
024E8:  ADDWFC 03,W
024EA:  MOVWF  FEA
024EC:  MOVFF  FEC,03
024F0:  MOVF   FED,F
024F2:  MOVF   FEF,W
024F4:  ANDWF  x69,W
024F6:  MOVWF  00
024F8:  MOVF   03,W
024FA:  ANDWF  x6A,W
024FC:  MOVFF  468,FEA
02500:  MOVFF  467,FE9
02504:  MOVWF  FEC
02506:  MOVF   FED,F
02508:  MOVFF  00,FEF
....................               ELSE delays2[afa][1] = delays2[afa][1]&tempd[fa][1]; 
0250C:  BRA    25A6
0250E:  MOVLB  4
02510:  MOVF   x66,W
02512:  MULLW  04
02514:  MOVF   FF3,W
02516:  CLRF   x68
02518:  MOVWF  x67
0251A:  MOVLW  02
0251C:  ADDWF  x67,W
0251E:  MOVWF  01
02520:  MOVLW  00
02522:  ADDWFC x68,W
02524:  MOVWF  03
02526:  MOVF   01,W
02528:  ADDLW  AB
0252A:  MOVWF  01
0252C:  MOVLW  03
0252E:  ADDWFC 03,F
02530:  MOVFF  01,467
02534:  MOVFF  03,468
02538:  MOVF   x66,W
0253A:  MULLW  04
0253C:  MOVF   FF3,W
0253E:  CLRF   x6A
02540:  MOVWF  x69
02542:  MOVLW  02
02544:  ADDWF  x69,W
02546:  MOVWF  01
02548:  MOVLW  00
0254A:  ADDWFC x6A,W
0254C:  MOVWF  03
0254E:  MOVF   01,W
02550:  ADDLW  AB
02552:  MOVWF  FE9
02554:  MOVLW  03
02556:  ADDWFC 03,W
02558:  MOVWF  FEA
0255A:  MOVFF  FEC,46A
0255E:  MOVF   FED,F
02560:  MOVFF  FEF,469
02564:  MOVF   x63,W
02566:  MULLW  04
02568:  MOVF   FF3,W
0256A:  CLRF   x6C
0256C:  MOVWF  x6B
0256E:  MOVLW  02
02570:  ADDWF  x6B,W
02572:  MOVWF  01
02574:  MOVLW  00
02576:  ADDWFC x6C,W
02578:  MOVWF  03
0257A:  MOVF   01,W
0257C:  ADDLW  21
0257E:  MOVWF  FE9
02580:  MOVLW  04
02582:  ADDWFC 03,W
02584:  MOVWF  FEA
02586:  MOVFF  FEC,03
0258A:  MOVF   FED,F
0258C:  MOVF   FEF,W
0258E:  ANDWF  x69,W
02590:  MOVWF  00
02592:  MOVF   03,W
02594:  ANDWF  x6A,W
02596:  MOVFF  468,FEA
0259A:  MOVFF  467,FE9
0259E:  MOVWF  FEC
025A0:  MOVF   FED,F
025A2:  MOVFF  00,FEF
....................            } 
....................  
....................            else IF( ! tempd[fa][0] == 0) 
025A6:  BRA    2744
025A8:  MOVF   x63,W
025AA:  MULLW  04
025AC:  MOVF   FF3,W
025AE:  CLRF   x68
025B0:  MOVWF  x67
025B2:  MOVLW  21
025B4:  ADDWF  x67,W
025B6:  MOVWF  FE9
025B8:  MOVLW  04
025BA:  ADDWFC x68,W
025BC:  MOVWF  FEA
025BE:  MOVF   FEF,F
025C0:  BNZ   25C6
025C2:  MOVF   FEC,F
025C4:  BZ    25CA
025C6:  MOVLW  00
025C8:  BRA    25CC
025CA:  MOVLW  01
025CC:  XORLW  00
025CE:  BTFSS  FD8.2
025D0:  BRA    2744
....................            { 
....................               ++afa; 
025D2:  INCF   x66,F
....................               IF(actmat) 
025D4:  MOVLB  0
025D6:  BTFSS  xB1.3
025D8:  BRA    2690
....................               { 
....................                  delays1[afa][0] = tempd[fa][0]; 
025DA:  MOVLB  4
025DC:  MOVF   x66,W
025DE:  MULLW  04
025E0:  MOVF   FF3,W
025E2:  CLRF   x68
025E4:  MOVWF  x67
025E6:  MOVLW  67
025E8:  ADDWF  x67,W
025EA:  MOVWF  01
025EC:  MOVLW  03
025EE:  ADDWFC x68,W
025F0:  MOVWF  03
025F2:  MOVWF  x68
025F4:  MOVF   x63,W
025F6:  MULLW  04
025F8:  MOVF   FF3,W
025FA:  CLRF   x6A
025FC:  MOVWF  x69
025FE:  MOVLW  21
02600:  ADDWF  x69,W
02602:  MOVWF  FE9
02604:  MOVLW  04
02606:  ADDWFC x6A,W
02608:  MOVWF  FEA
0260A:  MOVFF  FEC,03
0260E:  MOVF   FED,F
02610:  MOVFF  FEF,469
02614:  MOVFF  468,FEA
02618:  MOVFF  01,FE9
0261C:  MOVFF  03,FEC
02620:  MOVF   FED,F
02622:  MOVFF  469,FEF
....................                  delays1[afa][1] = tempd[fa][1]; 
02626:  MOVF   x66,W
02628:  MULLW  04
0262A:  MOVF   FF3,W
0262C:  CLRF   x68
0262E:  MOVWF  x67
02630:  MOVLW  02
02632:  ADDWF  x67,W
02634:  MOVWF  01
02636:  MOVLW  00
02638:  ADDWFC x68,W
0263A:  MOVWF  03
0263C:  MOVF   01,W
0263E:  ADDLW  67
02640:  MOVWF  01
02642:  MOVLW  03
02644:  ADDWFC 03,F
02646:  MOVFF  01,467
0264A:  MOVFF  03,468
0264E:  MOVF   x63,W
02650:  MULLW  04
02652:  MOVF   FF3,W
02654:  CLRF   x6A
02656:  MOVWF  x69
02658:  MOVLW  02
0265A:  ADDWF  x69,W
0265C:  MOVWF  01
0265E:  MOVLW  00
02660:  ADDWFC x6A,W
02662:  MOVWF  03
02664:  MOVF   01,W
02666:  ADDLW  21
02668:  MOVWF  FE9
0266A:  MOVLW  04
0266C:  ADDWFC 03,W
0266E:  MOVWF  FEA
02670:  MOVFF  FEC,03
02674:  MOVF   FED,F
02676:  MOVFF  FEF,469
0267A:  MOVFF  468,FEA
0267E:  MOVFF  467,FE9
02682:  MOVFF  03,FEC
02686:  MOVF   FED,F
02688:  MOVFF  469,FEF
....................               } 
....................  
....................               ELSE 
0268C:  BRA    2742
0268E:  MOVLB  0
....................               { 
....................                  delays2[afa][0] = tempd[fa][0]; 
02690:  MOVLB  4
02692:  MOVF   x66,W
02694:  MULLW  04
02696:  MOVF   FF3,W
02698:  CLRF   x68
0269A:  MOVWF  x67
0269C:  MOVLW  AB
0269E:  ADDWF  x67,W
026A0:  MOVWF  01
026A2:  MOVLW  03
026A4:  ADDWFC x68,W
026A6:  MOVWF  03
026A8:  MOVWF  x68
026AA:  MOVF   x63,W
026AC:  MULLW  04
026AE:  MOVF   FF3,W
026B0:  CLRF   x6A
026B2:  MOVWF  x69
026B4:  MOVLW  21
026B6:  ADDWF  x69,W
026B8:  MOVWF  FE9
026BA:  MOVLW  04
026BC:  ADDWFC x6A,W
026BE:  MOVWF  FEA
026C0:  MOVFF  FEC,03
026C4:  MOVF   FED,F
026C6:  MOVFF  FEF,469
026CA:  MOVFF  468,FEA
026CE:  MOVFF  01,FE9
026D2:  MOVFF  03,FEC
026D6:  MOVF   FED,F
026D8:  MOVFF  469,FEF
....................                  delays2[afa][1] = tempd[fa][1]; 
026DC:  MOVF   x66,W
026DE:  MULLW  04
026E0:  MOVF   FF3,W
026E2:  CLRF   x68
026E4:  MOVWF  x67
026E6:  MOVLW  02
026E8:  ADDWF  x67,W
026EA:  MOVWF  01
026EC:  MOVLW  00
026EE:  ADDWFC x68,W
026F0:  MOVWF  03
026F2:  MOVF   01,W
026F4:  ADDLW  AB
026F6:  MOVWF  01
026F8:  MOVLW  03
026FA:  ADDWFC 03,F
026FC:  MOVFF  01,467
02700:  MOVFF  03,468
02704:  MOVF   x63,W
02706:  MULLW  04
02708:  MOVF   FF3,W
0270A:  CLRF   x6A
0270C:  MOVWF  x69
0270E:  MOVLW  02
02710:  ADDWF  x69,W
02712:  MOVWF  01
02714:  MOVLW  00
02716:  ADDWFC x6A,W
02718:  MOVWF  03
0271A:  MOVF   01,W
0271C:  ADDLW  21
0271E:  MOVWF  FE9
02720:  MOVLW  04
02722:  ADDWFC 03,W
02724:  MOVWF  FEA
02726:  MOVFF  FEC,03
0272A:  MOVF   FED,F
0272C:  MOVFF  FEF,469
02730:  MOVFF  468,FEA
02734:  MOVFF  467,FE9
02738:  MOVFF  03,FEC
0273C:  MOVF   FED,F
0273E:  MOVFF  469,FEF
....................               } 
....................  
....................               ++numluzes; 
02742:  INCF   x61,F
....................            } 
....................         } 
02744:  INCF   x63,F
02746:  BRA    23DC
....................      } 
....................  
....................      IF(actmat)delays1[N_LUZES][0] = numluzes; 
02748:  MOVLB  0
0274A:  BTFSS  xB1.3
0274C:  BRA    2758
0274E:  MOVLB  3
02750:  CLRF   xA8
02752:  MOVFF  461,3A7
....................      ELSE  delays2[N_LUZES][0] = numluzes; 
02756:  BRA    2760
02758:  MOVLB  3
0275A:  CLRF   xEC
0275C:  MOVFF  461,3EB
....................     // printf("num luzes activas=%d valor primeira=%lu portWrite=%lu\n\r",numluzes,delays1[0][0],delays1[0][1]); 
....................       
....................      organizado=1; 
02760:  MOVLB  0
02762:  BSF    xB1.2
....................   } 
02764:  RETLW  00
....................  
.................... void dimmer_outputs_init() 
.................... { 
....................    portc=0xFF; 
02766:  MOVLW  FF
02768:  MOVWF  F82
....................    portd=0xFF; 
0276A:  MOVWF  F83
....................    trisc=0x00; //tudo saidas 
0276C:  CLRF   F94
....................    trisd=0x00; //tudo saidas 
0276E:  CLRF   F95
....................    int x; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
02770:  MOVLB  4
02772:  CLRF   x1F
02774:  MOVLB  1
02776:  MOVF   x3B,W
02778:  MOVLB  4
0277A:  SUBWF  x1F,W
0277C:  BTFSC  FD8.0
0277E:  BRA    28A8
02780:  CLRF   1B
02782:  BTFSC  FF2.7
02784:  BSF    1B.7
02786:  BCF    FF2.7
....................    { 
....................       switch (((struct outputs)mydevices.myoutputs[x]).type) { 
02788:  CLRF   x6F
0278A:  MOVFF  41F,46E
0278E:  CLRF   x71
02790:  MOVLW  23
02792:  MOVWF  x70
02794:  MOVLB  0
02796:  CALL   031E
0279A:  BTFSC  1B.7
0279C:  BSF    FF2.7
0279E:  MOVFF  02,03
027A2:  MOVF   01,W
027A4:  ADDLW  F0
027A6:  MOVWF  01
027A8:  MOVLW  01
027AA:  ADDWFC 03,F
027AC:  MOVFF  01,FE9
027B0:  MOVFF  03,FEA
027B4:  MOVF   FEF,W
027B6:  XORLW  01
027B8:  BZ    27BC
027BA:  BRA    28A2
....................          case dimmer: 
....................             lights[used_dimmers]=light_pins[((struct light)mydevices.myoutputs[x].device).output_pin]; 
027BC:  BCF    FD8.0
027BE:  MOVLB  3
027C0:  RLCF   x4E,W
027C2:  CLRF   03
027C4:  ADDLW  EF
027C6:  MOVWF  01
027C8:  MOVLW  03
027CA:  ADDWFC 03,F
027CC:  MOVFF  01,420
027D0:  MOVLB  4
027D2:  MOVFF  03,421
027D6:  CLRF   1B
027D8:  BTFSC  FF2.7
027DA:  BSF    1B.7
027DC:  BCF    FF2.7
027DE:  CLRF   x6F
027E0:  MOVFF  41F,46E
027E4:  CLRF   x71
027E6:  MOVLW  23
027E8:  MOVWF  x70
027EA:  MOVLB  0
027EC:  CALL   031E
027F0:  BTFSC  1B.7
027F2:  BSF    FF2.7
027F4:  MOVF   01,W
027F6:  ADDLW  B6
027F8:  MOVLB  4
027FA:  MOVWF  x22
027FC:  MOVLW  00
027FE:  ADDWFC 02,W
02800:  MOVWF  x23
02802:  MOVLW  01
02804:  ADDWF  x22,W
02806:  MOVWF  01
02808:  MOVLW  00
0280A:  ADDWFC x23,W
0280C:  MOVWF  03
0280E:  MOVF   01,W
02810:  ADDLW  3A
02812:  MOVWF  01
02814:  MOVLW  01
02816:  ADDWFC 03,F
02818:  MOVF   01,W
0281A:  ADDLW  1F
0281C:  MOVWF  FE9
0281E:  MOVLW  00
02820:  ADDWFC 03,W
02822:  MOVWF  FEA
02824:  BCF    FD8.0
02826:  RLCF   FEF,W
02828:  CLRF   03
0282A:  MOVLB  0
0282C:  CALL   0172
02830:  TBLRD*+
02832:  MOVFF  FF5,03
02836:  MOVLB  4
02838:  MOVFF  421,FEA
0283C:  MOVFF  420,FE9
02840:  MOVFF  03,FEC
02844:  MOVF   FED,F
02846:  MOVWF  FEF
02848:  CLRF   1B
0284A:  BTFSC  FF2.7
0284C:  BSF    1B.7
0284E:  BCF    FF2.7
....................             ((struct light)mydevices.myoutputs[x].device).internal_order=used_dimmers; 
02850:  CLRF   x6F
02852:  MOVFF  41F,46E
02856:  CLRF   x71
02858:  MOVLW  23
0285A:  MOVWF  x70
0285C:  MOVLB  0
0285E:  CALL   031E
02862:  BTFSC  1B.7
02864:  BSF    FF2.7
02866:  MOVF   01,W
02868:  ADDLW  B6
0286A:  MOVLB  4
0286C:  MOVWF  x20
0286E:  MOVLW  00
02870:  ADDWFC 02,W
02872:  MOVWF  x21
02874:  MOVLW  01
02876:  ADDWF  x20,W
02878:  MOVWF  01
0287A:  MOVLW  00
0287C:  ADDWFC x21,W
0287E:  MOVWF  03
02880:  MOVF   01,W
02882:  ADDLW  3A
02884:  MOVWF  01
02886:  MOVLW  01
02888:  ADDWFC 03,F
0288A:  MOVF   01,W
0288C:  ADDLW  20
0288E:  MOVWF  FE9
02890:  MOVLW  00
02892:  ADDWFC 03,W
02894:  MOVWF  FEA
02896:  MOVFF  34E,FEF
....................             ++used_dimmers;           
0289A:  MOVLB  3
0289C:  INCF   x4E,F
....................          break; 
0289E:  MOVLB  0
028A0:  BRA    28A2
....................       } 
....................    } 
028A2:  MOVLB  4
028A4:  INCF   x1F,F
028A6:  BRA    2774
....................    if(used_dimmers==0) 
028A8:  MOVLB  3
028AA:  MOVF   x4E,F
028AC:  BNZ   28B0
....................       return; 
028AE:  BRA    290E
....................    for(x=0;x<used_dimmers;++x) 
028B0:  MOVLB  4
028B2:  CLRF   x1F
028B4:  MOVLB  3
028B6:  MOVF   x4E,W
028B8:  MOVLB  4
028BA:  SUBWF  x1F,W
028BC:  BC    28E4
....................    { 
....................       dimmers_off_value=dimmers_off_value & lights[x]; 
028BE:  BCF    FD8.0
028C0:  RLCF   x1F,W
028C2:  CLRF   03
028C4:  ADDLW  EF
028C6:  MOVWF  FE9
028C8:  MOVLW  03
028CA:  ADDWFC 03,W
028CC:  MOVWF  FEA
028CE:  MOVFF  FEC,03
028D2:  MOVF   FED,F
028D4:  MOVF   FEF,W
028D6:  MOVLB  3
028D8:  ANDWF  x53,F
028DA:  MOVF   03,W
028DC:  ANDWF  x54,F
....................    } 
028DE:  MOVLB  4
028E0:  INCF   x1F,F
028E2:  BRA    28B4
....................    dimmers_off_value=~dimmers_off_value; 
028E4:  MOVLB  3
028E6:  COMF   x53,F
028E8:  COMF   x54,F
....................    actmat=0; 
028EA:  MOVLB  0
028EC:  BCF    xB1.3
....................    pointer=delays1; 
028EE:  MOVLW  03
028F0:  MOVLB  3
028F2:  MOVWF  x50
028F4:  MOVLW  67
028F6:  MOVWF  x4F
....................    org(); 
028F8:  MOVLB  0
028FA:  RCALL  2134
....................    pointer=delays2; 
028FC:  MOVLW  03
028FE:  MOVLB  3
02900:  MOVWF  x50
02902:  MOVLW  AB
02904:  MOVWF  x4F
....................    actmat=1; 
02906:  MOVLB  0
02908:  BSF    xB1.3
....................    org(); 
0290A:  RCALL  2134
0290C:  MOVLB  3
.................... } 
0290E:  MOVLB  0
02910:  GOTO   4282 (RETURN)
....................  
.................... void write_outputs() 
.................... { 
*
029F8:  MOVLB  4
029FA:  BCF    x20.0
....................    int x; 
....................    int1 update_dimmers=false; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
029FC:  CLRF   x1F
029FE:  MOVLB  1
02A00:  MOVF   x3B,W
02A02:  MOVLB  4
02A04:  SUBWF  x1F,W
02A06:  BTFSC  FD8.0
02A08:  GOTO   33A8
02A0C:  CLRF   1B
02A0E:  BTFSC  FF2.7
02A10:  BSF    1B.7
02A12:  BCF    FF2.7
....................    { 
....................       switch (((struct outputs)mydevices.myoutputs[x]).type) { 
02A14:  CLRF   x6F
02A16:  MOVFF  41F,46E
02A1A:  CLRF   x71
02A1C:  MOVLW  23
02A1E:  MOVWF  x70
02A20:  MOVLB  0
02A22:  CALL   031E
02A26:  BTFSC  1B.7
02A28:  BSF    FF2.7
02A2A:  MOVFF  02,03
02A2E:  MOVF   01,W
02A30:  ADDLW  F0
02A32:  MOVWF  01
02A34:  MOVLW  01
02A36:  ADDWFC 03,F
02A38:  MOVFF  01,FE9
02A3C:  MOVFF  03,FEA
02A40:  MOVF   FEF,W
02A42:  XORLW  01
02A44:  BZ    2A50
02A46:  XORLW  01
02A48:  BTFSC  FD8.2
02A4A:  BRA    2FBA
02A4C:  GOTO   33A0
....................          case dimmer: 
02A50:  CLRF   1B
02A52:  BTFSC  FF2.7
02A54:  BSF    1B.7
02A56:  BCF    FF2.7
....................             //printf("dimmer"); 
....................             if(((struct light)mydevices.myoutputs[x].device).dim_value.needs_update) 
02A58:  MOVLB  4
02A5A:  CLRF   x6F
02A5C:  MOVFF  41F,46E
02A60:  CLRF   x71
02A62:  MOVLW  23
02A64:  MOVWF  x70
02A66:  MOVLB  0
02A68:  CALL   031E
02A6C:  BTFSC  1B.7
02A6E:  BSF    FF2.7
02A70:  MOVF   01,W
02A72:  ADDLW  B6
02A74:  MOVLB  4
02A76:  MOVWF  x21
02A78:  MOVLW  00
02A7A:  ADDWFC 02,W
02A7C:  MOVWF  x22
02A7E:  MOVLW  01
02A80:  ADDWF  x21,W
02A82:  MOVWF  01
02A84:  MOVLW  00
02A86:  ADDWFC x22,W
02A88:  MOVWF  03
02A8A:  MOVF   01,W
02A8C:  ADDLW  3A
02A8E:  MOVWF  01
02A90:  MOVLW  01
02A92:  ADDWFC 03,F
02A94:  MOVF   01,W
02A96:  ADDLW  1D
02A98:  MOVWF  FE9
02A9A:  MOVLW  00
02A9C:  ADDWFC 03,W
02A9E:  MOVWF  FEA
02AA0:  BTFSS  FEF.0
02AA2:  BRA    2C08
02AA4:  CLRF   1B
02AA6:  BTFSC  FF2.7
02AA8:  BSF    1B.7
02AAA:  BCF    FF2.7
....................             { 
....................                if(((struct light)mydevices.myoutputs[x].device).out_state==_on) 
02AAC:  CLRF   x6F
02AAE:  MOVFF  41F,46E
02AB2:  CLRF   x71
02AB4:  MOVLW  23
02AB6:  MOVWF  x70
02AB8:  MOVLB  0
02ABA:  CALL   031E
02ABE:  BTFSC  1B.7
02AC0:  BSF    FF2.7
02AC2:  MOVF   01,W
02AC4:  ADDLW  B6
02AC6:  MOVLB  4
02AC8:  MOVWF  x21
02ACA:  MOVLW  00
02ACC:  ADDWFC 02,W
02ACE:  MOVWF  x22
02AD0:  MOVLW  01
02AD2:  ADDWF  x21,W
02AD4:  MOVWF  01
02AD6:  MOVLW  00
02AD8:  ADDWFC x22,W
02ADA:  MOVWF  03
02ADC:  MOVF   01,W
02ADE:  ADDLW  3A
02AE0:  MOVWF  01
02AE2:  MOVLW  01
02AE4:  ADDWFC 03,F
02AE6:  MOVF   01,W
02AE8:  ADDLW  1E
02AEA:  MOVWF  FE9
02AEC:  MOVLW  00
02AEE:  ADDWFC 03,W
02AF0:  MOVWF  FEA
02AF2:  MOVF   FEF,F
02AF4:  BNZ   2BB8
02AF6:  CLRF   1B
02AF8:  BTFSC  FF2.7
02AFA:  BSF    1B.7
02AFC:  BCF    FF2.7
....................                { 
....................                   ltlevel[((struct light)mydevices.myoutputs[x].device).internal_order]=((struct light)mydevices.myoutputs[x].device).dim_value.value; 
02AFE:  CLRF   x6F
02B00:  MOVFF  41F,46E
02B04:  CLRF   x71
02B06:  MOVLW  23
02B08:  MOVWF  x70
02B0A:  MOVLB  0
02B0C:  CALL   031E
02B10:  BTFSC  1B.7
02B12:  BSF    FF2.7
02B14:  MOVF   01,W
02B16:  ADDLW  B6
02B18:  MOVLB  4
02B1A:  MOVWF  x21
02B1C:  MOVLW  00
02B1E:  ADDWFC 02,W
02B20:  MOVWF  x22
02B22:  MOVLW  01
02B24:  ADDWF  x21,W
02B26:  MOVWF  01
02B28:  MOVLW  00
02B2A:  ADDWFC x22,W
02B2C:  MOVWF  03
02B2E:  MOVF   01,W
02B30:  ADDLW  3A
02B32:  MOVWF  01
02B34:  MOVLW  01
02B36:  ADDWFC 03,F
02B38:  MOVF   01,W
02B3A:  ADDLW  20
02B3C:  MOVWF  FE9
02B3E:  MOVLW  00
02B40:  ADDWFC 03,W
02B42:  MOVWF  FEA
02B44:  CLRF   03
02B46:  MOVF   FEF,W
02B48:  ADDLW  57
02B4A:  MOVWF  01
02B4C:  MOVLW  03
02B4E:  ADDWFC 03,F
02B50:  MOVFF  01,423
02B54:  MOVFF  03,424
02B58:  CLRF   1B
02B5A:  BTFSC  FF2.7
02B5C:  BSF    1B.7
02B5E:  BCF    FF2.7
02B60:  CLRF   x6F
02B62:  MOVFF  41F,46E
02B66:  CLRF   x71
02B68:  MOVLW  23
02B6A:  MOVWF  x70
02B6C:  MOVLB  0
02B6E:  CALL   031E
02B72:  BTFSC  1B.7
02B74:  BSF    FF2.7
02B76:  MOVF   01,W
02B78:  ADDLW  B6
02B7A:  MOVLB  4
02B7C:  MOVWF  x25
02B7E:  MOVLW  00
02B80:  ADDWFC 02,W
02B82:  MOVWF  x26
02B84:  MOVLW  01
02B86:  ADDWF  x25,W
02B88:  MOVWF  01
02B8A:  MOVLW  00
02B8C:  ADDWFC x26,W
02B8E:  MOVWF  03
02B90:  MOVF   01,W
02B92:  ADDLW  3A
02B94:  MOVWF  01
02B96:  MOVLW  01
02B98:  ADDWFC 03,F
02B9A:  MOVF   01,W
02B9C:  ADDLW  1C
02B9E:  MOVWF  FE9
02BA0:  MOVLW  00
02BA2:  ADDWFC 03,W
02BA4:  MOVWF  FEA
02BA6:  MOVFF  FEF,427
02BAA:  MOVFF  424,FEA
02BAE:  MOVFF  423,FE9
02BB2:  MOVFF  427,FEF
....................                   update_dimmers=true; 
02BB6:  BSF    x20.0
02BB8:  CLRF   1B
02BBA:  BTFSC  FF2.7
02BBC:  BSF    1B.7
02BBE:  BCF    FF2.7
....................                } 
....................                ((struct light)mydevices.myoutputs[x].device).dim_value.needs_update=false; 
02BC0:  CLRF   x6F
02BC2:  MOVFF  41F,46E
02BC6:  CLRF   x71
02BC8:  MOVLW  23
02BCA:  MOVWF  x70
02BCC:  MOVLB  0
02BCE:  CALL   031E
02BD2:  BTFSC  1B.7
02BD4:  BSF    FF2.7
02BD6:  MOVF   01,W
02BD8:  ADDLW  B6
02BDA:  MOVLB  4
02BDC:  MOVWF  x21
02BDE:  MOVLW  00
02BE0:  ADDWFC 02,W
02BE2:  MOVWF  x22
02BE4:  MOVLW  01
02BE6:  ADDWF  x21,W
02BE8:  MOVWF  01
02BEA:  MOVLW  00
02BEC:  ADDWFC x22,W
02BEE:  MOVWF  03
02BF0:  MOVF   01,W
02BF2:  ADDLW  3A
02BF4:  MOVWF  01
02BF6:  MOVLW  01
02BF8:  ADDWFC 03,F
02BFA:  MOVF   01,W
02BFC:  ADDLW  1D
02BFE:  MOVWF  FE9
02C00:  MOVLW  00
02C02:  ADDWFC 03,W
02C04:  MOVWF  FEA
02C06:  BCF    FEF.0
02C08:  CLRF   1B
02C0A:  BTFSC  FF2.7
02C0C:  BSF    1B.7
02C0E:  BCF    FF2.7
....................             } 
....................              
....................             if(((struct light)mydevices.myoutputs[x].device).off.needs_update) 
02C10:  CLRF   x6F
02C12:  MOVFF  41F,46E
02C16:  CLRF   x71
02C18:  MOVLW  23
02C1A:  MOVWF  x70
02C1C:  MOVLB  0
02C1E:  CALL   031E
02C22:  BTFSC  1B.7
02C24:  BSF    FF2.7
02C26:  MOVF   01,W
02C28:  ADDLW  B6
02C2A:  MOVLB  4
02C2C:  MOVWF  x21
02C2E:  MOVLW  00
02C30:  ADDWFC 02,W
02C32:  MOVWF  x22
02C34:  MOVLW  01
02C36:  ADDWF  x21,W
02C38:  MOVWF  01
02C3A:  MOVLW  00
02C3C:  ADDWFC x22,W
02C3E:  MOVWF  03
02C40:  MOVF   01,W
02C42:  ADDLW  3A
02C44:  MOVWF  01
02C46:  MOVLW  01
02C48:  ADDWFC 03,F
02C4A:  MOVF   01,W
02C4C:  ADDLW  13
02C4E:  MOVWF  FE9
02C50:  MOVLW  00
02C52:  ADDWFC 03,W
02C54:  MOVWF  FEA
02C56:  BTFSS  FEF.0
02C58:  BRA    2DAE
02C5A:  CLRF   1B
02C5C:  BTFSC  FF2.7
02C5E:  BSF    1B.7
02C60:  BCF    FF2.7
....................             { 
....................                if(((struct light)mydevices.myoutputs[x].device).off.value) 
02C62:  CLRF   x6F
02C64:  MOVFF  41F,46E
02C68:  CLRF   x71
02C6A:  MOVLW  23
02C6C:  MOVWF  x70
02C6E:  MOVLB  0
02C70:  CALL   031E
02C74:  BTFSC  1B.7
02C76:  BSF    FF2.7
02C78:  MOVF   01,W
02C7A:  ADDLW  B6
02C7C:  MOVLB  4
02C7E:  MOVWF  x21
02C80:  MOVLW  00
02C82:  ADDWFC 02,W
02C84:  MOVWF  x22
02C86:  MOVLW  01
02C88:  ADDWF  x21,W
02C8A:  MOVWF  01
02C8C:  MOVLW  00
02C8E:  ADDWFC x22,W
02C90:  MOVWF  03
02C92:  MOVF   01,W
02C94:  ADDLW  3A
02C96:  MOVWF  01
02C98:  MOVLW  01
02C9A:  ADDWFC 03,F
02C9C:  MOVF   01,W
02C9E:  ADDLW  12
02CA0:  MOVWF  FE9
02CA2:  MOVLW  00
02CA4:  ADDWFC 03,W
02CA6:  MOVWF  FEA
02CA8:  MOVF   FEF,F
02CAA:  BZ    2D5E
02CAC:  CLRF   1B
02CAE:  BTFSC  FF2.7
02CB0:  BSF    1B.7
02CB2:  BCF    FF2.7
....................                { 
....................                   ((struct light)mydevices.myoutputs[x].device).out_state=_off; 
02CB4:  CLRF   x6F
02CB6:  MOVFF  41F,46E
02CBA:  CLRF   x71
02CBC:  MOVLW  23
02CBE:  MOVWF  x70
02CC0:  MOVLB  0
02CC2:  CALL   031E
02CC6:  BTFSC  1B.7
02CC8:  BSF    FF2.7
02CCA:  MOVF   01,W
02CCC:  ADDLW  B6
02CCE:  MOVLB  4
02CD0:  MOVWF  x21
02CD2:  MOVLW  00
02CD4:  ADDWFC 02,W
02CD6:  MOVWF  x22
02CD8:  MOVLW  01
02CDA:  ADDWF  x21,W
02CDC:  MOVWF  01
02CDE:  MOVLW  00
02CE0:  ADDWFC x22,W
02CE2:  MOVWF  03
02CE4:  MOVF   01,W
02CE6:  ADDLW  3A
02CE8:  MOVWF  01
02CEA:  MOVLW  01
02CEC:  ADDWFC 03,F
02CEE:  MOVF   01,W
02CF0:  ADDLW  1E
02CF2:  MOVWF  FE9
02CF4:  MOVLW  00
02CF6:  ADDWFC 03,W
02CF8:  MOVWF  FEA
02CFA:  MOVLW  01
02CFC:  MOVWF  FEF
02CFE:  CLRF   1B
02D00:  BTFSC  FF2.7
02D02:  BSF    1B.7
02D04:  BCF    FF2.7
....................                   ltlevel[((struct light)mydevices.myoutputs[x].device).internal_order]=0; 
02D06:  CLRF   x6F
02D08:  MOVFF  41F,46E
02D0C:  CLRF   x71
02D0E:  MOVLW  23
02D10:  MOVWF  x70
02D12:  MOVLB  0
02D14:  CALL   031E
02D18:  BTFSC  1B.7
02D1A:  BSF    FF2.7
02D1C:  MOVF   01,W
02D1E:  ADDLW  B6
02D20:  MOVLB  4
02D22:  MOVWF  x21
02D24:  MOVLW  00
02D26:  ADDWFC 02,W
02D28:  MOVWF  x22
02D2A:  MOVLW  01
02D2C:  ADDWF  x21,W
02D2E:  MOVWF  01
02D30:  MOVLW  00
02D32:  ADDWFC x22,W
02D34:  MOVWF  03
02D36:  MOVF   01,W
02D38:  ADDLW  3A
02D3A:  MOVWF  01
02D3C:  MOVLW  01
02D3E:  ADDWFC 03,F
02D40:  MOVF   01,W
02D42:  ADDLW  20
02D44:  MOVWF  FE9
02D46:  MOVLW  00
02D48:  ADDWFC 03,W
02D4A:  MOVWF  FEA
02D4C:  CLRF   03
02D4E:  MOVF   FEF,W
02D50:  ADDLW  57
02D52:  MOVWF  FE9
02D54:  MOVLW  03
02D56:  ADDWFC 03,W
02D58:  MOVWF  FEA
02D5A:  CLRF   FEF
....................                   update_dimmers=true; 
02D5C:  BSF    x20.0
02D5E:  CLRF   1B
02D60:  BTFSC  FF2.7
02D62:  BSF    1B.7
02D64:  BCF    FF2.7
....................                } 
....................                ((struct light)mydevices.myoutputs[x].device).off.needs_update=false; 
02D66:  CLRF   x6F
02D68:  MOVFF  41F,46E
02D6C:  CLRF   x71
02D6E:  MOVLW  23
02D70:  MOVWF  x70
02D72:  MOVLB  0
02D74:  CALL   031E
02D78:  BTFSC  1B.7
02D7A:  BSF    FF2.7
02D7C:  MOVF   01,W
02D7E:  ADDLW  B6
02D80:  MOVLB  4
02D82:  MOVWF  x21
02D84:  MOVLW  00
02D86:  ADDWFC 02,W
02D88:  MOVWF  x22
02D8A:  MOVLW  01
02D8C:  ADDWF  x21,W
02D8E:  MOVWF  01
02D90:  MOVLW  00
02D92:  ADDWFC x22,W
02D94:  MOVWF  03
02D96:  MOVF   01,W
02D98:  ADDLW  3A
02D9A:  MOVWF  01
02D9C:  MOVLW  01
02D9E:  ADDWFC 03,F
02DA0:  MOVF   01,W
02DA2:  ADDLW  13
02DA4:  MOVWF  FE9
02DA6:  MOVLW  00
02DA8:  ADDWFC 03,W
02DAA:  MOVWF  FEA
02DAC:  BCF    FEF.0
02DAE:  CLRF   1B
02DB0:  BTFSC  FF2.7
02DB2:  BSF    1B.7
02DB4:  BCF    FF2.7
....................             } 
....................              
....................             if(((struct light)mydevices.myoutputs[x].device).on.needs_update) 
02DB6:  CLRF   x6F
02DB8:  MOVFF  41F,46E
02DBC:  CLRF   x71
02DBE:  MOVLW  23
02DC0:  MOVWF  x70
02DC2:  MOVLB  0
02DC4:  CALL   031E
02DC8:  BTFSC  1B.7
02DCA:  BSF    FF2.7
02DCC:  MOVF   01,W
02DCE:  ADDLW  B6
02DD0:  MOVLB  4
02DD2:  MOVWF  x21
02DD4:  MOVLW  00
02DD6:  ADDWFC 02,W
02DD8:  MOVWF  x22
02DDA:  MOVLW  01
02DDC:  ADDWF  x21,W
02DDE:  MOVWF  01
02DE0:  MOVLW  00
02DE2:  ADDWFC x22,W
02DE4:  MOVWF  03
02DE6:  MOVF   01,W
02DE8:  ADDLW  3A
02DEA:  MOVWF  01
02DEC:  MOVLW  01
02DEE:  ADDWFC 03,F
02DF0:  MOVF   01,W
02DF2:  ADDLW  09
02DF4:  MOVWF  FE9
02DF6:  MOVLW  00
02DF8:  ADDWFC 03,W
02DFA:  MOVWF  FEA
02DFC:  BTFSS  FEF.0
02DFE:  BRA    2FB6
02E00:  CLRF   1B
02E02:  BTFSC  FF2.7
02E04:  BSF    1B.7
02E06:  BCF    FF2.7
....................             { 
....................                if(((struct light)mydevices.myoutputs[x].device).on.value) 
02E08:  CLRF   x6F
02E0A:  MOVFF  41F,46E
02E0E:  CLRF   x71
02E10:  MOVLW  23
02E12:  MOVWF  x70
02E14:  MOVLB  0
02E16:  CALL   031E
02E1A:  BTFSC  1B.7
02E1C:  BSF    FF2.7
02E1E:  MOVF   01,W
02E20:  ADDLW  B6
02E22:  MOVLB  4
02E24:  MOVWF  x21
02E26:  MOVLW  00
02E28:  ADDWFC 02,W
02E2A:  MOVWF  x22
02E2C:  MOVLW  01
02E2E:  ADDWF  x21,W
02E30:  MOVWF  01
02E32:  MOVLW  00
02E34:  ADDWFC x22,W
02E36:  MOVWF  03
02E38:  MOVF   01,W
02E3A:  ADDLW  3A
02E3C:  MOVWF  01
02E3E:  MOVLW  01
02E40:  ADDWFC 03,F
02E42:  MOVF   01,W
02E44:  ADDLW  08
02E46:  MOVWF  FE9
02E48:  MOVLW  00
02E4A:  ADDWFC 03,W
02E4C:  MOVWF  FEA
02E4E:  MOVF   FEF,F
02E50:  BTFSC  FD8.2
02E52:  BRA    2F66
02E54:  CLRF   1B
02E56:  BTFSC  FF2.7
02E58:  BSF    1B.7
02E5A:  BCF    FF2.7
....................                { 
....................                   ((struct light)mydevices.myoutputs[x].device).out_state=_on; 
02E5C:  CLRF   x6F
02E5E:  MOVFF  41F,46E
02E62:  CLRF   x71
02E64:  MOVLW  23
02E66:  MOVWF  x70
02E68:  MOVLB  0
02E6A:  CALL   031E
02E6E:  BTFSC  1B.7
02E70:  BSF    FF2.7
02E72:  MOVF   01,W
02E74:  ADDLW  B6
02E76:  MOVLB  4
02E78:  MOVWF  x21
02E7A:  MOVLW  00
02E7C:  ADDWFC 02,W
02E7E:  MOVWF  x22
02E80:  MOVLW  01
02E82:  ADDWF  x21,W
02E84:  MOVWF  01
02E86:  MOVLW  00
02E88:  ADDWFC x22,W
02E8A:  MOVWF  03
02E8C:  MOVF   01,W
02E8E:  ADDLW  3A
02E90:  MOVWF  01
02E92:  MOVLW  01
02E94:  ADDWFC 03,F
02E96:  MOVF   01,W
02E98:  ADDLW  1E
02E9A:  MOVWF  FE9
02E9C:  MOVLW  00
02E9E:  ADDWFC 03,W
02EA0:  MOVWF  FEA
02EA2:  CLRF   FEF
02EA4:  CLRF   1B
02EA6:  BTFSC  FF2.7
02EA8:  BSF    1B.7
02EAA:  BCF    FF2.7
....................                   ltlevel[((struct light)mydevices.myoutputs[x].device).internal_order]=((struct light)mydevices.myoutputs[x].device).dim_value.value; 
02EAC:  CLRF   x6F
02EAE:  MOVFF  41F,46E
02EB2:  CLRF   x71
02EB4:  MOVLW  23
02EB6:  MOVWF  x70
02EB8:  MOVLB  0
02EBA:  CALL   031E
02EBE:  BTFSC  1B.7
02EC0:  BSF    FF2.7
02EC2:  MOVF   01,W
02EC4:  ADDLW  B6
02EC6:  MOVLB  4
02EC8:  MOVWF  x21
02ECA:  MOVLW  00
02ECC:  ADDWFC 02,W
02ECE:  MOVWF  x22
02ED0:  MOVLW  01
02ED2:  ADDWF  x21,W
02ED4:  MOVWF  01
02ED6:  MOVLW  00
02ED8:  ADDWFC x22,W
02EDA:  MOVWF  03
02EDC:  MOVF   01,W
02EDE:  ADDLW  3A
02EE0:  MOVWF  01
02EE2:  MOVLW  01
02EE4:  ADDWFC 03,F
02EE6:  MOVF   01,W
02EE8:  ADDLW  20
02EEA:  MOVWF  FE9
02EEC:  MOVLW  00
02EEE:  ADDWFC 03,W
02EF0:  MOVWF  FEA
02EF2:  CLRF   03
02EF4:  MOVF   FEF,W
02EF6:  ADDLW  57
02EF8:  MOVWF  01
02EFA:  MOVLW  03
02EFC:  ADDWFC 03,F
02EFE:  MOVFF  01,423
02F02:  MOVFF  03,424
02F06:  CLRF   1B
02F08:  BTFSC  FF2.7
02F0A:  BSF    1B.7
02F0C:  BCF    FF2.7
02F0E:  CLRF   x6F
02F10:  MOVFF  41F,46E
02F14:  CLRF   x71
02F16:  MOVLW  23
02F18:  MOVWF  x70
02F1A:  MOVLB  0
02F1C:  CALL   031E
02F20:  BTFSC  1B.7
02F22:  BSF    FF2.7
02F24:  MOVF   01,W
02F26:  ADDLW  B6
02F28:  MOVLB  4
02F2A:  MOVWF  x25
02F2C:  MOVLW  00
02F2E:  ADDWFC 02,W
02F30:  MOVWF  x26
02F32:  MOVLW  01
02F34:  ADDWF  x25,W
02F36:  MOVWF  01
02F38:  MOVLW  00
02F3A:  ADDWFC x26,W
02F3C:  MOVWF  03
02F3E:  MOVF   01,W
02F40:  ADDLW  3A
02F42:  MOVWF  01
02F44:  MOVLW  01
02F46:  ADDWFC 03,F
02F48:  MOVF   01,W
02F4A:  ADDLW  1C
02F4C:  MOVWF  FE9
02F4E:  MOVLW  00
02F50:  ADDWFC 03,W
02F52:  MOVWF  FEA
02F54:  MOVFF  FEF,427
02F58:  MOVFF  424,FEA
02F5C:  MOVFF  423,FE9
02F60:  MOVFF  427,FEF
....................                   update_dimmers=true; 
02F64:  BSF    x20.0
02F66:  CLRF   1B
02F68:  BTFSC  FF2.7
02F6A:  BSF    1B.7
02F6C:  BCF    FF2.7
....................                } 
....................                ((struct light)mydevices.myoutputs[x].device).on.needs_update=false; 
02F6E:  CLRF   x6F
02F70:  MOVFF  41F,46E
02F74:  CLRF   x71
02F76:  MOVLW  23
02F78:  MOVWF  x70
02F7A:  MOVLB  0
02F7C:  CALL   031E
02F80:  BTFSC  1B.7
02F82:  BSF    FF2.7
02F84:  MOVF   01,W
02F86:  ADDLW  B6
02F88:  MOVLB  4
02F8A:  MOVWF  x21
02F8C:  MOVLW  00
02F8E:  ADDWFC 02,W
02F90:  MOVWF  x22
02F92:  MOVLW  01
02F94:  ADDWF  x21,W
02F96:  MOVWF  01
02F98:  MOVLW  00
02F9A:  ADDWFC x22,W
02F9C:  MOVWF  03
02F9E:  MOVF   01,W
02FA0:  ADDLW  3A
02FA2:  MOVWF  01
02FA4:  MOVLW  01
02FA6:  ADDWFC 03,F
02FA8:  MOVF   01,W
02FAA:  ADDLW  09
02FAC:  MOVWF  FE9
02FAE:  MOVLW  00
02FB0:  ADDWFC 03,W
02FB2:  MOVWF  FEA
02FB4:  BCF    FEF.0
....................             } 
....................          break; 
02FB6:  MOVLB  0
02FB8:  BRA    33A0
....................          case _on_off: 
02FBA:  CLRF   1B
02FBC:  BTFSC  FF2.7
02FBE:  BSF    1B.7
02FC0:  BCF    FF2.7
....................             if(((struct oNoFF)mydevices.myoutputs[x].device).off.needs_update) 
02FC2:  MOVLB  4
02FC4:  CLRF   x6F
02FC6:  MOVFF  41F,46E
02FCA:  CLRF   x71
02FCC:  MOVLW  23
02FCE:  MOVWF  x70
02FD0:  MOVLB  0
02FD2:  CALL   031E
02FD6:  BTFSC  1B.7
02FD8:  BSF    FF2.7
02FDA:  MOVF   01,W
02FDC:  ADDLW  B6
02FDE:  MOVLB  4
02FE0:  MOVWF  x21
02FE2:  MOVLW  00
02FE4:  ADDWFC 02,W
02FE6:  MOVWF  x22
02FE8:  MOVLW  01
02FEA:  ADDWF  x21,W
02FEC:  MOVWF  01
02FEE:  MOVLW  00
02FF0:  ADDWFC x22,W
02FF2:  MOVWF  03
02FF4:  MOVF   01,W
02FF6:  ADDLW  3A
02FF8:  MOVWF  01
02FFA:  MOVLW  01
02FFC:  ADDWFC 03,F
02FFE:  MOVF   01,W
03000:  ADDLW  13
03002:  MOVWF  FE9
03004:  MOVLW  00
03006:  ADDWFC 03,W
03008:  MOVWF  FEA
0300A:  BTFSS  FEF.0
0300C:  BRA    31F2
0300E:  CLRF   1B
03010:  BTFSC  FF2.7
03012:  BSF    1B.7
03014:  BCF    FF2.7
....................             { 
....................                if(((struct oNoFF)mydevices.myoutputs[x].device).off.value) 
03016:  CLRF   x6F
03018:  MOVFF  41F,46E
0301C:  CLRF   x71
0301E:  MOVLW  23
03020:  MOVWF  x70
03022:  MOVLB  0
03024:  CALL   031E
03028:  BTFSC  1B.7
0302A:  BSF    FF2.7
0302C:  MOVF   01,W
0302E:  ADDLW  B6
03030:  MOVLB  4
03032:  MOVWF  x21
03034:  MOVLW  00
03036:  ADDWFC 02,W
03038:  MOVWF  x22
0303A:  MOVLW  01
0303C:  ADDWF  x21,W
0303E:  MOVWF  01
03040:  MOVLW  00
03042:  ADDWFC x22,W
03044:  MOVWF  03
03046:  MOVF   01,W
03048:  ADDLW  3A
0304A:  MOVWF  01
0304C:  MOVLW  01
0304E:  ADDWFC 03,F
03050:  MOVF   01,W
03052:  ADDLW  12
03054:  MOVWF  FE9
03056:  MOVLW  00
03058:  ADDWFC 03,W
0305A:  MOVWF  FEA
0305C:  MOVF   FEF,F
0305E:  BTFSC  FD8.2
03060:  BRA    31A2
03062:  CLRF   1B
03064:  BTFSC  FF2.7
03066:  BSF    1B.7
03068:  BCF    FF2.7
....................                { 
....................                   onoffsvalue=onoffsvalue|~light_pins[((struct oNoFF)mydevices.myoutputs[x].device).output_pin]; 
0306A:  CLRF   x6F
0306C:  MOVFF  41F,46E
03070:  CLRF   x71
03072:  MOVLW  23
03074:  MOVWF  x70
03076:  MOVLB  0
03078:  CALL   031E
0307C:  BTFSC  1B.7
0307E:  BSF    FF2.7
03080:  MOVF   01,W
03082:  ADDLW  B6
03084:  MOVLB  4
03086:  MOVWF  x21
03088:  MOVLW  00
0308A:  ADDWFC 02,W
0308C:  MOVWF  x22
0308E:  MOVLW  01
03090:  ADDWF  x21,W
03092:  MOVWF  01
03094:  MOVLW  00
03096:  ADDWFC x22,W
03098:  MOVWF  03
0309A:  MOVF   01,W
0309C:  ADDLW  3A
0309E:  MOVWF  01
030A0:  MOVLW  01
030A2:  ADDWFC 03,F
030A4:  MOVF   01,W
030A6:  ADDLW  14
030A8:  MOVWF  FE9
030AA:  MOVLW  00
030AC:  ADDWFC 03,W
030AE:  MOVWF  FEA
030B0:  BCF    FD8.0
030B2:  RLCF   FEF,W
030B4:  CLRF   03
030B6:  MOVLB  0
030B8:  CALL   0172
030BC:  TBLRD*+
030BE:  MOVFF  FF5,03
030C2:  CLRF   00
030C4:  DECF   00,F
030C6:  XORWF  00,F
030C8:  MOVLW  FF
030CA:  XORWF  03,F
030CC:  MOVF   00,W
030CE:  MOVLB  3
030D0:  IORWF  x55,F
030D2:  MOVF   03,W
030D4:  IORWF  x56,F
030D6:  CLRF   1B
030D8:  BTFSC  FF2.7
030DA:  BSF    1B.7
030DC:  BCF    FF2.7
....................                   printf("onoff off value %LX %LX",onoffsvalue,~light_pins[((struct oNoFF)mydevices.myoutputs[x].device).output_pin]); 
030DE:  MOVLB  4
030E0:  CLRF   x6F
030E2:  MOVFF  41F,46E
030E6:  CLRF   x71
030E8:  MOVLW  23
030EA:  MOVWF  x70
030EC:  MOVLB  0
030EE:  CALL   031E
030F2:  BTFSC  1B.7
030F4:  BSF    FF2.7
030F6:  MOVF   01,W
030F8:  ADDLW  B6
030FA:  MOVLB  4
030FC:  MOVWF  x21
030FE:  MOVLW  00
03100:  ADDWFC 02,W
03102:  MOVWF  x22
03104:  MOVLW  01
03106:  ADDWF  x21,W
03108:  MOVWF  01
0310A:  MOVLW  00
0310C:  ADDWFC x22,W
0310E:  MOVWF  03
03110:  MOVF   01,W
03112:  ADDLW  3A
03114:  MOVWF  01
03116:  MOVLW  01
03118:  ADDWFC 03,F
0311A:  MOVF   01,W
0311C:  ADDLW  14
0311E:  MOVWF  FE9
03120:  MOVLW  00
03122:  ADDWFC 03,W
03124:  MOVWF  FEA
03126:  BCF    FD8.0
03128:  RLCF   FEF,W
0312A:  CLRF   03
0312C:  MOVLB  0
0312E:  CALL   0172
03132:  TBLRD*+
03134:  MOVFF  FF5,03
03138:  XORLW  FF
0313A:  MOVLB  4
0313C:  MOVWF  x23
0313E:  MOVLW  FF
03140:  XORWF  03,W
03142:  MOVWF  x24
03144:  MOVLW  BA
03146:  MOVWF  FF6
03148:  MOVLW  02
0314A:  MOVWF  FF7
0314C:  MOVLW  00
0314E:  MOVWF  FF8
03150:  MOVLW  10
03152:  MOVWF  x25
03154:  MOVLB  0
03156:  RCALL  295A
03158:  MOVFF  356,425
0315C:  MOVLW  37
0315E:  MOVLB  4
03160:  MOVWF  x26
03162:  MOVLB  0
03164:  RCALL  298A
03166:  MOVFF  355,425
0316A:  MOVLW  37
0316C:  MOVLB  4
0316E:  MOVWF  x26
03170:  MOVLB  0
03172:  RCALL  298A
03174:  MOVLW  20
03176:  MOVLB  4
03178:  MOVWF  x2C
0317A:  MOVLB  0
0317C:  CALL   2914
03180:  MOVFF  424,425
03184:  MOVLW  37
03186:  MOVLB  4
03188:  MOVWF  x26
0318A:  MOVLB  0
0318C:  CALL   298A
03190:  MOVFF  423,425
03194:  MOVLW  37
03196:  MOVLB  4
03198:  MOVWF  x26
0319A:  MOVLB  0
0319C:  CALL   298A
031A0:  MOVLB  4
031A2:  CLRF   1B
031A4:  BTFSC  FF2.7
031A6:  BSF    1B.7
031A8:  BCF    FF2.7
....................                } 
....................                ((struct oNoFF)mydevices.myoutputs[x].device).off.needs_update=false; 
031AA:  CLRF   x6F
031AC:  MOVFF  41F,46E
031B0:  CLRF   x71
031B2:  MOVLW  23
031B4:  MOVWF  x70
031B6:  MOVLB  0
031B8:  CALL   031E
031BC:  BTFSC  1B.7
031BE:  BSF    FF2.7
031C0:  MOVF   01,W
031C2:  ADDLW  B6
031C4:  MOVLB  4
031C6:  MOVWF  x21
031C8:  MOVLW  00
031CA:  ADDWFC 02,W
031CC:  MOVWF  x22
031CE:  MOVLW  01
031D0:  ADDWF  x21,W
031D2:  MOVWF  01
031D4:  MOVLW  00
031D6:  ADDWFC x22,W
031D8:  MOVWF  03
031DA:  MOVF   01,W
031DC:  ADDLW  3A
031DE:  MOVWF  01
031E0:  MOVLW  01
031E2:  ADDWFC 03,F
031E4:  MOVF   01,W
031E6:  ADDLW  13
031E8:  MOVWF  FE9
031EA:  MOVLW  00
031EC:  ADDWFC 03,W
031EE:  MOVWF  FEA
031F0:  BCF    FEF.0
031F2:  CLRF   1B
031F4:  BTFSC  FF2.7
031F6:  BSF    1B.7
031F8:  BCF    FF2.7
....................             } 
....................              
....................             if(((struct oNoFF)mydevices.myoutputs[x].device).on.needs_update) 
031FA:  CLRF   x6F
031FC:  MOVFF  41F,46E
03200:  CLRF   x71
03202:  MOVLW  23
03204:  MOVWF  x70
03206:  MOVLB  0
03208:  CALL   031E
0320C:  BTFSC  1B.7
0320E:  BSF    FF2.7
03210:  MOVF   01,W
03212:  ADDLW  B6
03214:  MOVLB  4
03216:  MOVWF  x21
03218:  MOVLW  00
0321A:  ADDWFC 02,W
0321C:  MOVWF  x22
0321E:  MOVLW  01
03220:  ADDWF  x21,W
03222:  MOVWF  01
03224:  MOVLW  00
03226:  ADDWFC x22,W
03228:  MOVWF  03
0322A:  MOVF   01,W
0322C:  ADDLW  3A
0322E:  MOVWF  01
03230:  MOVLW  01
03232:  ADDWFC 03,F
03234:  MOVF   01,W
03236:  ADDLW  09
03238:  MOVWF  FE9
0323A:  MOVLW  00
0323C:  ADDWFC 03,W
0323E:  MOVWF  FEA
03240:  BTFSS  FEF.0
03242:  BRA    339C
....................             { 
....................                printf("onoff on"); 
03244:  MOVLW  D2
03246:  MOVWF  FF6
03248:  MOVLW  02
0324A:  MOVWF  FF7
0324C:  MOVLW  00
0324E:  MOVWF  FF8
03250:  MOVLB  0
03252:  CALL   29D0
03256:  CLRF   1B
03258:  BTFSC  FF2.7
0325A:  BSF    1B.7
0325C:  BCF    FF2.7
....................                if(((struct oNoFF)mydevices.myoutputs[x].device).on.value) 
0325E:  MOVLB  4
03260:  CLRF   x6F
03262:  MOVFF  41F,46E
03266:  CLRF   x71
03268:  MOVLW  23
0326A:  MOVWF  x70
0326C:  MOVLB  0
0326E:  CALL   031E
03272:  BTFSC  1B.7
03274:  BSF    FF2.7
03276:  MOVF   01,W
03278:  ADDLW  B6
0327A:  MOVLB  4
0327C:  MOVWF  x21
0327E:  MOVLW  00
03280:  ADDWFC 02,W
03282:  MOVWF  x22
03284:  MOVLW  01
03286:  ADDWF  x21,W
03288:  MOVWF  01
0328A:  MOVLW  00
0328C:  ADDWFC x22,W
0328E:  MOVWF  03
03290:  MOVF   01,W
03292:  ADDLW  3A
03294:  MOVWF  01
03296:  MOVLW  01
03298:  ADDWFC 03,F
0329A:  MOVF   01,W
0329C:  ADDLW  08
0329E:  MOVWF  FE9
032A0:  MOVLW  00
032A2:  ADDWFC 03,W
032A4:  MOVWF  FEA
032A6:  MOVF   FEF,F
032A8:  BZ    334C
032AA:  CLRF   1B
032AC:  BTFSC  FF2.7
032AE:  BSF    1B.7
032B0:  BCF    FF2.7
....................                { 
....................                   onoffsvalue=onoffsvalue & light_pins[((struct oNoFF)mydevices.myoutputs[x].device).output_pin]; 
032B2:  CLRF   x6F
032B4:  MOVFF  41F,46E
032B8:  CLRF   x71
032BA:  MOVLW  23
032BC:  MOVWF  x70
032BE:  MOVLB  0
032C0:  CALL   031E
032C4:  BTFSC  1B.7
032C6:  BSF    FF2.7
032C8:  MOVF   01,W
032CA:  ADDLW  B6
032CC:  MOVLB  4
032CE:  MOVWF  x21
032D0:  MOVLW  00
032D2:  ADDWFC 02,W
032D4:  MOVWF  x22
032D6:  MOVLW  01
032D8:  ADDWF  x21,W
032DA:  MOVWF  01
032DC:  MOVLW  00
032DE:  ADDWFC x22,W
032E0:  MOVWF  03
032E2:  MOVF   01,W
032E4:  ADDLW  3A
032E6:  MOVWF  01
032E8:  MOVLW  01
032EA:  ADDWFC 03,F
032EC:  MOVF   01,W
032EE:  ADDLW  14
032F0:  MOVWF  FE9
032F2:  MOVLW  00
032F4:  ADDWFC 03,W
032F6:  MOVWF  FEA
032F8:  BCF    FD8.0
032FA:  RLCF   FEF,W
032FC:  CLRF   03
032FE:  MOVLB  0
03300:  CALL   0172
03304:  TBLRD*+
03306:  MOVFF  FF5,03
0330A:  MOVLB  3
0330C:  ANDWF  x55,F
0330E:  MOVF   03,W
03310:  ANDWF  x56,F
....................                   printf("onoff on value %LX",onoffsvalue); 
03312:  MOVLW  DC
03314:  MOVWF  FF6
03316:  MOVLW  02
03318:  MOVWF  FF7
0331A:  MOVLW  00
0331C:  MOVWF  FF8
0331E:  MOVLW  0F
03320:  MOVLB  4
03322:  MOVWF  x25
03324:  MOVLB  0
03326:  CALL   295A
0332A:  MOVFF  356,425
0332E:  MOVLW  37
03330:  MOVLB  4
03332:  MOVWF  x26
03334:  MOVLB  0
03336:  CALL   298A
0333A:  MOVFF  355,425
0333E:  MOVLW  37
03340:  MOVLB  4
03342:  MOVWF  x26
03344:  MOVLB  0
03346:  CALL   298A
0334A:  MOVLB  4
0334C:  CLRF   1B
0334E:  BTFSC  FF2.7
03350:  BSF    1B.7
03352:  BCF    FF2.7
....................                } 
....................                ((struct light)mydevices.myoutputs[x].device).on.needs_update=false; 
03354:  CLRF   x6F
03356:  MOVFF  41F,46E
0335A:  CLRF   x71
0335C:  MOVLW  23
0335E:  MOVWF  x70
03360:  MOVLB  0
03362:  CALL   031E
03366:  BTFSC  1B.7
03368:  BSF    FF2.7
0336A:  MOVF   01,W
0336C:  ADDLW  B6
0336E:  MOVLB  4
03370:  MOVWF  x21
03372:  MOVLW  00
03374:  ADDWFC 02,W
03376:  MOVWF  x22
03378:  MOVLW  01
0337A:  ADDWF  x21,W
0337C:  MOVWF  01
0337E:  MOVLW  00
03380:  ADDWFC x22,W
03382:  MOVWF  03
03384:  MOVF   01,W
03386:  ADDLW  3A
03388:  MOVWF  01
0338A:  MOVLW  01
0338C:  ADDWFC 03,F
0338E:  MOVF   01,W
03390:  ADDLW  09
03392:  MOVWF  FE9
03394:  MOVLW  00
03396:  ADDWFC 03,W
03398:  MOVWF  FEA
0339A:  BCF    FEF.0
....................             } 
....................          break; 
0339C:  MOVLB  0
0339E:  BRA    33A0
....................       } 
....................    } 
033A0:  MOVLB  4
033A2:  INCF   x1F,F
033A4:  GOTO   29FE
....................    if(update_dimmers) 
033A8:  BTFSS  x20.0
033AA:  BRA    33B4
....................       org(); 
033AC:  MOVLB  0
033AE:  CALL   2134
033B2:  MOVLB  4
.................... } 
033B4:  MOVLB  0
033B6:  RETLW  00
....................  
.................... void dimmer_test() 
.................... { 
....................    mydevices.numberOfoutputs=1; 
*
020BC:  MOVLW  01
020BE:  MOVLB  1
020C0:  MOVWF  x3B
....................    unsigned int dim_adr[8]={1,21,31,255,255,255,255,255}; 
020C2:  MOVLB  4
020C4:  MOVWF  x1F
020C6:  MOVLW  15
020C8:  MOVWF  x20
020CA:  MOVLW  1F
020CC:  MOVWF  x21
020CE:  MOVLW  FF
020D0:  MOVWF  x22
020D2:  MOVWF  x23
020D4:  MOVWF  x24
020D6:  MOVWF  x25
020D8:  MOVWF  x26
....................    unsigned int off_adr[8]={3,51,61,255,255,255,255,255}; 
020DA:  MOVLW  03
020DC:  MOVWF  x27
020DE:  MOVLW  33
020E0:  MOVWF  x28
020E2:  MOVLW  3D
020E4:  MOVWF  x29
020E6:  MOVLW  FF
020E8:  MOVWF  x2A
020EA:  MOVWF  x2B
020EC:  MOVWF  x2C
020EE:  MOVWF  x2D
020F0:  MOVWF  x2E
....................    unsigned int on_adr[8]={2,81,91,255,255,255,255,255}; 
020F2:  MOVLW  02
020F4:  MOVWF  x2F
020F6:  MOVLW  51
020F8:  MOVWF  x30
020FA:  MOVLW  5B
020FC:  MOVWF  x31
020FE:  MOVLW  FF
02100:  MOVWF  x32
02102:  MOVWF  x33
02104:  MOVWF  x34
02106:  MOVWF  x35
02108:  MOVWF  x36
....................    dimmer_out_init(dim_adr,on_adr,off_adr,&mydevices.myoutputs[0],0); 
0210A:  MOVLW  04
0210C:  MOVWF  x38
0210E:  MOVLW  1F
02110:  MOVWF  x37
02112:  MOVLW  04
02114:  MOVWF  x3A
02116:  MOVLW  2F
02118:  MOVWF  x39
0211A:  MOVLW  04
0211C:  MOVWF  x3C
0211E:  MOVLW  27
02120:  MOVWF  x3B
02122:  MOVLW  01
02124:  MOVWF  x3E
02126:  MOVLW  F0
02128:  MOVWF  x3D
0212A:  CLRF   x3F
0212C:  MOVLB  0
0212E:  BRA    1F3A
....................   // onOff_out_init(on_adr,off_adr,&mydevices.myoutputs[0],0); 
.................... } 
02130:  GOTO   427E (RETURN)
....................  
....................  
.................... #include "datapoints.c" 
.................... int1 array_contains(struct data_point_in* array,unsigned int value) 
.................... { 
....................    int x; 
....................    for(x=0;x<8;++x) 
*
033D6:  MOVLB  4
033D8:  CLRF   x32
033DA:  MOVF   x32,W
033DC:  SUBLW  07
033DE:  BNC   33FE
....................    { 
....................      // printf("array[%d]=%u for value %u\n\r",x,((struct data_point_in*) array)->adress[x],value); 
....................      // delay_ms(100); 
....................       if(((struct data_point_in*) array)->adress[x]==value) return true;      
033E0:  CLRF   03
033E2:  MOVF   x32,W
033E4:  ADDWF  x2F,W
033E6:  MOVWF  FE9
033E8:  MOVF   x30,W
033EA:  ADDWFC 03,W
033EC:  MOVWF  FEA
033EE:  MOVF   x31,W
033F0:  SUBWF  FEF,W
033F2:  BNZ   33FA
033F4:  MOVLW  01
033F6:  MOVWF  01
033F8:  BRA    3402
....................    } 
033FA:  INCF   x32,F
033FC:  BRA    33DA
....................    return false; 
033FE:  MOVLW  00
03400:  MOVWF  01
.................... } 
03402:  MOVLB  0
03404:  RETLW  00
....................  
.................... void process_inpoints(unsigned int datapoint, unsigned int value)//processa os datapoints de entrada que estao associados a saidas reais 
.................... { 
....................    int x; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
03406:  MOVLB  4
03408:  CLRF   x2A
0340A:  MOVLB  1
0340C:  MOVF   x3B,W
0340E:  MOVLB  4
03410:  SUBWF  x2A,W
03412:  BTFSC  FD8.0
03414:  BRA    39AE
03416:  CLRF   1B
03418:  BTFSC  FF2.7
0341A:  BSF    1B.7
0341C:  BCF    FF2.7
....................    { 
....................       switch (((struct outputs)mydevices.myoutputs[x]).type) { 
0341E:  CLRF   x6F
03420:  MOVFF  42A,46E
03424:  CLRF   x71
03426:  MOVLW  23
03428:  MOVWF  x70
0342A:  MOVLB  0
0342C:  CALL   031E
03430:  BTFSC  1B.7
03432:  BSF    FF2.7
03434:  MOVFF  02,03
03438:  MOVF   01,W
0343A:  ADDLW  F0
0343C:  MOVWF  01
0343E:  MOVLW  01
03440:  ADDWFC 03,F
03442:  MOVFF  01,FE9
03446:  MOVFF  03,FEA
0344A:  MOVF   FEF,W
0344C:  XORLW  01
0344E:  BZ    345E
03450:  XORLW  01
03452:  BTFSC  FD8.2
03454:  BRA    378A
03456:  XORLW  02
03458:  BTFSC  FD8.2
0345A:  BRA    39A4
0345C:  BRA    39A6
....................  
....................     case dimmer: 
0345E:  CLRF   1B
03460:  BTFSC  FF2.7
03462:  BSF    1B.7
03464:  BCF    FF2.7
....................           //  printf("process datapoint %d with value %d\n",datapoint,value); 
....................            if (array_contains(&((struct light)mydevices.myoutputs[x].device).dim_value,datapoint)) 
03466:  MOVLB  4
03468:  CLRF   x6F
0346A:  MOVFF  42A,46E
0346E:  CLRF   x71
03470:  MOVLW  23
03472:  MOVWF  x70
03474:  MOVLB  0
03476:  CALL   031E
0347A:  BTFSC  1B.7
0347C:  BSF    FF2.7
0347E:  MOVF   01,W
03480:  ADDLW  B6
03482:  MOVLB  4
03484:  MOVWF  x2B
03486:  MOVLW  00
03488:  ADDWFC 02,W
0348A:  MOVWF  x2C
0348C:  MOVLW  01
0348E:  ADDWF  x2B,W
03490:  MOVWF  01
03492:  MOVLW  00
03494:  ADDWFC x2C,W
03496:  MOVWF  03
03498:  MOVF   01,W
0349A:  ADDLW  3A
0349C:  MOVWF  01
0349E:  MOVLW  01
034A0:  ADDWFC 03,F
034A2:  MOVF   01,W
034A4:  ADDLW  14
034A6:  MOVWF  01
034A8:  MOVLW  00
034AA:  ADDWFC 03,F
034AC:  MOVFF  01,42D
034B0:  MOVFF  03,42E
034B4:  MOVFF  03,430
034B8:  MOVFF  01,42F
034BC:  MOVFF  428,431
034C0:  MOVLB  0
034C2:  RCALL  33D6
034C4:  MOVF   01,F
034C6:  BZ    3570
034C8:  CLRF   1B
034CA:  BTFSC  FF2.7
034CC:  BSF    1B.7
034CE:  BCF    FF2.7
....................            { 
....................                ((struct light)mydevices.myoutputs[x].device).dim_value.value=value; 
034D0:  MOVLB  4
034D2:  CLRF   x6F
034D4:  MOVFF  42A,46E
034D8:  CLRF   x71
034DA:  MOVLW  23
034DC:  MOVWF  x70
034DE:  MOVLB  0
034E0:  CALL   031E
034E4:  BTFSC  1B.7
034E6:  BSF    FF2.7
034E8:  MOVF   01,W
034EA:  ADDLW  B6
034EC:  MOVLB  4
034EE:  MOVWF  x2B
034F0:  MOVLW  00
034F2:  ADDWFC 02,W
034F4:  MOVWF  x2C
034F6:  MOVLW  01
034F8:  ADDWF  x2B,W
034FA:  MOVWF  01
034FC:  MOVLW  00
034FE:  ADDWFC x2C,W
03500:  MOVWF  03
03502:  MOVF   01,W
03504:  ADDLW  3A
03506:  MOVWF  01
03508:  MOVLW  01
0350A:  ADDWFC 03,F
0350C:  MOVF   01,W
0350E:  ADDLW  1C
03510:  MOVWF  FE9
03512:  MOVLW  00
03514:  ADDWFC 03,W
03516:  MOVWF  FEA
03518:  MOVFF  429,FEF
0351C:  CLRF   1B
0351E:  BTFSC  FF2.7
03520:  BSF    1B.7
03522:  BCF    FF2.7
....................                ((struct light)mydevices.myoutputs[x].device).dim_value.needs_update=true; 
03524:  CLRF   x6F
03526:  MOVFF  42A,46E
0352A:  CLRF   x71
0352C:  MOVLW  23
0352E:  MOVWF  x70
03530:  MOVLB  0
03532:  CALL   031E
03536:  BTFSC  1B.7
03538:  BSF    FF2.7
0353A:  MOVF   01,W
0353C:  ADDLW  B6
0353E:  MOVLB  4
03540:  MOVWF  x2B
03542:  MOVLW  00
03544:  ADDWFC 02,W
03546:  MOVWF  x2C
03548:  MOVLW  01
0354A:  ADDWF  x2B,W
0354C:  MOVWF  01
0354E:  MOVLW  00
03550:  ADDWFC x2C,W
03552:  MOVWF  03
03554:  MOVF   01,W
03556:  ADDLW  3A
03558:  MOVWF  01
0355A:  MOVLW  01
0355C:  ADDWFC 03,F
0355E:  MOVF   01,W
03560:  ADDLW  1D
03562:  MOVWF  FE9
03564:  MOVLW  00
03566:  ADDWFC 03,W
03568:  MOVWF  FEA
0356A:  BSF    FEF.0
....................            } 
....................            else if (array_contains(&((struct light)mydevices.myoutputs[x].device).on,datapoint)) 
0356C:  BRA    3786
0356E:  MOVLB  0
03570:  CLRF   1B
03572:  BTFSC  FF2.7
03574:  BSF    1B.7
03576:  BCF    FF2.7
03578:  MOVLB  4
0357A:  CLRF   x6F
0357C:  MOVFF  42A,46E
03580:  CLRF   x71
03582:  MOVLW  23
03584:  MOVWF  x70
03586:  MOVLB  0
03588:  CALL   031E
0358C:  BTFSC  1B.7
0358E:  BSF    FF2.7
03590:  MOVF   01,W
03592:  ADDLW  B6
03594:  MOVLB  4
03596:  MOVWF  x2B
03598:  MOVLW  00
0359A:  ADDWFC 02,W
0359C:  MOVWF  x2C
0359E:  MOVLW  01
035A0:  ADDWF  x2B,W
035A2:  MOVWF  01
035A4:  MOVLW  00
035A6:  ADDWFC x2C,W
035A8:  MOVWF  03
035AA:  MOVF   01,W
035AC:  ADDLW  3A
035AE:  MOVWF  01
035B0:  MOVLW  01
035B2:  ADDWFC 03,F
035B4:  MOVFF  01,42D
035B8:  MOVFF  03,42E
035BC:  MOVFF  03,430
035C0:  MOVFF  01,42F
035C4:  MOVFF  428,431
035C8:  MOVLB  0
035CA:  RCALL  33D6
035CC:  MOVF   01,F
035CE:  BZ    3678
035D0:  CLRF   1B
035D2:  BTFSC  FF2.7
035D4:  BSF    1B.7
035D6:  BCF    FF2.7
....................            { 
....................            //printf("*on\n"); 
....................                ((struct light)mydevices.myoutputs[x].device).on.value=value; 
035D8:  MOVLB  4
035DA:  CLRF   x6F
035DC:  MOVFF  42A,46E
035E0:  CLRF   x71
035E2:  MOVLW  23
035E4:  MOVWF  x70
035E6:  MOVLB  0
035E8:  CALL   031E
035EC:  BTFSC  1B.7
035EE:  BSF    FF2.7
035F0:  MOVF   01,W
035F2:  ADDLW  B6
035F4:  MOVLB  4
035F6:  MOVWF  x2B
035F8:  MOVLW  00
035FA:  ADDWFC 02,W
035FC:  MOVWF  x2C
035FE:  MOVLW  01
03600:  ADDWF  x2B,W
03602:  MOVWF  01
03604:  MOVLW  00
03606:  ADDWFC x2C,W
03608:  MOVWF  03
0360A:  MOVF   01,W
0360C:  ADDLW  3A
0360E:  MOVWF  01
03610:  MOVLW  01
03612:  ADDWFC 03,F
03614:  MOVF   01,W
03616:  ADDLW  08
03618:  MOVWF  FE9
0361A:  MOVLW  00
0361C:  ADDWFC 03,W
0361E:  MOVWF  FEA
03620:  MOVFF  429,FEF
03624:  CLRF   1B
03626:  BTFSC  FF2.7
03628:  BSF    1B.7
0362A:  BCF    FF2.7
....................                ((struct light)mydevices.myoutputs[x].device).on.needs_update=true; 
0362C:  CLRF   x6F
0362E:  MOVFF  42A,46E
03632:  CLRF   x71
03634:  MOVLW  23
03636:  MOVWF  x70
03638:  MOVLB  0
0363A:  CALL   031E
0363E:  BTFSC  1B.7
03640:  BSF    FF2.7
03642:  MOVF   01,W
03644:  ADDLW  B6
03646:  MOVLB  4
03648:  MOVWF  x2B
0364A:  MOVLW  00
0364C:  ADDWFC 02,W
0364E:  MOVWF  x2C
03650:  MOVLW  01
03652:  ADDWF  x2B,W
03654:  MOVWF  01
03656:  MOVLW  00
03658:  ADDWFC x2C,W
0365A:  MOVWF  03
0365C:  MOVF   01,W
0365E:  ADDLW  3A
03660:  MOVWF  01
03662:  MOVLW  01
03664:  ADDWFC 03,F
03666:  MOVF   01,W
03668:  ADDLW  09
0366A:  MOVWF  FE9
0366C:  MOVLW  00
0366E:  ADDWFC 03,W
03670:  MOVWF  FEA
03672:  BSF    FEF.0
....................            } 
....................            else if (array_contains(&((struct light)mydevices.myoutputs[x].device).off,datapoint)) 
03674:  BRA    3786
03676:  MOVLB  0
03678:  CLRF   1B
0367A:  BTFSC  FF2.7
0367C:  BSF    1B.7
0367E:  BCF    FF2.7
03680:  MOVLB  4
03682:  CLRF   x6F
03684:  MOVFF  42A,46E
03688:  CLRF   x71
0368A:  MOVLW  23
0368C:  MOVWF  x70
0368E:  MOVLB  0
03690:  CALL   031E
03694:  BTFSC  1B.7
03696:  BSF    FF2.7
03698:  MOVF   01,W
0369A:  ADDLW  B6
0369C:  MOVLB  4
0369E:  MOVWF  x2B
036A0:  MOVLW  00
036A2:  ADDWFC 02,W
036A4:  MOVWF  x2C
036A6:  MOVLW  01
036A8:  ADDWF  x2B,W
036AA:  MOVWF  01
036AC:  MOVLW  00
036AE:  ADDWFC x2C,W
036B0:  MOVWF  03
036B2:  MOVF   01,W
036B4:  ADDLW  3A
036B6:  MOVWF  01
036B8:  MOVLW  01
036BA:  ADDWFC 03,F
036BC:  MOVF   01,W
036BE:  ADDLW  0A
036C0:  MOVWF  01
036C2:  MOVLW  00
036C4:  ADDWFC 03,F
036C6:  MOVFF  01,42D
036CA:  MOVFF  03,42E
036CE:  MOVFF  03,430
036D2:  MOVFF  01,42F
036D6:  MOVFF  428,431
036DA:  MOVLB  0
036DC:  RCALL  33D6
036DE:  MOVF   01,F
036E0:  BZ    3788
036E2:  CLRF   1B
036E4:  BTFSC  FF2.7
036E6:  BSF    1B.7
036E8:  BCF    FF2.7
....................            { 
....................            //printf("*off\n"); 
....................                ((struct light)mydevices.myoutputs[x].device).off.value=value; 
036EA:  MOVLB  4
036EC:  CLRF   x6F
036EE:  MOVFF  42A,46E
036F2:  CLRF   x71
036F4:  MOVLW  23
036F6:  MOVWF  x70
036F8:  MOVLB  0
036FA:  CALL   031E
036FE:  BTFSC  1B.7
03700:  BSF    FF2.7
03702:  MOVF   01,W
03704:  ADDLW  B6
03706:  MOVLB  4
03708:  MOVWF  x2B
0370A:  MOVLW  00
0370C:  ADDWFC 02,W
0370E:  MOVWF  x2C
03710:  MOVLW  01
03712:  ADDWF  x2B,W
03714:  MOVWF  01
03716:  MOVLW  00
03718:  ADDWFC x2C,W
0371A:  MOVWF  03
0371C:  MOVF   01,W
0371E:  ADDLW  3A
03720:  MOVWF  01
03722:  MOVLW  01
03724:  ADDWFC 03,F
03726:  MOVF   01,W
03728:  ADDLW  12
0372A:  MOVWF  FE9
0372C:  MOVLW  00
0372E:  ADDWFC 03,W
03730:  MOVWF  FEA
03732:  MOVFF  429,FEF
03736:  CLRF   1B
03738:  BTFSC  FF2.7
0373A:  BSF    1B.7
0373C:  BCF    FF2.7
....................                ((struct light)mydevices.myoutputs[x].device).off.needs_update=true; 
0373E:  CLRF   x6F
03740:  MOVFF  42A,46E
03744:  CLRF   x71
03746:  MOVLW  23
03748:  MOVWF  x70
0374A:  MOVLB  0
0374C:  CALL   031E
03750:  BTFSC  1B.7
03752:  BSF    FF2.7
03754:  MOVF   01,W
03756:  ADDLW  B6
03758:  MOVLB  4
0375A:  MOVWF  x2B
0375C:  MOVLW  00
0375E:  ADDWFC 02,W
03760:  MOVWF  x2C
03762:  MOVLW  01
03764:  ADDWF  x2B,W
03766:  MOVWF  01
03768:  MOVLW  00
0376A:  ADDWFC x2C,W
0376C:  MOVWF  03
0376E:  MOVF   01,W
03770:  ADDLW  3A
03772:  MOVWF  01
03774:  MOVLW  01
03776:  ADDWFC 03,F
03778:  MOVF   01,W
0377A:  ADDLW  13
0377C:  MOVWF  FE9
0377E:  MOVLW  00
03780:  ADDWFC 03,W
03782:  MOVWF  FEA
03784:  BSF    FEF.0
03786:  MOVLB  0
....................            } 
....................            break; 
03788:  BRA    39A8
....................  
....................     case _on_off: 
0378A:  CLRF   1B
0378C:  BTFSC  FF2.7
0378E:  BSF    1B.7
03790:  BCF    FF2.7
....................           if (array_contains(&((struct oNoFF)mydevices.myoutputs[x].device).on,datapoint)) 
03792:  MOVLB  4
03794:  CLRF   x6F
03796:  MOVFF  42A,46E
0379A:  CLRF   x71
0379C:  MOVLW  23
0379E:  MOVWF  x70
037A0:  MOVLB  0
037A2:  CALL   031E
037A6:  BTFSC  1B.7
037A8:  BSF    FF2.7
037AA:  MOVF   01,W
037AC:  ADDLW  B6
037AE:  MOVLB  4
037B0:  MOVWF  x2B
037B2:  MOVLW  00
037B4:  ADDWFC 02,W
037B6:  MOVWF  x2C
037B8:  MOVLW  01
037BA:  ADDWF  x2B,W
037BC:  MOVWF  01
037BE:  MOVLW  00
037C0:  ADDWFC x2C,W
037C2:  MOVWF  03
037C4:  MOVF   01,W
037C6:  ADDLW  3A
037C8:  MOVWF  01
037CA:  MOVLW  01
037CC:  ADDWFC 03,F
037CE:  MOVFF  01,42D
037D2:  MOVFF  03,42E
037D6:  MOVFF  03,430
037DA:  MOVFF  01,42F
037DE:  MOVFF  428,431
037E2:  MOVLB  0
037E4:  RCALL  33D6
037E6:  MOVF   01,F
037E8:  BZ    3892
037EA:  CLRF   1B
037EC:  BTFSC  FF2.7
037EE:  BSF    1B.7
037F0:  BCF    FF2.7
....................            { 
....................                ((struct oNoFF)mydevices.myoutputs[x].device).on.value=value; 
037F2:  MOVLB  4
037F4:  CLRF   x6F
037F6:  MOVFF  42A,46E
037FA:  CLRF   x71
037FC:  MOVLW  23
037FE:  MOVWF  x70
03800:  MOVLB  0
03802:  CALL   031E
03806:  BTFSC  1B.7
03808:  BSF    FF2.7
0380A:  MOVF   01,W
0380C:  ADDLW  B6
0380E:  MOVLB  4
03810:  MOVWF  x2B
03812:  MOVLW  00
03814:  ADDWFC 02,W
03816:  MOVWF  x2C
03818:  MOVLW  01
0381A:  ADDWF  x2B,W
0381C:  MOVWF  01
0381E:  MOVLW  00
03820:  ADDWFC x2C,W
03822:  MOVWF  03
03824:  MOVF   01,W
03826:  ADDLW  3A
03828:  MOVWF  01
0382A:  MOVLW  01
0382C:  ADDWFC 03,F
0382E:  MOVF   01,W
03830:  ADDLW  08
03832:  MOVWF  FE9
03834:  MOVLW  00
03836:  ADDWFC 03,W
03838:  MOVWF  FEA
0383A:  MOVFF  429,FEF
0383E:  CLRF   1B
03840:  BTFSC  FF2.7
03842:  BSF    1B.7
03844:  BCF    FF2.7
....................                ((struct oNoFF)mydevices.myoutputs[x].device).on.needs_update=true; 
03846:  CLRF   x6F
03848:  MOVFF  42A,46E
0384C:  CLRF   x71
0384E:  MOVLW  23
03850:  MOVWF  x70
03852:  MOVLB  0
03854:  CALL   031E
03858:  BTFSC  1B.7
0385A:  BSF    FF2.7
0385C:  MOVF   01,W
0385E:  ADDLW  B6
03860:  MOVLB  4
03862:  MOVWF  x2B
03864:  MOVLW  00
03866:  ADDWFC 02,W
03868:  MOVWF  x2C
0386A:  MOVLW  01
0386C:  ADDWF  x2B,W
0386E:  MOVWF  01
03870:  MOVLW  00
03872:  ADDWFC x2C,W
03874:  MOVWF  03
03876:  MOVF   01,W
03878:  ADDLW  3A
0387A:  MOVWF  01
0387C:  MOVLW  01
0387E:  ADDWFC 03,F
03880:  MOVF   01,W
03882:  ADDLW  09
03884:  MOVWF  FE9
03886:  MOVLW  00
03888:  ADDWFC 03,W
0388A:  MOVWF  FEA
0388C:  BSF    FEF.0
....................            } 
....................            else if (array_contains(&((struct oNoFF)mydevices.myoutputs[x].device).off,datapoint)) 
0388E:  BRA    39A0
03890:  MOVLB  0
03892:  CLRF   1B
03894:  BTFSC  FF2.7
03896:  BSF    1B.7
03898:  BCF    FF2.7
0389A:  MOVLB  4
0389C:  CLRF   x6F
0389E:  MOVFF  42A,46E
038A2:  CLRF   x71
038A4:  MOVLW  23
038A6:  MOVWF  x70
038A8:  MOVLB  0
038AA:  CALL   031E
038AE:  BTFSC  1B.7
038B0:  BSF    FF2.7
038B2:  MOVF   01,W
038B4:  ADDLW  B6
038B6:  MOVLB  4
038B8:  MOVWF  x2B
038BA:  MOVLW  00
038BC:  ADDWFC 02,W
038BE:  MOVWF  x2C
038C0:  MOVLW  01
038C2:  ADDWF  x2B,W
038C4:  MOVWF  01
038C6:  MOVLW  00
038C8:  ADDWFC x2C,W
038CA:  MOVWF  03
038CC:  MOVF   01,W
038CE:  ADDLW  3A
038D0:  MOVWF  01
038D2:  MOVLW  01
038D4:  ADDWFC 03,F
038D6:  MOVF   01,W
038D8:  ADDLW  0A
038DA:  MOVWF  01
038DC:  MOVLW  00
038DE:  ADDWFC 03,F
038E0:  MOVFF  01,42D
038E4:  MOVFF  03,42E
038E8:  MOVFF  03,430
038EC:  MOVFF  01,42F
038F0:  MOVFF  428,431
038F4:  MOVLB  0
038F6:  RCALL  33D6
038F8:  MOVF   01,F
038FA:  BZ    39A2
038FC:  CLRF   1B
038FE:  BTFSC  FF2.7
03900:  BSF    1B.7
03902:  BCF    FF2.7
....................            { 
....................                ((struct oNoFF)mydevices.myoutputs[x].device).off.value=value; 
03904:  MOVLB  4
03906:  CLRF   x6F
03908:  MOVFF  42A,46E
0390C:  CLRF   x71
0390E:  MOVLW  23
03910:  MOVWF  x70
03912:  MOVLB  0
03914:  CALL   031E
03918:  BTFSC  1B.7
0391A:  BSF    FF2.7
0391C:  MOVF   01,W
0391E:  ADDLW  B6
03920:  MOVLB  4
03922:  MOVWF  x2B
03924:  MOVLW  00
03926:  ADDWFC 02,W
03928:  MOVWF  x2C
0392A:  MOVLW  01
0392C:  ADDWF  x2B,W
0392E:  MOVWF  01
03930:  MOVLW  00
03932:  ADDWFC x2C,W
03934:  MOVWF  03
03936:  MOVF   01,W
03938:  ADDLW  3A
0393A:  MOVWF  01
0393C:  MOVLW  01
0393E:  ADDWFC 03,F
03940:  MOVF   01,W
03942:  ADDLW  12
03944:  MOVWF  FE9
03946:  MOVLW  00
03948:  ADDWFC 03,W
0394A:  MOVWF  FEA
0394C:  MOVFF  429,FEF
03950:  CLRF   1B
03952:  BTFSC  FF2.7
03954:  BSF    1B.7
03956:  BCF    FF2.7
....................                ((struct oNoFF)mydevices.myoutputs[x].device).off.needs_update=true; 
03958:  CLRF   x6F
0395A:  MOVFF  42A,46E
0395E:  CLRF   x71
03960:  MOVLW  23
03962:  MOVWF  x70
03964:  MOVLB  0
03966:  CALL   031E
0396A:  BTFSC  1B.7
0396C:  BSF    FF2.7
0396E:  MOVF   01,W
03970:  ADDLW  B6
03972:  MOVLB  4
03974:  MOVWF  x2B
03976:  MOVLW  00
03978:  ADDWFC 02,W
0397A:  MOVWF  x2C
0397C:  MOVLW  01
0397E:  ADDWF  x2B,W
03980:  MOVWF  01
03982:  MOVLW  00
03984:  ADDWFC x2C,W
03986:  MOVWF  03
03988:  MOVF   01,W
0398A:  ADDLW  3A
0398C:  MOVWF  01
0398E:  MOVLW  01
03990:  ADDWFC 03,F
03992:  MOVF   01,W
03994:  ADDLW  13
03996:  MOVWF  FE9
03998:  MOVLW  00
0399A:  ADDWFC 03,W
0399C:  MOVWF  FEA
0399E:  BSF    FEF.0
039A0:  MOVLB  0
....................            } 
....................            break; 
039A2:  BRA    39A8
....................     case shutter: 
....................  
....................            break; 
039A4:  BRA    39A8
....................     default: 
....................  
....................             break; } 
039A6:  BRA    39A8
....................  
....................    } 
039A8:  MOVLB  4
039AA:  INCF   x2A,F
039AC:  BRA    340A
.................... } 
039AE:  MOVLB  0
039B0:  GOTO   39BE (RETURN)
.................... void process_outpoint_answer(unsigned int adress,unsigned int value) 
.................... { 
....................    //   printf("update answer adress=%u value=%u\n\r",adress,value); 
....................       process_inpoints(adress,value); //internal processing 
039B4:  MOVFF  426,428
039B8:  MOVFF  427,429
039BC:  BRA    3406
....................       //TODO CAN Sending of values 
.................... } 
039BE:  RETLW  00
....................  
.................... void process_outpoints() 
.................... { 
....................     int x; 
....................    for(x=0;x<mydevices.numberOfInputs;++x) 
039C0:  MOVLB  4
039C2:  CLRF   x1F
039C4:  MOVLB  1
039C6:  MOVF   x3A,W
039C8:  MOVLB  4
039CA:  SUBWF  x1F,W
039CC:  BTFSC  FD8.0
039CE:  BRA    3F08
039D0:  CLRF   1B
039D2:  BTFSC  FF2.7
039D4:  BSF    1B.7
039D6:  BCF    FF2.7
....................    { // printf("type=%u\n\r",((struct inputs)mydevices.myinputs[x]).type); 
....................       switch (((struct inputs)mydevices.myinputs[x]).type) { 
039D8:  CLRF   x6F
039DA:  MOVFF  41F,46E
039DE:  CLRF   x71
039E0:  MOVLW  12
039E2:  MOVWF  x70
039E4:  MOVLB  0
039E6:  CALL   031E
039EA:  BTFSC  1B.7
039EC:  BSF    FF2.7
039EE:  MOVFF  02,03
039F2:  MOVF   01,W
039F4:  ADDLW  3C
039F6:  MOVWF  01
039F8:  MOVLW  01
039FA:  ADDWFC 03,F
039FC:  MOVFF  01,FE9
03A00:  MOVFF  03,FEA
03A04:  MOVF   FEF,W
03A06:  BZ    3A10
03A08:  XORLW  03
03A0A:  BTFSC  FD8.2
03A0C:  BRA    3EFC
03A0E:  BRA    3F00
....................     case dimmer_switch: 
03A10:  CLRF   1B
03A12:  BTFSC  FF2.7
03A14:  BSF    1B.7
03A16:  BCF    FF2.7
....................              //  printf("dimmer_switch"); 
....................                if( ((struct dimmer_switch)mydevices.myinputs[x].device).dim_level.needs_update) 
03A18:  MOVLB  4
03A1A:  CLRF   x6F
03A1C:  MOVFF  41F,46E
03A20:  CLRF   x71
03A22:  MOVLW  12
03A24:  MOVWF  x70
03A26:  MOVLB  0
03A28:  CALL   031E
03A2C:  BTFSC  1B.7
03A2E:  BSF    FF2.7
03A30:  MOVF   01,W
03A32:  ADDLW  02
03A34:  MOVLB  4
03A36:  MOVWF  x20
03A38:  MOVLW  00
03A3A:  ADDWFC 02,W
03A3C:  MOVWF  x21
03A3E:  MOVLW  01
03A40:  ADDWF  x20,W
03A42:  MOVWF  01
03A44:  MOVLW  00
03A46:  ADDWFC x21,W
03A48:  MOVWF  03
03A4A:  MOVF   01,W
03A4C:  ADDLW  3A
03A4E:  MOVWF  01
03A50:  MOVLW  01
03A52:  ADDWFC 03,F
03A54:  MOVF   01,W
03A56:  ADDLW  02
03A58:  MOVWF  FE9
03A5A:  MOVLW  00
03A5C:  ADDWFC 03,W
03A5E:  MOVWF  FEA
03A60:  BTFSS  FEF.0
03A62:  BRA    3BB2
03A64:  CLRF   1B
03A66:  BTFSC  FF2.7
03A68:  BSF    1B.7
03A6A:  BCF    FF2.7
....................                { 
....................                  // printf("dimlevel needs update\n"); 
....................                    process_outpoint_answer( ((struct dimmer_switch)mydevices.myinputs[x].device).dim_level.adress, ((struct dimmer_switch)mydevices.myinputs[x].device).dim_level.value); 
03A6C:  CLRF   x6F
03A6E:  MOVFF  41F,46E
03A72:  CLRF   x71
03A74:  MOVLW  12
03A76:  MOVWF  x70
03A78:  MOVLB  0
03A7A:  CALL   031E
03A7E:  BTFSC  1B.7
03A80:  BSF    FF2.7
03A82:  MOVF   01,W
03A84:  ADDLW  02
03A86:  MOVLB  4
03A88:  MOVWF  x20
03A8A:  MOVLW  00
03A8C:  ADDWFC 02,W
03A8E:  MOVWF  x21
03A90:  MOVLW  01
03A92:  ADDWF  x20,W
03A94:  MOVWF  01
03A96:  MOVLW  00
03A98:  ADDWFC x21,W
03A9A:  MOVWF  03
03A9C:  MOVF   01,W
03A9E:  ADDLW  3A
03AA0:  MOVWF  01
03AA2:  MOVLW  01
03AA4:  ADDWFC 03,F
03AA6:  MOVFF  01,FE9
03AAA:  MOVFF  03,FEA
03AAE:  MOVFF  FEF,422
03AB2:  CLRF   1B
03AB4:  BTFSC  FF2.7
03AB6:  BSF    1B.7
03AB8:  BCF    FF2.7
03ABA:  CLRF   x6F
03ABC:  MOVFF  41F,46E
03AC0:  CLRF   x71
03AC2:  MOVLW  12
03AC4:  MOVWF  x70
03AC6:  MOVLB  0
03AC8:  CALL   031E
03ACC:  BTFSC  1B.7
03ACE:  BSF    FF2.7
03AD0:  MOVF   01,W
03AD2:  ADDLW  02
03AD4:  MOVLB  4
03AD6:  MOVWF  x23
03AD8:  MOVLW  00
03ADA:  ADDWFC 02,W
03ADC:  MOVWF  x24
03ADE:  MOVLW  01
03AE0:  ADDWF  x23,W
03AE2:  MOVWF  01
03AE4:  MOVLW  00
03AE6:  ADDWFC x24,W
03AE8:  MOVWF  03
03AEA:  MOVF   01,W
03AEC:  ADDLW  3A
03AEE:  MOVWF  01
03AF0:  MOVLW  01
03AF2:  ADDWFC 03,F
03AF4:  MOVF   01,W
03AF6:  ADDLW  01
03AF8:  MOVWF  FE9
03AFA:  MOVLW  00
03AFC:  ADDWFC 03,W
03AFE:  MOVWF  FEA
03B00:  MOVFF  FEF,425
03B04:  MOVFF  422,426
03B08:  MOVFF  425,427
03B0C:  MOVLB  0
03B0E:  RCALL  39B4
03B10:  CLRF   1B
03B12:  BTFSC  FF2.7
03B14:  BSF    1B.7
03B16:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).dim_level.needs_update=false; 
03B18:  MOVLB  4
03B1A:  CLRF   x6F
03B1C:  MOVFF  41F,46E
03B20:  CLRF   x71
03B22:  MOVLW  12
03B24:  MOVWF  x70
03B26:  MOVLB  0
03B28:  CALL   031E
03B2C:  BTFSC  1B.7
03B2E:  BSF    FF2.7
03B30:  MOVF   01,W
03B32:  ADDLW  02
03B34:  MOVLB  4
03B36:  MOVWF  x20
03B38:  MOVLW  00
03B3A:  ADDWFC 02,W
03B3C:  MOVWF  x21
03B3E:  MOVLW  01
03B40:  ADDWF  x20,W
03B42:  MOVWF  01
03B44:  MOVLW  00
03B46:  ADDWFC x21,W
03B48:  MOVWF  03
03B4A:  MOVF   01,W
03B4C:  ADDLW  3A
03B4E:  MOVWF  01
03B50:  MOVLW  01
03B52:  ADDWFC 03,F
03B54:  MOVF   01,W
03B56:  ADDLW  02
03B58:  MOVWF  FE9
03B5A:  MOVLW  00
03B5C:  ADDWFC 03,W
03B5E:  MOVWF  FEA
03B60:  BCF    FEF.0
03B62:  CLRF   1B
03B64:  BTFSC  FF2.7
03B66:  BSF    1B.7
03B68:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).dim_level.value=0; 
03B6A:  CLRF   x6F
03B6C:  MOVFF  41F,46E
03B70:  CLRF   x71
03B72:  MOVLW  12
03B74:  MOVWF  x70
03B76:  MOVLB  0
03B78:  CALL   031E
03B7C:  BTFSC  1B.7
03B7E:  BSF    FF2.7
03B80:  MOVF   01,W
03B82:  ADDLW  02
03B84:  MOVLB  4
03B86:  MOVWF  x20
03B88:  MOVLW  00
03B8A:  ADDWFC 02,W
03B8C:  MOVWF  x21
03B8E:  MOVLW  01
03B90:  ADDWF  x20,W
03B92:  MOVWF  01
03B94:  MOVLW  00
03B96:  ADDWFC x21,W
03B98:  MOVWF  03
03B9A:  MOVF   01,W
03B9C:  ADDLW  3A
03B9E:  MOVWF  01
03BA0:  MOVLW  01
03BA2:  ADDWFC 03,F
03BA4:  MOVF   01,W
03BA6:  ADDLW  01
03BA8:  MOVWF  FE9
03BAA:  MOVLW  00
03BAC:  ADDWFC 03,W
03BAE:  MOVWF  FEA
03BB0:  CLRF   FEF
03BB2:  CLRF   1B
03BB4:  BTFSC  FF2.7
03BB6:  BSF    1B.7
03BB8:  BCF    FF2.7
....................                } 
....................                if( ((struct dimmer_switch)mydevices.myinputs[x].device).on.needs_update) 
03BBA:  CLRF   x6F
03BBC:  MOVFF  41F,46E
03BC0:  CLRF   x71
03BC2:  MOVLW  12
03BC4:  MOVWF  x70
03BC6:  MOVLB  0
03BC8:  CALL   031E
03BCC:  BTFSC  1B.7
03BCE:  BSF    FF2.7
03BD0:  MOVF   01,W
03BD2:  ADDLW  02
03BD4:  MOVLB  4
03BD6:  MOVWF  x20
03BD8:  MOVLW  00
03BDA:  ADDWFC 02,W
03BDC:  MOVWF  x21
03BDE:  MOVLW  01
03BE0:  ADDWF  x20,W
03BE2:  MOVWF  01
03BE4:  MOVLW  00
03BE6:  ADDWFC x21,W
03BE8:  MOVWF  03
03BEA:  MOVF   01,W
03BEC:  ADDLW  3A
03BEE:  MOVWF  01
03BF0:  MOVLW  01
03BF2:  ADDWFC 03,F
03BF4:  MOVF   01,W
03BF6:  ADDLW  05
03BF8:  MOVWF  FE9
03BFA:  MOVLW  00
03BFC:  ADDWFC 03,W
03BFE:  MOVWF  FEA
03C00:  BTFSS  FEF.0
03C02:  BRA    3D56
03C04:  CLRF   1B
03C06:  BTFSC  FF2.7
03C08:  BSF    1B.7
03C0A:  BCF    FF2.7
....................                {   
....................               // printf("on needs update\n"); 
....................                   process_outpoint_answer( ((struct dimmer_switch)mydevices.myinputs[x].device).on.adress, ((struct dimmer_switch)mydevices.myinputs[x].device).on.value); 
03C0C:  CLRF   x6F
03C0E:  MOVFF  41F,46E
03C12:  CLRF   x71
03C14:  MOVLW  12
03C16:  MOVWF  x70
03C18:  MOVLB  0
03C1A:  CALL   031E
03C1E:  BTFSC  1B.7
03C20:  BSF    FF2.7
03C22:  MOVF   01,W
03C24:  ADDLW  02
03C26:  MOVLB  4
03C28:  MOVWF  x20
03C2A:  MOVLW  00
03C2C:  ADDWFC 02,W
03C2E:  MOVWF  x21
03C30:  MOVLW  01
03C32:  ADDWF  x20,W
03C34:  MOVWF  01
03C36:  MOVLW  00
03C38:  ADDWFC x21,W
03C3A:  MOVWF  03
03C3C:  MOVF   01,W
03C3E:  ADDLW  3A
03C40:  MOVWF  01
03C42:  MOVLW  01
03C44:  ADDWFC 03,F
03C46:  MOVF   01,W
03C48:  ADDLW  03
03C4A:  MOVWF  FE9
03C4C:  MOVLW  00
03C4E:  ADDWFC 03,W
03C50:  MOVWF  FEA
03C52:  MOVFF  FEF,422
03C56:  CLRF   1B
03C58:  BTFSC  FF2.7
03C5A:  BSF    1B.7
03C5C:  BCF    FF2.7
03C5E:  CLRF   x6F
03C60:  MOVFF  41F,46E
03C64:  CLRF   x71
03C66:  MOVLW  12
03C68:  MOVWF  x70
03C6A:  MOVLB  0
03C6C:  CALL   031E
03C70:  BTFSC  1B.7
03C72:  BSF    FF2.7
03C74:  MOVF   01,W
03C76:  ADDLW  02
03C78:  MOVLB  4
03C7A:  MOVWF  x23
03C7C:  MOVLW  00
03C7E:  ADDWFC 02,W
03C80:  MOVWF  x24
03C82:  MOVLW  01
03C84:  ADDWF  x23,W
03C86:  MOVWF  01
03C88:  MOVLW  00
03C8A:  ADDWFC x24,W
03C8C:  MOVWF  03
03C8E:  MOVF   01,W
03C90:  ADDLW  3A
03C92:  MOVWF  01
03C94:  MOVLW  01
03C96:  ADDWFC 03,F
03C98:  MOVF   01,W
03C9A:  ADDLW  04
03C9C:  MOVWF  FE9
03C9E:  MOVLW  00
03CA0:  ADDWFC 03,W
03CA2:  MOVWF  FEA
03CA4:  MOVFF  FEF,425
03CA8:  MOVFF  422,426
03CAC:  MOVFF  425,427
03CB0:  MOVLB  0
03CB2:  RCALL  39B4
03CB4:  CLRF   1B
03CB6:  BTFSC  FF2.7
03CB8:  BSF    1B.7
03CBA:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).on.needs_update=false; 
03CBC:  MOVLB  4
03CBE:  CLRF   x6F
03CC0:  MOVFF  41F,46E
03CC4:  CLRF   x71
03CC6:  MOVLW  12
03CC8:  MOVWF  x70
03CCA:  MOVLB  0
03CCC:  CALL   031E
03CD0:  BTFSC  1B.7
03CD2:  BSF    FF2.7
03CD4:  MOVF   01,W
03CD6:  ADDLW  02
03CD8:  MOVLB  4
03CDA:  MOVWF  x20
03CDC:  MOVLW  00
03CDE:  ADDWFC 02,W
03CE0:  MOVWF  x21
03CE2:  MOVLW  01
03CE4:  ADDWF  x20,W
03CE6:  MOVWF  01
03CE8:  MOVLW  00
03CEA:  ADDWFC x21,W
03CEC:  MOVWF  03
03CEE:  MOVF   01,W
03CF0:  ADDLW  3A
03CF2:  MOVWF  01
03CF4:  MOVLW  01
03CF6:  ADDWFC 03,F
03CF8:  MOVF   01,W
03CFA:  ADDLW  05
03CFC:  MOVWF  FE9
03CFE:  MOVLW  00
03D00:  ADDWFC 03,W
03D02:  MOVWF  FEA
03D04:  BCF    FEF.0
03D06:  CLRF   1B
03D08:  BTFSC  FF2.7
03D0A:  BSF    1B.7
03D0C:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).on.value=0; 
03D0E:  CLRF   x6F
03D10:  MOVFF  41F,46E
03D14:  CLRF   x71
03D16:  MOVLW  12
03D18:  MOVWF  x70
03D1A:  MOVLB  0
03D1C:  CALL   031E
03D20:  BTFSC  1B.7
03D22:  BSF    FF2.7
03D24:  MOVF   01,W
03D26:  ADDLW  02
03D28:  MOVLB  4
03D2A:  MOVWF  x20
03D2C:  MOVLW  00
03D2E:  ADDWFC 02,W
03D30:  MOVWF  x21
03D32:  MOVLW  01
03D34:  ADDWF  x20,W
03D36:  MOVWF  01
03D38:  MOVLW  00
03D3A:  ADDWFC x21,W
03D3C:  MOVWF  03
03D3E:  MOVF   01,W
03D40:  ADDLW  3A
03D42:  MOVWF  01
03D44:  MOVLW  01
03D46:  ADDWFC 03,F
03D48:  MOVF   01,W
03D4A:  ADDLW  04
03D4C:  MOVWF  FE9
03D4E:  MOVLW  00
03D50:  ADDWFC 03,W
03D52:  MOVWF  FEA
03D54:  CLRF   FEF
03D56:  CLRF   1B
03D58:  BTFSC  FF2.7
03D5A:  BSF    1B.7
03D5C:  BCF    FF2.7
....................                } 
....................                if( ((struct dimmer_switch)mydevices.myinputs[x].device).off.needs_update) 
03D5E:  CLRF   x6F
03D60:  MOVFF  41F,46E
03D64:  CLRF   x71
03D66:  MOVLW  12
03D68:  MOVWF  x70
03D6A:  MOVLB  0
03D6C:  CALL   031E
03D70:  BTFSC  1B.7
03D72:  BSF    FF2.7
03D74:  MOVF   01,W
03D76:  ADDLW  02
03D78:  MOVLB  4
03D7A:  MOVWF  x20
03D7C:  MOVLW  00
03D7E:  ADDWFC 02,W
03D80:  MOVWF  x21
03D82:  MOVLW  01
03D84:  ADDWF  x20,W
03D86:  MOVWF  01
03D88:  MOVLW  00
03D8A:  ADDWFC x21,W
03D8C:  MOVWF  03
03D8E:  MOVF   01,W
03D90:  ADDLW  3A
03D92:  MOVWF  01
03D94:  MOVLW  01
03D96:  ADDWFC 03,F
03D98:  MOVF   01,W
03D9A:  ADDLW  08
03D9C:  MOVWF  FE9
03D9E:  MOVLW  00
03DA0:  ADDWFC 03,W
03DA2:  MOVWF  FEA
03DA4:  BTFSS  FEF.0
03DA6:  BRA    3EFA
03DA8:  CLRF   1B
03DAA:  BTFSC  FF2.7
03DAC:  BSF    1B.7
03DAE:  BCF    FF2.7
....................                { 
....................               // printf("off needs update\n"); 
....................                   process_outpoint_answer( ((struct dimmer_switch)mydevices.myinputs[x].device).off.adress, ((struct dimmer_switch)mydevices.myinputs[x].device).off.value); 
03DB0:  CLRF   x6F
03DB2:  MOVFF  41F,46E
03DB6:  CLRF   x71
03DB8:  MOVLW  12
03DBA:  MOVWF  x70
03DBC:  MOVLB  0
03DBE:  CALL   031E
03DC2:  BTFSC  1B.7
03DC4:  BSF    FF2.7
03DC6:  MOVF   01,W
03DC8:  ADDLW  02
03DCA:  MOVLB  4
03DCC:  MOVWF  x20
03DCE:  MOVLW  00
03DD0:  ADDWFC 02,W
03DD2:  MOVWF  x21
03DD4:  MOVLW  01
03DD6:  ADDWF  x20,W
03DD8:  MOVWF  01
03DDA:  MOVLW  00
03DDC:  ADDWFC x21,W
03DDE:  MOVWF  03
03DE0:  MOVF   01,W
03DE2:  ADDLW  3A
03DE4:  MOVWF  01
03DE6:  MOVLW  01
03DE8:  ADDWFC 03,F
03DEA:  MOVF   01,W
03DEC:  ADDLW  06
03DEE:  MOVWF  FE9
03DF0:  MOVLW  00
03DF2:  ADDWFC 03,W
03DF4:  MOVWF  FEA
03DF6:  MOVFF  FEF,422
03DFA:  CLRF   1B
03DFC:  BTFSC  FF2.7
03DFE:  BSF    1B.7
03E00:  BCF    FF2.7
03E02:  CLRF   x6F
03E04:  MOVFF  41F,46E
03E08:  CLRF   x71
03E0A:  MOVLW  12
03E0C:  MOVWF  x70
03E0E:  MOVLB  0
03E10:  CALL   031E
03E14:  BTFSC  1B.7
03E16:  BSF    FF2.7
03E18:  MOVF   01,W
03E1A:  ADDLW  02
03E1C:  MOVLB  4
03E1E:  MOVWF  x23
03E20:  MOVLW  00
03E22:  ADDWFC 02,W
03E24:  MOVWF  x24
03E26:  MOVLW  01
03E28:  ADDWF  x23,W
03E2A:  MOVWF  01
03E2C:  MOVLW  00
03E2E:  ADDWFC x24,W
03E30:  MOVWF  03
03E32:  MOVF   01,W
03E34:  ADDLW  3A
03E36:  MOVWF  01
03E38:  MOVLW  01
03E3A:  ADDWFC 03,F
03E3C:  MOVF   01,W
03E3E:  ADDLW  07
03E40:  MOVWF  FE9
03E42:  MOVLW  00
03E44:  ADDWFC 03,W
03E46:  MOVWF  FEA
03E48:  MOVFF  FEF,425
03E4C:  MOVFF  422,426
03E50:  MOVFF  425,427
03E54:  MOVLB  0
03E56:  RCALL  39B4
03E58:  CLRF   1B
03E5A:  BTFSC  FF2.7
03E5C:  BSF    1B.7
03E5E:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).off.needs_update=false; 
03E60:  MOVLB  4
03E62:  CLRF   x6F
03E64:  MOVFF  41F,46E
03E68:  CLRF   x71
03E6A:  MOVLW  12
03E6C:  MOVWF  x70
03E6E:  MOVLB  0
03E70:  CALL   031E
03E74:  BTFSC  1B.7
03E76:  BSF    FF2.7
03E78:  MOVF   01,W
03E7A:  ADDLW  02
03E7C:  MOVLB  4
03E7E:  MOVWF  x20
03E80:  MOVLW  00
03E82:  ADDWFC 02,W
03E84:  MOVWF  x21
03E86:  MOVLW  01
03E88:  ADDWF  x20,W
03E8A:  MOVWF  01
03E8C:  MOVLW  00
03E8E:  ADDWFC x21,W
03E90:  MOVWF  03
03E92:  MOVF   01,W
03E94:  ADDLW  3A
03E96:  MOVWF  01
03E98:  MOVLW  01
03E9A:  ADDWFC 03,F
03E9C:  MOVF   01,W
03E9E:  ADDLW  08
03EA0:  MOVWF  FE9
03EA2:  MOVLW  00
03EA4:  ADDWFC 03,W
03EA6:  MOVWF  FEA
03EA8:  BCF    FEF.0
03EAA:  CLRF   1B
03EAC:  BTFSC  FF2.7
03EAE:  BSF    1B.7
03EB0:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).off.value=0; 
03EB2:  CLRF   x6F
03EB4:  MOVFF  41F,46E
03EB8:  CLRF   x71
03EBA:  MOVLW  12
03EBC:  MOVWF  x70
03EBE:  MOVLB  0
03EC0:  CALL   031E
03EC4:  BTFSC  1B.7
03EC6:  BSF    FF2.7
03EC8:  MOVF   01,W
03ECA:  ADDLW  02
03ECC:  MOVLB  4
03ECE:  MOVWF  x20
03ED0:  MOVLW  00
03ED2:  ADDWFC 02,W
03ED4:  MOVWF  x21
03ED6:  MOVLW  01
03ED8:  ADDWF  x20,W
03EDA:  MOVWF  01
03EDC:  MOVLW  00
03EDE:  ADDWFC x21,W
03EE0:  MOVWF  03
03EE2:  MOVF   01,W
03EE4:  ADDLW  3A
03EE6:  MOVWF  01
03EE8:  MOVLW  01
03EEA:  ADDWFC 03,F
03EEC:  MOVF   01,W
03EEE:  ADDLW  07
03EF0:  MOVWF  FE9
03EF2:  MOVLW  00
03EF4:  ADDWFC 03,W
03EF6:  MOVWF  FEA
03EF8:  CLRF   FEF
....................                } 
....................                break; 
03EFA:  BRA    3F04
....................     case timer: 
....................  
....................            break; 
03EFC:  MOVLB  4
03EFE:  BRA    3F04
....................     default: 
....................  
....................             break; } 
03F00:  MOVLB  4
03F02:  BRA    3F04
....................  
....................    } 
03F04:  INCF   x1F,F
03F06:  BRA    39C4
.................... } 
03F08:  MOVLB  0
03F0A:  GOTO   429E (RETURN)
....................  
....................  
....................  
.................... ////////////////////////////////////////// 
.................... //apagar 
.................... volatile unsigned int32 clock; 
....................  
.................... //dimmer constants 
.................... static int TimeBase=0; 
.................... static int32 reg=39; 
.................... //dimmer end 
....................  
.................... //struct switches msw; 
.................... #include "switch_functions.c" 
.................... void process_onOff(struct on_off_switch *sw) 
.................... { 
.................... //printf("AKI1"); 
....................    if((sw->current_state==button_pressed) && (sw-> previous_state == button_depressed)) 
*
0075A:  MOVLW  06
0075C:  MOVLB  4
0075E:  ADDWF  x70,W
00760:  MOVWF  FE9
00762:  MOVLW  00
00764:  ADDWFC x71,W
00766:  MOVWF  FEA
00768:  MOVLW  00
0076A:  BTFSC  FEF.0
0076C:  MOVLW  01
0076E:  ANDLW  01
00770:  BNZ   084E
00772:  MOVLW  06
00774:  ADDWF  x70,W
00776:  MOVWF  FE9
00778:  MOVLW  00
0077A:  ADDWFC x71,W
0077C:  MOVWF  FEA
0077E:  MOVLW  00
00780:  BTFSC  FEF.1
00782:  MOVLW  01
00784:  ANDLW  01
00786:  SUBLW  01
00788:  BNZ   084E
....................    {    
....................       sw-> previous_state = button_pressed; 
0078A:  MOVLW  06
0078C:  ADDWF  x70,W
0078E:  MOVWF  FE9
00790:  MOVLW  00
00792:  ADDWFC x71,W
00794:  MOVWF  FEA
00796:  BCF    FEF.1
....................       if(sw->outstate==off) 
00798:  MOVLW  0B
0079A:  ADDWF  x70,W
0079C:  MOVWF  FE9
0079E:  MOVLW  00
007A0:  ADDWFC x71,W
007A2:  MOVWF  FEA
007A4:  DECFSZ FEF,W
007A6:  BRA    07F2
....................       { 
....................          sw->outstate=on; 
007A8:  MOVLW  0B
007AA:  ADDWF  x70,W
007AC:  MOVWF  FE9
007AE:  MOVLW  00
007B0:  ADDWFC x71,W
007B2:  MOVWF  FEA
007B4:  CLRF   FEF
....................          sw->on.value=1; 
007B6:  MOVLW  01
007B8:  ADDWF  x70,W
007BA:  MOVWF  FE9
007BC:  MOVLW  00
007BE:  ADDWFC x71,W
007C0:  MOVWF  FEA
007C2:  MOVLW  01
007C4:  MOVWF  FEF
....................          sw->on.needs_update=true; 
007C6:  MOVLW  02
007C8:  ADDWF  x70,W
007CA:  MOVWF  FE9
007CC:  MOVLW  00
007CE:  ADDWFC x71,W
007D0:  MOVWF  FEA
007D2:  BSF    FEF.0
....................          sw->off.value=0; 
007D4:  MOVLW  04
007D6:  ADDWF  x70,W
007D8:  MOVWF  FE9
007DA:  MOVLW  00
007DC:  ADDWFC x71,W
007DE:  MOVWF  FEA
007E0:  CLRF   FEF
....................          sw->off.needs_update=true; 
007E2:  MOVLW  05
007E4:  ADDWF  x70,W
007E6:  MOVWF  FE9
007E8:  MOVLW  00
007EA:  ADDWFC x71,W
007EC:  MOVWF  FEA
007EE:  BSF    FEF.0
....................       } 
....................       else if(sw->outstate==on) 
007F0:  BRA    084C
007F2:  MOVLW  0B
007F4:  ADDWF  x70,W
007F6:  MOVWF  FE9
007F8:  MOVLW  00
007FA:  ADDWFC x71,W
007FC:  MOVWF  FEA
007FE:  MOVF   FEF,F
00800:  BNZ   084C
....................       { 
....................          sw->outstate=off; 
00802:  MOVLW  0B
00804:  ADDWF  x70,W
00806:  MOVWF  FE9
00808:  MOVLW  00
0080A:  ADDWFC x71,W
0080C:  MOVWF  FEA
0080E:  MOVLW  01
00810:  MOVWF  FEF
....................          sw->off.value=1; 
00812:  MOVLW  04
00814:  ADDWF  x70,W
00816:  MOVWF  FE9
00818:  MOVLW  00
0081A:  ADDWFC x71,W
0081C:  MOVWF  FEA
0081E:  MOVLW  01
00820:  MOVWF  FEF
....................          sw->off.needs_update=true; 
00822:  MOVLW  05
00824:  ADDWF  x70,W
00826:  MOVWF  FE9
00828:  MOVLW  00
0082A:  ADDWFC x71,W
0082C:  MOVWF  FEA
0082E:  BSF    FEF.0
....................          sw->on.value=0; 
00830:  MOVLW  01
00832:  ADDWF  x70,W
00834:  MOVWF  FE9
00836:  MOVLW  00
00838:  ADDWFC x71,W
0083A:  MOVWF  FEA
0083C:  CLRF   FEF
....................          sw->on.needs_update=true; 
0083E:  MOVLW  02
00840:  ADDWF  x70,W
00842:  MOVWF  FE9
00844:  MOVLW  00
00846:  ADDWFC x71,W
00848:  MOVWF  FEA
0084A:  BSF    FEF.0
....................       } 
.................... } 
....................    else if(sw->current_state==button_depressed) 
0084C:  BRA    0874
0084E:  MOVLW  06
00850:  ADDWF  x70,W
00852:  MOVWF  FE9
00854:  MOVLW  00
00856:  ADDWFC x71,W
00858:  MOVWF  FEA
0085A:  MOVLW  00
0085C:  BTFSC  FEF.0
0085E:  MOVLW  01
00860:  ANDLW  01
00862:  SUBLW  01
00864:  BNZ   0874
....................       sw-> previous_state = button_depressed; 
00866:  MOVLW  06
00868:  ADDWF  x70,W
0086A:  MOVWF  FE9
0086C:  MOVLW  00
0086E:  ADDWFC x71,W
00870:  MOVWF  FEA
00872:  BSF    FEF.1
.................... } 
00874:  MOVLB  0
00876:  GOTO   0D9C (RETURN)
.................... void process_buttons(struct button_switch *sw) 
.................... { 
....................    if(sw->current_state==button_pressed && sw->outstate==off)  
0087A:  MOVLW  06
0087C:  MOVLB  4
0087E:  ADDWF  x70,W
00880:  MOVWF  FE9
00882:  MOVLW  00
00884:  ADDWFC x71,W
00886:  MOVWF  FEA
00888:  MOVLW  00
0088A:  BTFSC  FEF.0
0088C:  MOVLW  01
0088E:  ANDLW  01
00890:  BNZ   08EC
00892:  MOVLW  0B
00894:  ADDWF  x70,W
00896:  MOVWF  FE9
00898:  MOVLW  00
0089A:  ADDWFC x71,W
0089C:  MOVWF  FEA
0089E:  DECFSZ FEF,W
008A0:  BRA    08EC
....................    { 
....................          sw->outstate=on; 
008A2:  MOVLW  0B
008A4:  ADDWF  x70,W
008A6:  MOVWF  FE9
008A8:  MOVLW  00
008AA:  ADDWFC x71,W
008AC:  MOVWF  FEA
008AE:  CLRF   FEF
....................          sw->on.value=1; 
008B0:  MOVLW  01
008B2:  ADDWF  x70,W
008B4:  MOVWF  FE9
008B6:  MOVLW  00
008B8:  ADDWFC x71,W
008BA:  MOVWF  FEA
008BC:  MOVLW  01
008BE:  MOVWF  FEF
....................          sw->on.needs_update=true; 
008C0:  MOVLW  02
008C2:  ADDWF  x70,W
008C4:  MOVWF  FE9
008C6:  MOVLW  00
008C8:  ADDWFC x71,W
008CA:  MOVWF  FEA
008CC:  BSF    FEF.0
....................          sw->off.value=0; 
008CE:  MOVLW  04
008D0:  ADDWF  x70,W
008D2:  MOVWF  FE9
008D4:  MOVLW  00
008D6:  ADDWFC x71,W
008D8:  MOVWF  FEA
008DA:  CLRF   FEF
....................          sw->off.needs_update=true; 
008DC:  MOVLW  05
008DE:  ADDWF  x70,W
008E0:  MOVWF  FE9
008E2:  MOVLW  00
008E4:  ADDWFC x71,W
008E6:  MOVWF  FEA
008E8:  BSF    FEF.0
....................    } 
....................    else if(sw->current_state==button_depressed && sw->outstate==on)   
008EA:  BRA    095E
008EC:  MOVLW  06
008EE:  ADDWF  x70,W
008F0:  MOVWF  FE9
008F2:  MOVLW  00
008F4:  ADDWFC x71,W
008F6:  MOVWF  FEA
008F8:  MOVLW  00
008FA:  BTFSC  FEF.0
008FC:  MOVLW  01
008FE:  ANDLW  01
00900:  SUBLW  01
00902:  BNZ   095E
00904:  MOVLW  0B
00906:  ADDWF  x70,W
00908:  MOVWF  FE9
0090A:  MOVLW  00
0090C:  ADDWFC x71,W
0090E:  MOVWF  FEA
00910:  MOVF   FEF,F
00912:  BNZ   095E
....................    { 
....................          sw->outstate=off; 
00914:  MOVLW  0B
00916:  ADDWF  x70,W
00918:  MOVWF  FE9
0091A:  MOVLW  00
0091C:  ADDWFC x71,W
0091E:  MOVWF  FEA
00920:  MOVLW  01
00922:  MOVWF  FEF
....................          sw->off.value=1; 
00924:  MOVLW  04
00926:  ADDWF  x70,W
00928:  MOVWF  FE9
0092A:  MOVLW  00
0092C:  ADDWFC x71,W
0092E:  MOVWF  FEA
00930:  MOVLW  01
00932:  MOVWF  FEF
....................          sw->off.needs_update=true; 
00934:  MOVLW  05
00936:  ADDWF  x70,W
00938:  MOVWF  FE9
0093A:  MOVLW  00
0093C:  ADDWFC x71,W
0093E:  MOVWF  FEA
00940:  BSF    FEF.0
....................          sw->on.value=0; 
00942:  MOVLW  01
00944:  ADDWF  x70,W
00946:  MOVWF  FE9
00948:  MOVLW  00
0094A:  ADDWFC x71,W
0094C:  MOVWF  FEA
0094E:  CLRF   FEF
....................          sw->on.needs_update=true; 
00950:  MOVLW  02
00952:  ADDWF  x70,W
00954:  MOVWF  FE9
00956:  MOVLW  00
00958:  ADDWFC x71,W
0095A:  MOVWF  FEA
0095C:  BSF    FEF.0
....................    } 
.................... } 
0095E:  MOVLB  0
00960:  GOTO   0D9C (RETURN)
.................... void process_dimmers(struct dimmer_switch *sw) 
.................... { 
*
003B4:  MOVLW  09
003B6:  MOVLB  4
003B8:  ADDWF  x70,W
003BA:  MOVWF  FE9
003BC:  MOVLW  00
003BE:  ADDWFC x71,W
003C0:  MOVWF  FEA
003C2:  MOVFF  FEF,472
....................    int last_level=sw->current_level; 
....................    if(sw->current_state==button_pressed)//se o botao esta premido 
003C6:  MOVLW  0E
003C8:  ADDWF  x70,W
003CA:  MOVWF  FE9
003CC:  MOVLW  00
003CE:  ADDWFC x71,W
003D0:  MOVWF  FEA
003D2:  MOVLW  00
003D4:  BTFSC  FEF.0
003D6:  MOVLW  01
003D8:  ANDLW  01
003DA:  BTFSS  FD8.2
003DC:  BRA    05AC
....................    { 
....................     //  printf("STATE %u",sw->current_state); 
....................      // printf("DIF %LU",clock - sw->timer); 
....................       sw-> previous_state = button_pressed; 
003DE:  MOVLW  0E
003E0:  ADDWF  x70,W
003E2:  MOVWF  FE9
003E4:  MOVLW  00
003E6:  ADDWFC x71,W
003E8:  MOVWF  FEA
003EA:  BCF    FEF.1
....................       if ((clock - sw->timer > reg || sw->outstate == dimming) && sw->outstate!=maxed) 
003EC:  MOVLW  0A
003EE:  ADDWF  x70,W
003F0:  MOVWF  FE9
003F2:  MOVLW  00
003F4:  ADDWFC x71,W
003F6:  MOVWF  FEA
003F8:  MOVFF  FEF,00
003FC:  MOVFF  FEC,01
00400:  MOVFF  FEC,02
00404:  MOVFF  FEC,03
00408:  MOVF   00,W
0040A:  SUBWF  x0F,W
0040C:  MOVWF  x73
0040E:  MOVF   01,W
00410:  SUBWFB x10,W
00412:  MOVWF  x74
00414:  MOVF   02,W
00416:  SUBWFB x11,W
00418:  MOVWF  x75
0041A:  MOVF   03,W
0041C:  SUBWFB x12,W
0041E:  MOVWF  x76
00420:  MOVF   x17,W
00422:  SUBWF  x76,W
00424:  BNC   043E
00426:  BNZ   0452
00428:  MOVF   x16,W
0042A:  SUBWF  x75,W
0042C:  BNC   043E
0042E:  BNZ   0452
00430:  MOVF   x15,W
00432:  SUBWF  x74,W
00434:  BNC   043E
00436:  BNZ   0452
00438:  MOVF   x73,W
0043A:  SUBWF  x14,W
0043C:  BNC   0452
0043E:  MOVLW  0F
00440:  ADDWF  x70,W
00442:  MOVWF  FE9
00444:  MOVLW  00
00446:  ADDWFC x71,W
00448:  MOVWF  FEA
0044A:  MOVF   FEF,W
0044C:  SUBLW  02
0044E:  BTFSS  FD8.2
00450:  BRA    05AA
00452:  MOVLW  0F
00454:  ADDWF  x70,W
00456:  MOVWF  FE9
00458:  MOVLW  00
0045A:  ADDWFC x71,W
0045C:  MOVWF  FEA
0045E:  MOVF   FEF,W
00460:  SUBLW  04
00462:  BTFSC  FD8.2
00464:  BRA    05AA
....................       {  
....................          if(sw->outstate==off) 
00466:  MOVLW  0F
00468:  ADDWF  x70,W
0046A:  MOVWF  FE9
0046C:  MOVLW  00
0046E:  ADDWFC x71,W
00470:  MOVWF  FEA
00472:  DECFSZ FEF,W
00474:  BRA    04B4
....................          { 
....................             sw->outstate=maxed; 
00476:  MOVLW  0F
00478:  ADDWF  x70,W
0047A:  MOVWF  FE9
0047C:  MOVLW  00
0047E:  ADDWFC x71,W
00480:  MOVWF  FEA
00482:  MOVLW  04
00484:  MOVWF  FEF
....................             sw->on.value=1; 
00486:  ADDWF  x70,W
00488:  MOVWF  FE9
0048A:  MOVLW  00
0048C:  ADDWFC x71,W
0048E:  MOVWF  FEA
00490:  MOVLW  01
00492:  MOVWF  FEF
....................             sw->current_level = 127; 
00494:  MOVLW  09
00496:  ADDWF  x70,W
00498:  MOVWF  FE9
0049A:  MOVLW  00
0049C:  ADDWFC x71,W
0049E:  MOVWF  FEA
004A0:  MOVLW  7F
004A2:  MOVWF  FEF
....................             sw->on.needs_update=1; 
004A4:  MOVLW  05
004A6:  ADDWF  x70,W
004A8:  MOVWF  FE9
004AA:  MOVLW  00
004AC:  ADDWFC x71,W
004AE:  MOVWF  FEA
004B0:  BSF    FEF.0
....................          } 
....................         else 
004B2:  BRA    05A8
....................         { 
....................          sw->outstate = dimming; 
004B4:  MOVLW  0F
004B6:  ADDWF  x70,W
004B8:  MOVWF  FE9
004BA:  MOVLW  00
004BC:  ADDWFC x71,W
004BE:  MOVWF  FEA
004C0:  MOVLW  02
004C2:  MOVWF  FEF
....................          if (clock - sw->timer > TimeBase) //regula 
004C4:  MOVLW  0A
004C6:  ADDWF  x70,W
004C8:  MOVWF  FE9
004CA:  MOVLW  00
004CC:  ADDWFC x71,W
004CE:  MOVWF  FEA
004D0:  MOVFF  FEF,00
004D4:  MOVFF  FEC,01
004D8:  MOVFF  FEC,02
004DC:  MOVFF  FEC,03
004E0:  MOVF   00,W
004E2:  SUBWF  x0F,W
004E4:  MOVWF  x73
004E6:  MOVF   01,W
004E8:  SUBWFB x10,W
004EA:  MOVWF  x74
004EC:  MOVF   02,W
004EE:  SUBWFB x11,W
004F0:  MOVWF  x75
004F2:  MOVF   03,W
004F4:  SUBWFB x12,W
004F6:  MOVWF  x76
004F8:  MOVF   x76,F
004FA:  BNZ   050A
004FC:  MOVF   x75,F
004FE:  BNZ   050A
00500:  MOVF   x74,F
00502:  BNZ   050A
00504:  MOVF   x73,W
00506:  SUBWF  x13,W
00508:  BC    058C
....................          { 
....................             if (sw->direction == up) //para cima 
0050A:  MOVLW  0E
0050C:  ADDWF  x70,W
0050E:  MOVWF  FE9
00510:  MOVLW  00
00512:  ADDWFC x71,W
00514:  MOVWF  FEA
00516:  MOVLW  00
00518:  BTFSC  FEF.2
0051A:  MOVLW  01
0051C:  ANDLW  01
0051E:  BNZ   0550
....................             { 
....................                ++sw->current_level; 
00520:  MOVLW  09
00522:  ADDWF  x70,W
00524:  MOVWF  FE9
00526:  MOVLW  00
00528:  ADDWFC x71,W
0052A:  MOVWF  FEA
0052C:  INCF   FEF,F
....................                if (sw->current_level == 127) sw->direction = down; 
0052E:  MOVLW  09
00530:  ADDWF  x70,W
00532:  MOVWF  FE9
00534:  MOVLW  00
00536:  ADDWFC x71,W
00538:  MOVWF  FEA
0053A:  MOVF   FEF,W
0053C:  SUBLW  7F
0053E:  BNZ   054E
00540:  MOVLW  0E
00542:  ADDWF  x70,W
00544:  MOVWF  FE9
00546:  MOVLW  00
00548:  ADDWFC x71,W
0054A:  MOVWF  FEA
0054C:  BSF    FEF.2
....................             } 
....................             else//para baixo 
0054E:  BRA    058C
....................             { 
....................                --sw->current_level; 
00550:  MOVLW  09
00552:  ADDWF  x70,W
00554:  MOVWF  FE9
00556:  MOVLW  00
00558:  ADDWFC x71,W
0055A:  MOVWF  FEA
0055C:  DECF   FEF,F
....................                if (sw->current_level == 0)  
0055E:  MOVLW  09
00560:  ADDWF  x70,W
00562:  MOVWF  FE9
00564:  MOVLW  00
00566:  ADDWFC x71,W
00568:  MOVWF  FEA
0056A:  MOVF   FEF,F
0056C:  BNZ   058C
....................                {   
....................                   sw->direction = up; 
0056E:  MOVLW  0E
00570:  ADDWF  x70,W
00572:  MOVWF  FE9
00574:  MOVLW  00
00576:  ADDWFC x71,W
00578:  MOVWF  FEA
0057A:  BCF    FEF.2
....................                   sw->off.value=1; 
0057C:  MOVLW  07
0057E:  ADDWF  x70,W
00580:  MOVWF  FE9
00582:  MOVLW  00
00584:  ADDWFC x71,W
00586:  MOVWF  FEA
00588:  MOVLW  01
0058A:  MOVWF  FEF
....................                } 
....................             } 
....................          } 
....................          sw->timer = clock; 
0058C:  MOVLW  0A
0058E:  ADDWF  x70,W
00590:  MOVWF  FE9
00592:  MOVLW  00
00594:  ADDWFC x71,W
00596:  MOVWF  FEA
00598:  MOVFF  40F,FEF
0059C:  MOVFF  410,FEC
005A0:  MOVFF  411,FEC
005A4:  MOVFF  412,FEC
....................       } 
....................       } 
....................       else 
005A8:  BRA    05AA
....................       { 
....................          //sw - > timer = clock; 
....................       } 
....................    } 
....................    else//se o botao nao esta premido 
005AA:  BRA    070C
....................    { 
....................       if (sw->previous_state == button_pressed) //se o botao acabou de ser deslargado 
005AC:  MOVLW  0E
005AE:  ADDWF  x70,W
005B0:  MOVWF  FE9
005B2:  MOVLW  00
005B4:  ADDWFC x71,W
005B6:  MOVWF  FEA
005B8:  MOVLW  00
005BA:  BTFSC  FEF.1
005BC:  MOVLW  01
005BE:  ANDLW  01
005C0:  BTFSS  FD8.2
005C2:  BRA    06F0
....................       { 
....................          sw->previous_state = button_depressed; 
005C4:  MOVLW  0E
005C6:  ADDWF  x70,W
005C8:  MOVWF  FE9
005CA:  MOVLW  00
005CC:  ADDWFC x71,W
005CE:  MOVWF  FEA
005D0:  BSF    FEF.1
....................          if (sw->outstate == dimming) //se esteve a regular 
005D2:  MOVLW  0F
005D4:  ADDWF  x70,W
005D6:  MOVWF  FE9
005D8:  MOVLW  00
005DA:  ADDWFC x71,W
005DC:  MOVWF  FEA
005DE:  MOVF   FEF,W
005E0:  SUBLW  02
005E2:  BNZ   0628
....................          { 
....................             sw-> outstate = on; 
005E4:  MOVLW  0F
005E6:  ADDWF  x70,W
005E8:  MOVWF  FE9
005EA:  MOVLW  00
005EC:  ADDWFC x71,W
005EE:  MOVWF  FEA
005F0:  CLRF   FEF
....................             if (sw->direction == up) sw->direction = down; //inverte direccao 
005F2:  MOVLW  0E
005F4:  ADDWF  x70,W
005F6:  MOVWF  FE9
005F8:  MOVLW  00
005FA:  ADDWFC x71,W
005FC:  MOVWF  FEA
005FE:  MOVLW  00
00600:  BTFSC  FEF.2
00602:  MOVLW  01
00604:  ANDLW  01
00606:  BNZ   0618
00608:  MOVLW  0E
0060A:  ADDWF  x70,W
0060C:  MOVWF  FE9
0060E:  MOVLW  00
00610:  ADDWFC x71,W
00612:  MOVWF  FEA
00614:  BSF    FEF.2
....................             else sw->direction = up; 
00616:  BRA    0626
00618:  MOVLW  0E
0061A:  ADDWF  x70,W
0061C:  MOVWF  FE9
0061E:  MOVLW  00
00620:  ADDWFC x71,W
00622:  MOVWF  FEA
00624:  BCF    FEF.2
....................          } 
....................          else//se nao esteve a regular 
00626:  BRA    06F0
....................          { 
....................             if (sw->outstate == off) //se estava desligada 
00628:  MOVLW  0F
0062A:  ADDWF  x70,W
0062C:  MOVWF  FE9
0062E:  MOVLW  00
00630:  ADDWFC x71,W
00632:  MOVWF  FEA
00634:  DECFSZ FEF,W
00636:  BRA    0674
....................             { 
....................               // printf("on"); 
....................                sw->outstate=on; 
00638:  MOVLW  0F
0063A:  ADDWF  x70,W
0063C:  MOVWF  FE9
0063E:  MOVLW  00
00640:  ADDWFC x71,W
00642:  MOVWF  FEA
00644:  CLRF   FEF
....................                sw->on.value=1; 
00646:  MOVLW  04
00648:  ADDWF  x70,W
0064A:  MOVWF  FE9
0064C:  MOVLW  00
0064E:  ADDWFC x71,W
00650:  MOVWF  FEA
00652:  MOVLW  01
00654:  MOVWF  FEF
....................                sw->direction = down; 
00656:  MOVLW  0E
00658:  ADDWF  x70,W
0065A:  MOVWF  FE9
0065C:  MOVLW  00
0065E:  ADDWFC x71,W
00660:  MOVWF  FEA
00662:  BSF    FEF.2
....................                sw->on.needs_update=true; 
00664:  MOVLW  05
00666:  ADDWF  x70,W
00668:  MOVWF  FE9
0066A:  MOVLW  00
0066C:  ADDWFC x71,W
0066E:  MOVWF  FEA
00670:  BSF    FEF.0
....................             } 
....................             else if (sw->outstate == on) 
00672:  BRA    06F0
00674:  MOVLW  0F
00676:  ADDWF  x70,W
00678:  MOVWF  FE9
0067A:  MOVLW  00
0067C:  ADDWFC x71,W
0067E:  MOVWF  FEA
00680:  MOVF   FEF,F
00682:  BNZ   06C2
....................             { 
....................               // printf("off"); 
....................                //sw->current_level = 0; //senao desliga 
....................                sw->outstate=off; 
00684:  MOVLW  0F
00686:  ADDWF  x70,W
00688:  MOVWF  FE9
0068A:  MOVLW  00
0068C:  ADDWFC x71,W
0068E:  MOVWF  FEA
00690:  MOVLW  01
00692:  MOVWF  FEF
....................                sw->off.value=1; 
00694:  MOVLW  07
00696:  ADDWF  x70,W
00698:  MOVWF  FE9
0069A:  MOVLW  00
0069C:  ADDWFC x71,W
0069E:  MOVWF  FEA
006A0:  MOVLW  01
006A2:  MOVWF  FEF
....................                sw->direction = up; 
006A4:  MOVLW  0E
006A6:  ADDWF  x70,W
006A8:  MOVWF  FE9
006AA:  MOVLW  00
006AC:  ADDWFC x71,W
006AE:  MOVWF  FEA
006B0:  BCF    FEF.2
....................                sw->off.needs_update=true; 
006B2:  MOVLW  08
006B4:  ADDWF  x70,W
006B6:  MOVWF  FE9
006B8:  MOVLW  00
006BA:  ADDWFC x71,W
006BC:  MOVWF  FEA
006BE:  BSF    FEF.0
....................             } 
....................             else if(sw->outstate == maxed) 
006C0:  BRA    06F0
006C2:  MOVLW  0F
006C4:  ADDWF  x70,W
006C6:  MOVWF  FE9
006C8:  MOVLW  00
006CA:  ADDWFC x71,W
006CC:  MOVWF  FEA
006CE:  MOVF   FEF,W
006D0:  SUBLW  04
006D2:  BNZ   06F0
....................             { 
....................                sw->outstate=on; 
006D4:  MOVLW  0F
006D6:  ADDWF  x70,W
006D8:  MOVWF  FE9
006DA:  MOVLW  00
006DC:  ADDWFC x71,W
006DE:  MOVWF  FEA
006E0:  CLRF   FEF
....................                sw->direction = down; 
006E2:  MOVLW  0E
006E4:  ADDWF  x70,W
006E6:  MOVWF  FE9
006E8:  MOVLW  00
006EA:  ADDWFC x71,W
006EC:  MOVWF  FEA
006EE:  BSF    FEF.2
....................             } 
....................          } 
....................       } 
....................       sw->timer = clock; 
006F0:  MOVLW  0A
006F2:  ADDWF  x70,W
006F4:  MOVWF  FE9
006F6:  MOVLW  00
006F8:  ADDWFC x71,W
006FA:  MOVWF  FEA
006FC:  MOVFF  40F,FEF
00700:  MOVFF  410,FEC
00704:  MOVFF  411,FEC
00708:  MOVFF  412,FEC
....................    } 
....................  //  onOffHelper(sw); 
....................    if (last_level!=sw->current_level)  
0070C:  MOVLW  09
0070E:  ADDWF  x70,W
00710:  MOVWF  FE9
00712:  MOVLW  00
00714:  ADDWFC x71,W
00716:  MOVWF  FEA
00718:  MOVF   FEF,W
0071A:  SUBWF  x72,W
0071C:  BZ    0754
....................    { 
....................       sw->dim_level.value=sw->current_level; 
0071E:  MOVLW  01
00720:  ADDWF  x70,W
00722:  MOVWF  01
00724:  MOVLW  00
00726:  ADDWFC x71,W
00728:  MOVWF  03
0072A:  MOVLW  09
0072C:  ADDWF  x70,W
0072E:  MOVWF  FE9
00730:  MOVLW  00
00732:  ADDWFC x71,W
00734:  MOVWF  FEA
00736:  MOVFF  FEF,475
0073A:  MOVFF  03,FEA
0073E:  MOVFF  01,FE9
00742:  MOVFF  475,FEF
....................       sw->dim_level.needs_update=true; 
00746:  MOVLW  02
00748:  ADDWF  x70,W
0074A:  MOVWF  FE9
0074C:  MOVLW  00
0074E:  ADDWFC x71,W
00750:  MOVWF  FEA
00752:  BSF    FEF.0
....................    } 
.................... } 
00754:  MOVLB  0
00756:  GOTO   0D9C (RETURN)
....................  
.................... void read_inputs()//called periodicaly to pass current phisical input (or timer values) value to structures 
.................... { 
....................   int x; 
....................    for(x=0;x<mydevices.numberOfInputs;++x) 
*
00964:  MOVLB  4
00966:  CLRF   x6D
00968:  MOVLB  1
0096A:  MOVF   x3A,W
0096C:  MOVLB  4
0096E:  SUBWF  x6D,W
00970:  BTFSC  FD8.0
00972:  BRA    0DA2
....................    { 
....................       switch (((struct inputs)mydevices.myinputs[x]).type) { 
00974:  CLRF   x6F
00976:  MOVFF  46D,46E
0097A:  CLRF   x71
0097C:  MOVLW  12
0097E:  MOVWF  x70
00980:  MOVLB  0
00982:  RCALL  031E
00984:  MOVFF  02,03
00988:  MOVF   01,W
0098A:  ADDLW  3C
0098C:  MOVWF  01
0098E:  MOVLW  01
00990:  ADDWFC 03,F
00992:  MOVFF  01,FE9
00996:  MOVFF  03,FEA
0099A:  MOVF   FEF,W
0099C:  BZ    09B2
0099E:  XORLW  03
009A0:  BTFSC  FD8.2
009A2:  BRA    0AF8
009A4:  XORLW  02
009A6:  BTFSC  FD8.2
009A8:  BRA    0AFA
009AA:  XORLW  03
009AC:  BTFSC  FD8.2
009AE:  BRA    0C48
009B0:  BRA    0D9A
....................     case dimmer_switch: 
....................            // printf("aki"); 
....................             if (input (((struct dimmer_switch)mydevices.myinputs[x].device).realbutton))  
009B2:  MOVLB  4
009B4:  CLRF   x6F
009B6:  MOVFF  46D,46E
009BA:  CLRF   x71
009BC:  MOVLW  12
009BE:  MOVWF  x70
009C0:  MOVLB  0
009C2:  RCALL  031E
009C4:  MOVF   01,W
009C6:  ADDLW  02
009C8:  MOVLB  4
009CA:  MOVWF  x6E
009CC:  MOVLW  00
009CE:  ADDWFC 02,W
009D0:  MOVWF  x6F
009D2:  MOVLW  01
009D4:  ADDWF  x6E,W
009D6:  MOVWF  01
009D8:  MOVLW  00
009DA:  ADDWFC x6F,W
009DC:  MOVWF  03
009DE:  MOVF   01,W
009E0:  ADDLW  3A
009E2:  MOVWF  01
009E4:  MOVLW  01
009E6:  ADDWFC 03,F
009E8:  MOVF   01,W
009EA:  ADDLW  10
009EC:  MOVWF  FE9
009EE:  MOVLW  00
009F0:  ADDWFC 03,W
009F2:  MOVWF  FEA
009F4:  MOVFF  FEF,470
009F8:  MOVFF  470,471
009FC:  MOVLW  01
009FE:  MOVWF  x72
00A00:  MOVLW  0F
00A02:  MOVWF  x74
00A04:  MOVLW  92
00A06:  MOVWF  x73
00A08:  MOVLB  0
00A0A:  RCALL  0340
00A0C:  MOVFF  470,471
00A10:  MOVLW  0F
00A12:  MOVLB  4
00A14:  MOVWF  x73
00A16:  MOVLW  80
00A18:  MOVWF  x72
00A1A:  MOVLB  0
00A1C:  RCALL  0382
00A1E:  BTFSS  01.0
00A20:  BRA    0A6A
....................             { 
....................                ((struct dimmer_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
00A22:  MOVLB  4
00A24:  CLRF   x6F
00A26:  MOVFF  46D,46E
00A2A:  CLRF   x71
00A2C:  MOVLW  12
00A2E:  MOVWF  x70
00A30:  MOVLB  0
00A32:  RCALL  031E
00A34:  MOVF   01,W
00A36:  ADDLW  02
00A38:  MOVLB  4
00A3A:  MOVWF  x6E
00A3C:  MOVLW  00
00A3E:  ADDWFC 02,W
00A40:  MOVWF  x6F
00A42:  MOVLW  01
00A44:  ADDWF  x6E,W
00A46:  MOVWF  01
00A48:  MOVLW  00
00A4A:  ADDWFC x6F,W
00A4C:  MOVWF  03
00A4E:  MOVF   01,W
00A50:  ADDLW  3A
00A52:  MOVWF  01
00A54:  MOVLW  01
00A56:  ADDWFC 03,F
00A58:  MOVF   01,W
00A5A:  ADDLW  0E
00A5C:  MOVWF  FE9
00A5E:  MOVLW  00
00A60:  ADDWFC 03,W
00A62:  MOVWF  FEA
00A64:  BSF    FEF.0
....................             } 
....................             else  
00A66:  BRA    0AAE
00A68:  MOVLB  0
....................             { 
....................                ((struct dimmer_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
00A6A:  MOVLB  4
00A6C:  CLRF   x6F
00A6E:  MOVFF  46D,46E
00A72:  CLRF   x71
00A74:  MOVLW  12
00A76:  MOVWF  x70
00A78:  MOVLB  0
00A7A:  RCALL  031E
00A7C:  MOVF   01,W
00A7E:  ADDLW  02
00A80:  MOVLB  4
00A82:  MOVWF  x6E
00A84:  MOVLW  00
00A86:  ADDWFC 02,W
00A88:  MOVWF  x6F
00A8A:  MOVLW  01
00A8C:  ADDWF  x6E,W
00A8E:  MOVWF  01
00A90:  MOVLW  00
00A92:  ADDWFC x6F,W
00A94:  MOVWF  03
00A96:  MOVF   01,W
00A98:  ADDLW  3A
00A9A:  MOVWF  01
00A9C:  MOVLW  01
00A9E:  ADDWFC 03,F
00AA0:  MOVF   01,W
00AA2:  ADDLW  0E
00AA4:  MOVWF  FE9
00AA6:  MOVLW  00
00AA8:  ADDWFC 03,W
00AAA:  MOVWF  FEA
00AAC:  BCF    FEF.0
....................             } 
....................             process_dimmers(&mydevices.myinputs[x].device); 
00AAE:  CLRF   x6F
00AB0:  MOVFF  46D,46E
00AB4:  CLRF   x71
00AB6:  MOVLW  12
00AB8:  MOVWF  x70
00ABA:  MOVLB  0
00ABC:  RCALL  031E
00ABE:  MOVF   01,W
00AC0:  ADDLW  02
00AC2:  MOVLB  4
00AC4:  MOVWF  x6E
00AC6:  MOVLW  00
00AC8:  ADDWFC 02,W
00ACA:  MOVWF  x6F
00ACC:  MOVLW  01
00ACE:  ADDWF  x6E,W
00AD0:  MOVWF  01
00AD2:  MOVLW  00
00AD4:  ADDWFC x6F,W
00AD6:  MOVWF  03
00AD8:  MOVF   01,W
00ADA:  ADDLW  3A
00ADC:  MOVWF  01
00ADE:  MOVLW  01
00AE0:  ADDWFC 03,F
00AE2:  MOVFF  01,46E
00AE6:  MOVFF  03,46F
00AEA:  MOVFF  03,471
00AEE:  MOVFF  01,470
00AF2:  MOVLB  0
00AF4:  BRA    03B4
....................             break; 
00AF6:  BRA    0D9C
....................     case timer: 
....................  
....................            break; 
00AF8:  BRA    0D9C
....................     case on_off_switch: 
....................            // printf("aki"); 
....................             if (input (((struct on_off_switch)mydevices.myinputs[x].device).realbutton))  
00AFA:  MOVLB  4
00AFC:  CLRF   x6F
00AFE:  MOVFF  46D,46E
00B02:  CLRF   x71
00B04:  MOVLW  12
00B06:  MOVWF  x70
00B08:  MOVLB  0
00B0A:  RCALL  031E
00B0C:  MOVF   01,W
00B0E:  ADDLW  02
00B10:  MOVLB  4
00B12:  MOVWF  x6E
00B14:  MOVLW  00
00B16:  ADDWFC 02,W
00B18:  MOVWF  x6F
00B1A:  MOVLW  01
00B1C:  ADDWF  x6E,W
00B1E:  MOVWF  01
00B20:  MOVLW  00
00B22:  ADDWFC x6F,W
00B24:  MOVWF  03
00B26:  MOVF   01,W
00B28:  ADDLW  3A
00B2A:  MOVWF  01
00B2C:  MOVLW  01
00B2E:  ADDWFC 03,F
00B30:  MOVF   01,W
00B32:  ADDLW  0C
00B34:  MOVWF  FE9
00B36:  MOVLW  00
00B38:  ADDWFC 03,W
00B3A:  MOVWF  FEA
00B3C:  MOVFF  FEF,470
00B40:  MOVFF  470,471
00B44:  MOVLW  01
00B46:  MOVWF  x72
00B48:  MOVLW  0F
00B4A:  MOVWF  x74
00B4C:  MOVLW  92
00B4E:  MOVWF  x73
00B50:  MOVLB  0
00B52:  CALL   0340
00B56:  MOVFF  470,471
00B5A:  MOVLW  0F
00B5C:  MOVLB  4
00B5E:  MOVWF  x73
00B60:  MOVLW  80
00B62:  MOVWF  x72
00B64:  MOVLB  0
00B66:  RCALL  0382
00B68:  BTFSS  01.0
00B6A:  BRA    0BB6
....................             { 
....................                ((struct on_off_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
00B6C:  MOVLB  4
00B6E:  CLRF   x6F
00B70:  MOVFF  46D,46E
00B74:  CLRF   x71
00B76:  MOVLW  12
00B78:  MOVWF  x70
00B7A:  MOVLB  0
00B7C:  CALL   031E
00B80:  MOVF   01,W
00B82:  ADDLW  02
00B84:  MOVLB  4
00B86:  MOVWF  x6E
00B88:  MOVLW  00
00B8A:  ADDWFC 02,W
00B8C:  MOVWF  x6F
00B8E:  MOVLW  01
00B90:  ADDWF  x6E,W
00B92:  MOVWF  01
00B94:  MOVLW  00
00B96:  ADDWFC x6F,W
00B98:  MOVWF  03
00B9A:  MOVF   01,W
00B9C:  ADDLW  3A
00B9E:  MOVWF  01
00BA0:  MOVLW  01
00BA2:  ADDWFC 03,F
00BA4:  MOVF   01,W
00BA6:  ADDLW  06
00BA8:  MOVWF  FE9
00BAA:  MOVLW  00
00BAC:  ADDWFC 03,W
00BAE:  MOVWF  FEA
00BB0:  BSF    FEF.0
....................             } 
....................             else  
00BB2:  BRA    0BFC
00BB4:  MOVLB  0
....................             { 
....................                ((struct on_off_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
00BB6:  MOVLB  4
00BB8:  CLRF   x6F
00BBA:  MOVFF  46D,46E
00BBE:  CLRF   x71
00BC0:  MOVLW  12
00BC2:  MOVWF  x70
00BC4:  MOVLB  0
00BC6:  CALL   031E
00BCA:  MOVF   01,W
00BCC:  ADDLW  02
00BCE:  MOVLB  4
00BD0:  MOVWF  x6E
00BD2:  MOVLW  00
00BD4:  ADDWFC 02,W
00BD6:  MOVWF  x6F
00BD8:  MOVLW  01
00BDA:  ADDWF  x6E,W
00BDC:  MOVWF  01
00BDE:  MOVLW  00
00BE0:  ADDWFC x6F,W
00BE2:  MOVWF  03
00BE4:  MOVF   01,W
00BE6:  ADDLW  3A
00BE8:  MOVWF  01
00BEA:  MOVLW  01
00BEC:  ADDWFC 03,F
00BEE:  MOVF   01,W
00BF0:  ADDLW  06
00BF2:  MOVWF  FE9
00BF4:  MOVLW  00
00BF6:  ADDWFC 03,W
00BF8:  MOVWF  FEA
00BFA:  BCF    FEF.0
....................             } 
....................             process_onOff(&mydevices.myinputs[x].device); 
00BFC:  CLRF   x6F
00BFE:  MOVFF  46D,46E
00C02:  CLRF   x71
00C04:  MOVLW  12
00C06:  MOVWF  x70
00C08:  MOVLB  0
00C0A:  CALL   031E
00C0E:  MOVF   01,W
00C10:  ADDLW  02
00C12:  MOVLB  4
00C14:  MOVWF  x6E
00C16:  MOVLW  00
00C18:  ADDWFC 02,W
00C1A:  MOVWF  x6F
00C1C:  MOVLW  01
00C1E:  ADDWF  x6E,W
00C20:  MOVWF  01
00C22:  MOVLW  00
00C24:  ADDWFC x6F,W
00C26:  MOVWF  03
00C28:  MOVF   01,W
00C2A:  ADDLW  3A
00C2C:  MOVWF  01
00C2E:  MOVLW  01
00C30:  ADDWFC 03,F
00C32:  MOVFF  01,46E
00C36:  MOVFF  03,46F
00C3A:  MOVFF  03,471
00C3E:  MOVFF  01,470
00C42:  MOVLB  0
00C44:  BRA    075A
....................     break; 
00C46:  BRA    0D9C
....................     case button_switch: 
....................            // printf("aki"); 
....................             if (input (((struct button_switch)mydevices.myinputs[x].device).realbutton))  
00C48:  MOVLB  4
00C4A:  CLRF   x6F
00C4C:  MOVFF  46D,46E
00C50:  CLRF   x71
00C52:  MOVLW  12
00C54:  MOVWF  x70
00C56:  MOVLB  0
00C58:  CALL   031E
00C5C:  MOVF   01,W
00C5E:  ADDLW  02
00C60:  MOVLB  4
00C62:  MOVWF  x6E
00C64:  MOVLW  00
00C66:  ADDWFC 02,W
00C68:  MOVWF  x6F
00C6A:  MOVLW  01
00C6C:  ADDWF  x6E,W
00C6E:  MOVWF  01
00C70:  MOVLW  00
00C72:  ADDWFC x6F,W
00C74:  MOVWF  03
00C76:  MOVF   01,W
00C78:  ADDLW  3A
00C7A:  MOVWF  01
00C7C:  MOVLW  01
00C7E:  ADDWFC 03,F
00C80:  MOVF   01,W
00C82:  ADDLW  0C
00C84:  MOVWF  FE9
00C86:  MOVLW  00
00C88:  ADDWFC 03,W
00C8A:  MOVWF  FEA
00C8C:  MOVFF  FEF,470
00C90:  MOVFF  470,471
00C94:  MOVLW  01
00C96:  MOVWF  x72
00C98:  MOVLW  0F
00C9A:  MOVWF  x74
00C9C:  MOVLW  92
00C9E:  MOVWF  x73
00CA0:  MOVLB  0
00CA2:  CALL   0340
00CA6:  MOVFF  470,471
00CAA:  MOVLW  0F
00CAC:  MOVLB  4
00CAE:  MOVWF  x73
00CB0:  MOVLW  80
00CB2:  MOVWF  x72
00CB4:  MOVLB  0
00CB6:  CALL   0382
00CBA:  BTFSS  01.0
00CBC:  BRA    0D08
....................             { 
....................                ((struct button_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
00CBE:  MOVLB  4
00CC0:  CLRF   x6F
00CC2:  MOVFF  46D,46E
00CC6:  CLRF   x71
00CC8:  MOVLW  12
00CCA:  MOVWF  x70
00CCC:  MOVLB  0
00CCE:  CALL   031E
00CD2:  MOVF   01,W
00CD4:  ADDLW  02
00CD6:  MOVLB  4
00CD8:  MOVWF  x6E
00CDA:  MOVLW  00
00CDC:  ADDWFC 02,W
00CDE:  MOVWF  x6F
00CE0:  MOVLW  01
00CE2:  ADDWF  x6E,W
00CE4:  MOVWF  01
00CE6:  MOVLW  00
00CE8:  ADDWFC x6F,W
00CEA:  MOVWF  03
00CEC:  MOVF   01,W
00CEE:  ADDLW  3A
00CF0:  MOVWF  01
00CF2:  MOVLW  01
00CF4:  ADDWFC 03,F
00CF6:  MOVF   01,W
00CF8:  ADDLW  06
00CFA:  MOVWF  FE9
00CFC:  MOVLW  00
00CFE:  ADDWFC 03,W
00D00:  MOVWF  FEA
00D02:  BSF    FEF.0
....................             } 
....................             else  
00D04:  BRA    0D4E
00D06:  MOVLB  0
....................             { 
....................                ((struct button_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
00D08:  MOVLB  4
00D0A:  CLRF   x6F
00D0C:  MOVFF  46D,46E
00D10:  CLRF   x71
00D12:  MOVLW  12
00D14:  MOVWF  x70
00D16:  MOVLB  0
00D18:  CALL   031E
00D1C:  MOVF   01,W
00D1E:  ADDLW  02
00D20:  MOVLB  4
00D22:  MOVWF  x6E
00D24:  MOVLW  00
00D26:  ADDWFC 02,W
00D28:  MOVWF  x6F
00D2A:  MOVLW  01
00D2C:  ADDWF  x6E,W
00D2E:  MOVWF  01
00D30:  MOVLW  00
00D32:  ADDWFC x6F,W
00D34:  MOVWF  03
00D36:  MOVF   01,W
00D38:  ADDLW  3A
00D3A:  MOVWF  01
00D3C:  MOVLW  01
00D3E:  ADDWFC 03,F
00D40:  MOVF   01,W
00D42:  ADDLW  06
00D44:  MOVWF  FE9
00D46:  MOVLW  00
00D48:  ADDWFC 03,W
00D4A:  MOVWF  FEA
00D4C:  BCF    FEF.0
....................             } 
....................             process_buttons(&mydevices.myinputs[x].device); 
00D4E:  CLRF   x6F
00D50:  MOVFF  46D,46E
00D54:  CLRF   x71
00D56:  MOVLW  12
00D58:  MOVWF  x70
00D5A:  MOVLB  0
00D5C:  CALL   031E
00D60:  MOVF   01,W
00D62:  ADDLW  02
00D64:  MOVLB  4
00D66:  MOVWF  x6E
00D68:  MOVLW  00
00D6A:  ADDWFC 02,W
00D6C:  MOVWF  x6F
00D6E:  MOVLW  01
00D70:  ADDWF  x6E,W
00D72:  MOVWF  01
00D74:  MOVLW  00
00D76:  ADDWFC x6F,W
00D78:  MOVWF  03
00D7A:  MOVF   01,W
00D7C:  ADDLW  3A
00D7E:  MOVWF  01
00D80:  MOVLW  01
00D82:  ADDWFC 03,F
00D84:  MOVFF  01,46E
00D88:  MOVFF  03,46F
00D8C:  MOVFF  03,471
00D90:  MOVFF  01,470
00D94:  MOVLB  0
00D96:  BRA    087A
....................     break; 
00D98:  BRA    0D9C
....................     default: 
....................  
....................             break;  
00D9A:  BRA    0D9C
....................             } 
....................  
....................    } 
00D9C:  MOVLB  4
00D9E:  INCF   x6D,F
00DA0:  BRA    0968
.................... } 
00DA2:  MOVLB  0
00DA4:  GOTO   0DC2 (RETURN)
.................... void print_inputs(int1 disable_updates) 
.................... { 
....................    int x; 
....................     
....................    { 
....................       delay_ms (200) ; 
....................       for(x=0;x<mydevices.numberOfInputs;++x) 
....................       { 
....................          switch (((struct inputs)mydevices.myinputs[x]).type) { 
....................             case dimmer_switch: 
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.needs_update) 
....................                { 
....................                   printf("dim_level %u\n\r"((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.value); 
....................                   if(disable_updates)((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.needs_update=false; 
....................                } 
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).on.needs_update) 
....................                { 
....................                   printf("on %u\n\r",((struct dimmer_switch)mydevices.myinputs[0].device).on.value); 
....................                   if(disable_updates)((struct dimmer_switch)mydevices.myinputs[0].device).on.needs_update=false; 
....................                }            
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).off.needs_update) 
....................                { 
....................                   printf("off %u\n\r",((struct dimmer_switch)mydevices.myinputs[0].device).off.value); 
....................                   if(disable_updates)((struct dimmer_switch)mydevices.myinputs[0].device).off.needs_update=false; 
....................                } 
....................                break; 
....................             case on_off_switch: 
....................                if(((struct on_off_switch)mydevices.myinputs[0].device).on.needs_update) 
....................                { 
....................                   printf("on %u\n\r",((struct on_off_switch)mydevices.myinputs[0].device).on.value); 
....................                   if(disable_updates)((struct on_off_switch)mydevices.myinputs[0].device).on.needs_update=false; 
....................                }            
....................                if(((struct on_off_switch)mydevices.myinputs[0].device).off.needs_update) 
....................                { 
....................                   printf("off %u\n\r",((struct on_off_switch)mydevices.myinputs[0].device).off.value); 
....................                   if(disable_updates)((struct on_off_switch)mydevices.myinputs[0].device).off.needs_update=false; 
....................                } 
....................             break; 
....................             case button_switch: 
....................                if(((struct button_switch)mydevices.myinputs[0].device).on.needs_update) 
....................                { 
....................                   printf("on %u\n\r",((struct button_switch)mydevices.myinputs[0].device).on.value); 
....................                   if(disable_updates)((struct button_switch)mydevices.myinputs[0].device).on.needs_update=false; 
....................                }            
....................                if(((struct button_switch)mydevices.myinputs[0].device).off.needs_update) 
....................                { 
....................                   printf("off %u\n\r",((struct button_switch)mydevices.myinputs[0].device).off.value); 
....................                   if(disable_updates)((struct button_switch)mydevices.myinputs[0].device).off.needs_update=false; 
....................                } 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... #include "interrupt_functions.c" 
.................... int1 flag=0;//mains not detected flag 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  
.................... { 
....................    ++clock; 
00DA8:  MOVLW  01
00DAA:  MOVLB  4
00DAC:  ADDWF  x0F,F
00DAE:  BTFSC  FD8.0
00DB0:  INCF   x10,F
00DB2:  BTFSC  FD8.2
00DB4:  INCF   x11,F
00DB6:  BTFSC  FD8.2
00DB8:  INCF   x12,F
....................    if (bit_test (clock, 1)) read_inputs(); 
00DBA:  BTFSS  x0F.1
00DBC:  BRA    0DC4
00DBE:  MOVLB  0
00DC0:  BRA    0964
00DC2:  MOVLB  4
.................... } 
....................  
00DC4:  BCF    FF2.2
00DC6:  MOVLB  0
00DC8:  GOTO   011C
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................    flag = 1; 
00DCC:  BSF    xB1.4
.................... } 
00DCE:  BCF    F9E.0
00DD0:  GOTO   011C
.................... #int_TIMER2 
.................... void  TIMER2_isr(void) 
.................... { 
....................    static unsigned int32 clockT2; 
....................    static unsigned int clockT2temp; 
....................    //static int lixo=0; 
....................    ++clockT2temp; 
00DD4:  MOVLB  4
00DD6:  INCF   x1C,F
....................    if(clockT2temp==200)//1 second call 
00DD8:  MOVF   x1C,W
00DDA:  SUBLW  C8
00DDC:  BNZ   0DF4
....................    { 
....................       output_toggle(LED); 
00DDE:  BCF    F96.2
00DE0:  BTG    F8D.2
....................       clockT2temp=0; 
00DE2:  CLRF   x1C
....................       ++clockT2; 
00DE4:  MOVLW  01
00DE6:  ADDWF  x18,F
00DE8:  BTFSC  FD8.0
00DEA:  INCF   x19,F
00DEC:  BTFSC  FD8.2
00DEE:  INCF   x1A,F
00DF0:  BTFSC  FD8.2
00DF2:  INCF   x1B,F
....................       /* 
....................       if(!lixo) 
....................       { 
....................          ++((struct light)mydevices.myoutputs[0].device).dim_value.value; 
....................          ((struct light)mydevices.myoutputs[0].device).dim_value.needs_update=true; 
....................       } 
....................       else 
....................       { 
....................          --((struct light)mydevices.myoutputs[0].device).dim_value.value; 
....................          ((struct light)mydevices.myoutputs[0].device).dim_value.needs_update=true; 
....................       } 
....................       if(((struct light)mydevices.myoutputs[0].device).dim_value.value==127) 
....................          lixo=1; 
....................       else if(((struct light)mydevices.myoutputs[0].device).dim_value.value==0) 
....................          lixo=0; 
....................       */ 
....................    } 
.................... } 
....................  
00DF4:  BCF    F9E.1
00DF6:  MOVLB  0
00DF8:  GOTO   011C
.................... #int_EXT 
.................... void  EXT_isr(void)  
.................... { 
00DFC:  MOVLB  3
00DFE:  MOVF   x55,W
00E00:  IORWF  x53,W
00E02:  MOVLB  4
00E04:  MOVWF  x6D
00E06:  MOVLB  3
00E08:  MOVF   x56,W
00E0A:  IORWF  x54,W
00E0C:  MOVLB  4
00E0E:  MOVWF  x6E
....................           
....................   // set_timer1 (0) ; 
....................          unsigned int16 temp= onoffsvalue | dimmers_off_value; 
....................          portc=MAKE8(temp,1); 
00E10:  MOVFF  46E,F82
....................          portd=MAKE8(temp,0); 
00E14:  MOVFF  46D,F83
....................    
....................          if (organizado) 
00E18:  MOVLB  0
00E1A:  BTFSS  xB1.2
00E1C:  BRA    0E40
....................          { 
....................             organizado=0; 
00E1E:  BCF    xB1.2
....................             if (actmat)  
00E20:  BTFSS  xB1.3
00E22:  BRA    0E34
....................             { 
....................                actmat=0; 
00E24:  BCF    xB1.3
....................                pointer=delays1; 
00E26:  MOVLW  03
00E28:  MOVLB  3
00E2A:  MOVWF  x50
00E2C:  MOVLW  67
00E2E:  MOVWF  x4F
....................             } 
....................             else 
00E30:  BRA    0E40
00E32:  MOVLB  0
....................             { 
....................                actmat=1; 
00E34:  BSF    xB1.3
....................                pointer=delays2; 
00E36:  MOVLW  03
00E38:  MOVLB  3
00E3A:  MOVWF  x50
00E3C:  MOVLW  AB
00E3E:  MOVWF  x4F
....................             } 
....................          } 
....................          vez=0; 
00E40:  MOVLB  3
00E42:  CLRF   x51
....................          CCP_1=matrizluz[fpointer(0,0)]; 
00E44:  MOVLB  4
00E46:  CLRF   x6F
00E48:  CLRF   x70
*
00EB4:  MOVFF  02,470
00EB8:  MOVFF  01,46F
00EBC:  BCF    FD8.0
00EBE:  RLCF   01,W
00EC0:  MOVWF  02
00EC2:  RLCF   x70,W
00EC4:  MOVWF  03
00EC6:  MOVF   02,W
00EC8:  MOVLB  0
00ECA:  CALL   01A6
00ECE:  TBLRD*+
00ED0:  MOVFF  FF5,03
00ED4:  MOVWF  FBE
00ED6:  MOVFF  03,FBF
....................          mnumluzes=fpointer(N_LUZES,0); 
00EDA:  MOVLW  10
00EDC:  MOVLB  4
00EDE:  MOVWF  x6F
00EE0:  CLRF   x70
*
00F4C:  MOVFF  01,352
....................          set_timer1(0); 
00F50:  CLRF   FCF
00F52:  CLRF   FCE
.................... } 
....................  
00F54:  BCF    FF2.1
00F56:  MOVLB  0
00F58:  GOTO   011C
.................... #int_CCP1 
.................... void CCP1_isr(void)  
.................... { 
....................    if(mnumluzes!=0) 
00F5C:  MOVLB  3
00F5E:  MOVF   x52,F
00F60:  BTFSC  FD8.2
00F62:  BRA    1088
....................    { 
....................       int16 auxccp=fpointer(vez,1); 
00F64:  MOVFF  351,46F
00F68:  MOVLW  01
00F6A:  MOVLB  4
00F6C:  MOVWF  x70
*
00FD8:  MOVFF  02,46E
00FDC:  MOVFF  01,46D
....................      // printf("AUXCPP %lu",auxccp); 
....................       portc=(portc & MAKE8(auxccp,1)); 
00FE0:  MOVF   x6E,W
00FE2:  ANDWF  F82,F
....................       portd=(portd & MAKE8(auxccp,0)); 
00FE4:  MOVF   x6D,W
00FE6:  ANDWF  F83,F
....................       ++vez; 
00FE8:  MOVLB  3
00FEA:  INCF   x51,F
....................       --mnumluzes; 
00FEC:  DECF   x52,F
....................       CCP_1=matrizluz[fpointer(vez,0)]; 
00FEE:  MOVFF  351,46F
00FF2:  MOVLB  4
00FF4:  CLRF   x70
*
01060:  MOVFF  02,470
01064:  MOVFF  01,46F
01068:  BCF    FD8.0
0106A:  RLCF   01,W
0106C:  MOVWF  02
0106E:  RLCF   x70,W
01070:  MOVWF  03
01072:  MOVF   02,W
01074:  MOVLB  0
01076:  CALL   01A6
0107A:  TBLRD*+
0107C:  MOVFF  FF5,03
01080:  MOVWF  FBE
01082:  MOVFF  03,FBF
01086:  MOVLB  3
....................    } 
.................... } 
....................  
01088:  BCF    F9E.2
0108A:  MOVLB  0
0108C:  GOTO   011C
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
.................... } 
....................  
01090:  BCF    F9E.5
01092:  GOTO   011C
.................... #int_TBE 
.................... void  TBE_isr(void)  
.................... { 
.................... } 
....................  
01096:  BCF    F9E.4
01098:  GOTO   011C
.................... #int_BUSCOL 
.................... void  BUSCOL_isr(void)  
.................... { 
.................... } 
....................  
0109C:  BCF    FA1.3
0109E:  GOTO   011C
.................... #int_OSCF 
.................... void  OSCF_isr(void)  
.................... { 
.................... } 
....................  
010A2:  BCF    FA1.7
010A4:  GOTO   011C
.................... #int_canrx0 
.................... void canrx0_int ( )  
.................... { 
....................    canReceive (); 
*
01650:  RCALL  12A0
....................    // TODO: add CAN recieve code here 
.................... } 
....................  
01652:  BCF    FA4.0
01654:  GOTO   011C
.................... #int_canrx1 
.................... void canrx1_int ( )  
.................... { 
....................    canReceive (); 
01658:  RCALL  12A0
....................    // TODO: add CAN recieve code here 
.................... } 
....................  
0165A:  BCF    FA4.1
0165C:  GOTO   011C
.................... #int_cantx0 
.................... void cantx0_int ( )  
.................... { 
....................    canTransmit (); 
*
01A80:  RCALL  1866
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
01A82:  BCF    FA4.2
01A84:  GOTO   011C
.................... #int_cantx1 
.................... void cantx1_int ( )  
.................... { 
....................    canTransmit (); 
01A88:  RCALL  1866
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
01A8A:  BCF    FA4.3
01A8C:  GOTO   011C
.................... #int_cantx2 
.................... void cantx2_int ( )  
.................... { 
....................    canTransmit (); 
01A90:  RCALL  1866
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
01A92:  BCF    FA4.4
01A94:  GOTO   011C
.................... #int_canirx 
.................... void canirx_int ( )  
.................... { 
....................    // TODO: add CAN IRX handling code here 
.................... } 
....................  
01A98:  BCF    FA4.7
01A9A:  GOTO   011C
.................... #int_canerr 
.................... void canerr_int ( )  
.................... { 
....................    // TODO: add CAN error handling code here 
.................... } 
....................  
01A9E:  BCF    FA4.5
01AA0:  GOTO   011C
.................... void interrupts_enable() 
.................... { 
....................    enable_interrupts (int_canrx0); 
*
033B8:  BSF    FA3.0
....................    enable_interrupts (int_canrx1); 
033BA:  BSF    FA3.1
....................    enable_interrupts (int_cantx0); 
033BC:  BSF    FA3.2
....................    enable_interrupts (int_cantx1); 
033BE:  BSF    FA3.3
....................    enable_interrupts (int_cantx2); 
033C0:  BSF    FA3.4
....................    enable_interrupts (int_canirx); 
033C2:  BSF    FA3.7
....................    enable_interrupts (int_canerr); 
033C4:  BSF    FA3.5
....................    enable_interrupts(INT_CCP1); 
033C6:  BSF    F9D.2
....................    enable_interrupts (int_TIMER0) ; 
033C8:  BSF    FF2.5
....................    enable_interrupts (int_TIMER2) ; 
033CA:  BSF    F9D.1
....................    enable_interrupts (int_EXT) ; 
033CC:  BSF    FF2.4
....................    //enable_interrupts (int_TBE) ; 
....................    //enable_interrupts (int_BUSCOL) ; 
....................    //enable_interrupts (int_CANIRX) ; 
....................    //enable_interrupts (int_CANERR) ; 
....................    //enable_interrupts (int_CANTX2) ; 
....................    //enable_interrupts (int_CANTX1) ; 
....................    //enable_interrupts (int_CANTX0) ; 
....................    //enable_interrupts (int_CANRX1) ; 
....................    //enable_interrupts (int_CANRX0) ; 
....................    //enable_interrupts (int_OSCF) ; 
....................    enable_interrupts (GLOBAL) ; 
033CE:  MOVLW  C0
033D0:  IORWF  FF2,F
.................... } 
033D2:  GOTO   428A (RETURN)
....................  
.................... #include "hw_setup.c" 
.................... void hw_setup() 
.................... { 
....................    ////CAN_BUS SETUP 
....................    can_init () ; 
*
01C78:  BRA    1B24
....................    can_set_mode (CAN_OP_CONFIG) ;   
01C7A:  MOVLW  04
01C7C:  MOVLB  4
01C7E:  MOVWF  x1F
01C80:  MOVLB  0
01C82:  RCALL  1ACE
....................    BRGCON1.brp = 4; 
01C84:  MOVLW  C0
01C86:  ANDWF  F70,W
01C88:  IORLW  04
01C8A:  MOVWF  F70
....................    BRGCON1.sjw = 0; 
01C8C:  MOVLW  3F
01C8E:  ANDWF  F70,W
01C90:  MOVWF  F70
....................    BRGCON2.prseg = 2; 
01C92:  MOVLW  F8
01C94:  ANDWF  F71,W
01C96:  IORLW  02
01C98:  MOVWF  F71
....................    BRGCON2.seg1ph = 5; 
01C9A:  MOVLW  C7
01C9C:  ANDWF  F71,W
01C9E:  IORLW  28
01CA0:  MOVWF  F71
....................    BRGCON2.sam = FALSE; 
01CA2:  BCF    F71.6
....................    BRGCON2.seg2phts = FALSE; 
01CA4:  BCF    F71.7
....................    BRGCON3.seg2ph = 5; 
01CA6:  MOVLW  F8
01CA8:  ANDWF  F72,W
01CAA:  IORLW  05
01CAC:  MOVWF  F72
....................    BRGCON3.wakfil = TRUE; 
01CAE:  BSF    F72.6
....................    can_set_mode (CAN_OP_NORMAL) ; 
01CB0:  MOVLB  4
01CB2:  CLRF   x1F
01CB4:  MOVLB  0
01CB6:  RCALL  1ACE
....................        
....................    ////TIMERS SETUP 
....................    setup_timer_0 (RTCC_INTERNAL | RTCC_DIV_4); //div16 1.6us thick 104ms overflow 
01CB8:  MOVLW  81
01CBA:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_2); 
01CBC:  MOVLW  95
01CBE:  MOVWF  FCD
....................    setup_timer_2(T2_DIV_BY_16,241,13); 
01CC0:  MOVLW  60
01CC2:  IORLW  06
01CC4:  MOVWF  FCA
01CC6:  MOVLW  F1
01CC8:  MOVWF  FCB
....................    setup_ccp1(CCP_COMPARE_INT); 
01CCA:  MOVLW  0A
01CCC:  MOVWF  FBD
....................    ////OTHERS 
....................    ext_int_edge(l_to_h); 
01CCE:  BSF    FF1.6
....................     
....................     
....................    /////DISABLED HW//////// 
....................    setup_adc_ports (NO_ANALOGS | VSS_VDD) ; 
01CD0:  MOVF   FC1,W
01CD2:  ANDLW  C0
01CD4:  IORLW  0F
01CD6:  MOVWF  FC1
....................    setup_adc (ADC_CLOCK_DIV_2 | ADC_TAD_MUL_0) ; 
01CD8:  MOVF   FC0,W
01CDA:  ANDLW  C0
01CDC:  MOVWF  FC0
01CDE:  BCF    FC0.7
01CE0:  BSF    FC2.0
....................    setup_psp (PSP_DISABLED) ; 
01CE2:  BCF    F96.4
....................    setup_spi (SPI_SS_DISABLED) ; 
01CE4:  BCF    FC6.5
01CE6:  MOVLW  01
01CE8:  MOVWF  FC6
01CEA:  MOVLW  00
01CEC:  MOVWF  FC7
....................    setup_comparator (NC_NC_NC_NC) ; 
01CEE:  MOVLW  07
01CF0:  MOVWF  FB4
01CF2:  MOVF   F95,W
01CF4:  MOVWF  F95
01CF6:  MOVF   F96,W
01CF8:  MOVWF  F96
01CFA:  CLRWDT
01CFC:  MOVLW  20
01CFE:  MOVWF  00
01D00:  DECFSZ 00,F
01D02:  BRA    1D00
01D04:  BRA    1D06
01D06:  MOVF   FB4,W
01D08:  BCF    FA1.6
....................    setup_vref (FALSE) ; 
01D0A:  CLRF   FB5
....................    setup_timer_3 (T3_DISABLED | T3_DIV_BY_1) ; 
01D0C:  CLRF   FB1
....................    //setup_wdt (WDT_ON) ; 
....................    } 
01D0E:  GOTO   4276 (RETURN)
....................  
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... void main() 
.................... { 
*
0407A:  CLRF   FF8
0407C:  BCF    FD0.7
0407E:  BSF    07.7
04080:  CLRF   FEA
04082:  CLRF   FE9
04084:  BCF    F93.5
04086:  BSF    F8A.5
04088:  CLRF   24
0408A:  BCF    xB1.0
0408C:  CLRF   xB2
0408E:  BSF    xB1.1
04090:  MOVLB  3
04092:  CLRF   x4E
04094:  MOVLB  0
04096:  BCF    xB1.3
04098:  MOVLB  3
0409A:  CLRF   x54
0409C:  CLRF   x53
0409E:  MOVLW  FF
040A0:  MOVWF  x56
040A2:  MOVWF  x55
040A4:  MOVLB  4
040A6:  CLRF   x13
040A8:  CLRF   x17
040AA:  CLRF   x16
040AC:  CLRF   x15
040AE:  MOVLW  27
040B0:  MOVWF  x14
040B2:  MOVLB  0
040B4:  BCF    xB1.4
040B6:  MOVF   FC1,W
040B8:  ANDLW  C0
040BA:  IORLW  0F
040BC:  MOVWF  FC1
040BE:  MOVLW  07
040C0:  MOVWF  FB4
040C2:  CLRF   1C
040C4:  MOVLW  01
040C6:  MOVWF  1D
040C8:  MOVLW  02
040CA:  MOVWF  1E
040CC:  MOVLW  03
040CE:  MOVWF  1F
040D0:  MOVLW  04
040D2:  MOVWF  20
040D4:  MOVLW  05
040D6:  MOVWF  21
040D8:  MOVLW  20
040DA:  MOVWF  22
040DC:  MOVLW  21
040DE:  MOVWF  23
040E0:  MOVLW  0B
040E2:  MOVLB  1
040E4:  MOVWF  x35
040E6:  CLRF   x36
040E8:  CLRF   x37
040EA:  CLRF   x38
040EC:  MOVLW  0A
040EE:  MOVLB  3
040F0:  MOVWF  x57
040F2:  MOVWF  x58
040F4:  MOVWF  x59
040F6:  MOVWF  x5A
040F8:  MOVWF  x5B
040FA:  MOVWF  x5C
040FC:  MOVWF  x5D
040FE:  MOVWF  x5E
04100:  MOVWF  x5F
04102:  MOVWF  x60
04104:  MOVWF  x61
04106:  MOVWF  x62
04108:  MOVWF  x63
0410A:  MOVWF  x64
0410C:  MOVWF  x65
0410E:  MOVWF  x66
04110:  CLRF   x67
04112:  CLRF   x68
04114:  CLRF   x69
04116:  CLRF   x6A
04118:  CLRF   x6B
0411A:  CLRF   x6C
0411C:  MOVLW  01
0411E:  MOVWF  x6D
04120:  CLRF   x6E
04122:  CLRF   x6F
04124:  CLRF   x70
04126:  MOVLW  02
04128:  MOVWF  x71
0412A:  CLRF   x72
0412C:  CLRF   x73
0412E:  CLRF   x74
04130:  MOVLW  03
04132:  MOVWF  x75
04134:  CLRF   x76
04136:  CLRF   x77
04138:  CLRF   x78
0413A:  MOVLW  04
0413C:  MOVWF  x79
0413E:  CLRF   x7A
04140:  CLRF   x7B
04142:  CLRF   x7C
04144:  MOVLW  05
04146:  MOVWF  x7D
04148:  CLRF   x7E
0414A:  CLRF   x7F
0414C:  CLRF   x80
0414E:  MOVLW  06
04150:  MOVWF  x81
04152:  CLRF   x82
04154:  CLRF   x83
04156:  CLRF   x84
04158:  MOVLW  07
0415A:  MOVWF  x85
0415C:  CLRF   x86
0415E:  CLRF   x87
04160:  CLRF   x88
04162:  MOVLW  08
04164:  MOVWF  x89
04166:  CLRF   x8A
04168:  CLRF   x8B
0416A:  CLRF   x8C
0416C:  MOVLW  09
0416E:  MOVWF  x8D
04170:  CLRF   x8E
04172:  CLRF   x8F
04174:  CLRF   x90
04176:  MOVLW  0A
04178:  MOVWF  x91
0417A:  CLRF   x92
0417C:  CLRF   x93
0417E:  CLRF   x94
04180:  MOVLW  0B
04182:  MOVWF  x95
04184:  CLRF   x96
04186:  CLRF   x97
04188:  CLRF   x98
0418A:  MOVLW  0C
0418C:  MOVWF  x99
0418E:  CLRF   x9A
04190:  CLRF   x9B
04192:  CLRF   x9C
04194:  MOVLW  0D
04196:  MOVWF  x9D
04198:  CLRF   x9E
0419A:  CLRF   x9F
0419C:  CLRF   xA0
0419E:  MOVLW  0E
041A0:  MOVWF  xA1
041A2:  CLRF   xA2
041A4:  CLRF   xA3
041A6:  CLRF   xA4
041A8:  MOVLW  0F
041AA:  MOVWF  xA5
041AC:  CLRF   xA6
041AE:  CLRF   xA7
041B0:  CLRF   xA8
041B2:  CLRF   xA9
041B4:  CLRF   xAA
041B6:  CLRF   xAB
041B8:  CLRF   xAC
041BA:  CLRF   xAD
041BC:  CLRF   xAE
041BE:  CLRF   xAF
041C0:  CLRF   xB0
041C2:  MOVLW  01
041C4:  MOVWF  xB1
041C6:  CLRF   xB2
041C8:  CLRF   xB3
041CA:  CLRF   xB4
041CC:  MOVLW  02
041CE:  MOVWF  xB5
041D0:  CLRF   xB6
041D2:  CLRF   xB7
041D4:  CLRF   xB8
041D6:  MOVLW  03
041D8:  MOVWF  xB9
041DA:  CLRF   xBA
041DC:  CLRF   xBB
041DE:  CLRF   xBC
041E0:  MOVLW  04
041E2:  MOVWF  xBD
041E4:  CLRF   xBE
041E6:  CLRF   xBF
041E8:  CLRF   xC0
041EA:  MOVLW  05
041EC:  MOVWF  xC1
041EE:  CLRF   xC2
041F0:  CLRF   xC3
041F2:  CLRF   xC4
041F4:  MOVLW  06
041F6:  MOVWF  xC5
041F8:  CLRF   xC6
041FA:  CLRF   xC7
041FC:  CLRF   xC8
041FE:  MOVLW  07
04200:  MOVWF  xC9
04202:  CLRF   xCA
04204:  CLRF   xCB
04206:  CLRF   xCC
04208:  MOVLW  08
0420A:  MOVWF  xCD
0420C:  CLRF   xCE
0420E:  CLRF   xCF
04210:  CLRF   xD0
04212:  MOVLW  09
04214:  MOVWF  xD1
04216:  CLRF   xD2
04218:  CLRF   xD3
0421A:  CLRF   xD4
0421C:  MOVLW  0A
0421E:  MOVWF  xD5
04220:  CLRF   xD6
04222:  CLRF   xD7
04224:  CLRF   xD8
04226:  MOVLW  0B
04228:  MOVWF  xD9
0422A:  CLRF   xDA
0422C:  CLRF   xDB
0422E:  CLRF   xDC
04230:  MOVLW  0C
04232:  MOVWF  xDD
04234:  CLRF   xDE
04236:  CLRF   xDF
04238:  CLRF   xE0
0423A:  MOVLW  0D
0423C:  MOVWF  xE1
0423E:  CLRF   xE2
04240:  CLRF   xE3
04242:  CLRF   xE4
04244:  MOVLW  0E
04246:  MOVWF  xE5
04248:  CLRF   xE6
0424A:  CLRF   xE7
0424C:  CLRF   xE8
0424E:  MOVLW  0F
04250:  MOVWF  xE9
04252:  CLRF   xEA
04254:  CLRF   xEB
04256:  CLRF   xEC
04258:  CLRF   xED
0425A:  CLRF   xEE
0425C:  MOVLB  4
0425E:  CLRF   x18
04260:  CLRF   x19
04262:  CLRF   x1A
04264:  CLRF   x1B
04266:  CLRF   x1C
....................    clock = 0; 
04268:  CLRF   x12
0426A:  CLRF   x11
0426C:  CLRF   x10
0426E:  CLRF   x0F
....................        
....................    hw_setup(); 
04270:  MOVLB  0
04272:  GOTO   1C78
....................    //TODO: User Code 
....................    //struct switches array[NUMBER_OF_SWITCHES]; 
....................    
....................    button_test(); 
04276:  GOTO   1ED6
....................    dimmer_test(); 
0427A:  GOTO   20BC
....................    dimmer_outputs_init(); 
0427E:  GOTO   2766
....................    /*((struct light)mydevices.myoutputs[0].device).dim_value.value=50; 
....................    ((struct light)mydevices.myoutputs[0].device).dim_value.needs_update=true; 
....................    ((struct light)mydevices.myoutputs[0].device).off.value=1; 
....................    ((struct light)mydevices.myoutputs[0].device).off.needs_update=true; 
....................  */ 
....................    write_outputs(); 
04282:  CALL   29F8
....................    interrupts_enable(); 
04286:  GOTO   33B8
....................    printf("start\n\r"); 
0428A:  MOVLW  A4
0428C:  MOVWF  FF6
0428E:  MOVLW  1A
04290:  MOVWF  FF7
04292:  MOVLW  00
04294:  MOVWF  FF8
04296:  CALL   29D0
....................    while(true){ 
....................    process_outpoints(); 
0429A:  GOTO   39C0
....................    write_outputs(); 
0429E:  CALL   29F8
....................   // print_inputs(false); 
....................    }; 
042A2:  BRA    429A
....................      
....................  
....................    while(organizado==0){} 
042A4:  BTFSC  xB1.2
042A6:  BRA    42AA
042A8:  BRA    42A4
....................    for(temp=0;temp<17;++temp) 
042AA:  MOVLB  1
042AC:  CLRF   x39
042AE:  MOVF   x39,W
042B0:  SUBLW  10
042B2:  BTFSS  FD8.0
042B4:  BRA    43FE
....................    { 
....................       printf("%lu <-> %lu\n\r",fpointer(temp,0),fpointer(temp,1)); 
042B6:  MOVFF  139,46F
042BA:  MOVLB  4
042BC:  CLRF   x70
*
04328:  MOVFF  02,420
0432C:  MOVFF  01,41F
04330:  MOVFF  139,46F
04334:  MOVLW  01
04336:  MOVWF  x70
*
043A2:  MOVFF  02,422
043A6:  MOVFF  01,421
043AA:  MOVLW  10
043AC:  MOVWF  FE9
043AE:  MOVFF  420,424
043B2:  MOVFF  41F,423
043B6:  MOVLB  0
043B8:  RCALL  3F0E
043BA:  MOVLW  AF
043BC:  MOVWF  FF6
043BE:  MOVLW  1A
043C0:  MOVWF  FF7
043C2:  MOVLW  00
043C4:  MOVWF  FF8
043C6:  MOVLW  05
043C8:  MOVLB  4
043CA:  MOVWF  x25
043CC:  MOVLB  0
043CE:  CALL   295A
043D2:  MOVLW  10
043D4:  MOVWF  FE9
043D6:  MOVFF  422,424
043DA:  MOVFF  421,423
043DE:  RCALL  3F0E
043E0:  MOVLW  0A
043E2:  MOVLB  4
043E4:  MOVWF  x2C
043E6:  MOVLB  0
043E8:  CALL   2914
043EC:  MOVLW  0D
043EE:  MOVLB  4
043F0:  MOVWF  x2C
043F2:  MOVLB  0
043F4:  CALL   2914
....................    } 
043F8:  MOVLB  1
043FA:  INCF   x39,F
043FC:  BRA    42AE
....................     int16 auxccp=fpointer(0,1); 
043FE:  MOVLB  4
04400:  CLRF   x6F
04402:  MOVLW  01
04404:  MOVWF  x70
*
04470:  MOVFF  02,41E
04474:  MOVFF  01,41D
....................       printf("%lu <-> %u <-> %u\n\r",auxccp,MAKE8(auxccp,1),MAKE8(auxccp,0)); 
04478:  MOVFF  41E,41F
0447C:  MOVFF  41D,420
04480:  MOVLW  10
04482:  MOVWF  FE9
04484:  MOVFF  41E,424
04488:  MOVFF  41D,423
0448C:  MOVLB  0
0448E:  RCALL  3F0E
04490:  MOVLW  BD
04492:  MOVWF  FF6
04494:  MOVLW  1A
04496:  MOVWF  FF7
04498:  MOVLW  00
0449A:  MOVWF  FF8
0449C:  MOVLW  05
0449E:  MOVLB  4
044A0:  MOVWF  x25
044A2:  MOVLB  0
044A4:  CALL   295A
044A8:  MOVFF  41F,421
044AC:  MOVLW  1B
044AE:  MOVLB  4
044B0:  MOVWF  x22
044B2:  MOVLB  0
044B4:  RCALL  3FF8
044B6:  MOVLW  C4
044B8:  MOVWF  FF6
044BA:  MOVLW  1A
044BC:  MOVWF  FF7
044BE:  MOVLW  00
044C0:  MOVWF  FF8
044C2:  MOVLW  05
044C4:  MOVLB  4
044C6:  MOVWF  x25
044C8:  MOVLB  0
044CA:  CALL   295A
044CE:  MOVFF  420,421
044D2:  MOVLW  1B
044D4:  MOVLB  4
044D6:  MOVWF  x22
044D8:  MOVLB  0
044DA:  RCALL  3FF8
044DC:  MOVLW  0A
044DE:  MOVLB  4
044E0:  MOVWF  x2C
044E2:  MOVLB  0
044E4:  CALL   2914
044E8:  MOVLW  0D
044EA:  MOVLB  4
044EC:  MOVWF  x2C
044EE:  MOVLB  0
044F0:  CALL   2914
....................  
.................... } 
....................  
....................  
044F4:  BRA    44F4

Configuration Fuses:
   Word  1: C600   H4 IESO FCMEN
   Word  2: 0E19   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0030   NOSTVREN DEBUG NOLVP NOXINST BBSIZ4K
   Word  5: C03F   NOPROTECT NOCPD NOCPB
   Word  6: E03F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 403F   NOEBTR NOEBTRB
