CCS PCH C Compiler, Version 4.106, 32200               02-Jun-11 11:54

               Filename: C:\Users\Xapo\Documents\Electronica\domos2011\FW\light_mod\main.lst

               ROM used: 11046 bytes (11%)
                         Largest free fragment is 54486
               RAM used: 1044 (31%) at main() level
                         1316 (40%) worst case
               Stack:    8 worst case (3 in main + 5 for interrupts)

*
00000:  GOTO   245C
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   099C
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   09C0
00074:  BTFSS  FF2.4
00076:  GOTO   0080
0007A:  BTFSC  FF2.1
0007C:  GOTO   09C8
00080:  BTFSS  F9D.5
00082:  GOTO   008C
00086:  BTFSC  F9E.5
00088:  GOTO   0B10
0008C:  BTFSS  F9D.4
0008E:  GOTO   0098
00092:  BTFSC  F9E.4
00094:  GOTO   0B16
00098:  BTFSS  F9D.2
0009A:  GOTO   00A4
0009E:  BTFSC  F9E.2
000A0:  GOTO   155A
000A4:  BTFSS  FA0.3
000A6:  GOTO   00B0
000AA:  BTFSC  FA1.3
000AC:  GOTO   0B1C
000B0:  BTFSS  FA3.7
000B2:  GOTO   00BC
000B6:  BTFSC  FA4.7
000B8:  GOTO   154E
000BC:  BTFSS  FA3.5
000BE:  GOTO   00C8
000C2:  BTFSC  FA4.5
000C4:  GOTO   1554
000C8:  BTFSS  FA3.4
000CA:  GOTO   00D4
000CE:  BTFSC  FA4.4
000D0:  GOTO   1546
000D4:  BTFSS  FA3.3
000D6:  GOTO   00E0
000DA:  BTFSC  FA4.3
000DC:  GOTO   153E
000E0:  BTFSS  FA3.2
000E2:  GOTO   00EC
000E6:  BTFSC  FA4.2
000E8:  GOTO   1536
000EC:  BTFSS  FA3.1
000EE:  GOTO   00F8
000F2:  BTFSC  FA4.1
000F4:  GOTO   1106
000F8:  BTFSS  FA3.0
000FA:  GOTO   0104
000FE:  BTFSC  FA4.0
00100:  GOTO   10FE
00104:  BTFSS  FA0.7
00106:  GOTO   0110
0010A:  BTFSC  FA1.7
0010C:  GOTO   0B22
00110:  MOVFF  0E,00
00114:  MOVFF  0F,01
00118:  MOVFF  10,02
0011C:  MOVFF  11,03
00120:  MOVFF  0C,FE9
00124:  MOVFF  07,FEA
00128:  BSF    07.7
0012A:  MOVFF  08,FE1
0012E:  MOVFF  09,FE2
00132:  MOVFF  0A,FD9
00136:  MOVFF  0B,FDA
0013A:  MOVFF  12,FF3
0013E:  MOVFF  13,FF4
00142:  MOVFF  14,FFA
00146:  MOVFF  15,FF5
0014A:  MOVFF  16,FF6
0014E:  MOVFF  17,FF7
00152:  MOVFF  18,FF8
00156:  MOVFF  19,FFB
0015A:  MOVF   04,W
0015C:  MOVFF  06,FE0
00160:  MOVFF  05,FD8
00164:  RETFIE 0
....................  
.................... #include "main.h" 
.................... #include <18F4685.h> 
.................... //////// Standard Header file for the PIC18F4685 device //////////////// 
.................... #device PIC18F4685 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES H4                    	//High speed osc with HW enabled 4X PLL 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT              	//Reset when brownout detected 
.................... #FUSES BORV20                	//Brownout reset at 2.0V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES BBSIZ4K               	//4K words Boot Block size 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=40000000,RESTART_WDT) 
*
02382:  MOVLW  04
02384:  MOVWF  FEA
02386:  MOVLW  A3
02388:  MOVWF  FE9
0238A:  MOVF   FEF,W
0238C:  BZ    23B0
0238E:  MOVLW  0C
02390:  MOVWF  01
02392:  MOVLW  BF
02394:  MOVWF  00
02396:  CLRWDT
02398:  DECFSZ 00,F
0239A:  BRA    2396
0239C:  DECFSZ 01,F
0239E:  BRA    2392
023A0:  MOVLW  F7
023A2:  MOVWF  00
023A4:  DECFSZ 00,F
023A6:  BRA    23A4
023A8:  NOP   
023AA:  CLRWDT
023AC:  DECFSZ FEF,F
023AE:  BRA    238E
023B0:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B5,rcv=PIN_B4,bits=8,restart_wdt) 
*
00372:  BCF    F93.5
00374:  BCF    F8A.5
00376:  MOVLW  08
00378:  MOVWF  01
0037A:  BRA    037C
0037C:  NOP   
0037E:  BSF    01.7
00380:  BRA    03A2
00382:  BCF    01.7
00384:  MOVLB  5
00386:  RRCF   x03,F
00388:  MOVLB  0
0038A:  BTFSC  FD8.0
0038C:  BSF    F8A.5
0038E:  BTFSS  FD8.0
00390:  BCF    F8A.5
00392:  BSF    01.6
00394:  BRA    03A2
00396:  BCF    01.6
00398:  DECFSZ 01,F
0039A:  BRA    0384
0039C:  BRA    039E
0039E:  NOP   
003A0:  BSF    F8A.5
003A2:  MOVLW  01
003A4:  MOVWF  00
003A6:  CLRF   FE9
003A8:  DECFSZ FE9,F
003AA:  BRA    03A8
003AC:  DECFSZ 00,F
003AE:  BRA    03A6
003B0:  MOVLW  53
003B2:  MOVWF  FE9
003B4:  DECFSZ FE9,F
003B6:  BRA    03B4
003B8:  BRA    03BA
003BA:  CLRWDT
003BC:  BTFSC  01.7
003BE:  BRA    0382
003C0:  BTFSC  01.6
003C2:  BRA    0396
003C4:  RETLW  00
....................  
....................  
.................... #include "C:\Users\Programacao\Documents\CCS_Projects\18F\LightMod\global_defs.h" 
.................... #define  NUMBER_OF_SWITCHES 8 
.................... #define  LED PIN_E2 
.................... #define  OUT1  PIN_C0 
.................... #define  OUT2  PIN_C1 
.................... #define  OUT3  PIN_C2 
.................... #define  OUT4  PIN_C3 
.................... #define  OUT5  PIN_C4 
.................... #define  OUT6  PIN_C5 
.................... #define  OUT7  PIN_C6 
.................... #define  OUT8  PIN_C7 
.................... #define  OUT9  PIN_D1 
.................... #define  OUT10  PIN_D0 
.................... #define  OUT11  PIN_D2 
.................... #define  OUT12  PIN_D3 
.................... #define  OUT13  PIN_D7 
.................... #define  OUT14  PIN_D6 
.................... #define  OUT15  PIN_D5 
.................... #define  OUT16  PIN_D4 
.................... #define  INP1  PIN_A0 
.................... #define  INP2  PIN_A1 
.................... #define  INP3  PIN_A2 
.................... #define  INP4  PIN_A3 
.................... #define  INP5  PIN_A4 
.................... #define  INP6  PIN_A5 
.................... #define  INP7  PIN_E0 
.................... #define  INP8  PIN_E1 
....................  
.................... #byte porta=0xf80 
.................... #byte portb=0xf81 
.................... #byte portc=0xf82 
.................... #byte portd=0xf83 
.................... #byte porte=0xf84 
.................... #byte trisa=0xf92 
.................... #byte trisb=0xf93 
.................... #byte trisc=0xf94 
.................... #byte trisd=0xf95 
.................... #byte trise=0xf96 
....................  
.................... static int inputs[8]={INP1,INP2,INP3,INP4,INP5,INP6,INP7,INP8}; 
....................  
.................... #include "C:\Users\Programacao\Documents\CCS_Projects\18F\LightMod\can_functions.c" 
.................... #define CAN_USE_EXTENDED_ID FALSE 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = 0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = 0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT=0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1=0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2=0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3=0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive caputre 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON=0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON=0xF40 
.................... #byte   TXB1CON=0xF30 
.................... #byte   TXB2CON=0xF20 
.................... #byte TXBaCON=0xF60 //txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH=0xF41 
.................... #byte TXB0SIDL=0xF42 
.................... #byte TXB1SIDH=0xF31 
.................... #byte TXB1SIDL=0xF32 
.................... #byte TXB2SIDH=0xF21 
.................... #byte TXB2SIDL=0xF22 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH=0xF43 
.................... #byte TXB0EIDL=0xF44 
.................... #byte TXB1EIDH=0xF33 
.................... #byte TXB1EIDL=0xF34 
.................... #byte TXB2EIDH=0xF23 
.................... #byte TXB2EIDL=0xF24 
....................  
.................... #define RX0MASK      0xF1B    //rxm0eidl 
.................... #define RX1MASK      0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   0xF03    //rxf0eidl 
.................... #define RX0FILTER1   0xF07    //rxf1eidl 
.................... #define RX1FILTER2   0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   0xF13    //rxf4eidl 
.................... #define RX1FILTER5   0xF17    //rxf5eidl 
.................... #define RXB0ID       0xF64    //rxb0eidl 
.................... #define RXB1ID       0xF54    //rxb1eidl 
.................... #define TXB0ID       0xF44    //txb0eidl 
.................... #define TXB1ID       0xF34    //txb1eidl 
.................... #define TXB2ID       0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0=0xF46 
.................... #byte TXB0D7=0xF4D 
.................... #byte TXB1D0=0xF36 
.................... #byte TXB1D7=0xF3D 
.................... #byte TXB2D0=0xF26 
.................... #byte TXB2D7=0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC=0xF45 
.................... #byte TXB1DLC=0xF35 
.................... #byte TXB2DLC=0xF25 
.................... #byte TXBaDLC=0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON=0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON=0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH=0xF61 
.................... #byte   RXB0SIDL=0xF62 
.................... #byte   RXB1SIDH=0xF51 
.................... #byte   RXB1SIDL=0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH=0xF63 
.................... #byte   RXB0EIDL=0xF64 
.................... #byte   RXB1EIDH=0xF53 
.................... #byte   RXB1EIDL=0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC=0xF65 
.................... #byte   RXB1DLC=0xF55 
.................... #byte   RXBaDLC=0xF65 
....................  
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0=0xF66 
.................... #byte RXB0D7=0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT=0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH=0xF00 
.................... #byte RXF0SIDL=0xF01 
.................... #byte RXF1SIDH=0xF04 
.................... #byte RXF1SIDL=0xF05 
.................... #byte RXF2SIDH=0xF08 
.................... #byte RXF2SIDL=0xF09 
.................... #byte RXF3SIDH=0xF0C 
.................... #byte RXF3SIDL=0xF0D 
.................... #byte RXF4SIDH=0xF10 
.................... #byte RXF4SIDL=0xF11 
.................... #byte RXF5SIDH=0xF14 
.................... #byte RXF5SIDL=0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH=0xF02 
.................... #byte RXF0EIDL=0xF03 
.................... #byte RXF1EIDH=0xF06 
.................... #byte RXF1EIDL=0xF07 
.................... #byte RXF2EIDH=0xF0A 
.................... #byte RXF2EIDL=0xF0B 
.................... #byte RXF3EIDH=0xF0E 
.................... #byte RXF3EIDL=0xF0F 
.................... #byte RXF4EIDH=0xF12 
.................... #byte RXF4EIDL=0xF13 
.................... #byte RXF5EIDH=0xF16 
.................... #byte RXF5EIDL=0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH=0xF18 
.................... #byte RXM0SIDL=0xF19 
.................... #byte RXM1SIDH=0xF1C 
.................... #byte RXM1SIDL=0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH=0xF1A 
.................... #byte RXM0EIDL=0xF1B 
.................... #byte RXM1EIDH=0xF1E 
.................... #byte RXM1EIDL=0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = 0xFA4.7 
.................... #bit CAN_INT_WAKIF = 0xFA4.6 
.................... #bit CAN_INT_ERRIF = 0xFA4.5 
.................... #bit CAN_INT_TXB2IF = 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(int* addr, int32 id, int1 ext); 
.................... int32 can_get_id(int * addr, int1 ext); 
.................... int   can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(int32 & id, int * data, int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
01724:  MOVLW  04
01726:  MOVLB  4
01728:  MOVWF  xA2
0172A:  MOVLB  0
0172C:  RCALL  16CE
....................    can_set_baud(); 
0172E:  BRA    16F4
....................  
....................    RXB0CON=0; 
01730:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
01732:  MOVLW  9F
01734:  ANDWF  F60,W
01736:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
01738:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
0173A:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
0173E:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
01740:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
01742:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
01744:  BCF    F73.6
01746:  CLRF   1B
01748:  BTFSC  FF2.7
0174A:  BSF    1B.7
0174C:  BCF    FF2.7
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
0174E:  MOVLW  0F
01750:  MOVLB  5
01752:  MOVWF  x18
01754:  MOVLW  1B
01756:  MOVWF  x17
01758:  CLRF   x1C
0175A:  CLRF   x1B
0175C:  CLRF   x1A
0175E:  CLRF   x19
01760:  CLRF   x1D
01762:  MOVLB  0
01764:  RCALL  110E
01766:  BTFSC  1B.7
01768:  BSF    FF2.7
0176A:  CLRF   1B
0176C:  BTFSC  FF2.7
0176E:  BSF    1B.7
01770:  BCF    FF2.7
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
01772:  MOVLW  0F
01774:  MOVLB  5
01776:  MOVWF  x18
01778:  MOVLW  03
0177A:  MOVWF  x17
0177C:  CLRF   x1C
0177E:  CLRF   x1B
01780:  CLRF   x1A
01782:  CLRF   x19
01784:  CLRF   x1D
01786:  MOVLB  0
01788:  RCALL  110E
0178A:  BTFSC  1B.7
0178C:  BSF    FF2.7
0178E:  CLRF   1B
01790:  BTFSC  FF2.7
01792:  BSF    1B.7
01794:  BCF    FF2.7
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
01796:  MOVLW  0F
01798:  MOVLB  5
0179A:  MOVWF  x18
0179C:  MOVLW  07
0179E:  MOVWF  x17
017A0:  CLRF   x1C
017A2:  CLRF   x1B
017A4:  CLRF   x1A
017A6:  CLRF   x19
017A8:  CLRF   x1D
017AA:  MOVLB  0
017AC:  RCALL  110E
017AE:  BTFSC  1B.7
017B0:  BSF    FF2.7
017B2:  CLRF   1B
017B4:  BTFSC  FF2.7
017B6:  BSF    1B.7
017B8:  BCF    FF2.7
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
017BA:  MOVLW  0F
017BC:  MOVLB  5
017BE:  MOVWF  x18
017C0:  MOVLW  1F
017C2:  MOVWF  x17
017C4:  CLRF   x1C
017C6:  CLRF   x1B
017C8:  CLRF   x1A
017CA:  CLRF   x19
017CC:  CLRF   x1D
017CE:  MOVLB  0
017D0:  RCALL  110E
017D2:  BTFSC  1B.7
017D4:  BSF    FF2.7
017D6:  CLRF   1B
017D8:  BTFSC  FF2.7
017DA:  BSF    1B.7
017DC:  BCF    FF2.7
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
017DE:  MOVLW  0F
017E0:  MOVLB  5
017E2:  MOVWF  x18
017E4:  MOVLW  0B
017E6:  MOVWF  x17
017E8:  CLRF   x1C
017EA:  CLRF   x1B
017EC:  CLRF   x1A
017EE:  CLRF   x19
017F0:  CLRF   x1D
017F2:  MOVLB  0
017F4:  RCALL  110E
017F6:  BTFSC  1B.7
017F8:  BSF    FF2.7
017FA:  CLRF   1B
017FC:  BTFSC  FF2.7
017FE:  BSF    1B.7
01800:  BCF    FF2.7
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
01802:  MOVLW  0F
01804:  MOVLB  5
01806:  MOVWF  x18
01808:  MOVWF  x17
0180A:  CLRF   x1C
0180C:  CLRF   x1B
0180E:  CLRF   x1A
01810:  CLRF   x19
01812:  CLRF   x1D
01814:  MOVLB  0
01816:  RCALL  110E
01818:  BTFSC  1B.7
0181A:  BSF    FF2.7
0181C:  CLRF   1B
0181E:  BTFSC  FF2.7
01820:  BSF    1B.7
01822:  BCF    FF2.7
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
01824:  MOVLW  0F
01826:  MOVLB  5
01828:  MOVWF  x18
0182A:  MOVLW  13
0182C:  MOVWF  x17
0182E:  CLRF   x1C
01830:  CLRF   x1B
01832:  CLRF   x1A
01834:  CLRF   x19
01836:  CLRF   x1D
01838:  MOVLB  0
0183A:  RCALL  110E
0183C:  BTFSC  1B.7
0183E:  BSF    FF2.7
01840:  CLRF   1B
01842:  BTFSC  FF2.7
01844:  BSF    1B.7
01846:  BCF    FF2.7
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
01848:  MOVLW  0F
0184A:  MOVLB  5
0184C:  MOVWF  x18
0184E:  MOVLW  17
01850:  MOVWF  x17
01852:  CLRF   x1C
01854:  CLRF   x1B
01856:  CLRF   x1A
01858:  CLRF   x19
0185A:  CLRF   x1D
0185C:  MOVLB  0
0185E:  RCALL  110E
01860:  BTFSC  1B.7
01862:  BSF    FF2.7
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
01864:  MOVF   F93,W
01866:  ANDLW  FB
01868:  IORLW  08
0186A:  MOVLB  4
0186C:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
0186E:  CLRF   xA2
01870:  MOVLB  0
01872:  RCALL  16CE
.................... } 
01874:  GOTO   263E (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
016F4:  MOVLW  C0
016F6:  ANDWF  F70,W
016F8:  IORLW  04
016FA:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
016FC:  MOVLW  3F
016FE:  ANDWF  F70,W
01700:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
01702:  MOVLW  F8
01704:  ANDWF  F71,W
01706:  IORLW  02
01708:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
0170A:  MOVLW  C7
0170C:  ANDWF  F71,W
0170E:  IORLW  28
01710:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
01712:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
01714:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
01716:  MOVLW  F8
01718:  ANDWF  F72,W
0171A:  IORLW  05
0171C:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
0171E:  BCF    F72.6
.................... } 
01720:  GOTO   1730 (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
016CE:  MOVLB  4
016D0:  SWAPF  xA2,W
016D2:  ANDLW  70
016D4:  MOVWF  00
016D6:  BCF    FD8.0
016D8:  RLCF   00,F
016DA:  MOVLW  1F
016DC:  ANDWF  F6F,W
016DE:  IORWF  00,W
016E0:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
016E2:  MOVFF  F6E,00
016E6:  SWAPF  00,F
016E8:  RRCF   00,W
016EA:  ANDLW  07
016EC:  SUBWF  xA2,W
016EE:  BNZ   16E2
.................... } 
016F0:  MOVLB  0
016F2:  RETLW  00
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(int* addr, int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
0110E:  MOVFF  518,51F
01112:  MOVFF  517,51E
....................  
....................    if (ext) {  //extended 
01116:  MOVLB  5
01118:  MOVF   x1D,F
0111A:  BZ    11C0
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
0111C:  MOVFF  51E,FE9
01120:  MOVFF  51F,FEA
01124:  MOVFF  519,FEF
....................  
....................       //eidh 
....................       ptr--; 
01128:  MOVF   x1E,W
0112A:  BTFSC  FD8.2
0112C:  DECF   x1F,F
0112E:  DECF   x1E,F
....................       *ptr=make8(id,1); //8:15 
01130:  MOVFF  51E,FE9
01134:  MOVFF  51F,FEA
01138:  MOVFF  51A,FEF
....................  
....................       //sidl 
....................       ptr--; 
0113C:  MOVF   x1E,W
0113E:  BTFSC  FD8.2
01140:  DECF   x1F,F
01142:  DECF   x1E,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
01144:  MOVFF  51E,FE9
01148:  MOVFF  51F,FEA
0114C:  MOVF   x1B,W
0114E:  ANDLW  03
01150:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
01152:  MOVFF  51E,FE9
01156:  MOVFF  51F,FEA
0115A:  MOVFF  51B,00
0115E:  RLCF   00,F
01160:  RLCF   00,F
01162:  RLCF   00,F
01164:  MOVLW  F8
01166:  ANDWF  00,F
01168:  MOVF   00,W
0116A:  ANDLW  E0
0116C:  IORWF  FEF,W
0116E:  MOVWF  FEF
....................       *ptr|=0x08; 
01170:  MOVFF  51E,FE9
01174:  MOVFF  51F,FEA
01178:  MOVF   FEF,W
0117A:  IORLW  08
0117C:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
0117E:  MOVF   x1E,W
01180:  BTFSC  FD8.2
01182:  DECF   x1F,F
01184:  DECF   x1E,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
01186:  MOVFF  51E,FE9
0118A:  MOVFF  51F,FEA
0118E:  MOVFF  51B,00
01192:  SWAPF  00,F
01194:  RRCF   00,F
01196:  MOVLW  07
01198:  ANDWF  00,F
0119A:  MOVF   00,W
0119C:  ANDLW  07
0119E:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
011A0:  MOVFF  51E,FE9
011A4:  MOVFF  51F,FEA
011A8:  MOVFF  51C,00
011AC:  RLCF   00,F
011AE:  RLCF   00,F
011B0:  RLCF   00,F
011B2:  MOVLW  F8
011B4:  ANDWF  00,F
011B6:  MOVF   00,W
011B8:  ANDLW  F8
011BA:  IORWF  FEF,W
011BC:  MOVWF  FEF
....................    } 
....................    else {   //standard 
011BE:  BRA    123E
....................       //eidl 
....................       *ptr=0; 
011C0:  MOVFF  51E,FE9
011C4:  MOVFF  51F,FEA
011C8:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
011CA:  MOVF   x1E,W
011CC:  BTFSC  FD8.2
011CE:  DECF   x1F,F
011D0:  DECF   x1E,F
....................       *ptr=0; 
011D2:  MOVFF  51E,FE9
011D6:  MOVFF  51F,FEA
011DA:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
011DC:  MOVF   x1E,W
011DE:  BTFSC  FD8.2
011E0:  DECF   x1F,F
011E2:  DECF   x1E,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
011E4:  MOVFF  51E,FE9
011E8:  MOVFF  51F,FEA
011EC:  MOVFF  519,00
011F0:  SWAPF  00,F
011F2:  RLCF   00,F
011F4:  MOVLW  E0
011F6:  ANDWF  00,F
011F8:  MOVF   00,W
011FA:  ANDLW  E0
011FC:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
011FE:  MOVF   x1E,W
01200:  BTFSC  FD8.2
01202:  DECF   x1F,F
01204:  DECF   x1E,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
01206:  MOVFF  51E,FE9
0120A:  MOVFF  51F,FEA
0120E:  MOVFF  519,00
01212:  RRCF   00,F
01214:  RRCF   00,F
01216:  RRCF   00,F
01218:  MOVLW  1F
0121A:  ANDWF  00,F
0121C:  MOVF   00,W
0121E:  ANDLW  1F
01220:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
01222:  MOVFF  51E,FE9
01226:  MOVFF  51F,FEA
0122A:  MOVFF  51A,00
0122E:  SWAPF  00,F
01230:  RLCF   00,F
01232:  MOVLW  E0
01234:  ANDWF  00,F
01236:  MOVF   00,W
01238:  ANDLW  E0
0123A:  IORWF  FEF,W
0123C:  MOVWF  FEF
....................    } 
.................... } 
0123E:  MOVLB  0
01240:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int32 can_get_id(int * addr, int1 ext) { 
....................    int32 ret; 
....................    int * ptr; 
....................  
....................    ret=0; 
*
00B28:  MOVLB  5
00B2A:  CLRF   x19
00B2C:  CLRF   x18
00B2E:  CLRF   x17
00B30:  CLRF   x16
....................    ptr=addr; 
00B32:  MOVFF  514,51B
00B36:  MOVFF  513,51A
....................  
....................    if (ext) { 
00B3A:  MOVF   x15,F
00B3C:  BTFSC  FD8.2
00B3E:  BRA    0C66
....................       ret=*ptr;  //eidl 
00B40:  MOVFF  51B,03
00B44:  MOVFF  51A,FE9
00B48:  MOVFF  51B,FEA
00B4C:  MOVFF  FEF,00
00B50:  CLRF   01
00B52:  CLRF   02
00B54:  CLRF   03
00B56:  MOVFF  03,519
00B5A:  MOVFF  02,518
00B5E:  MOVFF  01,517
00B62:  MOVFF  00,516
....................  
....................       ptr--;     //eidh 
00B66:  MOVF   x1A,W
00B68:  BTFSC  FD8.2
00B6A:  DECF   x1B,F
00B6C:  DECF   x1A,F
....................       ret|=((int32)*ptr << 8); 
00B6E:  MOVFF  51A,FE9
00B72:  MOVFF  51B,FEA
00B76:  MOVF   FEF,W
00B78:  CLRF   x1E
00B7A:  CLRF   x1D
00B7C:  MOVWF  x1C
00B7E:  CLRF   00
00B80:  MOVF   00,W
00B82:  IORWF  x16,F
00B84:  MOVF   x1C,W
00B86:  IORWF  x17,F
00B88:  MOVF   x1D,W
00B8A:  IORWF  x18,F
00B8C:  MOVF   x1E,W
00B8E:  IORWF  x19,F
....................  
....................       ptr--;     //sidl 
00B90:  MOVF   x1A,W
00B92:  BTFSC  FD8.2
00B94:  DECF   x1B,F
00B96:  DECF   x1A,F
....................       ret|=((int32)*ptr & 0x03) << 16; 
00B98:  MOVFF  51A,FE9
00B9C:  MOVFF  51B,FEA
00BA0:  MOVF   FEF,W
00BA2:  CLRF   x1F
00BA4:  CLRF   x1E
00BA6:  CLRF   x1D
00BA8:  MOVWF  x1C
00BAA:  MOVLW  03
00BAC:  ANDWF  x1C,F
00BAE:  CLRF   x1D
00BB0:  CLRF   x1E
00BB2:  CLRF   x1F
00BB4:  CLRF   00
00BB6:  CLRF   01
00BB8:  MOVF   00,W
00BBA:  IORWF  x16,F
00BBC:  MOVF   01,W
00BBE:  IORWF  x17,F
00BC0:  MOVF   x1C,W
00BC2:  IORWF  x18,F
00BC4:  MOVF   x1D,W
00BC6:  IORWF  x19,F
....................       ret|=((int32)*ptr & 0xE0) << 13; 
00BC8:  MOVFF  51A,FE9
00BCC:  MOVFF  51B,FEA
00BD0:  MOVF   FEF,W
00BD2:  CLRF   x1F
00BD4:  CLRF   x1E
00BD6:  CLRF   x1D
00BD8:  MOVWF  x1C
00BDA:  MOVLW  E0
00BDC:  ANDWF  x1C,F
00BDE:  CLRF   x1D
00BE0:  CLRF   x1E
00BE2:  CLRF   x1F
00BE4:  CLRF   00
00BE6:  RLCF   x1C,W
00BE8:  MOVWF  01
00BEA:  RLCF   x1D,W
00BEC:  MOVWF  02
00BEE:  RLCF   x1E,W
00BF0:  MOVWF  03
00BF2:  RLCF   01,F
00BF4:  RLCF   02,F
00BF6:  RLCF   03,F
00BF8:  RLCF   01,F
00BFA:  RLCF   02,F
00BFC:  RLCF   03,F
00BFE:  RLCF   01,F
00C00:  RLCF   02,F
00C02:  RLCF   03,F
00C04:  RLCF   01,F
00C06:  RLCF   02,F
00C08:  RLCF   03,F
00C0A:  MOVLW  E0
00C0C:  ANDWF  01,F
00C0E:  MOVF   00,W
00C10:  IORWF  x16,F
00C12:  MOVF   01,W
00C14:  IORWF  x17,F
00C16:  MOVF   02,W
00C18:  IORWF  x18,F
00C1A:  MOVF   03,W
00C1C:  IORWF  x19,F
....................  
....................       ptr--;     //sidh 
00C1E:  MOVF   x1A,W
00C20:  BTFSC  FD8.2
00C22:  DECF   x1B,F
00C24:  DECF   x1A,F
....................       ret|=((int32)*ptr << 21); 
00C26:  MOVFF  51A,FE9
00C2A:  MOVFF  51B,FEA
00C2E:  MOVF   FEF,W
00C30:  CLRF   x1D
00C32:  MOVWF  x1C
00C34:  CLRF   00
00C36:  CLRF   01
00C38:  RLCF   x1C,W
00C3A:  MOVWF  02
00C3C:  RLCF   x1D,W
00C3E:  MOVWF  03
00C40:  RLCF   02,F
00C42:  RLCF   03,F
00C44:  RLCF   02,F
00C46:  RLCF   03,F
00C48:  RLCF   02,F
00C4A:  RLCF   03,F
00C4C:  RLCF   02,F
00C4E:  RLCF   03,F
00C50:  MOVLW  E0
00C52:  ANDWF  02,F
00C54:  MOVF   00,W
00C56:  IORWF  x16,F
00C58:  MOVF   01,W
00C5A:  IORWF  x17,F
00C5C:  MOVF   02,W
00C5E:  IORWF  x18,F
00C60:  MOVF   03,W
00C62:  IORWF  x19,F
....................  
....................    } 
....................    else { 
00C64:  BRA    0D0C
....................       ptr-=2;    //sidl 
00C66:  MOVLW  02
00C68:  SUBWF  x1A,F
00C6A:  MOVLW  00
00C6C:  SUBWFB x1B,F
....................       ret=((int32)*ptr & 0xE0) >> 5; 
00C6E:  MOVFF  51A,FE9
00C72:  MOVFF  51B,FEA
00C76:  MOVF   FEF,W
00C78:  CLRF   x1F
00C7A:  CLRF   x1E
00C7C:  CLRF   x1D
00C7E:  MOVWF  x1C
00C80:  MOVLW  E0
00C82:  ANDWF  x1C,F
00C84:  CLRF   x1D
00C86:  CLRF   x1E
00C88:  CLRF   x1F
00C8A:  RRCF   x1F,W
00C8C:  MOVWF  x19
00C8E:  RRCF   x1E,W
00C90:  MOVWF  x18
00C92:  RRCF   x1D,W
00C94:  MOVWF  x17
00C96:  RRCF   x1C,W
00C98:  MOVWF  x16
00C9A:  RRCF   x19,F
00C9C:  RRCF   x18,F
00C9E:  RRCF   x17,F
00CA0:  RRCF   x16,F
00CA2:  RRCF   x19,F
00CA4:  RRCF   x18,F
00CA6:  RRCF   x17,F
00CA8:  RRCF   x16,F
00CAA:  RRCF   x19,F
00CAC:  RRCF   x18,F
00CAE:  RRCF   x17,F
00CB0:  RRCF   x16,F
00CB2:  RRCF   x19,F
00CB4:  RRCF   x18,F
00CB6:  RRCF   x17,F
00CB8:  RRCF   x16,F
00CBA:  MOVLW  07
00CBC:  ANDWF  x19,F
....................  
....................       ptr--;     //sidh 
00CBE:  MOVF   x1A,W
00CC0:  BTFSC  FD8.2
00CC2:  DECF   x1B,F
00CC4:  DECF   x1A,F
....................       ret|=((int32)*ptr << 3); 
00CC6:  MOVFF  51A,FE9
00CCA:  MOVFF  51B,FEA
00CCE:  MOVF   FEF,W
00CD0:  CLRF   x1F
00CD2:  CLRF   x1E
00CD4:  CLRF   x1D
00CD6:  MOVWF  x1C
00CD8:  RLCF   x1C,W
00CDA:  MOVWF  00
00CDC:  RLCF   x1D,W
00CDE:  MOVWF  01
00CE0:  RLCF   x1E,W
00CE2:  MOVWF  02
00CE4:  RLCF   x1F,W
00CE6:  MOVWF  03
00CE8:  RLCF   00,F
00CEA:  RLCF   01,F
00CEC:  RLCF   02,F
00CEE:  RLCF   03,F
00CF0:  RLCF   00,F
00CF2:  RLCF   01,F
00CF4:  RLCF   02,F
00CF6:  RLCF   03,F
00CF8:  MOVLW  F8
00CFA:  ANDWF  00,F
00CFC:  MOVF   00,W
00CFE:  IORWF  x16,F
00D00:  MOVF   01,W
00D02:  IORWF  x17,F
00D04:  MOVF   02,W
00D06:  IORWF  x18,F
00D08:  MOVF   03,W
00D0A:  IORWF  x19,F
....................    } 
....................  
....................    return(ret); 
00D0C:  MOVFF  516,00
00D10:  MOVFF  517,01
00D14:  MOVFF  518,02
00D18:  MOVFF  519,03
.................... } 
00D1C:  MOVLB  0
00D1E:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr) { 
....................    int i; 
....................    int * txd0; 
....................    int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
01242:  MOVLW  0F
01244:  MOVLB  5
01246:  MOVWF  x15
01248:  MOVLW  66
0124A:  MOVWF  x14
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
0124C:  MOVLB  F
0124E:  BTFSC  x40.3
01250:  BRA    1262
....................       CANCON.win=CAN_WIN_TX0; 
01252:  MOVLW  F1
01254:  ANDWF  F6F,W
01256:  IORLW  08
01258:  MOVWF  F6F
....................       port=0; 
0125A:  MOVLB  5
0125C:  CLRF   x16
....................    } 
....................    else if (!TXB1CON.txreq) { 
0125E:  BRA    1296
01260:  MOVLB  F
01262:  BTFSC  x30.3
01264:  BRA    1278
....................       CANCON.win=CAN_WIN_TX1; 
01266:  MOVLW  F1
01268:  ANDWF  F6F,W
0126A:  IORLW  06
0126C:  MOVWF  F6F
....................       port=1; 
0126E:  MOVLW  01
01270:  MOVLB  5
01272:  MOVWF  x16
....................    } 
....................    else if (!TXB2CON.txreq) { 
01274:  BRA    1296
01276:  MOVLB  F
01278:  BTFSC  x20.3
0127A:  BRA    128E
....................       CANCON.win=CAN_WIN_TX2; 
0127C:  MOVLW  F1
0127E:  ANDWF  F6F,W
01280:  IORLW  04
01282:  MOVWF  F6F
....................       port=2; 
01284:  MOVLW  02
01286:  MOVLB  5
01288:  MOVWF  x16
....................    } 
....................    else { 
0128A:  BRA    1296
0128C:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
0128E:  MOVLW  00
01290:  MOVWF  01
01292:  BRA    130E
01294:  MOVLB  5
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
01296:  MOVF   x10,W
01298:  ANDLW  03
0129A:  MOVWF  00
0129C:  MOVLW  FC
0129E:  ANDWF  F60,W
012A0:  IORWF  00,W
012A2:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
012A4:  MOVLW  0F
012A6:  MOVWF  x18
012A8:  MOVLW  64
012AA:  MOVWF  x17
012AC:  MOVFF  50C,51C
012B0:  MOVFF  50B,51B
012B4:  MOVFF  50A,51A
012B8:  MOVFF  509,519
012BC:  MOVFF  511,51D
012C0:  MOVLB  0
012C2:  RCALL  110E
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
012C4:  MOVFF  50F,F65
....................    TXBaDLC.rtr=rtr; 
012C8:  BCF    F65.6
012CA:  MOVLB  5
012CC:  BTFSC  x12.0
012CE:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
012D0:  CLRF   x13
012D2:  MOVF   x0F,W
012D4:  SUBWF  x13,W
012D6:  BC    1300
....................       *txd0=*data; 
012D8:  MOVFF  50D,FE9
012DC:  MOVFF  50E,FEA
012E0:  MOVFF  FEF,519
012E4:  MOVFF  515,FEA
012E8:  MOVFF  514,FE9
012EC:  MOVFF  519,FEF
....................       txd0++; 
012F0:  INCF   x14,F
012F2:  BTFSC  FD8.2
012F4:  INCF   x15,F
....................       data++; 
012F6:  INCF   x0D,F
012F8:  BTFSC  FD8.2
012FA:  INCF   x0E,F
....................     } 
012FC:  INCF   x13,F
012FE:  BRA    12D2
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
01300:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
01302:  MOVLW  F1
01304:  ANDWF  F6F,W
01306:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
01308:  MOVLW  01
0130A:  MOVWF  01
0130C:  MOVLB  F
.................... } 
0130E:  MOVLB  0
01310:  GOTO   152E (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(int32 & id, int * data, int & len, struct rx_stat & stat) 
.................... { 
....................     int i; 
....................     int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
00D3A:  BTFSS  F60.7
00D3C:  BRA    0D6E
*
00FE4:  BTFSS  F60.7
00FE6:  BRA    1018
....................         CANCON.win=CAN_WIN_RX0; 
*
00D3E:  MOVLW  F1
00D40:  ANDWF  F6F,W
00D42:  MOVWF  F6F
*
00FE8:  MOVLW  F1
00FEA:  ANDWF  F6F,W
00FEC:  MOVWF  F6F
....................         stat.buffer=0; 
*
00D44:  MOVLB  4
00D46:  BCF    xFC.4
*
00FEE:  MOVLB  4
00FF0:  BCF    xFC.4
....................  
....................         CAN_INT_RXB0IF=0; 
*
00D48:  BCF    FA4.0
*
00FF2:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
*
00D4A:  BCF    xFC.0
00D4C:  BTFSC  F74.7
00D4E:  BSF    xFC.0
*
00FF4:  BCF    xFC.0
00FF6:  BTFSC  F74.7
00FF8:  BSF    xFC.0
....................         COMSTAT.rx0ovfl=0; 
*
00D50:  BCF    F74.7
*
00FFA:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
*
00D52:  BTFSS  F60.2
00D54:  BRA    0D6C
*
00FFC:  BTFSS  F60.2
00FFE:  BRA    1016
....................          stat.filthit=RXB0CON.filthit0; 
*
00D56:  MOVLW  00
00D58:  BTFSC  F60.0
00D5A:  MOVLW  01
00D5C:  ANDLW  07
00D5E:  MOVWF  00
00D60:  BCF    FD8.0
00D62:  RLCF   00,F
00D64:  MOVLW  F1
00D66:  ANDWF  xFC,W
00D68:  IORWF  00,W
00D6A:  MOVWF  xFC
*
01000:  MOVLW  00
01002:  BTFSC  F60.0
01004:  MOVLW  01
01006:  ANDLW  07
01008:  MOVWF  00
0100A:  BCF    FD8.0
0100C:  RLCF   00,F
0100E:  MOVLW  F1
01010:  ANDWF  xFC,W
01012:  IORWF  00,W
01014:  MOVWF  xFC
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
*
00D6C:  BRA    0DAE
00D6E:  MOVLB  F
00D70:  BTFSS  x50.7
00D72:  BRA    0DA6
*
01016:  BRA    1058
01018:  MOVLB  F
0101A:  BTFSS  x50.7
0101C:  BRA    1050
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
*
00D74:  MOVLW  F1
00D76:  ANDWF  F6F,W
00D78:  IORLW  0A
00D7A:  MOVWF  F6F
*
0101E:  MOVLW  F1
01020:  ANDWF  F6F,W
01022:  IORLW  0A
01024:  MOVWF  F6F
....................         stat.buffer=1; 
*
00D7C:  MOVLB  4
00D7E:  BSF    xFC.4
*
01026:  MOVLB  4
01028:  BSF    xFC.4
....................  
....................         CAN_INT_RXB1IF=0; 
*
00D80:  BCF    FA4.1
*
0102A:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
*
00D82:  BCF    xFC.0
00D84:  BTFSC  F74.6
00D86:  BSF    xFC.0
*
0102C:  BCF    xFC.0
0102E:  BTFSC  F74.6
01030:  BSF    xFC.0
....................         COMSTAT.rx1ovfl=0; 
*
00D88:  BCF    F74.6
*
01032:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
*
00D8A:  MOVLB  F
00D8C:  MOVF   x50,W
00D8E:  ANDLW  07
00D90:  ANDLW  07
00D92:  MOVWF  00
00D94:  BCF    FD8.0
00D96:  RLCF   00,F
00D98:  MOVLW  F1
00D9A:  MOVLB  4
00D9C:  ANDWF  xFC,W
00D9E:  IORWF  00,W
00DA0:  MOVWF  xFC
*
01034:  MOVLB  F
01036:  MOVF   x50,W
01038:  ANDLW  07
0103A:  ANDLW  07
0103C:  MOVWF  00
0103E:  BCF    FD8.0
01040:  RLCF   00,F
01042:  MOVLW  F1
01044:  MOVLB  4
01046:  ANDWF  xFC,W
01048:  IORWF  00,W
0104A:  MOVWF  xFC
....................     } 
....................     else { 
*
00DA2:  BRA    0DAE
00DA4:  MOVLB  F
*
0104C:  BRA    1058
0104E:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
00DA6:  MOVLW  00
00DA8:  MOVWF  01
00DAA:  BRA    0E4C
00DAC:  MOVLB  4
*
01050:  MOVLW  00
01052:  MOVWF  01
01054:  BRA    10F6
01056:  MOVLB  4
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
*
00DAE:  MOVF   F65,W
00DB0:  ANDLW  0F
00DB2:  MOVWF  xFB
*
01058:  MOVF   F65,W
0105A:  ANDLW  0F
0105C:  MOVWF  xFB
....................     stat.rtr=RXBaDLC.rtr; 
*
00DB4:  BCF    xFC.5
00DB6:  BTFSC  F65.6
00DB8:  BSF    xFC.5
*
0105E:  BCF    xFC.5
01060:  BTFSC  F65.6
01062:  BSF    xFC.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
*
00DBA:  BCF    xFC.6
00DBC:  BTFSC  F62.3
00DBE:  BSF    xFC.6
*
01064:  BCF    xFC.6
01066:  BTFSC  F62.3
01068:  BSF    xFC.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
*
00DC0:  MOVLW  00
00DC2:  BTFSC  xFC.6
00DC4:  MOVLW  01
00DC6:  MOVLB  5
00DC8:  MOVWF  x0C
00DCA:  MOVLW  0F
00DCC:  MOVWF  x14
00DCE:  MOVLW  64
00DD0:  MOVWF  x13
00DD2:  MOVFF  50C,515
00DD6:  MOVLB  0
00DD8:  RCALL  0B28
00DDA:  MOVFF  03,4FA
00DDE:  MOVFF  02,4F9
00DE2:  MOVFF  01,4F8
00DE6:  MOVFF  00,4F7
*
0106A:  MOVLW  00
0106C:  BTFSC  xFC.6
0106E:  MOVLW  01
01070:  MOVLB  5
01072:  MOVWF  x0C
01074:  MOVLW  0F
01076:  MOVWF  x14
01078:  MOVLW  64
0107A:  MOVWF  x13
0107C:  MOVFF  50C,515
01080:  MOVLB  0
01082:  RCALL  0B28
01084:  MOVFF  03,4FA
01088:  MOVFF  02,4F9
0108C:  MOVFF  01,4F8
01090:  MOVFF  00,4F7
....................  
....................     ptr = &TXRXBaD0; 
*
00DEA:  MOVLW  0F
00DEC:  MOVLB  5
00DEE:  MOVWF  x0B
00DF0:  MOVLW  66
00DF2:  MOVWF  x0A
*
01094:  MOVLW  0F
01096:  MOVLB  5
01098:  MOVWF  x0B
0109A:  MOVLW  66
0109C:  MOVWF  x0A
....................     for ( i = 0; i < len; i++ ) { 
*
00DF4:  CLRF   x09
00DF6:  MOVLB  4
00DF8:  MOVF   xFB,W
00DFA:  MOVLB  5
00DFC:  SUBWF  x09,W
00DFE:  BC    0E28
*
0109E:  CLRF   x09
010A0:  MOVLB  4
010A2:  MOVF   xFB,W
010A4:  MOVLB  5
010A6:  SUBWF  x09,W
010A8:  BC    10D2
....................         *data = *ptr; 
*
00E00:  MOVFF  50A,FE9
00E04:  MOVFF  50B,FEA
00E08:  MOVFF  FEF,50E
00E0C:  MOVFF  508,FEA
00E10:  MOVFF  507,FE9
00E14:  MOVFF  50E,FEF
*
010AA:  MOVFF  50A,FE9
010AE:  MOVFF  50B,FEA
010B2:  MOVFF  FEF,50E
010B6:  MOVFF  508,FEA
010BA:  MOVFF  507,FE9
010BE:  MOVFF  50E,FEF
....................         data++; 
*
00E18:  INCF   x07,F
00E1A:  BTFSC  FD8.2
00E1C:  INCF   x08,F
*
010C2:  INCF   x07,F
010C4:  BTFSC  FD8.2
010C6:  INCF   x08,F
....................         ptr++; 
*
00E1E:  INCF   x0A,F
00E20:  BTFSC  FD8.2
00E22:  INCF   x0B,F
*
010C8:  INCF   x0A,F
010CA:  BTFSC  FD8.2
010CC:  INCF   x0B,F
....................     } 
*
00E24:  INCF   x09,F
00E26:  BRA    0DF6
*
010CE:  INCF   x09,F
010D0:  BRA    10A0
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
*
00E28:  MOVLW  F1
00E2A:  ANDWF  F6F,W
00E2C:  MOVWF  F6F
*
010D2:  MOVLW  F1
010D4:  ANDWF  F6F,W
010D6:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
*
00E2E:  MOVLB  4
00E30:  BCF    xFC.7
00E32:  BTFSC  FA4.7
00E34:  BSF    xFC.7
*
010D8:  MOVLB  4
010DA:  BCF    xFC.7
010DC:  BTFSC  FA4.7
010DE:  BSF    xFC.7
....................     CAN_INT_IRXIF = 0; 
*
00E36:  BCF    FA4.7
*
010E0:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
*
00E38:  BTFSS  xFC.4
00E3A:  BRA    0E44
*
010E2:  BTFSS  xFC.4
010E4:  BRA    10EE
....................       RXB1CON.rxful=0; 
*
00E3C:  MOVLB  F
00E3E:  BCF    x50.7
*
010E6:  MOVLB  F
010E8:  BCF    x50.7
....................     } 
....................     else { 
*
00E40:  BRA    0E48
00E42:  MOVLB  4
*
010EA:  BRA    10F2
010EC:  MOVLB  4
....................       RXB0CON.rxful=0; 
*
00E44:  BCF    F60.7
00E46:  MOVLB  F
*
010EE:  BCF    F60.7
010F0:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
*
00E48:  MOVLW  01
00E4A:  MOVWF  01
*
010F2:  MOVLW  01
010F4:  MOVWF  01
010F6:  MOVLB  5
010F8:  MOVLB  4
.................... } 
....................  
....................  
....................  
....................  
.................... /** 
....................  * no comments 
....................  */ 
.................... #define dev1_ze 10 
....................  
.................... #define CAN_RECEIVE_STACK_SIZE 10 
.................... int can_rspoint=0; 
.................... int can_rstack [CAN_RECEIVE_STACK_SIZE] [14]; 
.................... int1 can_rsfull=FALSE; 
.................... #define can_receiver_full() can_rsfull 
.................... #define CAN_TRANSMIT_STACK_SIZE 10 
.................... int can_tspoint=0; 
.................... int can_tstack [CAN_TRANSMIT_STACK_SIZE] [13]; 
.................... int1 can_tsempty=TRUE; 
.................... #define can_transmitter_empty() can_tsempty 
.................... #define CAN_FILTER_SIZE 1 
.................... int32 can_filter [CAN_FILTER_SIZE] = {11}; 
....................  
....................  
.................... void canReceive ( ) 
.................... { 
....................    int32 rx_id; 
....................    int8  rx_len, rx_stat; 
....................    int8  buffer [8]; 
....................    int8  i; 
....................  
....................    if(can_rspoint==-1) 
*
00D20:  MOVF   24,W
00D22:  SUBLW  FF
00D24:  BNZ   0D28
....................       can_rspoint++; 
00D26:  INCF   24,F
....................  
....................    if(can_rspoint < CAN_RECEIVE_STACK_SIZE) 
00D28:  MOVF   24,W
00D2A:  SUBLW  09
00D2C:  BTFSS  FD8.0
00D2E:  BRA    0FDA
....................    { 
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
00D30:  MOVLW  04
00D32:  MOVLB  5
00D34:  MOVWF  x08
00D36:  MOVLW  FD
00D38:  MOVWF  x07
....................    { 
....................       int8 j; 
....................       for(j=0;j<CAN_FILTER_SIZE;j++) 
*
00E4C:  MOVLB  5
00E4E:  CLRF   x06
00E50:  MOVF   x06,F
00E52:  BNZ   0E98
....................          if(rx_id==can_filter[j]) 
00E54:  MOVF   x06,W
00E56:  MULLW  04
00E58:  MOVF   FF3,W
00E5A:  CLRF   03
00E5C:  ADDLW  35
00E5E:  MOVWF  FE9
00E60:  MOVLW  01
00E62:  ADDWFC 03,W
00E64:  MOVWF  FEA
00E66:  MOVFF  FEF,00
00E6A:  MOVFF  FEC,01
00E6E:  MOVFF  FEC,02
00E72:  MOVFF  FEC,03
00E76:  MOVF   00,W
00E78:  MOVLB  4
00E7A:  SUBWF  xF7,W
00E7C:  BNZ   0E92
00E7E:  MOVF   01,W
00E80:  SUBWF  xF8,W
00E82:  BNZ   0E92
00E84:  MOVF   02,W
00E86:  SUBWF  xF9,W
00E88:  BNZ   0E92
00E8A:  MOVF   03,W
00E8C:  SUBWF  xFA,W
00E8E:  BNZ   0E92
....................             return; 
00E90:  BRA    10FA
00E92:  MOVLB  5
00E94:  INCF   x06,F
00E96:  BRA    0E50
....................    } 
....................       can_rstack[can_rspoint][0]=make8(rx_id,3); 
00E98:  MOVF   24,W
00E9A:  MULLW  0E
00E9C:  MOVF   FF3,W
00E9E:  CLRF   x08
00EA0:  MOVWF  x07
00EA2:  MOVLW  25
00EA4:  ADDWF  x07,W
00EA6:  MOVWF  FE9
00EA8:  MOVLW  00
00EAA:  ADDWFC x08,W
00EAC:  MOVWF  FEA
00EAE:  MOVLB  4
00EB0:  MOVFF  4FA,FEF
....................       can_rstack[can_rspoint][1]=make8(rx_id,2); 
00EB4:  MOVF   24,W
00EB6:  MULLW  0E
00EB8:  MOVF   FF3,W
00EBA:  MOVLB  5
00EBC:  CLRF   x08
00EBE:  MOVWF  x07
00EC0:  MOVLW  01
00EC2:  ADDWF  x07,W
00EC4:  MOVWF  01
00EC6:  MOVLW  00
00EC8:  ADDWFC x08,W
00ECA:  MOVWF  03
00ECC:  MOVF   01,W
00ECE:  ADDLW  25
00ED0:  MOVWF  FE9
00ED2:  MOVLW  00
00ED4:  ADDWFC 03,W
00ED6:  MOVWF  FEA
00ED8:  MOVLB  4
00EDA:  MOVFF  4F9,FEF
....................       can_rstack[can_rspoint][2]=make8(rx_id,1); 
00EDE:  MOVF   24,W
00EE0:  MULLW  0E
00EE2:  MOVF   FF3,W
00EE4:  MOVLB  5
00EE6:  CLRF   x08
00EE8:  MOVWF  x07
00EEA:  MOVLW  02
00EEC:  ADDWF  x07,W
00EEE:  MOVWF  01
00EF0:  MOVLW  00
00EF2:  ADDWFC x08,W
00EF4:  MOVWF  03
00EF6:  MOVF   01,W
00EF8:  ADDLW  25
00EFA:  MOVWF  FE9
00EFC:  MOVLW  00
00EFE:  ADDWFC 03,W
00F00:  MOVWF  FEA
00F02:  MOVLB  4
00F04:  MOVFF  4F8,FEF
....................       can_rstack[can_rspoint][3]=make8(rx_id,0); 
00F08:  MOVF   24,W
00F0A:  MULLW  0E
00F0C:  MOVF   FF3,W
00F0E:  MOVLB  5
00F10:  CLRF   x08
00F12:  MOVWF  x07
00F14:  MOVLW  03
00F16:  ADDWF  x07,W
00F18:  MOVWF  01
00F1A:  MOVLW  00
00F1C:  ADDWFC x08,W
00F1E:  MOVWF  03
00F20:  MOVF   01,W
00F22:  ADDLW  25
00F24:  MOVWF  FE9
00F26:  MOVLW  00
00F28:  ADDWFC 03,W
00F2A:  MOVWF  FEA
00F2C:  MOVLB  4
00F2E:  MOVFF  4F7,FEF
....................  
....................       can_rstack[can_rspoint][4]=rx_len; 
00F32:  MOVF   24,W
00F34:  MULLW  0E
00F36:  MOVF   FF3,W
00F38:  MOVLB  5
00F3A:  CLRF   x08
00F3C:  MOVWF  x07
00F3E:  MOVLW  04
00F40:  ADDWF  x07,W
00F42:  MOVWF  01
00F44:  MOVLW  00
00F46:  ADDWFC x08,W
00F48:  MOVWF  03
00F4A:  MOVF   01,W
00F4C:  ADDLW  25
00F4E:  MOVWF  FE9
00F50:  MOVLW  00
00F52:  ADDWFC 03,W
00F54:  MOVWF  FEA
00F56:  MOVFF  4FB,FEF
....................       can_rstack[can_rspoint][5]=rx_stat; 
00F5A:  MOVF   24,W
00F5C:  MULLW  0E
00F5E:  MOVF   FF3,W
00F60:  CLRF   x08
00F62:  MOVWF  x07
00F64:  MOVLW  05
00F66:  ADDWF  x07,W
00F68:  MOVWF  01
00F6A:  MOVLW  00
00F6C:  ADDWFC x08,W
00F6E:  MOVWF  03
00F70:  MOVF   01,W
00F72:  ADDLW  25
00F74:  MOVWF  FE9
00F76:  MOVLW  00
00F78:  ADDWFC 03,W
00F7A:  MOVWF  FEA
00F7C:  MOVFF  4FC,FEF
....................  
....................       for(i=0;i<rx_len;i++) 
00F80:  CLRF   x05
00F82:  MOVLB  4
00F84:  MOVF   xFB,W
00F86:  MOVLB  5
00F88:  SUBWF  x05,W
00F8A:  BC    0FD4
....................       { 
....................          can_rstack[can_rspoint][i+6]=buffer[i]; 
00F8C:  MOVF   24,W
00F8E:  MULLW  0E
00F90:  MOVF   FF3,W
00F92:  CLRF   x08
00F94:  MOVWF  x07
00F96:  MOVLW  06
00F98:  ADDWF  x05,W
00F9A:  CLRF   03
00F9C:  ADDWF  x07,W
00F9E:  MOVWF  01
00FA0:  MOVF   x08,W
00FA2:  ADDWFC 03,F
00FA4:  MOVF   01,W
00FA6:  ADDLW  25
00FA8:  MOVWF  01
00FAA:  MOVLW  00
00FAC:  ADDWFC 03,F
00FAE:  MOVFF  03,508
00FB2:  CLRF   03
00FB4:  MOVF   x05,W
00FB6:  ADDLW  FD
00FB8:  MOVWF  FE9
00FBA:  MOVLW  04
00FBC:  ADDWFC 03,W
00FBE:  MOVWF  FEA
00FC0:  MOVFF  FEF,509
00FC4:  MOVFF  508,FEA
00FC8:  MOVFF  01,FE9
00FCC:  MOVFF  509,FEF
....................       } 
00FD0:  INCF   x05,F
00FD2:  BRA    0F82
....................  
....................       can_rspoint++; 
00FD4:  INCF   24,F
....................    } 
....................    else 
00FD6:  BRA    10F8
00FD8:  MOVLB  0
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
00FDA:  MOVLW  04
00FDC:  MOVLB  5
00FDE:  MOVWF  x08
00FE0:  MOVLW  FD
00FE2:  MOVWF  x07
.................... } 
*
010FA:  MOVLB  0
010FC:  RETLW  00
....................  
....................  
.................... int1 can_Pop ( int32 & rx_id, int * buffer, int & rx_len, int & rx_stat ) 
.................... { 
....................    int i; 
....................  
....................    if(can_rspoint==CAN_RECEIVE_STACK_SIZE) 
....................       can_rspoint--; 
....................  
....................    if(can_rspoint!=-1) 
....................    { 
....................       rx_id=make32(can_rstack[can_rspoint][0], 
....................                   can_rstack[can_rspoint][1], 
....................                   can_rstack[can_rspoint][2], 
....................                   can_rstack[can_rspoint][3]); 
....................  
....................       rx_len=can_rstack[can_rspoint][4]; 
....................       rx_stat=can_rstack[can_rspoint][5]; 
....................  
....................       for(i=0;i<rx_len;i++) 
....................       { 
....................          buffer[i]=can_rstack[can_rspoint][i+6]; 
....................       } 
....................       can_rspoint--; 
....................  
....................       return TRUE; 
....................    }    
....................    else 
....................    return FALSE; 
.................... } 
....................  
.................... void canTransmit ( ) 
.................... { 
....................    int32 tx_id; 
....................    int8  tx_length; 
....................    int8  tx_priority; 
....................    int8  tx_buffer[8]; 
....................    int1  tx_extendedID; 
....................    int1  tx_emptyframe; 
....................    int8  i; 
....................  
....................    if(can_tspoint==CAN_TRANSMIT_STACK_SIZE) 
*
01314:  MOVF   xB2,W
01316:  SUBLW  0A
01318:  BNZ   131C
....................    { 
....................       can_tspoint--; 
0131A:  DECF   xB2,F
....................    } 
....................  
....................    if(can_tspoint!=-1) 
0131C:  MOVF   xB2,W
0131E:  SUBLW  FF
01320:  BTFSC  FD8.2
01322:  BRA    1532
....................    { 
....................  
....................       tx_id=make32(can_tstack[can_tspoint][0], 
....................                   can_tstack[can_tspoint][1], 
....................                   can_tstack[can_tspoint][2], 
....................                   can_tstack[can_tspoint][3]); 
01324:  MOVF   xB2,W
01326:  MULLW  0D
01328:  MOVF   FF3,W
0132A:  MOVLB  5
0132C:  CLRF   x08
0132E:  MOVWF  x07
01330:  MOVLW  B3
01332:  ADDWF  x07,W
01334:  MOVWF  FE9
01336:  MOVLW  00
01338:  ADDWFC x08,W
0133A:  MOVWF  FEA
0133C:  MOVFF  FEF,507
01340:  MOVLB  0
01342:  MOVF   xB2,W
01344:  MULLW  0D
01346:  MOVF   FF3,W
01348:  MOVLB  5
0134A:  CLRF   x09
0134C:  MOVWF  x08
0134E:  MOVLW  01
01350:  ADDWF  x08,W
01352:  MOVWF  01
01354:  MOVLW  00
01356:  ADDWFC x09,W
01358:  MOVWF  03
0135A:  MOVF   01,W
0135C:  ADDLW  B3
0135E:  MOVWF  FE9
01360:  MOVLW  00
01362:  ADDWFC 03,W
01364:  MOVWF  FEA
01366:  MOVFF  FEF,508
0136A:  MOVLB  0
0136C:  MOVF   xB2,W
0136E:  MULLW  0D
01370:  MOVF   FF3,W
01372:  MOVLB  5
01374:  CLRF   x0A
01376:  MOVWF  x09
01378:  MOVLW  02
0137A:  ADDWF  x09,W
0137C:  MOVWF  01
0137E:  MOVLW  00
01380:  ADDWFC x0A,W
01382:  MOVWF  03
01384:  MOVF   01,W
01386:  ADDLW  B3
01388:  MOVWF  FE9
0138A:  MOVLW  00
0138C:  ADDWFC 03,W
0138E:  MOVWF  FEA
01390:  MOVFF  FEF,509
01394:  MOVLB  0
01396:  MOVF   xB2,W
01398:  MULLW  0D
0139A:  MOVF   FF3,W
0139C:  MOVLB  5
0139E:  CLRF   x0B
013A0:  MOVWF  x0A
013A2:  MOVLW  03
013A4:  ADDWF  x0A,W
013A6:  MOVWF  01
013A8:  MOVLW  00
013AA:  ADDWFC x0B,W
013AC:  MOVWF  03
013AE:  MOVF   01,W
013B0:  ADDLW  B3
013B2:  MOVWF  FE9
013B4:  MOVLW  00
013B6:  ADDWFC 03,W
013B8:  MOVWF  FEA
013BA:  MOVFF  FEF,50A
013BE:  MOVFF  507,4FA
013C2:  MOVFF  508,4F9
013C6:  MOVFF  509,4F8
013CA:  MOVFF  50A,4F7
....................  
....................       tx_length=can_tstack[can_tspoint][12]>>4; 
013CE:  MOVLB  0
013D0:  MOVF   xB2,W
013D2:  MULLW  0D
013D4:  MOVF   FF3,W
013D6:  MOVLB  5
013D8:  CLRF   x08
013DA:  MOVWF  x07
013DC:  MOVLW  0C
013DE:  ADDWF  x07,W
013E0:  MOVWF  01
013E2:  MOVLW  00
013E4:  ADDWFC x08,W
013E6:  MOVWF  03
013E8:  MOVF   01,W
013EA:  ADDLW  B3
013EC:  MOVWF  FE9
013EE:  MOVLW  00
013F0:  ADDWFC 03,W
013F2:  MOVWF  FEA
013F4:  SWAPF  FEF,W
013F6:  MOVLB  4
013F8:  MOVWF  xFB
013FA:  MOVLW  0F
013FC:  ANDWF  xFB,F
....................       tx_priority=(can_tstack[can_tspoint][12]&0x0c)>>2; 
013FE:  MOVLB  0
01400:  MOVF   xB2,W
01402:  MULLW  0D
01404:  MOVF   FF3,W
01406:  MOVLB  5
01408:  CLRF   x08
0140A:  MOVWF  x07
0140C:  MOVLW  0C
0140E:  ADDWF  x07,W
01410:  MOVWF  01
01412:  MOVLW  00
01414:  ADDWFC x08,W
01416:  MOVWF  03
01418:  MOVF   01,W
0141A:  ADDLW  B3
0141C:  MOVWF  FE9
0141E:  MOVLW  00
01420:  ADDWFC 03,W
01422:  MOVWF  FEA
01424:  MOVF   FEF,W
01426:  ANDLW  0C
01428:  MOVWF  00
0142A:  RRCF   00,W
0142C:  MOVLB  4
0142E:  MOVWF  xFC
01430:  RRCF   xFC,F
01432:  MOVLW  3F
01434:  ANDWF  xFC,F
....................       tx_extendedID=bit_test(can_tstack[can_tspoint][12],1); 
01436:  MOVLB  0
01438:  MOVF   xB2,W
0143A:  MULLW  0D
0143C:  MOVF   FF3,W
0143E:  MOVLB  5
01440:  CLRF   x08
01442:  MOVWF  x07
01444:  MOVLW  0C
01446:  ADDWF  x07,W
01448:  MOVWF  01
0144A:  MOVLW  00
0144C:  ADDWFC x08,W
0144E:  MOVWF  03
01450:  MOVF   01,W
01452:  ADDLW  B3
01454:  MOVWF  FE9
01456:  MOVLW  00
01458:  ADDWFC 03,W
0145A:  MOVWF  FEA
0145C:  MOVFF  FEF,507
01460:  BCF    x05.0
01462:  BTFSC  x07.1
01464:  BSF    x05.0
....................       tx_emptyframe=bit_test(can_tstack[can_tspoint][12],0); 
01466:  MOVLB  0
01468:  MOVF   xB2,W
0146A:  MULLW  0D
0146C:  MOVF   FF3,W
0146E:  MOVLB  5
01470:  CLRF   x08
01472:  MOVWF  x07
01474:  MOVLW  0C
01476:  ADDWF  x07,W
01478:  MOVWF  01
0147A:  MOVLW  00
0147C:  ADDWFC x08,W
0147E:  MOVWF  03
01480:  MOVF   01,W
01482:  ADDLW  B3
01484:  MOVWF  FE9
01486:  MOVLW  00
01488:  ADDWFC 03,W
0148A:  MOVWF  FEA
0148C:  MOVFF  FEF,507
01490:  BCF    x05.1
01492:  BTFSC  x07.0
01494:  BSF    x05.1
....................  
....................       for(i=0;i<tx_length;i++) 
01496:  CLRF   x06
01498:  MOVLB  4
0149A:  MOVF   xFB,W
0149C:  MOVLB  5
0149E:  SUBWF  x06,W
014A0:  BC    14F2
....................       { 
....................          tx_buffer[i]=can_tstack[can_tspoint][i+4]; 
014A2:  CLRF   03
014A4:  MOVF   x06,W
014A6:  ADDLW  FD
014A8:  MOVWF  01
014AA:  MOVLW  04
014AC:  ADDWFC 03,F
014AE:  MOVFF  01,507
014B2:  MOVFF  03,508
014B6:  MOVLB  0
014B8:  MOVF   xB2,W
014BA:  MULLW  0D
014BC:  MOVF   FF3,W
014BE:  MOVLB  5
014C0:  CLRF   x0A
014C2:  MOVWF  x09
014C4:  MOVLW  04
014C6:  ADDWF  x06,W
014C8:  CLRF   03
014CA:  ADDWF  x09,W
014CC:  MOVWF  01
014CE:  MOVF   x0A,W
014D0:  ADDWFC 03,F
014D2:  MOVF   01,W
014D4:  ADDLW  B3
014D6:  MOVWF  FE9
014D8:  MOVLW  00
014DA:  ADDWFC 03,W
014DC:  MOVWF  FEA
014DE:  MOVFF  FEF,509
014E2:  MOVFF  508,FEA
014E6:  MOVFF  507,FE9
014EA:  MOVFF  509,FEF
....................       } 
014EE:  INCF   x06,F
014F0:  BRA    1498
....................  
....................       can_putd(tx_id,tx_buffer,tx_length,tx_priority,tx_extendedID,tx_emptyframe); 
014F2:  MOVLW  00
014F4:  BTFSC  x05.0
014F6:  MOVLW  01
014F8:  MOVWF  x07
014FA:  MOVLW  00
014FC:  BTFSC  x05.1
014FE:  MOVLW  01
01500:  MOVWF  x08
01502:  MOVFF  4FA,50C
01506:  MOVFF  4F9,50B
0150A:  MOVFF  4F8,50A
0150E:  MOVFF  4F7,509
01512:  MOVLW  04
01514:  MOVWF  x0E
01516:  MOVLW  FD
01518:  MOVWF  x0D
0151A:  MOVFF  4FB,50F
0151E:  MOVFF  4FC,510
01522:  MOVFF  507,511
01526:  MOVFF  508,512
0152A:  MOVLB  0
0152C:  BRA    1242
....................  
....................       can_tspoint--; 
0152E:  DECF   xB2,F
....................    } 
....................    else 
01530:  BRA    1534
....................       return; 
01532:  BRA    1534
.................... } 
01534:  RETLW  00
....................  
....................  
.................... int1 can_push (int32 tx_id, int8 * tx_buffer, int8 tx_length, int8 tx_priority, int1 tx_extendedID, int1 tx_emptyframe) 
.................... { 
....................    int8  i; 
....................    if(can_tspoint==-1) 
....................       can_tspoint++; 
....................  
....................    if(can_tspoint < CAN_TRANSMIT_STACK_SIZE) 
....................    { 
....................       can_tstack[can_tspoint][0]=make8(tx_id,3); 
....................       can_tstack[can_tspoint][1]=make8(tx_id,2); 
....................       can_tstack[can_tspoint][2]=make8(tx_id,1); 
....................       can_tstack[can_tspoint][3]=make8(tx_id,0); 
....................  
....................       for(i=0;i<tx_length;i++) 
....................       { 
....................          can_tstack[can_tspoint][i+4]=tx_buffer[i]; 
....................       } 
....................  
....................       can_tstack[can_tspoint][12]=(tx_length<<4)|(tx_priority<<2)|((int8)tx_extendedID<<1)|((int8)tx_emptyframe); 
....................  
....................       can_tspoint++; 
....................    } 
.................... } 
....................  
.................... int temp; 
.................... #include "dimming_functions.c" 
.................... #define N_LUZES 16 //numero maximo de dimmers 
.................... int used_dimmers=16; 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
.................... int1 organizado;//flag que diz se os dimmings estao organizados 
.................... int1 actmat;//matriz em uso 
.................... int16 pointer;//apontador para matriz em uso 
.................... int vez;//indice da matriz de dimming corrente 
.................... int mnumluzes;//quantos valores de dimming diferentes temos 
.................... int ltlevel[N_LUZES]={10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10}; 
.................... int16 delays1[N_LUZES+1][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15}; 
.................... int16 delays2[N_LUZES+1][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15}; 
.................... const int16 lights[N_LUZES]={0b1111111011111111,0b1111110111111111,0b1111101111111111,0b1111011111111111,0b1110111111111111,0b1101111111111111,0b1011111111111111,0b0111111111111111, 
....................          /*<........................................................................portC..................................................................................>*/ 
.................... 0b1111111111111110,0b1111111111111101,0b1111111111111011,0b1111111111110111,0b1111111111101111,0b1111111111011111,0b1111111110111111,0b1111111101111111}; 
.................... /*<.................................................................................portD.............................................................>*/ 
.................... const long Matrizluz[128]={ 
.................... 38400,38731 , 38492 , 38253 , 38014 , 37775 , 37536 , 37297 , 37058 , 36819 , 36580 
.................... , 36341 , 36102 , 35863 , 35624 , 35385 , 35146 , 34907 , 34668 , 34429 , 34190 , 33951 
....................  , 33712 , 33473 , 33234 , 32995 , 32756 , 32517 , 32278 , 32039 , 31800 , 31561 , 31322 
....................  , 31083 , 30844 , 30605 , 30366 , 30127 , 29888 , 29649 , 29410 , 29171 , 28932 , 28693 
....................  , 28454 , 28215 , 27976 , 27737 , 27498 , 27259 , 27020 , 26781 , 26542 , 26303 , 26064 
....................  , 25825 , 25586 , 25347 , 25108 , 24869 , 24630 , 24391 , 24152 , 23913 , 23674 , 23435 
....................  , 23196 , 22957 , 22718 , 22479 , 22240 , 22001 , 21762 , 21523 , 21284 , 21045 , 20806 
....................  , 20567 , 20328 , 20089 , 19850 , 19611 , 19372 , 19133 , 18894 , 18655 , 18416 , 18177 
....................  , 17938 , 17699 , 17460 , 17221 , 16982 , 16743 , 16504 , 16265 , 16026 , 15787 , 15548 
....................  , 15309 , 15070 , 14831 , 14592 , 14353 , 14114 , 13875 , 13636 , 13397 , 13158 , 12919 
....................  , 12680 , 12441 , 12202 , 11963 , 11724 , 11485 , 11246 , 11007 , 10768 , 10529 , 10290 
....................  , 10051 , 9812 , 9573 , 9334 , 9095 , 8856 , 617 }; 
....................   
....................   
....................  #INLINE 
....................   INT16 fpointer(int ax,int ay) 
....................    { 
....................       int16 * p; 
....................       p=(pointer + 2* ax * 2 + 2*ay); 
*
009FE:  BCF    FD8.0
00A00:  RLCF   xF9,W
00A02:  MOVWF  00
00A04:  BCF    FD8.0
00A06:  RLCF   00,F
00A08:  MOVF   00,W
00A0A:  MOVLB  1
00A0C:  ADDWF  x3B,W
00A0E:  MOVLB  4
00A10:  MOVWF  xFD
00A12:  MOVLW  00
00A14:  MOVLB  1
00A16:  ADDWFC x3C,W
00A18:  MOVLB  4
00A1A:  MOVWF  xFE
00A1C:  BCF    FD8.0
00A1E:  RLCF   xFA,W
00A20:  ADDWF  xFD,W
00A22:  MOVWF  xFB
00A24:  MOVLW  00
00A26:  ADDWFC xFE,W
00A28:  MOVWF  xFC
*
00A96:  BCF    FD8.0
00A98:  RLCF   xF9,W
00A9A:  MOVWF  00
00A9C:  BCF    FD8.0
00A9E:  RLCF   00,F
00AA0:  MOVF   00,W
00AA2:  MOVLB  1
00AA4:  ADDWF  x3B,W
00AA6:  MOVLB  4
00AA8:  MOVWF  xFD
00AAA:  MOVLW  00
00AAC:  MOVLB  1
00AAE:  ADDWFC x3C,W
00AB0:  MOVLB  4
00AB2:  MOVWF  xFE
00AB4:  BCF    FD8.0
00AB6:  RLCF   xFA,W
00AB8:  ADDWF  xFD,W
00ABA:  MOVWF  xFB
00ABC:  MOVLW  00
00ABE:  ADDWFC xFE,W
00AC0:  MOVWF  xFC
*
01570:  BCF    FD8.0
01572:  RLCF   xF9,W
01574:  MOVWF  00
01576:  BCF    FD8.0
01578:  RLCF   00,F
0157A:  MOVF   00,W
0157C:  MOVLB  1
0157E:  ADDWF  x3B,W
01580:  MOVLB  4
01582:  MOVWF  xFD
01584:  MOVLW  00
01586:  MOVLB  1
01588:  ADDWFC x3C,W
0158A:  MOVLB  4
0158C:  MOVWF  xFE
0158E:  BCF    FD8.0
01590:  RLCF   xFA,W
01592:  ADDWF  xFD,W
01594:  MOVWF  xFB
01596:  MOVLW  00
01598:  ADDWFC xFE,W
0159A:  MOVWF  xFC
*
015F8:  BCF    FD8.0
015FA:  RLCF   xF9,W
015FC:  MOVWF  00
015FE:  BCF    FD8.0
01600:  RLCF   00,F
01602:  MOVF   00,W
01604:  MOVLB  1
01606:  ADDWF  x3B,W
01608:  MOVLB  4
0160A:  MOVWF  xFD
0160C:  MOVLW  00
0160E:  MOVLB  1
01610:  ADDWFC x3C,W
01612:  MOVLB  4
01614:  MOVWF  xFE
01616:  BCF    FD8.0
01618:  RLCF   xFA,W
0161A:  ADDWF  xFD,W
0161C:  MOVWF  xFB
0161E:  MOVLW  00
01620:  ADDWFC xFE,W
01622:  MOVWF  xFC
*
0289A:  BCF    FD8.0
0289C:  RLCF   xF9,W
0289E:  MOVWF  00
028A0:  BCF    FD8.0
028A2:  RLCF   00,F
028A4:  MOVF   00,W
028A6:  MOVLB  1
028A8:  ADDWF  x3B,W
028AA:  MOVLB  4
028AC:  MOVWF  xFD
028AE:  MOVLW  00
028B0:  MOVLB  1
028B2:  ADDWFC x3C,W
028B4:  MOVLB  4
028B6:  MOVWF  xFE
028B8:  BCF    FD8.0
028BA:  RLCF   xFA,W
028BC:  ADDWF  xFD,W
028BE:  MOVWF  xFB
028C0:  MOVLW  00
028C2:  ADDWFC xFE,W
028C4:  MOVWF  xFC
*
02914:  BCF    FD8.0
02916:  RLCF   xF9,W
02918:  MOVWF  00
0291A:  BCF    FD8.0
0291C:  RLCF   00,F
0291E:  MOVF   00,W
02920:  MOVLB  1
02922:  ADDWF  x3B,W
02924:  MOVLB  4
02926:  MOVWF  xFD
02928:  MOVLW  00
0292A:  MOVLB  1
0292C:  ADDWFC x3C,W
0292E:  MOVLB  4
02930:  MOVWF  xFE
02932:  BCF    FD8.0
02934:  RLCF   xFA,W
02936:  ADDWF  xFD,W
02938:  MOVWF  xFB
0293A:  MOVLW  00
0293C:  ADDWFC xFE,W
0293E:  MOVWF  xFC
*
029FE:  BCF    FD8.0
02A00:  RLCF   xF9,W
02A02:  MOVWF  00
02A04:  BCF    FD8.0
02A06:  RLCF   00,F
02A08:  MOVF   00,W
02A0A:  MOVLB  1
02A0C:  ADDWF  x3B,W
02A0E:  MOVLB  4
02A10:  MOVWF  xFD
02A12:  MOVLW  00
02A14:  MOVLB  1
02A16:  ADDWFC x3C,W
02A18:  MOVLB  4
02A1A:  MOVWF  xFE
02A1C:  BCF    FD8.0
02A1E:  RLCF   xFA,W
02A20:  ADDWF  xFD,W
02A22:  MOVWF  xFB
02A24:  MOVLW  00
02A26:  ADDWFC xFE,W
02A28:  MOVWF  xFC
....................      RETURN *(int16*)(pointer + 2* ax * 2 + 2*ay); 
*
00A2A:  BCF    FD8.0
00A2C:  RLCF   xF9,W
00A2E:  MOVWF  00
00A30:  BCF    FD8.0
00A32:  RLCF   00,F
00A34:  MOVF   00,W
00A36:  MOVLB  1
00A38:  ADDWF  x3B,W
00A3A:  MOVLB  4
00A3C:  MOVWF  xFD
00A3E:  MOVLW  00
00A40:  MOVLB  1
00A42:  ADDWFC x3C,W
00A44:  MOVLB  4
00A46:  MOVWF  xFE
00A48:  BCF    FD8.0
00A4A:  RLCF   xFA,W
00A4C:  ADDWF  xFD,W
00A4E:  MOVWF  01
00A50:  MOVLW  00
00A52:  ADDWFC xFE,W
00A54:  MOVWF  03
00A56:  MOVFF  01,FE9
00A5A:  MOVWF  FEA
00A5C:  MOVFF  FEF,01
00A60:  INCF   FE9,F
00A62:  MOVF   FEF,W
00A64:  DECF   FE9,F
00A66:  MOVWF  02
*
00AC2:  BCF    FD8.0
00AC4:  RLCF   xF9,W
00AC6:  MOVWF  00
00AC8:  BCF    FD8.0
00ACA:  RLCF   00,F
00ACC:  MOVF   00,W
00ACE:  MOVLB  1
00AD0:  ADDWF  x3B,W
00AD2:  MOVLB  4
00AD4:  MOVWF  xFD
00AD6:  MOVLW  00
00AD8:  MOVLB  1
00ADA:  ADDWFC x3C,W
00ADC:  MOVLB  4
00ADE:  MOVWF  xFE
00AE0:  BCF    FD8.0
00AE2:  RLCF   xFA,W
00AE4:  ADDWF  xFD,W
00AE6:  MOVWF  01
00AE8:  MOVLW  00
00AEA:  ADDWFC xFE,W
00AEC:  MOVWF  03
00AEE:  MOVFF  01,FE9
00AF2:  MOVWF  FEA
00AF4:  MOVFF  FEF,01
00AF8:  INCF   FE9,F
00AFA:  MOVF   FEF,W
00AFC:  DECF   FE9,F
00AFE:  MOVWF  02
*
0159C:  BCF    FD8.0
0159E:  RLCF   xF9,W
015A0:  MOVWF  00
015A2:  BCF    FD8.0
015A4:  RLCF   00,F
015A6:  MOVF   00,W
015A8:  MOVLB  1
015AA:  ADDWF  x3B,W
015AC:  MOVLB  4
015AE:  MOVWF  xFD
015B0:  MOVLW  00
015B2:  MOVLB  1
015B4:  ADDWFC x3C,W
015B6:  MOVLB  4
015B8:  MOVWF  xFE
015BA:  BCF    FD8.0
015BC:  RLCF   xFA,W
015BE:  ADDWF  xFD,W
015C0:  MOVWF  01
015C2:  MOVLW  00
015C4:  ADDWFC xFE,W
015C6:  MOVWF  03
015C8:  MOVFF  01,FE9
015CC:  MOVWF  FEA
015CE:  MOVFF  FEF,01
015D2:  INCF   FE9,F
015D4:  MOVF   FEF,W
015D6:  DECF   FE9,F
015D8:  MOVWF  02
*
01624:  BCF    FD8.0
01626:  RLCF   xF9,W
01628:  MOVWF  00
0162A:  BCF    FD8.0
0162C:  RLCF   00,F
0162E:  MOVF   00,W
01630:  MOVLB  1
01632:  ADDWF  x3B,W
01634:  MOVLB  4
01636:  MOVWF  xFD
01638:  MOVLW  00
0163A:  MOVLB  1
0163C:  ADDWFC x3C,W
0163E:  MOVLB  4
01640:  MOVWF  xFE
01642:  BCF    FD8.0
01644:  RLCF   xFA,W
01646:  ADDWF  xFD,W
01648:  MOVWF  01
0164A:  MOVLW  00
0164C:  ADDWFC xFE,W
0164E:  MOVWF  03
01650:  MOVFF  01,FE9
01654:  MOVWF  FEA
01656:  MOVFF  FEF,01
0165A:  INCF   FE9,F
0165C:  MOVF   FEF,W
0165E:  DECF   FE9,F
01660:  MOVWF  02
*
028C6:  BCF    FD8.0
028C8:  RLCF   xF9,W
028CA:  MOVWF  00
028CC:  BCF    FD8.0
028CE:  RLCF   00,F
028D0:  MOVF   00,W
028D2:  MOVLB  1
028D4:  ADDWF  x3B,W
028D6:  MOVLB  4
028D8:  MOVWF  xFD
028DA:  MOVLW  00
028DC:  MOVLB  1
028DE:  ADDWFC x3C,W
028E0:  MOVLB  4
028E2:  MOVWF  xFE
028E4:  BCF    FD8.0
028E6:  RLCF   xFA,W
028E8:  ADDWF  xFD,W
028EA:  MOVWF  01
028EC:  MOVLW  00
028EE:  ADDWFC xFE,W
028F0:  MOVWF  03
028F2:  MOVFF  01,FE9
028F6:  MOVWF  FEA
028F8:  MOVFF  FEF,01
028FC:  INCF   FE9,F
028FE:  MOVF   FEF,W
02900:  DECF   FE9,F
02902:  MOVWF  02
*
02940:  BCF    FD8.0
02942:  RLCF   xF9,W
02944:  MOVWF  00
02946:  BCF    FD8.0
02948:  RLCF   00,F
0294A:  MOVF   00,W
0294C:  MOVLB  1
0294E:  ADDWF  x3B,W
02950:  MOVLB  4
02952:  MOVWF  xFD
02954:  MOVLW  00
02956:  MOVLB  1
02958:  ADDWFC x3C,W
0295A:  MOVLB  4
0295C:  MOVWF  xFE
0295E:  BCF    FD8.0
02960:  RLCF   xFA,W
02962:  ADDWF  xFD,W
02964:  MOVWF  01
02966:  MOVLW  00
02968:  ADDWFC xFE,W
0296A:  MOVWF  03
0296C:  MOVFF  01,FE9
02970:  MOVWF  FEA
02972:  MOVFF  FEF,01
02976:  INCF   FE9,F
02978:  MOVF   FEF,W
0297A:  DECF   FE9,F
0297C:  MOVWF  02
*
02A2A:  BCF    FD8.0
02A2C:  RLCF   xF9,W
02A2E:  MOVWF  00
02A30:  BCF    FD8.0
02A32:  RLCF   00,F
02A34:  MOVF   00,W
02A36:  MOVLB  1
02A38:  ADDWF  x3B,W
02A3A:  MOVLB  4
02A3C:  MOVWF  xFD
02A3E:  MOVLW  00
02A40:  MOVLB  1
02A42:  ADDWFC x3C,W
02A44:  MOVLB  4
02A46:  MOVWF  xFE
02A48:  BCF    FD8.0
02A4A:  RLCF   xFA,W
02A4C:  ADDWF  xFD,W
02A4E:  MOVWF  01
02A50:  MOVLW  00
02A52:  ADDWFC xFE,W
02A54:  MOVWF  03
02A56:  MOVFF  01,FE9
02A5A:  MOVWF  FEA
02A5C:  MOVFF  FEF,01
02A60:  INCF   FE9,F
02A62:  MOVF   FEF,W
02A64:  DECF   FE9,F
02A66:  MOVWF  02
....................    } 
....................  
....................    
....................   VOID org(void) 
....................   { 
*
01AC6:  MOVLB  4
01AC8:  BSF    xE4.0
....................      INT clockorg; 
....................      INT16 tempd[N_LUZES][2]; 
....................      INT numluzes; 
....................      INT1 again = 1; 
....................      INT fa; 
....................      INT16 fl; 
....................      INT afa; 
....................      FOR(fa = 0;fa < used_dimmers;++fa) 
01ACA:  CLRF   xE5
01ACC:  MOVLB  1
01ACE:  MOVF   x3A,W
01AD0:  MOVLB  4
01AD2:  SUBWF  xE5,W
01AD4:  BC    1B50
....................      { 
....................         tempd[fa][0] = ltlevel[fa];//tempd[x][0] fica com o valor de dimming 0...127 
01AD6:  MOVF   xE5,W
01AD8:  MULLW  04
01ADA:  MOVF   FF3,W
01ADC:  CLRF   xEA
01ADE:  MOVWF  xE9
01AE0:  MOVLW  A3
01AE2:  ADDWF  xE9,W
01AE4:  MOVWF  01
01AE6:  MOVLW  04
01AE8:  ADDWFC xEA,W
01AEA:  MOVWF  03
01AEC:  MOVWF  xEA
01AEE:  CLRF   03
01AF0:  MOVF   xE5,W
01AF2:  ADDLW  3F
01AF4:  MOVWF  FE9
01AF6:  MOVLW  01
01AF8:  ADDWFC 03,W
01AFA:  MOVWF  FEA
01AFC:  MOVF   FEF,W
01AFE:  CLRF   03
01B00:  MOVFF  4EA,FEA
01B04:  MOVFF  01,FE9
01B08:  MOVFF  03,FEC
01B0C:  MOVF   FED,F
01B0E:  MOVWF  FEF
....................         tempd[fa][1] = lights[fa];//tempd[x][1] fica com o valor binario DO porto de saida 
01B10:  MOVF   xE5,W
01B12:  MULLW  04
01B14:  MOVF   FF3,W
01B16:  CLRF   xEA
01B18:  MOVWF  xE9
01B1A:  MOVLW  02
01B1C:  ADDWF  xE9,W
01B1E:  MOVWF  01
01B20:  MOVLW  00
01B22:  ADDWFC xEA,W
01B24:  MOVWF  03
01B26:  MOVF   01,W
01B28:  ADDLW  A3
01B2A:  MOVWF  FE9
01B2C:  MOVLW  04
01B2E:  ADDWFC 03,W
01B30:  MOVWF  FEA
01B32:  BCF    FD8.0
01B34:  RLCF   xE5,W
01B36:  CLRF   03
01B38:  MOVLB  0
01B3A:  CALL   0166
01B3E:  TBLRD*+
01B40:  MOVFF  FF5,03
01B44:  MOVWF  FEF
01B46:  MOVFF  03,FEC
....................      } 
01B4A:  MOVLB  4
01B4C:  INCF   xE5,F
01B4E:  BRA    1ACC
....................  
....................      WHILE(again) 
....................      { 
01B50:  BTFSS  xE4.0
01B52:  BRA    1D1A
....................         again = 0; 
01B54:  BCF    xE4.0
....................         FOR(fa = 0;fa < used_dimmers-1;++fa) 
01B56:  CLRF   xE5
01B58:  MOVLW  01
01B5A:  MOVLB  1
01B5C:  SUBWF  x3A,W
01B5E:  MOVLB  4
01B60:  SUBWF  xE5,W
01B62:  BTFSC  FD8.0
01B64:  BRA    1D18
....................         { 
....................            //coloca valores por ordem tempd[0][0] o maior 
....................            IF(tempd[fa][0] < tempd[fa + 1][0]) 
01B66:  MOVF   xE5,W
01B68:  MULLW  04
01B6A:  MOVF   FF3,W
01B6C:  CLRF   xEA
01B6E:  MOVWF  xE9
01B70:  MOVLW  A3
01B72:  ADDWF  xE9,W
01B74:  MOVWF  FE9
01B76:  MOVLW  04
01B78:  ADDWFC xEA,W
01B7A:  MOVWF  FEA
01B7C:  MOVFF  FEC,4EA
01B80:  MOVF   FED,F
01B82:  MOVFF  FEF,4E9
01B86:  MOVLW  01
01B88:  ADDWF  xE5,W
01B8A:  MULLW  04
01B8C:  MOVF   FF3,W
01B8E:  CLRF   xEC
01B90:  MOVWF  xEB
01B92:  MOVLW  A3
01B94:  ADDWF  xEB,W
01B96:  MOVWF  FE9
01B98:  MOVLW  04
01B9A:  ADDWFC xEC,W
01B9C:  MOVWF  FEA
01B9E:  MOVFF  FEC,03
01BA2:  MOVF   FED,F
01BA4:  MOVFF  FEF,01
01BA8:  MOVF   xEA,W
01BAA:  SUBWF  03,W
01BAC:  BTFSS  FD8.0
01BAE:  BRA    1D14
01BB0:  BNZ   1BBA
01BB2:  MOVF   01,W
01BB4:  SUBWF  xE9,W
01BB6:  BTFSC  FD8.0
01BB8:  BRA    1D14
....................            { 
....................               again = 1; 
01BBA:  BSF    xE4.0
....................               fl = tempd[fa][0]; 
01BBC:  MOVF   xE5,W
01BBE:  MULLW  04
01BC0:  MOVF   FF3,W
01BC2:  CLRF   xEA
01BC4:  MOVWF  xE9
01BC6:  MOVLW  A3
01BC8:  ADDWF  xE9,W
01BCA:  MOVWF  FE9
01BCC:  MOVLW  04
01BCE:  ADDWFC xEA,W
01BD0:  MOVWF  FEA
01BD2:  MOVFF  FEC,03
01BD6:  MOVF   FED,F
01BD8:  MOVFF  FEF,4E6
01BDC:  MOVFF  03,4E7
....................               tempd[fa][0] = tempd[fa + 1][0]; 
01BE0:  MOVF   xE5,W
01BE2:  MULLW  04
01BE4:  MOVF   FF3,W
01BE6:  CLRF   xEA
01BE8:  MOVWF  xE9
01BEA:  MOVLW  A3
01BEC:  ADDWF  xE9,W
01BEE:  MOVWF  01
01BF0:  MOVLW  04
01BF2:  ADDWFC xEA,W
01BF4:  MOVWF  03
01BF6:  MOVWF  xEA
01BF8:  MOVLW  01
01BFA:  ADDWF  xE5,W
01BFC:  MULLW  04
01BFE:  MOVF   FF3,W
01C00:  CLRF   xEC
01C02:  MOVWF  xEB
01C04:  MOVLW  A3
01C06:  ADDWF  xEB,W
01C08:  MOVWF  FE9
01C0A:  MOVLW  04
01C0C:  ADDWFC xEC,W
01C0E:  MOVWF  FEA
01C10:  MOVFF  FEC,03
01C14:  MOVF   FED,F
01C16:  MOVFF  FEF,4EB
01C1A:  MOVFF  4EA,FEA
01C1E:  MOVFF  01,FE9
01C22:  MOVFF  03,FEC
01C26:  MOVF   FED,F
01C28:  MOVFF  4EB,FEF
....................               tempd[fa + 1][0] = fl; 
01C2C:  MOVLW  01
01C2E:  ADDWF  xE5,W
01C30:  MULLW  04
01C32:  MOVF   FF3,W
01C34:  CLRF   xEA
01C36:  MOVWF  xE9
01C38:  MOVLW  A3
01C3A:  ADDWF  xE9,W
01C3C:  MOVWF  FE9
01C3E:  MOVLW  04
01C40:  ADDWFC xEA,W
01C42:  MOVWF  FEA
01C44:  MOVFF  4E7,FEC
01C48:  MOVF   FED,F
01C4A:  MOVFF  4E6,FEF
....................               fl = tempd[fa][1]; 
01C4E:  MOVF   xE5,W
01C50:  MULLW  04
01C52:  MOVF   FF3,W
01C54:  CLRF   xEA
01C56:  MOVWF  xE9
01C58:  MOVLW  02
01C5A:  ADDWF  xE9,W
01C5C:  MOVWF  01
01C5E:  MOVLW  00
01C60:  ADDWFC xEA,W
01C62:  MOVWF  03
01C64:  MOVF   01,W
01C66:  ADDLW  A3
01C68:  MOVWF  FE9
01C6A:  MOVLW  04
01C6C:  ADDWFC 03,W
01C6E:  MOVWF  FEA
01C70:  MOVFF  FEC,03
01C74:  MOVF   FED,F
01C76:  MOVFF  FEF,4E6
01C7A:  MOVFF  03,4E7
....................               tempd[fa][1] = tempd[fa + 1][1]; 
01C7E:  MOVF   xE5,W
01C80:  MULLW  04
01C82:  MOVF   FF3,W
01C84:  CLRF   xEA
01C86:  MOVWF  xE9
01C88:  MOVLW  02
01C8A:  ADDWF  xE9,W
01C8C:  MOVWF  01
01C8E:  MOVLW  00
01C90:  ADDWFC xEA,W
01C92:  MOVWF  03
01C94:  MOVF   01,W
01C96:  ADDLW  A3
01C98:  MOVWF  01
01C9A:  MOVLW  04
01C9C:  ADDWFC 03,F
01C9E:  MOVFF  01,4E9
01CA2:  MOVFF  03,4EA
01CA6:  MOVLW  01
01CA8:  ADDWF  xE5,W
01CAA:  MULLW  04
01CAC:  MOVF   FF3,W
01CAE:  CLRF   xEC
01CB0:  MOVWF  xEB
01CB2:  MOVLW  02
01CB4:  ADDWF  xEB,W
01CB6:  MOVWF  01
01CB8:  MOVLW  00
01CBA:  ADDWFC xEC,W
01CBC:  MOVWF  03
01CBE:  MOVF   01,W
01CC0:  ADDLW  A3
01CC2:  MOVWF  FE9
01CC4:  MOVLW  04
01CC6:  ADDWFC 03,W
01CC8:  MOVWF  FEA
01CCA:  MOVFF  FEC,03
01CCE:  MOVF   FED,F
01CD0:  MOVFF  FEF,4EB
01CD4:  MOVFF  4EA,FEA
01CD8:  MOVFF  4E9,FE9
01CDC:  MOVFF  03,FEC
01CE0:  MOVF   FED,F
01CE2:  MOVFF  4EB,FEF
....................               tempd[fa + 1][1] = fl; 
01CE6:  MOVLW  01
01CE8:  ADDWF  xE5,W
01CEA:  MULLW  04
01CEC:  MOVF   FF3,W
01CEE:  CLRF   xEA
01CF0:  MOVWF  xE9
01CF2:  MOVLW  02
01CF4:  ADDWF  xE9,W
01CF6:  MOVWF  01
01CF8:  MOVLW  00
01CFA:  ADDWFC xEA,W
01CFC:  MOVWF  03
01CFE:  MOVF   01,W
01D00:  ADDLW  A3
01D02:  MOVWF  FE9
01D04:  MOVLW  04
01D06:  ADDWFC 03,W
01D08:  MOVWF  FEA
01D0A:  MOVFF  4E7,FEC
01D0E:  MOVF   FED,F
01D10:  MOVFF  4E6,FEF
....................            } 
....................         } 
01D14:  INCF   xE5,F
01D16:  BRA    1B58
....................      } 
01D18:  BRA    1B50
....................       for(temp=0;temp<17;++temp) 
01D1A:  MOVLB  1
01D1C:  CLRF   x39
01D1E:  MOVF   x39,W
01D20:  SUBLW  10
01D22:  BNC   1DE0
....................    { 
....................       printf("%lu <-> %lu\n\r",tempd[temp][0],tempd[temp][1]); 
01D24:  MOVF   x39,W
01D26:  MULLW  04
01D28:  MOVF   FF3,W
01D2A:  MOVLB  4
01D2C:  CLRF   xEA
01D2E:  MOVWF  xE9
01D30:  MOVLW  A3
01D32:  ADDWF  xE9,W
01D34:  MOVWF  FE9
01D36:  MOVLW  04
01D38:  ADDWFC xEA,W
01D3A:  MOVWF  FEA
01D3C:  MOVFF  FEC,4EA
01D40:  MOVF   FED,F
01D42:  MOVFF  FEF,4E9
01D46:  MOVLB  1
01D48:  MOVF   x39,W
01D4A:  MULLW  04
01D4C:  MOVF   FF3,W
01D4E:  MOVLB  4
01D50:  CLRF   xEC
01D52:  MOVWF  xEB
01D54:  MOVLW  02
01D56:  ADDWF  xEB,W
01D58:  MOVWF  01
01D5A:  MOVLW  00
01D5C:  ADDWFC xEC,W
01D5E:  MOVWF  03
01D60:  MOVF   01,W
01D62:  ADDLW  A3
01D64:  MOVWF  FE9
01D66:  MOVLW  04
01D68:  ADDWFC 03,W
01D6A:  MOVWF  FEA
01D6C:  MOVFF  FEC,4EC
01D70:  MOVF   FED,F
01D72:  MOVFF  FEF,4EB
01D76:  MOVLW  10
01D78:  MOVWF  FE9
01D7A:  MOVFF  4EA,4EE
01D7E:  MOVFF  4E9,4ED
01D82:  MOVLB  0
01D84:  RCALL  1878
01D86:  MOVLW  B1
01D88:  MOVWF  FF6
01D8A:  MOVLW  02
01D8C:  MOVWF  FF7
01D8E:  MOVLW  00
01D90:  MOVWF  FF8
01D92:  MOVLW  05
01D94:  MOVLB  4
01D96:  MOVWF  xED
01D98:  MOVLB  0
01D9A:  RCALL  1942
01D9C:  MOVLW  10
01D9E:  MOVWF  FE9
01DA0:  MOVFF  4EC,4EE
01DA4:  MOVFF  4EB,4ED
01DA8:  RCALL  1878
01DAA:  CLRF   1B
01DAC:  BTFSC  FF2.7
01DAE:  BSF    1B.7
01DB0:  BCF    FF2.7
01DB2:  MOVLW  0A
01DB4:  MOVLB  5
01DB6:  MOVWF  x03
01DB8:  MOVLB  0
01DBA:  CALL   0372
01DBE:  BTFSC  1B.7
01DC0:  BSF    FF2.7
01DC2:  CLRF   1B
01DC4:  BTFSC  FF2.7
01DC6:  BSF    1B.7
01DC8:  BCF    FF2.7
01DCA:  MOVLW  0D
01DCC:  MOVLB  5
01DCE:  MOVWF  x03
01DD0:  MOVLB  0
01DD2:  CALL   0372
01DD6:  BTFSC  1B.7
01DD8:  BSF    FF2.7
....................    } 
01DDA:  MOVLB  1
01DDC:  INCF   x39,F
01DDE:  BRA    1D1E
....................      IF(tempd[0][0] == 0)numluzes = 0;//luzes todas off 
01DE0:  MOVLB  4
01DE2:  MOVF   xA3,F
01DE4:  BNZ   1DEE
01DE6:  MOVF   xA4,F
01DE8:  BNZ   1DEE
01DEA:  CLRF   xE3
....................      ELSE 
01DEC:  BRA    218E
....................      { 
....................         numluzes = 1; 
01DEE:  MOVLW  01
01DF0:  MOVWF  xE3
....................         afa = 0; 
01DF2:  CLRF   xE8
....................         IF(actmat) 
01DF4:  MOVLB  0
01DF6:  BTFSS  xB1.3
01DF8:  BRA    1E0C
....................         { 
....................            delays1[0][0] = tempd[0][0]; 
01DFA:  MOVFF  4A4,150
01DFE:  MOVFF  4A3,14F
....................            delays1[0][1] = tempd[0][1]; 
01E02:  MOVFF  4A6,152
01E06:  MOVFF  4A5,151
....................         } 
....................  
....................         ELSE 
01E0A:  BRA    1E1C
....................         { 
....................            delays2[0][0] = tempd[0][0]; 
01E0C:  MOVFF  4A4,194
01E10:  MOVFF  4A3,193
....................            delays2[0][1] = tempd[0][1]; 
01E14:  MOVFF  4A6,196
01E18:  MOVFF  4A5,195
....................         } 
....................  
....................         FOR(fa = 1;fa < used_dimmers;++fa) 
01E1C:  MOVLW  01
01E1E:  MOVLB  4
01E20:  MOVWF  xE5
01E22:  MOVLB  1
01E24:  MOVF   x3A,W
01E26:  MOVLB  4
01E28:  SUBWF  xE5,W
01E2A:  BTFSC  FD8.0
01E2C:  BRA    218E
....................         { 
....................            IF((tempd[fa][0] == tempd[fa - 1][0])&( ! tempd[fa][0] == 0)) 
01E2E:  MOVF   xE5,W
01E30:  MULLW  04
01E32:  MOVF   FF3,W
01E34:  CLRF   xEA
01E36:  MOVWF  xE9
01E38:  MOVLW  A3
01E3A:  ADDWF  xE9,W
01E3C:  MOVWF  FE9
01E3E:  MOVLW  04
01E40:  ADDWFC xEA,W
01E42:  MOVWF  FEA
01E44:  MOVFF  FEC,4EA
01E48:  MOVF   FED,F
01E4A:  MOVFF  FEF,4E9
01E4E:  MOVLW  01
01E50:  SUBWF  xE5,W
01E52:  MULLW  04
01E54:  MOVF   FF3,W
01E56:  CLRF   xEC
01E58:  MOVWF  xEB
01E5A:  MOVLW  A3
01E5C:  ADDWF  xEB,W
01E5E:  MOVWF  FE9
01E60:  MOVLW  04
01E62:  ADDWFC xEC,W
01E64:  MOVWF  FEA
01E66:  MOVFF  FEC,03
01E6A:  MOVF   FED,F
01E6C:  MOVF   FEF,W
01E6E:  SUBWF  xE9,W
01E70:  BNZ   1E78
01E72:  MOVF   03,W
01E74:  SUBWF  xEA,W
01E76:  BZ    1E7C
01E78:  MOVLW  00
01E7A:  BRA    1E7E
01E7C:  MOVLW  01
01E7E:  MOVWF  xE9
01E80:  MOVF   xE5,W
01E82:  MULLW  04
01E84:  MOVF   FF3,W
01E86:  CLRF   xEB
01E88:  MOVWF  xEA
01E8A:  MOVLW  A3
01E8C:  ADDWF  xEA,W
01E8E:  MOVWF  FE9
01E90:  MOVLW  04
01E92:  ADDWFC xEB,W
01E94:  MOVWF  FEA
01E96:  MOVF   FEF,F
01E98:  BNZ   1E9E
01E9A:  MOVF   FEC,F
01E9C:  BZ    1EA2
01E9E:  MOVLW  00
01EA0:  BRA    1EA4
01EA2:  MOVLW  01
01EA4:  XORLW  00
01EA6:  BZ    1EAC
01EA8:  MOVLW  00
01EAA:  BRA    1EAE
01EAC:  MOVLW  01
01EAE:  ANDWF  xE9,W
01EB0:  BTFSC  FD8.2
01EB2:  BRA    1FEE
....................            { 
....................               IF(actmat)delays1[afa][1] = delays1[afa][1]&tempd[fa][1]; 
01EB4:  MOVLB  0
01EB6:  BTFSS  xB1.3
01EB8:  BRA    1F54
01EBA:  MOVLB  4
01EBC:  MOVF   xE8,W
01EBE:  MULLW  04
01EC0:  MOVF   FF3,W
01EC2:  CLRF   xEA
01EC4:  MOVWF  xE9
01EC6:  MOVLW  02
01EC8:  ADDWF  xE9,W
01ECA:  MOVWF  01
01ECC:  MOVLW  00
01ECE:  ADDWFC xEA,W
01ED0:  MOVWF  03
01ED2:  MOVF   01,W
01ED4:  ADDLW  4F
01ED6:  MOVWF  01
01ED8:  MOVLW  01
01EDA:  ADDWFC 03,F
01EDC:  MOVFF  01,4E9
01EE0:  MOVFF  03,4EA
01EE4:  MOVF   xE8,W
01EE6:  MULLW  04
01EE8:  MOVF   FF3,W
01EEA:  CLRF   xEC
01EEC:  MOVWF  xEB
01EEE:  MOVLW  02
01EF0:  ADDWF  xEB,W
01EF2:  MOVWF  01
01EF4:  MOVLW  00
01EF6:  ADDWFC xEC,W
01EF8:  MOVWF  03
01EFA:  MOVF   01,W
01EFC:  ADDLW  4F
01EFE:  MOVWF  FE9
01F00:  MOVLW  01
01F02:  ADDWFC 03,W
01F04:  MOVWF  FEA
01F06:  MOVFF  FEC,4EC
01F0A:  MOVF   FED,F
01F0C:  MOVFF  FEF,4EB
01F10:  MOVF   xE5,W
01F12:  MULLW  04
01F14:  MOVF   FF3,W
01F16:  CLRF   xEE
01F18:  MOVWF  xED
01F1A:  MOVLW  02
01F1C:  ADDWF  xED,W
01F1E:  MOVWF  01
01F20:  MOVLW  00
01F22:  ADDWFC xEE,W
01F24:  MOVWF  03
01F26:  MOVF   01,W
01F28:  ADDLW  A3
01F2A:  MOVWF  FE9
01F2C:  MOVLW  04
01F2E:  ADDWFC 03,W
01F30:  MOVWF  FEA
01F32:  MOVFF  FEC,03
01F36:  MOVF   FED,F
01F38:  MOVF   FEF,W
01F3A:  ANDWF  xEB,W
01F3C:  MOVWF  00
01F3E:  MOVF   03,W
01F40:  ANDWF  xEC,W
01F42:  MOVFF  4EA,FEA
01F46:  MOVFF  4E9,FE9
01F4A:  MOVWF  FEC
01F4C:  MOVF   FED,F
01F4E:  MOVFF  00,FEF
....................               ELSE delays2[afa][1] = delays2[afa][1]&tempd[fa][1]; 
01F52:  BRA    1FEC
01F54:  MOVLB  4
01F56:  MOVF   xE8,W
01F58:  MULLW  04
01F5A:  MOVF   FF3,W
01F5C:  CLRF   xEA
01F5E:  MOVWF  xE9
01F60:  MOVLW  02
01F62:  ADDWF  xE9,W
01F64:  MOVWF  01
01F66:  MOVLW  00
01F68:  ADDWFC xEA,W
01F6A:  MOVWF  03
01F6C:  MOVF   01,W
01F6E:  ADDLW  93
01F70:  MOVWF  01
01F72:  MOVLW  01
01F74:  ADDWFC 03,F
01F76:  MOVFF  01,4E9
01F7A:  MOVFF  03,4EA
01F7E:  MOVF   xE8,W
01F80:  MULLW  04
01F82:  MOVF   FF3,W
01F84:  CLRF   xEC
01F86:  MOVWF  xEB
01F88:  MOVLW  02
01F8A:  ADDWF  xEB,W
01F8C:  MOVWF  01
01F8E:  MOVLW  00
01F90:  ADDWFC xEC,W
01F92:  MOVWF  03
01F94:  MOVF   01,W
01F96:  ADDLW  93
01F98:  MOVWF  FE9
01F9A:  MOVLW  01
01F9C:  ADDWFC 03,W
01F9E:  MOVWF  FEA
01FA0:  MOVFF  FEC,4EC
01FA4:  MOVF   FED,F
01FA6:  MOVFF  FEF,4EB
01FAA:  MOVF   xE5,W
01FAC:  MULLW  04
01FAE:  MOVF   FF3,W
01FB0:  CLRF   xEE
01FB2:  MOVWF  xED
01FB4:  MOVLW  02
01FB6:  ADDWF  xED,W
01FB8:  MOVWF  01
01FBA:  MOVLW  00
01FBC:  ADDWFC xEE,W
01FBE:  MOVWF  03
01FC0:  MOVF   01,W
01FC2:  ADDLW  A3
01FC4:  MOVWF  FE9
01FC6:  MOVLW  04
01FC8:  ADDWFC 03,W
01FCA:  MOVWF  FEA
01FCC:  MOVFF  FEC,03
01FD0:  MOVF   FED,F
01FD2:  MOVF   FEF,W
01FD4:  ANDWF  xEB,W
01FD6:  MOVWF  00
01FD8:  MOVF   03,W
01FDA:  ANDWF  xEC,W
01FDC:  MOVFF  4EA,FEA
01FE0:  MOVFF  4E9,FE9
01FE4:  MOVWF  FEC
01FE6:  MOVF   FED,F
01FE8:  MOVFF  00,FEF
....................            } 
....................  
....................            else IF( ! tempd[fa][0] == 0) 
01FEC:  BRA    218A
01FEE:  MOVF   xE5,W
01FF0:  MULLW  04
01FF2:  MOVF   FF3,W
01FF4:  CLRF   xEA
01FF6:  MOVWF  xE9
01FF8:  MOVLW  A3
01FFA:  ADDWF  xE9,W
01FFC:  MOVWF  FE9
01FFE:  MOVLW  04
02000:  ADDWFC xEA,W
02002:  MOVWF  FEA
02004:  MOVF   FEF,F
02006:  BNZ   200C
02008:  MOVF   FEC,F
0200A:  BZ    2010
0200C:  MOVLW  00
0200E:  BRA    2012
02010:  MOVLW  01
02012:  XORLW  00
02014:  BTFSS  FD8.2
02016:  BRA    218A
....................            { 
....................               ++afa; 
02018:  INCF   xE8,F
....................               IF(actmat) 
0201A:  MOVLB  0
0201C:  BTFSS  xB1.3
0201E:  BRA    20D6
....................               { 
....................                  delays1[afa][0] = tempd[fa][0]; 
02020:  MOVLB  4
02022:  MOVF   xE8,W
02024:  MULLW  04
02026:  MOVF   FF3,W
02028:  CLRF   xEA
0202A:  MOVWF  xE9
0202C:  MOVLW  4F
0202E:  ADDWF  xE9,W
02030:  MOVWF  01
02032:  MOVLW  01
02034:  ADDWFC xEA,W
02036:  MOVWF  03
02038:  MOVWF  xEA
0203A:  MOVF   xE5,W
0203C:  MULLW  04
0203E:  MOVF   FF3,W
02040:  CLRF   xEC
02042:  MOVWF  xEB
02044:  MOVLW  A3
02046:  ADDWF  xEB,W
02048:  MOVWF  FE9
0204A:  MOVLW  04
0204C:  ADDWFC xEC,W
0204E:  MOVWF  FEA
02050:  MOVFF  FEC,03
02054:  MOVF   FED,F
02056:  MOVFF  FEF,4EB
0205A:  MOVFF  4EA,FEA
0205E:  MOVFF  01,FE9
02062:  MOVFF  03,FEC
02066:  MOVF   FED,F
02068:  MOVFF  4EB,FEF
....................                  delays1[afa][1] = tempd[fa][1]; 
0206C:  MOVF   xE8,W
0206E:  MULLW  04
02070:  MOVF   FF3,W
02072:  CLRF   xEA
02074:  MOVWF  xE9
02076:  MOVLW  02
02078:  ADDWF  xE9,W
0207A:  MOVWF  01
0207C:  MOVLW  00
0207E:  ADDWFC xEA,W
02080:  MOVWF  03
02082:  MOVF   01,W
02084:  ADDLW  4F
02086:  MOVWF  01
02088:  MOVLW  01
0208A:  ADDWFC 03,F
0208C:  MOVFF  01,4E9
02090:  MOVFF  03,4EA
02094:  MOVF   xE5,W
02096:  MULLW  04
02098:  MOVF   FF3,W
0209A:  CLRF   xEC
0209C:  MOVWF  xEB
0209E:  MOVLW  02
020A0:  ADDWF  xEB,W
020A2:  MOVWF  01
020A4:  MOVLW  00
020A6:  ADDWFC xEC,W
020A8:  MOVWF  03
020AA:  MOVF   01,W
020AC:  ADDLW  A3
020AE:  MOVWF  FE9
020B0:  MOVLW  04
020B2:  ADDWFC 03,W
020B4:  MOVWF  FEA
020B6:  MOVFF  FEC,03
020BA:  MOVF   FED,F
020BC:  MOVFF  FEF,4EB
020C0:  MOVFF  4EA,FEA
020C4:  MOVFF  4E9,FE9
020C8:  MOVFF  03,FEC
020CC:  MOVF   FED,F
020CE:  MOVFF  4EB,FEF
....................               } 
....................  
....................               ELSE 
020D2:  BRA    2188
020D4:  MOVLB  0
....................               { 
....................                  delays2[afa][0] = tempd[fa][0]; 
020D6:  MOVLB  4
020D8:  MOVF   xE8,W
020DA:  MULLW  04
020DC:  MOVF   FF3,W
020DE:  CLRF   xEA
020E0:  MOVWF  xE9
020E2:  MOVLW  93
020E4:  ADDWF  xE9,W
020E6:  MOVWF  01
020E8:  MOVLW  01
020EA:  ADDWFC xEA,W
020EC:  MOVWF  03
020EE:  MOVWF  xEA
020F0:  MOVF   xE5,W
020F2:  MULLW  04
020F4:  MOVF   FF3,W
020F6:  CLRF   xEC
020F8:  MOVWF  xEB
020FA:  MOVLW  A3
020FC:  ADDWF  xEB,W
020FE:  MOVWF  FE9
02100:  MOVLW  04
02102:  ADDWFC xEC,W
02104:  MOVWF  FEA
02106:  MOVFF  FEC,03
0210A:  MOVF   FED,F
0210C:  MOVFF  FEF,4EB
02110:  MOVFF  4EA,FEA
02114:  MOVFF  01,FE9
02118:  MOVFF  03,FEC
0211C:  MOVF   FED,F
0211E:  MOVFF  4EB,FEF
....................                  delays2[afa][1] = tempd[fa][1]; 
02122:  MOVF   xE8,W
02124:  MULLW  04
02126:  MOVF   FF3,W
02128:  CLRF   xEA
0212A:  MOVWF  xE9
0212C:  MOVLW  02
0212E:  ADDWF  xE9,W
02130:  MOVWF  01
02132:  MOVLW  00
02134:  ADDWFC xEA,W
02136:  MOVWF  03
02138:  MOVF   01,W
0213A:  ADDLW  93
0213C:  MOVWF  01
0213E:  MOVLW  01
02140:  ADDWFC 03,F
02142:  MOVFF  01,4E9
02146:  MOVFF  03,4EA
0214A:  MOVF   xE5,W
0214C:  MULLW  04
0214E:  MOVF   FF3,W
02150:  CLRF   xEC
02152:  MOVWF  xEB
02154:  MOVLW  02
02156:  ADDWF  xEB,W
02158:  MOVWF  01
0215A:  MOVLW  00
0215C:  ADDWFC xEC,W
0215E:  MOVWF  03
02160:  MOVF   01,W
02162:  ADDLW  A3
02164:  MOVWF  FE9
02166:  MOVLW  04
02168:  ADDWFC 03,W
0216A:  MOVWF  FEA
0216C:  MOVFF  FEC,03
02170:  MOVF   FED,F
02172:  MOVFF  FEF,4EB
02176:  MOVFF  4EA,FEA
0217A:  MOVFF  4E9,FE9
0217E:  MOVFF  03,FEC
02182:  MOVF   FED,F
02184:  MOVFF  4EB,FEF
....................               } 
....................  
....................               ++numluzes; 
02188:  INCF   xE3,F
....................            } 
....................         } 
0218A:  INCF   xE5,F
0218C:  BRA    1E22
....................      } 
....................  
....................      IF(actmat)delays1[N_LUZES][0] = numluzes; 
0218E:  MOVLB  0
02190:  BTFSS  xB1.3
02192:  BRA    219E
02194:  MOVLB  1
02196:  CLRF   x90
02198:  MOVFF  4E3,18F
....................      ELSE  delays2[N_LUZES][0] = numluzes; 
0219C:  BRA    21A6
0219E:  MOVLB  1
021A0:  CLRF   xD4
021A2:  MOVFF  4E3,1D3
....................      printf("numluzes=%d %lu %lu\n\r",numluzes,delays1[0][0],delays1[0][1]); 
021A6:  MOVLW  BC
021A8:  MOVWF  FF6
021AA:  MOVLW  02
021AC:  MOVWF  FF7
021AE:  MOVLW  00
021B0:  MOVWF  FF8
021B2:  MOVLW  09
021B4:  MOVLB  4
021B6:  MOVWF  xED
021B8:  MOVLB  0
021BA:  CALL   1942
021BE:  MOVFF  4E3,4E9
021C2:  MOVLW  1F
021C4:  MOVLB  4
021C6:  MOVWF  xEA
021C8:  MOVLB  0
021CA:  GOTO   19AC
021CE:  CLRF   1B
021D0:  BTFSC  FF2.7
021D2:  BSF    1B.7
021D4:  BCF    FF2.7
021D6:  MOVLW  20
021D8:  MOVLB  5
021DA:  MOVWF  x03
021DC:  MOVLB  0
021DE:  CALL   0372
021E2:  BTFSC  1B.7
021E4:  BSF    FF2.7
021E6:  MOVLW  10
021E8:  MOVWF  FE9
021EA:  MOVFF  150,4EE
021EE:  MOVFF  14F,4ED
021F2:  CALL   1878
021F6:  CLRF   1B
021F8:  BTFSC  FF2.7
021FA:  BSF    1B.7
021FC:  BCF    FF2.7
021FE:  MOVLW  20
02200:  MOVLB  5
02202:  MOVWF  x03
02204:  MOVLB  0
02206:  CALL   0372
0220A:  BTFSC  1B.7
0220C:  BSF    FF2.7
0220E:  MOVLW  10
02210:  MOVWF  FE9
02212:  MOVFF  152,4EE
02216:  MOVFF  151,4ED
0221A:  CALL   1878
0221E:  CLRF   1B
02220:  BTFSC  FF2.7
02222:  BSF    1B.7
02224:  BCF    FF2.7
02226:  MOVLW  0A
02228:  MOVLB  5
0222A:  MOVWF  x03
0222C:  MOVLB  0
0222E:  CALL   0372
02232:  BTFSC  1B.7
02234:  BSF    FF2.7
02236:  CLRF   1B
02238:  BTFSC  FF2.7
0223A:  BSF    1B.7
0223C:  BCF    FF2.7
0223E:  MOVLW  0D
02240:  MOVLB  5
02242:  MOVWF  x03
02244:  MOVLB  0
02246:  CALL   0372
0224A:  BTFSC  1B.7
0224C:  BSF    FF2.7
....................       
....................      organizado=1; 
0224E:  BSF    xB1.2
....................   } 
02250:  RETLW  00
....................  
....................  
....................  
.................... #include "struct_and_enums.c" 
.................... enum switch_type {on_off,dimmer,button}; 
.................... enum switch_outstate {on, off, dimming, dimmed, maxed}; 
.................... enum switch_direction {up, down}; 
.................... enum switch_state {button_pressed, button_depressed}; 
.................... enum output_type {_on_off, _dimmer,shutter}; 
.................... enum output_state {_on, _off, _dimmed}; 
.................... enum timer_type {time_on, time_off, periodic_on}; 
.................... enum input_type {switch_,timer,none}; 
....................  
.................... void dimmer_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input); 
.................... typedef struct data_point_out 
.................... { 
....................    unsigned int adress; 
....................    unsigned int value; 
....................    int1 needs_update; 
.................... }; 
.................... typedef struct data_point_in 
.................... { 
....................    unsigned int adress[8]; 
....................    unsigned int value; 
....................    int1 needs_update; 
.................... }; 
.................... ///////////////////////INPUTS////////////////////////////////////// 
.................... typedef struct switches 
.................... { 
....................    switch_type type; 
....................    struct data_point_out dim_level; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    unsigned int current_level; 
....................    int32  timer; 
....................    switch_state current_state; 
....................    switch_state previous_state; 
....................    switch_direction direction; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
.................... typedef struct timer 
.................... { 
....................    timer_type type; 
....................    int32 timeToAct; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    int32  timer; 
.................... }; 
.................... union input 
.................... { 
....................    struct switches; 
....................    struct timer; 
.................... }; 
....................  
.................... typedef struct inputs 
.................... { 
....................    enum input_type type; 
....................    union input device; 
.................... }; 
.................... ///////////////////////OUTPUTS////////////////////////////////////// 
.................... struct light 
.................... { 
....................    struct data_point_in on; 
....................    struct data_point_in off; 
....................    struct data_point_in dim_value; 
....................    unsigned int  out_value; 
....................    unsigned int  timer; 
....................    int1  needs_update; 
....................    output_state previous_state; 
.................... }; 
....................  
.................... union output 
.................... { 
....................    struct light; 
.................... }; 
....................  
.................... typedef struct outputs 
.................... { 
....................    enum output_type type; 
....................    union output device; 
.................... }; 
....................  
.................... typedef struct devices 
.................... { 
....................       unsigned int numberOfInputs; 
....................       unsigned int numberOfOutputs; 
....................       struct inputs myinputs[10]; 
....................       struct outputs myoutputs[10]; 
.................... }devicestype; 
....................  
.................... devicestype mydevices; 
.................... void dimmer_init(int dim_adr,int on_adr,int off_adr,struct inputs* input,int real_button) 
.................... { 
....................       input->type=switch_; 
02252:  MOVLB  4
02254:  MOVFF  4A5,FE9
02258:  MOVFF  4A6,FEA
0225C:  CLRF   FEF
....................       input->device.dim_level.adress=dim_adr; 
0225E:  MOVLW  02
02260:  ADDWF  xA5,W
02262:  MOVWF  FE9
02264:  MOVLW  00
02266:  ADDWFC xA6,W
02268:  MOVWF  FEA
0226A:  MOVFF  4A2,FEF
....................       input->device.on.adress=on_adr; 
0226E:  MOVLW  05
02270:  ADDWF  xA5,W
02272:  MOVWF  FE9
02274:  MOVLW  00
02276:  ADDWFC xA6,W
02278:  MOVWF  FEA
0227A:  MOVFF  4A3,FEF
....................       input->device.off.adress=off_adr; 
0227E:  MOVLW  08
02280:  ADDWF  xA5,W
02282:  MOVWF  FE9
02284:  MOVLW  00
02286:  ADDWFC xA6,W
02288:  MOVWF  FEA
0228A:  MOVFF  4A4,FEF
....................       input->device.previous_state=button_depressed; 
0228E:  MOVLW  10
02290:  ADDWF  xA5,W
02292:  MOVWF  FE9
02294:  MOVLW  00
02296:  ADDWFC xA6,W
02298:  MOVWF  FEA
0229A:  BSF    FEF.1
....................       input->device.outstate=off; 
0229C:  MOVLW  11
0229E:  ADDWF  xA5,W
022A0:  MOVWF  FE9
022A2:  MOVLW  00
022A4:  ADDWFC xA6,W
022A6:  MOVWF  FEA
022A8:  MOVLW  01
022AA:  MOVWF  FEF
....................       input->device.current_level=0; 
022AC:  MOVLW  0B
022AE:  ADDWF  xA5,W
022B0:  MOVWF  FE9
022B2:  MOVLW  00
022B4:  ADDWFC xA6,W
022B6:  MOVWF  FEA
022B8:  CLRF   FEF
....................       input->device.direction=up; 
022BA:  MOVLW  10
022BC:  ADDWF  xA5,W
022BE:  MOVWF  FE9
022C0:  MOVLW  00
022C2:  ADDWFC xA6,W
022C4:  MOVWF  FEA
022C6:  BCF    FEF.2
....................       input->device.dim_level.needs_update=0; 
022C8:  MOVLW  04
022CA:  ADDWF  xA5,W
022CC:  MOVWF  FE9
022CE:  MOVLW  00
022D0:  ADDWFC xA6,W
022D2:  MOVWF  FEA
022D4:  BCF    FEF.0
....................        input->device.on.needs_update=0; 
022D6:  MOVLW  07
022D8:  ADDWF  xA5,W
022DA:  MOVWF  FE9
022DC:  MOVLW  00
022DE:  ADDWFC xA6,W
022E0:  MOVWF  FEA
022E2:  BCF    FEF.0
....................       input->device.off.needs_update=0; 
022E4:  MOVLW  0A
022E6:  ADDWF  xA5,W
022E8:  MOVWF  FE9
022EA:  MOVLW  00
022EC:  ADDWFC xA6,W
022EE:  MOVWF  FEA
022F0:  BCF    FEF.0
....................        
....................       input->device.dim_level.value=0; 
022F2:  MOVLW  03
022F4:  ADDWF  xA5,W
022F6:  MOVWF  FE9
022F8:  MOVLW  00
022FA:  ADDWFC xA6,W
022FC:  MOVWF  FEA
022FE:  CLRF   FEF
....................       input->device.on.value=0; 
02300:  MOVLW  06
02302:  ADDWF  xA5,W
02304:  MOVWF  FE9
02306:  MOVLW  00
02308:  ADDWFC xA6,W
0230A:  MOVWF  FEA
0230C:  CLRF   FEF
....................       input->device.off.value=0; 
0230E:  MOVLW  09
02310:  ADDWF  xA5,W
02312:  MOVWF  FE9
02314:  MOVLW  00
02316:  ADDWFC xA6,W
02318:  MOVWF  FEA
0231A:  CLRF   FEF
....................        
....................       input->device.type=dimmer; 
0231C:  MOVLW  01
0231E:  ADDWF  xA5,W
02320:  MOVWF  FE9
02322:  MOVLW  00
02324:  ADDWFC xA6,W
02326:  MOVWF  FEA
02328:  MOVLW  01
0232A:  MOVWF  FEF
....................       input->device.realbutton=inputs[real_button]; 
0232C:  MOVLW  12
0232E:  ADDWF  xA5,W
02330:  MOVWF  01
02332:  MOVLW  00
02334:  ADDWFC xA6,W
02336:  MOVWF  03
02338:  MOVWF  xA9
0233A:  CLRF   03
0233C:  MOVF   xA7,W
0233E:  ADDLW  1C
02340:  MOVWF  FE9
02342:  MOVLW  00
02344:  ADDWFC 03,W
02346:  MOVWF  FEA
02348:  MOVFF  FEF,4AA
0234C:  MOVFF  4A9,FEA
02350:  MOVFF  01,FE9
02354:  MOVFF  4AA,FEF
.................... } 
02358:  MOVLB  0
0235A:  GOTO   237E (RETURN)
....................  
....................  
....................  
....................  
.................... void test() 
.................... {     mydevices.numberOfInputs=1; 
0235E:  MOVLW  01
02360:  MOVLB  1
02362:  MOVWF  xD7
....................       dimmer_init(1,2,3,&mydevices.myinputs[0],0); 
02364:  MOVLB  4
02366:  MOVWF  xA2
02368:  MOVLW  02
0236A:  MOVWF  xA3
0236C:  MOVLW  03
0236E:  MOVWF  xA4
02370:  MOVLW  01
02372:  MOVWF  xA6
02374:  MOVLW  D9
02376:  MOVWF  xA5
02378:  CLRF   xA7
0237A:  MOVLB  0
0237C:  BRA    2252
.................... } 
0237E:  GOTO   2722 (RETURN)
....................  
....................  
....................  
.................... #include "datapoints.c" 
.................... int1 array_contains(int * array,int & value) 
.................... { 
....................    int x; 
....................    for(x=0;x<8;++x) 
....................    { 
....................       if(&(array)==value) return true; 
....................       ++array; 
....................    } 
....................    return false; 
.................... } 
....................  
.................... void process_outpoint_answer(int adress,int value) 
.................... { 
....................     
.................... } 
....................  
.................... void process_inpoints(int &datapoint, int &value) 
.................... { 
....................    int x; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
....................    { 
....................       switch (mydevices.myoutputs[x].type) { 
....................  
....................     case _dimmer: 
....................            if (array_contains(mydevices.myoutputs[x].device.dim_value.adress,datapoint)) 
....................            { 
....................                mydevices.myoutputs[x].device.dim_value.value=value; 
....................                mydevices.myoutputs[x].device.dim_value.needs_update=true; 
....................            } 
....................            else if (array_contains(mydevices.myoutputs[x].device.on.adress,datapoint)) 
....................            { 
....................                mydevices.myoutputs[x].device.on.value=value; 
....................                mydevices.myoutputs[x].device.on.needs_update=true; 
....................            } 
....................            else if (array_contains(mydevices.myoutputs[x].device.off.adress,datapoint)) 
....................            { 
....................                mydevices.myoutputs[x].device.off.value=value; 
....................                mydevices.myoutputs[x].device.off.needs_update=true; 
....................            } 
....................            break; 
....................  
....................     case _on_off: 
....................  
....................            break; 
....................     case shutter: 
....................  
....................            break; 
....................     default: 
....................  
....................             break; } 
....................  
....................    } 
.................... } 
....................  
.................... void process_outpoints() 
.................... { 
....................     int x; 
....................    for(x=0;x<mydevices.numberOfInputs;++x) 
....................    { 
....................       switch (mydevices.myinputs[x].type) { 
....................     case switch_: 
....................                if(mydevices.myinputs[x].device.dim_level.needs_update) 
....................                { 
....................                   process_outpoint_answer(mydevices.myinputs[x].device.dim_level.adress,mydevices.myinputs[x].device.dim_level.value); 
....................                   mydevices.myinputs[x].device.dim_level.needs_update=false; 
....................                   mydevices.myinputs[x].device.dim_level.value=0; 
....................                } 
....................            if(mydevices.myinputs[x].device.on.needs_update) 
....................                { 
....................                   process_outpoint_answer(mydevices.myinputs[x].device.on.adress,mydevices.myinputs[x].device.on.value); 
....................                   mydevices.myinputs[x].device.on.needs_update=false; 
....................                   mydevices.myinputs[x].device.on.value=0; 
....................                } 
....................                if(mydevices.myinputs[x].device.off.needs_update) 
....................                { 
....................                   process_outpoint_answer(mydevices.myinputs[x].device.off.adress,mydevices.myinputs[x].device.off.value); 
....................                   mydevices.myinputs[x].device.off.needs_update=false; 
....................                   mydevices.myinputs[x].device.off.value=0; 
....................                } 
....................                break; 
....................     case timer: 
....................  
....................            break; 
....................     default: 
....................  
....................             break; } 
....................  
....................    } 
.................... } 
....................  
.................... ////////////////////////////////////////// 
.................... //apagar 
.................... int32 clock; 
....................  
.................... //dimmer constants 
.................... static int TimeBase=0; 
.................... static int32 reg=39; 
.................... //dimmer end 
....................  
.................... struct switches msw; 
.................... #include "switch_functions.c" 
.................... void onOffHelper(struct switches *sw) 
.................... { 
....................    if(sw->dim_level.value!=0)  
....................    { 
....................        sw->on.value=1; 
....................        sw->off.value=0; 
....................    } 
....................    else 
....................    { 
....................       sw->on.value=0; 
....................       sw->off.value=1; 
....................    } 
.................... } 
.................... void process_onOff(struct switches *sw) 
.................... { 
....................    int last_dim=sw->dim_level.value; 
....................    int last_on=sw->on.value; 
....................    int last_off=sw->off.value; 
....................    if(sw->current_state==button_pressed && sw-> previous_state == button_depressed) 
....................    {    
....................       if(sw->dim_level.value==0) 
....................       {   
....................          sw->dim_level.value=127; 
....................       } 
....................       else  
....................       { 
....................          sw->dim_level.value=0; 
....................       } 
....................       sw->previous_state=button_pressed; 
....................    } 
....................    else if(sw->current_state==button_depressed) 
....................       sw-> previous_state = button_depressed; 
....................    onOffHelper(sw); 
....................    if (last_dim!=sw->dim_level.value) sw->dim_level.needs_update=true; 
....................    if (last_on!=sw->on.value) sw->on.needs_update=true; 
....................    if (last_off!=sw->off.value) sw->off.needs_update=true; 
.................... } 
.................... void process_buttons(struct switches *sw) 
.................... { 
....................    int last_dim=sw->dim_level.value; 
....................    int last_on=sw->on.value; 
....................    int last_off=sw->off.value;   
....................    if(sw->current_state==button_pressed)  
....................    { 
....................       sw->dim_level.value=127; 
....................    } 
....................    else   
....................    { 
....................       sw->dim_level.value=0; 
....................    } 
....................    onOffHelper(sw); 
....................    if (last_dim!=sw->dim_level.value) sw->dim_level.needs_update=true; 
....................    if (last_on!=sw->on.value) sw->on.needs_update=true; 
....................    if (last_off!=sw->off.value) sw->off.needs_update=true; 
.................... } 
.................... void process_dimmers(struct switches *sw) 
.................... { 
*
003F0:  MOVLW  0A
003F2:  MOVLB  4
003F4:  ADDWF  xFA,W
003F6:  MOVWF  FE9
003F8:  MOVLW  00
003FA:  ADDWFC xFB,W
003FC:  MOVWF  FEA
003FE:  MOVFF  FEF,4FC
00402:  MOVLW  02
00404:  ADDWF  xFA,W
00406:  MOVWF  FE9
00408:  MOVLW  00
0040A:  ADDWFC xFB,W
0040C:  MOVWF  FEA
0040E:  MOVFF  FEF,4FD
....................    int last_level=sw->current_level; 
....................    int last_dim=sw->dim_level.value; 
....................    if(sw->current_state==button_pressed)//se o botao esta premido 
00412:  MOVLW  0F
00414:  ADDWF  xFA,W
00416:  MOVWF  FE9
00418:  MOVLW  00
0041A:  ADDWFC xFB,W
0041C:  MOVWF  FEA
0041E:  MOVLW  00
00420:  BTFSC  FEF.0
00422:  MOVLW  01
00424:  ANDLW  01
00426:  BTFSS  FD8.2
00428:  BRA    0660
....................    { 
....................      // printf("DIF %LU",clock - sw->timer); 
....................       sw-> previous_state = button_pressed; 
0042A:  MOVLW  0F
0042C:  ADDWF  xFA,W
0042E:  MOVWF  FE9
00430:  MOVLW  00
00432:  ADDWFC xFB,W
00434:  MOVWF  FEA
00436:  BCF    FEF.1
....................       if ((clock - sw->timer > reg || sw->outstate == dimming) && sw->outstate!=maxed) 
00438:  MOVLW  0B
0043A:  ADDWF  xFA,W
0043C:  MOVWF  FE9
0043E:  MOVLW  00
00440:  ADDWFC xFB,W
00442:  MOVWF  FEA
00444:  MOVFF  FEF,00
00448:  MOVFF  FEC,01
0044C:  MOVFF  FEC,02
00450:  MOVFF  FEC,03
00454:  MOVF   00,W
00456:  MOVLB  3
00458:  SUBWF  xF5,W
0045A:  MOVLB  4
0045C:  MOVWF  xFE
0045E:  MOVF   01,W
00460:  MOVLB  3
00462:  SUBWFB xF6,W
00464:  MOVLB  4
00466:  MOVWF  xFF
00468:  MOVF   02,W
0046A:  MOVLB  3
0046C:  SUBWFB xF7,W
0046E:  MOVLB  5
00470:  MOVWF  x00
00472:  MOVF   03,W
00474:  MOVLB  3
00476:  SUBWFB xF8,W
00478:  MOVLB  5
0047A:  MOVWF  x01
0047C:  MOVLB  3
0047E:  MOVF   xFD,W
00480:  MOVLB  5
00482:  SUBWF  x01,W
00484:  BNC   04BA
00486:  BNZ   04D0
00488:  MOVLB  3
0048A:  MOVF   xFC,W
0048C:  MOVLB  5
0048E:  SUBWF  x00,W
00490:  BNC   04BA
00492:  BNZ   04D0
00494:  MOVLB  3
00496:  MOVF   xFB,W
00498:  MOVLB  4
0049A:  SUBWF  xFF,W
0049C:  BTFSC  FD8.0
0049E:  BRA    04A4
004A0:  MOVLB  5
004A2:  BRA    04BA
004A4:  BTFSC  FD8.2
004A6:  BRA    04AC
004A8:  MOVLB  5
004AA:  BRA    04D0
004AC:  MOVF   xFE,W
004AE:  MOVLB  3
004B0:  SUBWF  xFA,W
004B2:  BTFSC  FD8.0
004B4:  BRA    04BA
004B6:  MOVLB  5
004B8:  BRA    04D0
004BA:  MOVLW  10
004BC:  MOVLB  4
004BE:  ADDWF  xFA,W
004C0:  MOVWF  FE9
004C2:  MOVLW  00
004C4:  ADDWFC xFB,W
004C6:  MOVWF  FEA
004C8:  MOVF   FEF,W
004CA:  SUBLW  02
004CC:  BTFSS  FD8.2
004CE:  BRA    065E
004D0:  MOVLW  10
004D2:  MOVLB  4
004D4:  ADDWF  xFA,W
004D6:  MOVWF  FE9
004D8:  MOVLW  00
004DA:  ADDWFC xFB,W
004DC:  MOVWF  FEA
004DE:  MOVF   FEF,W
004E0:  SUBLW  04
004E2:  BTFSC  FD8.2
004E4:  BRA    065E
....................       {  
....................          if(sw->outstate==off) 
004E6:  MOVLW  10
004E8:  ADDWF  xFA,W
004EA:  MOVWF  FE9
004EC:  MOVLW  00
004EE:  ADDWFC xFB,W
004F0:  MOVWF  FEA
004F2:  DECFSZ FEF,W
004F4:  BRA    0548
....................          { 
....................             printf("MAXED"); 
004F6:  MOVLW  D2
004F8:  MOVWF  FF6
004FA:  MOVLW  02
004FC:  MOVWF  FF7
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  MOVLB  0
00504:  BRA    03C6
....................             sw->outstate=maxed; 
00506:  MOVLW  10
00508:  MOVLB  4
0050A:  ADDWF  xFA,W
0050C:  MOVWF  FE9
0050E:  MOVLW  00
00510:  ADDWFC xFB,W
00512:  MOVWF  FEA
00514:  MOVLW  04
00516:  MOVWF  FEF
....................             sw->on.value=1; 
00518:  MOVLW  05
0051A:  ADDWF  xFA,W
0051C:  MOVWF  FE9
0051E:  MOVLW  00
00520:  ADDWFC xFB,W
00522:  MOVWF  FEA
00524:  MOVLW  01
00526:  MOVWF  FEF
....................             sw->current_level = 127; 
00528:  MOVLW  0A
0052A:  ADDWF  xFA,W
0052C:  MOVWF  FE9
0052E:  MOVLW  00
00530:  ADDWFC xFB,W
00532:  MOVWF  FEA
00534:  MOVLW  7F
00536:  MOVWF  FEF
....................             sw->on.needs_update=1; 
00538:  MOVLW  06
0053A:  ADDWF  xFA,W
0053C:  MOVWF  FE9
0053E:  MOVLW  00
00540:  ADDWFC xFB,W
00542:  MOVWF  FEA
00544:  BSF    FEF.0
....................          } 
....................         else 
00546:  BRA    065C
....................         { 
....................          sw->outstate = dimming; 
00548:  MOVLW  10
0054A:  ADDWF  xFA,W
0054C:  MOVWF  FE9
0054E:  MOVLW  00
00550:  ADDWFC xFB,W
00552:  MOVWF  FEA
00554:  MOVLW  02
00556:  MOVWF  FEF
....................          if (clock - sw->timer > TimeBase) //regula 
00558:  MOVLW  0B
0055A:  ADDWF  xFA,W
0055C:  MOVWF  FE9
0055E:  MOVLW  00
00560:  ADDWFC xFB,W
00562:  MOVWF  FEA
00564:  MOVFF  FEF,00
00568:  MOVFF  FEC,01
0056C:  MOVFF  FEC,02
00570:  MOVFF  FEC,03
00574:  MOVF   00,W
00576:  MOVLB  3
00578:  SUBWF  xF5,W
0057A:  MOVLB  4
0057C:  MOVWF  xFE
0057E:  MOVF   01,W
00580:  MOVLB  3
00582:  SUBWFB xF6,W
00584:  MOVLB  4
00586:  MOVWF  xFF
00588:  MOVF   02,W
0058A:  MOVLB  3
0058C:  SUBWFB xF7,W
0058E:  MOVLB  5
00590:  MOVWF  x00
00592:  MOVF   03,W
00594:  MOVLB  3
00596:  SUBWFB xF8,W
00598:  MOVLB  5
0059A:  MOVWF  x01
0059C:  MOVF   x01,F
0059E:  BNZ   05BA
005A0:  MOVF   x00,F
005A2:  BNZ   05BA
005A4:  MOVLB  4
005A6:  MOVF   xFF,F
005A8:  BTFSC  FD8.2
005AA:  BRA    05B0
005AC:  MOVLB  5
005AE:  BRA    05BA
005B0:  MOVF   xFE,W
005B2:  MOVLB  3
005B4:  SUBWF  xF9,W
005B6:  BC    063E
005B8:  MOVLB  5
....................          { 
....................             if (sw->direction == up) //para cima 
005BA:  MOVLW  0F
005BC:  MOVLB  4
005BE:  ADDWF  xFA,W
005C0:  MOVWF  FE9
005C2:  MOVLW  00
005C4:  ADDWFC xFB,W
005C6:  MOVWF  FEA
005C8:  MOVLW  00
005CA:  BTFSC  FEF.2
005CC:  MOVLW  01
005CE:  ANDLW  01
005D0:  BNZ   0602
....................             { 
....................                ++sw->current_level; 
005D2:  MOVLW  0A
005D4:  ADDWF  xFA,W
005D6:  MOVWF  FE9
005D8:  MOVLW  00
005DA:  ADDWFC xFB,W
005DC:  MOVWF  FEA
005DE:  INCF   FEF,F
....................                if (sw->current_level == 127) sw->direction = down; 
005E0:  MOVLW  0A
005E2:  ADDWF  xFA,W
005E4:  MOVWF  FE9
005E6:  MOVLW  00
005E8:  ADDWFC xFB,W
005EA:  MOVWF  FEA
005EC:  MOVF   FEF,W
005EE:  SUBLW  7F
005F0:  BNZ   0600
005F2:  MOVLW  0F
005F4:  ADDWF  xFA,W
005F6:  MOVWF  FE9
005F8:  MOVLW  00
005FA:  ADDWFC xFB,W
005FC:  MOVWF  FEA
005FE:  BSF    FEF.2
....................             } 
....................             else//para baixo 
00600:  BRA    063E
....................             { 
....................                --sw->current_level; 
00602:  MOVLW  0A
00604:  ADDWF  xFA,W
00606:  MOVWF  FE9
00608:  MOVLW  00
0060A:  ADDWFC xFB,W
0060C:  MOVWF  FEA
0060E:  DECF   FEF,F
....................                if (sw->current_level == 0)  
00610:  MOVLW  0A
00612:  ADDWF  xFA,W
00614:  MOVWF  FE9
00616:  MOVLW  00
00618:  ADDWFC xFB,W
0061A:  MOVWF  FEA
0061C:  MOVF   FEF,F
0061E:  BNZ   063E
....................                {   
....................                   sw->direction = up; 
00620:  MOVLW  0F
00622:  ADDWF  xFA,W
00624:  MOVWF  FE9
00626:  MOVLW  00
00628:  ADDWFC xFB,W
0062A:  MOVWF  FEA
0062C:  BCF    FEF.2
....................                   sw->off.value=1; 
0062E:  MOVLW  08
00630:  ADDWF  xFA,W
00632:  MOVWF  FE9
00634:  MOVLW  00
00636:  ADDWFC xFB,W
00638:  MOVWF  FEA
0063A:  MOVLW  01
0063C:  MOVWF  FEF
....................                } 
....................             } 
....................          } 
....................          sw->timer = clock; 
0063E:  MOVLW  0B
00640:  MOVLB  4
00642:  ADDWF  xFA,W
00644:  MOVWF  FE9
00646:  MOVLW  00
00648:  ADDWFC xFB,W
0064A:  MOVWF  FEA
0064C:  MOVFF  3F5,FEF
00650:  MOVFF  3F6,FEC
00654:  MOVFF  3F7,FEC
00658:  MOVFF  3F8,FEC
....................       } 
....................       } 
....................       else 
0065C:  BRA    065E
....................       { 
....................          //sw - > timer = clock; 
....................       } 
....................    } 
....................    else//se o botao nao esta premido 
0065E:  BRA    07C0
....................    { 
....................       if (sw->previous_state == button_pressed) //se o botao acabou de ser deslargado 
00660:  MOVLW  0F
00662:  ADDWF  xFA,W
00664:  MOVWF  FE9
00666:  MOVLW  00
00668:  ADDWFC xFB,W
0066A:  MOVWF  FEA
0066C:  MOVLW  00
0066E:  BTFSC  FEF.1
00670:  MOVLW  01
00672:  ANDLW  01
00674:  BTFSS  FD8.2
00676:  BRA    07A4
....................       { 
....................          sw->previous_state = button_depressed; 
00678:  MOVLW  0F
0067A:  ADDWF  xFA,W
0067C:  MOVWF  FE9
0067E:  MOVLW  00
00680:  ADDWFC xFB,W
00682:  MOVWF  FEA
00684:  BSF    FEF.1
....................          if (sw->outstate == dimming) //se esteve a regular 
00686:  MOVLW  10
00688:  ADDWF  xFA,W
0068A:  MOVWF  FE9
0068C:  MOVLW  00
0068E:  ADDWFC xFB,W
00690:  MOVWF  FEA
00692:  MOVF   FEF,W
00694:  SUBLW  02
00696:  BNZ   06DC
....................          { 
....................             sw-> outstate = on; 
00698:  MOVLW  10
0069A:  ADDWF  xFA,W
0069C:  MOVWF  FE9
0069E:  MOVLW  00
006A0:  ADDWFC xFB,W
006A2:  MOVWF  FEA
006A4:  CLRF   FEF
....................             if (sw->direction == up) sw->direction = down; //inverte direccao 
006A6:  MOVLW  0F
006A8:  ADDWF  xFA,W
006AA:  MOVWF  FE9
006AC:  MOVLW  00
006AE:  ADDWFC xFB,W
006B0:  MOVWF  FEA
006B2:  MOVLW  00
006B4:  BTFSC  FEF.2
006B6:  MOVLW  01
006B8:  ANDLW  01
006BA:  BNZ   06CC
006BC:  MOVLW  0F
006BE:  ADDWF  xFA,W
006C0:  MOVWF  FE9
006C2:  MOVLW  00
006C4:  ADDWFC xFB,W
006C6:  MOVWF  FEA
006C8:  BSF    FEF.2
....................             else sw->direction = up; 
006CA:  BRA    06DA
006CC:  MOVLW  0F
006CE:  ADDWF  xFA,W
006D0:  MOVWF  FE9
006D2:  MOVLW  00
006D4:  ADDWFC xFB,W
006D6:  MOVWF  FEA
006D8:  BCF    FEF.2
....................          } 
....................          else//se nao esteve a regular 
006DA:  BRA    07A4
....................          { 
....................             if (sw->outstate == off) //se estava desligada 
006DC:  MOVLW  10
006DE:  ADDWF  xFA,W
006E0:  MOVWF  FE9
006E2:  MOVLW  00
006E4:  ADDWFC xFB,W
006E6:  MOVWF  FEA
006E8:  DECFSZ FEF,W
006EA:  BRA    0728
....................             { 
....................               // printf("on"); 
....................                sw->outstate=on; 
006EC:  MOVLW  10
006EE:  ADDWF  xFA,W
006F0:  MOVWF  FE9
006F2:  MOVLW  00
006F4:  ADDWFC xFB,W
006F6:  MOVWF  FEA
006F8:  CLRF   FEF
....................                sw->on.value=1; 
006FA:  MOVLW  05
006FC:  ADDWF  xFA,W
006FE:  MOVWF  FE9
00700:  MOVLW  00
00702:  ADDWFC xFB,W
00704:  MOVWF  FEA
00706:  MOVLW  01
00708:  MOVWF  FEF
....................                sw->direction = down; 
0070A:  MOVLW  0F
0070C:  ADDWF  xFA,W
0070E:  MOVWF  FE9
00710:  MOVLW  00
00712:  ADDWFC xFB,W
00714:  MOVWF  FEA
00716:  BSF    FEF.2
....................                sw->on.needs_update=true; 
00718:  MOVLW  06
0071A:  ADDWF  xFA,W
0071C:  MOVWF  FE9
0071E:  MOVLW  00
00720:  ADDWFC xFB,W
00722:  MOVWF  FEA
00724:  BSF    FEF.0
....................             } 
....................             else if (sw->outstate == on) 
00726:  BRA    07A4
00728:  MOVLW  10
0072A:  ADDWF  xFA,W
0072C:  MOVWF  FE9
0072E:  MOVLW  00
00730:  ADDWFC xFB,W
00732:  MOVWF  FEA
00734:  MOVF   FEF,F
00736:  BNZ   0776
....................             { 
....................               // printf("off"); 
....................                //sw->current_level = 0; //senao desliga 
....................                sw->outstate=off; 
00738:  MOVLW  10
0073A:  ADDWF  xFA,W
0073C:  MOVWF  FE9
0073E:  MOVLW  00
00740:  ADDWFC xFB,W
00742:  MOVWF  FEA
00744:  MOVLW  01
00746:  MOVWF  FEF
....................                sw->off.value=1; 
00748:  MOVLW  08
0074A:  ADDWF  xFA,W
0074C:  MOVWF  FE9
0074E:  MOVLW  00
00750:  ADDWFC xFB,W
00752:  MOVWF  FEA
00754:  MOVLW  01
00756:  MOVWF  FEF
....................                sw->direction = up; 
00758:  MOVLW  0F
0075A:  ADDWF  xFA,W
0075C:  MOVWF  FE9
0075E:  MOVLW  00
00760:  ADDWFC xFB,W
00762:  MOVWF  FEA
00764:  BCF    FEF.2
....................                sw->off.needs_update=true; 
00766:  MOVLW  09
00768:  ADDWF  xFA,W
0076A:  MOVWF  FE9
0076C:  MOVLW  00
0076E:  ADDWFC xFB,W
00770:  MOVWF  FEA
00772:  BSF    FEF.0
....................             } 
....................             else if(sw->outstate == maxed) 
00774:  BRA    07A4
00776:  MOVLW  10
00778:  ADDWF  xFA,W
0077A:  MOVWF  FE9
0077C:  MOVLW  00
0077E:  ADDWFC xFB,W
00780:  MOVWF  FEA
00782:  MOVF   FEF,W
00784:  SUBLW  04
00786:  BNZ   07A4
....................             { 
....................                sw->outstate=on; 
00788:  MOVLW  10
0078A:  ADDWF  xFA,W
0078C:  MOVWF  FE9
0078E:  MOVLW  00
00790:  ADDWFC xFB,W
00792:  MOVWF  FEA
00794:  CLRF   FEF
....................                sw->direction = down; 
00796:  MOVLW  0F
00798:  ADDWF  xFA,W
0079A:  MOVWF  FE9
0079C:  MOVLW  00
0079E:  ADDWFC xFB,W
007A0:  MOVWF  FEA
007A2:  BSF    FEF.2
....................             } 
....................          } 
....................       } 
....................       sw->timer = clock; 
007A4:  MOVLW  0B
007A6:  ADDWF  xFA,W
007A8:  MOVWF  FE9
007AA:  MOVLW  00
007AC:  ADDWFC xFB,W
007AE:  MOVWF  FEA
007B0:  MOVFF  3F5,FEF
007B4:  MOVFF  3F6,FEC
007B8:  MOVFF  3F7,FEC
007BC:  MOVFF  3F8,FEC
....................    } 
....................  //  onOffHelper(sw); 
....................    if (last_level!=sw->current_level)  
007C0:  MOVLW  0A
007C2:  ADDWF  xFA,W
007C4:  MOVWF  FE9
007C6:  MOVLW  00
007C8:  ADDWFC xFB,W
007CA:  MOVWF  FEA
007CC:  MOVF   FEF,W
007CE:  SUBWF  xFC,W
007D0:  BZ    080C
....................    { 
....................       sw->dim_level.value=sw->current_level; 
007D2:  MOVLW  02
007D4:  ADDWF  xFA,W
007D6:  MOVWF  01
007D8:  MOVLW  00
007DA:  ADDWFC xFB,W
007DC:  MOVWF  03
007DE:  MOVLW  0A
007E0:  ADDWF  xFA,W
007E2:  MOVWF  FE9
007E4:  MOVLW  00
007E6:  ADDWFC xFB,W
007E8:  MOVWF  FEA
007EA:  MOVFF  FEF,500
007EE:  MOVLB  5
007F0:  MOVFF  03,FEA
007F4:  MOVFF  01,FE9
007F8:  MOVFF  500,FEF
....................       sw->dim_level.needs_update=true; 
007FC:  MOVLW  03
007FE:  MOVLB  4
00800:  ADDWF  xFA,W
00802:  MOVWF  FE9
00804:  MOVLW  00
00806:  ADDWFC xFB,W
00808:  MOVWF  FEA
0080A:  BSF    FEF.0
....................    } 
.................... } 
0080C:  MOVLB  0
0080E:  GOTO   0990 (RETURN)
....................  
.................... void read_inputs() 
.................... { 
....................   int x; 
....................    for(x=0;x<mydevices.numberOfInputs;++x) 
00812:  MOVLB  4
00814:  CLRF   xF7
00816:  MOVLB  1
00818:  MOVF   xD7,W
0081A:  MOVLB  4
0081C:  SUBWF  xF7,W
0081E:  BTFSC  FD8.0
00820:  BRA    0996
....................    { 
....................       switch (mydevices.myinputs[x].type) { 
00822:  CLRF   xF9
00824:  MOVFF  4F7,4F8
00828:  CLRF   xFB
0082A:  MOVLW  13
0082C:  MOVWF  xFA
0082E:  MOVLB  0
00830:  RCALL  02D8
00832:  MOVFF  02,03
00836:  MOVF   01,W
00838:  ADDLW  D9
0083A:  MOVWF  FE9
0083C:  MOVLW  01
0083E:  ADDWFC 02,W
00840:  MOVWF  FEA
00842:  MOVF   FEF,W
00844:  BZ    084E
00846:  XORLW  01
00848:  BTFSC  FD8.2
0084A:  BRA    098C
0084C:  BRA    098E
....................     case switch_: 
....................            // printf("aki"); 
....................             if (input (mydevices.myinputs[x].device.realbutton)) mydevices.myinputs[x].device.current_state = button_depressed; 
0084E:  MOVLB  4
00850:  CLRF   xF9
00852:  MOVFF  4F7,4F8
00856:  CLRF   xFB
00858:  MOVLW  13
0085A:  MOVWF  xFA
0085C:  MOVLB  0
0085E:  RCALL  02D8
00860:  MOVF   01,W
00862:  ADDLW  02
00864:  MOVLB  4
00866:  MOVWF  xF8
00868:  MOVLW  00
0086A:  ADDWFC 02,W
0086C:  MOVWF  xF9
0086E:  MOVLW  01
00870:  ADDWF  xF8,F
00872:  MOVLW  00
00874:  ADDWFC xF9,F
00876:  MOVLW  11
00878:  ADDWF  xF8,W
0087A:  MOVWF  01
0087C:  MOVLW  00
0087E:  ADDWFC xF9,W
00880:  MOVWF  03
00882:  MOVF   01,W
00884:  ADDLW  D7
00886:  MOVWF  FE9
00888:  MOVLW  01
0088A:  ADDWFC 03,W
0088C:  MOVWF  FEA
0088E:  MOVFF  FEF,4F8
00892:  MOVFF  4F8,4F9
00896:  MOVLW  01
00898:  MOVWF  xFA
0089A:  MOVLW  0F
0089C:  MOVWF  xFC
0089E:  MOVLW  92
008A0:  MOVWF  xFB
008A2:  MOVLB  0
008A4:  BRA    02FA
008A6:  MOVFF  4F8,4F9
008AA:  MOVLW  0F
008AC:  MOVLB  4
008AE:  MOVWF  xFB
008B0:  MOVLW  80
008B2:  MOVWF  xFA
008B4:  MOVLB  0
008B6:  BRA    033E
008B8:  BTFSS  01.0
008BA:  BRA    0900
008BC:  MOVLB  4
008BE:  CLRF   xF9
008C0:  MOVFF  4F7,4F8
008C4:  CLRF   xFB
008C6:  MOVLW  13
008C8:  MOVWF  xFA
008CA:  MOVLB  0
008CC:  RCALL  02D8
008CE:  MOVF   01,W
008D0:  ADDLW  02
008D2:  MOVLB  4
008D4:  MOVWF  xF8
008D6:  MOVLW  00
008D8:  ADDWFC 02,W
008DA:  MOVWF  xF9
008DC:  MOVLW  01
008DE:  ADDWF  xF8,F
008E0:  MOVLW  00
008E2:  ADDWFC xF9,F
008E4:  MOVLW  0F
008E6:  ADDWF  xF8,W
008E8:  MOVWF  01
008EA:  MOVLW  00
008EC:  ADDWFC xF9,W
008EE:  MOVWF  03
008F0:  MOVF   01,W
008F2:  ADDLW  D7
008F4:  MOVWF  FE9
008F6:  MOVLW  01
008F8:  ADDWFC 03,W
008FA:  MOVWF  FEA
008FC:  BSF    FEF.0
....................             else mydevices.myinputs[x].device.current_state = button_pressed; 
008FE:  BRA    0942
00900:  MOVLB  4
00902:  CLRF   xF9
00904:  MOVFF  4F7,4F8
00908:  CLRF   xFB
0090A:  MOVLW  13
0090C:  MOVWF  xFA
0090E:  MOVLB  0
00910:  RCALL  02D8
00912:  MOVF   01,W
00914:  ADDLW  02
00916:  MOVLB  4
00918:  MOVWF  xF8
0091A:  MOVLW  00
0091C:  ADDWFC 02,W
0091E:  MOVWF  xF9
00920:  MOVLW  01
00922:  ADDWF  xF8,F
00924:  MOVLW  00
00926:  ADDWFC xF9,F
00928:  MOVLW  0F
0092A:  ADDWF  xF8,W
0092C:  MOVWF  01
0092E:  MOVLW  00
00930:  ADDWFC xF9,W
00932:  MOVWF  03
00934:  MOVF   01,W
00936:  ADDLW  D7
00938:  MOVWF  FE9
0093A:  MOVLW  01
0093C:  ADDWFC 03,W
0093E:  MOVWF  FEA
00940:  BCF    FEF.0
....................             process_dimmers(&mydevices.myinputs[x].device); 
00942:  CLRF   xF9
00944:  MOVFF  4F7,4F8
00948:  CLRF   xFB
0094A:  MOVLW  13
0094C:  MOVWF  xFA
0094E:  MOVLB  0
00950:  RCALL  02D8
00952:  MOVF   01,W
00954:  ADDLW  02
00956:  MOVLB  4
00958:  MOVWF  xF8
0095A:  MOVLW  00
0095C:  ADDWFC 02,W
0095E:  MOVWF  xF9
00960:  MOVLW  01
00962:  ADDWF  xF8,W
00964:  MOVWF  01
00966:  MOVLW  00
00968:  ADDWFC xF9,W
0096A:  MOVWF  03
0096C:  MOVF   01,W
0096E:  ADDLW  D7
00970:  MOVWF  01
00972:  MOVLW  01
00974:  ADDWFC 03,F
00976:  MOVFF  01,4F8
0097A:  MOVFF  03,4F9
0097E:  MOVFF  03,4FB
00982:  MOVFF  01,4FA
00986:  MOVLB  0
00988:  BRA    03F0
....................             break; 
0098A:  BRA    0990
....................     case timer: 
....................  
....................            break; 
0098C:  BRA    0990
....................     default: 
....................  
....................             break;  
0098E:  BRA    0990
....................             } 
....................  
....................    } 
00990:  MOVLB  4
00992:  INCF   xF7,F
00994:  BRA    0816
.................... } 
00996:  MOVLB  0
00998:  GOTO   09B6 (RETURN)
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... int1 flag=0;//mains not detected flag 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  
.................... { 
....................    ++clock; 
0099C:  MOVLW  01
0099E:  MOVLB  3
009A0:  ADDWF  xF5,F
009A2:  BTFSC  FD8.0
009A4:  INCF   xF6,F
009A6:  BTFSC  FD8.2
009A8:  INCF   xF7,F
009AA:  BTFSC  FD8.2
009AC:  INCF   xF8,F
....................    if (bit_test (clock, 1)) read_inputs(); 
009AE:  BTFSS  xF5.1
009B0:  BRA    09B8
009B2:  MOVLB  0
009B4:  BRA    0812
009B6:  MOVLB  3
.................... } 
....................  
009B8:  BCF    FF2.2
009BA:  MOVLB  0
009BC:  GOTO   0110
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................    flag = 1; 
009C0:  BSF    xB1.4
.................... } 
....................  
009C2:  BCF    F9E.0
009C4:  GOTO   0110
.................... #int_EXT 
.................... void  EXT_isr(void)  
.................... { 
....................  
....................   // set_timer1 (0) ; 
....................          portc=0xFF; 
009C8:  MOVLW  FF
009CA:  MOVWF  F82
....................          portd=0xFF; 
009CC:  MOVWF  F83
....................          if (organizado)  
009CE:  BTFSS  xB1.2
009D0:  BRA    09F4
....................          { 
....................             organizado=0; 
009D2:  BCF    xB1.2
....................             if (actmat)  
009D4:  BTFSS  xB1.3
009D6:  BRA    09E8
....................             { 
....................                actmat=0; 
009D8:  BCF    xB1.3
....................                pointer=delays1; 
009DA:  MOVLW  01
009DC:  MOVLB  1
009DE:  MOVWF  x3C
009E0:  MOVLW  4F
009E2:  MOVWF  x3B
....................             } 
....................             else 
009E4:  BRA    09F4
009E6:  MOVLB  0
....................             { 
....................                actmat=1; 
009E8:  BSF    xB1.3
....................                pointer=delays2; 
009EA:  MOVLW  01
009EC:  MOVLB  1
009EE:  MOVWF  x3C
009F0:  MOVLW  93
009F2:  MOVWF  x3B
....................             } 
....................          } 
....................          vez=0; 
009F4:  MOVLB  1
009F6:  CLRF   x3D
....................          CCP_1=matrizluz[fpointer(0,0)]; 
009F8:  MOVLB  4
009FA:  CLRF   xF9
009FC:  CLRF   xFA
*
00A68:  MOVFF  02,4F8
00A6C:  MOVFF  01,4F7
00A70:  BCF    FD8.0
00A72:  RLCF   01,W
00A74:  MOVWF  02
00A76:  RLCF   xF8,W
00A78:  MOVWF  03
00A7A:  MOVF   02,W
00A7C:  MOVLB  0
00A7E:  CALL   019A
00A82:  TBLRD*+
00A84:  MOVFF  FF5,03
00A88:  MOVWF  FBE
00A8A:  MOVFF  03,FBF
....................          mnumluzes=fpointer(N_LUZES,0); 
00A8E:  MOVLW  10
00A90:  MOVLB  4
00A92:  MOVWF  xF9
00A94:  CLRF   xFA
*
00B00:  MOVFF  01,13E
....................          set_timer1(0); 
00B04:  CLRF   FCF
00B06:  CLRF   FCE
.................... } 
....................  
00B08:  BCF    FF2.1
00B0A:  MOVLB  0
00B0C:  GOTO   0110
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
.................... } 
....................  
00B10:  BCF    F9E.5
00B12:  GOTO   0110
.................... #int_TBE 
.................... void  TBE_isr(void)  
.................... { 
.................... } 
....................  
00B16:  BCF    F9E.4
00B18:  GOTO   0110
.................... #int_BUSCOL 
.................... void  BUSCOL_isr(void)  
.................... { 
.................... } 
....................  
00B1C:  BCF    FA1.3
00B1E:  GOTO   0110
.................... #int_OSCF 
.................... void  OSCF_isr(void)  
.................... { 
.................... } 
....................  
00B22:  BCF    FA1.7
00B24:  GOTO   0110
.................... #int_canrx0 
.................... void canrx0_int ( )  
.................... { 
....................    canReceive (); 
*
010FE:  RCALL  0D20
....................    // TODO: add CAN recieve code here 
.................... } 
....................  
01100:  BCF    FA4.0
01102:  GOTO   0110
.................... #int_canrx1 
.................... void canrx1_int ( )  
.................... { 
....................    canReceive (); 
01106:  RCALL  0D20
....................    // TODO: add CAN recieve code here 
.................... } 
....................  
01108:  BCF    FA4.1
0110A:  GOTO   0110
.................... #int_cantx0 
.................... void cantx0_int ( )  
.................... { 
....................    canTransmit (); 
*
01536:  RCALL  1314
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
01538:  BCF    FA4.2
0153A:  GOTO   0110
.................... #int_cantx1 
.................... void cantx1_int ( )  
.................... { 
....................    canTransmit (); 
0153E:  RCALL  1314
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
01540:  BCF    FA4.3
01542:  GOTO   0110
.................... #int_cantx2 
.................... void cantx2_int ( )  
.................... { 
....................    canTransmit (); 
01546:  RCALL  1314
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
01548:  BCF    FA4.4
0154A:  GOTO   0110
.................... #int_canirx 
.................... void canirx_int ( )  
.................... { 
....................    // TODO: add CAN IRX handling code here 
.................... } 
....................  
0154E:  BCF    FA4.7
01550:  GOTO   0110
.................... #int_canerr 
.................... void canerr_int ( )  
.................... { 
....................    // TODO: add CAN error handling code here 
.................... } 
....................  
01554:  BCF    FA4.5
01556:  GOTO   0110
.................... #int_CCP1 
.................... void CCP1_isr(void)  
.................... { 
....................    if(mnumluzes!=0) 
0155A:  MOVLB  1
0155C:  MOVF   x3E,F
0155E:  BTFSC  FD8.2
01560:  BRA    168A
....................    { 
....................    output_low (LED) ; 
01562:  BCF    F96.2
01564:  BCF    F8D.2
....................       int16 auxccp=fpointer(vez,1); 
01566:  MOVFF  13D,4F9
0156A:  MOVLW  01
0156C:  MOVLB  4
0156E:  MOVWF  xFA
*
015DA:  MOVFF  02,4F8
015DE:  MOVFF  01,4F7
....................       portc=(portc & MAKE8(auxccp,1)); 
015E2:  MOVF   xF8,W
015E4:  ANDWF  F82,F
....................       portd=(portd & MAKE8(auxccp,0)); 
015E6:  MOVF   xF7,W
015E8:  ANDWF  F83,F
....................       ++vez; 
015EA:  MOVLB  1
015EC:  INCF   x3D,F
....................       --mnumluzes; 
015EE:  DECF   x3E,F
....................       CCP_1=matrizluz[fpointer(vez,0)]; 
015F0:  MOVFF  13D,4F9
015F4:  MOVLB  4
015F6:  CLRF   xFA
*
01662:  MOVFF  02,4FA
01666:  MOVFF  01,4F9
0166A:  BCF    FD8.0
0166C:  RLCF   01,W
0166E:  MOVWF  02
01670:  RLCF   xFA,W
01672:  MOVWF  03
01674:  MOVF   02,W
01676:  MOVLB  0
01678:  CALL   019A
0167C:  TBLRD*+
0167E:  MOVFF  FF5,03
01682:  MOVWF  FBE
01684:  MOVFF  03,FBF
01688:  MOVLB  1
....................    } 
.................... } 
0168A:  BCF    F9E.2
0168C:  MOVLB  0
0168E:  GOTO   0110
.................... void main() 
.................... { 
*
0245C:  CLRF   FF8
0245E:  BCF    FD0.7
02460:  BSF    07.7
02462:  CLRF   FEA
02464:  CLRF   FE9
02466:  BCF    F93.5
02468:  BSF    F8A.5
0246A:  CLRF   24
0246C:  BCF    xB1.0
0246E:  CLRF   xB2
02470:  BSF    xB1.1
02472:  MOVLW  10
02474:  MOVLB  1
02476:  MOVWF  x3A
02478:  MOVLB  3
0247A:  CLRF   xF9
0247C:  CLRF   xFD
0247E:  CLRF   xFC
02480:  CLRF   xFB
02482:  MOVLW  27
02484:  MOVWF  xFA
02486:  MOVLB  0
02488:  BCF    xB1.4
0248A:  MOVF   FC1,W
0248C:  ANDLW  C0
0248E:  IORLW  0F
02490:  MOVWF  FC1
02492:  MOVLW  07
02494:  MOVWF  FB4
02496:  CLRF   1C
02498:  MOVLW  01
0249A:  MOVWF  1D
0249C:  MOVLW  02
0249E:  MOVWF  1E
024A0:  MOVLW  03
024A2:  MOVWF  1F
024A4:  MOVLW  04
024A6:  MOVWF  20
024A8:  MOVLW  05
024AA:  MOVWF  21
024AC:  MOVLW  20
024AE:  MOVWF  22
024B0:  MOVLW  21
024B2:  MOVWF  23
024B4:  MOVLW  0B
024B6:  MOVLB  1
024B8:  MOVWF  x35
024BA:  CLRF   x36
024BC:  CLRF   x37
024BE:  CLRF   x38
024C0:  MOVLW  0A
024C2:  MOVWF  x3F
024C4:  MOVWF  x40
024C6:  MOVWF  x41
024C8:  MOVWF  x42
024CA:  MOVWF  x43
024CC:  MOVWF  x44
024CE:  MOVWF  x45
024D0:  MOVWF  x46
024D2:  MOVWF  x47
024D4:  MOVWF  x48
024D6:  MOVWF  x49
024D8:  MOVWF  x4A
024DA:  MOVWF  x4B
024DC:  MOVWF  x4C
024DE:  MOVWF  x4D
024E0:  MOVWF  x4E
024E2:  CLRF   x4F
024E4:  CLRF   x50
024E6:  CLRF   x51
024E8:  CLRF   x52
024EA:  CLRF   x53
024EC:  CLRF   x54
024EE:  MOVLW  01
024F0:  MOVWF  x55
024F2:  CLRF   x56
024F4:  CLRF   x57
024F6:  CLRF   x58
024F8:  MOVLW  02
024FA:  MOVWF  x59
024FC:  CLRF   x5A
024FE:  CLRF   x5B
02500:  CLRF   x5C
02502:  MOVLW  03
02504:  MOVWF  x5D
02506:  CLRF   x5E
02508:  CLRF   x5F
0250A:  CLRF   x60
0250C:  MOVLW  04
0250E:  MOVWF  x61
02510:  CLRF   x62
02512:  CLRF   x63
02514:  CLRF   x64
02516:  MOVLW  05
02518:  MOVWF  x65
0251A:  CLRF   x66
0251C:  CLRF   x67
0251E:  CLRF   x68
02520:  MOVLW  06
02522:  MOVWF  x69
02524:  CLRF   x6A
02526:  CLRF   x6B
02528:  CLRF   x6C
0252A:  MOVLW  07
0252C:  MOVWF  x6D
0252E:  CLRF   x6E
02530:  CLRF   x6F
02532:  CLRF   x70
02534:  MOVLW  08
02536:  MOVWF  x71
02538:  CLRF   x72
0253A:  CLRF   x73
0253C:  CLRF   x74
0253E:  MOVLW  09
02540:  MOVWF  x75
02542:  CLRF   x76
02544:  CLRF   x77
02546:  CLRF   x78
02548:  MOVLW  0A
0254A:  MOVWF  x79
0254C:  CLRF   x7A
0254E:  CLRF   x7B
02550:  CLRF   x7C
02552:  MOVLW  0B
02554:  MOVWF  x7D
02556:  CLRF   x7E
02558:  CLRF   x7F
0255A:  CLRF   x80
0255C:  MOVLW  0C
0255E:  MOVWF  x81
02560:  CLRF   x82
02562:  CLRF   x83
02564:  CLRF   x84
02566:  MOVLW  0D
02568:  MOVWF  x85
0256A:  CLRF   x86
0256C:  CLRF   x87
0256E:  CLRF   x88
02570:  MOVLW  0E
02572:  MOVWF  x89
02574:  CLRF   x8A
02576:  CLRF   x8B
02578:  CLRF   x8C
0257A:  MOVLW  0F
0257C:  MOVWF  x8D
0257E:  CLRF   x8E
02580:  CLRF   x8F
02582:  CLRF   x90
02584:  CLRF   x91
02586:  CLRF   x92
02588:  CLRF   x93
0258A:  CLRF   x94
0258C:  CLRF   x95
0258E:  CLRF   x96
02590:  CLRF   x97
02592:  CLRF   x98
02594:  MOVLW  01
02596:  MOVWF  x99
02598:  CLRF   x9A
0259A:  CLRF   x9B
0259C:  CLRF   x9C
0259E:  MOVLW  02
025A0:  MOVWF  x9D
025A2:  CLRF   x9E
025A4:  CLRF   x9F
025A6:  CLRF   xA0
025A8:  MOVLW  03
025AA:  MOVWF  xA1
025AC:  CLRF   xA2
025AE:  CLRF   xA3
025B0:  CLRF   xA4
025B2:  MOVLW  04
025B4:  MOVWF  xA5
025B6:  CLRF   xA6
025B8:  CLRF   xA7
025BA:  CLRF   xA8
025BC:  MOVLW  05
025BE:  MOVWF  xA9
025C0:  CLRF   xAA
025C2:  CLRF   xAB
025C4:  CLRF   xAC
025C6:  MOVLW  06
025C8:  MOVWF  xAD
025CA:  CLRF   xAE
025CC:  CLRF   xAF
025CE:  CLRF   xB0
025D0:  MOVLW  07
025D2:  MOVWF  xB1
025D4:  CLRF   xB2
025D6:  CLRF   xB3
025D8:  CLRF   xB4
025DA:  MOVLW  08
025DC:  MOVWF  xB5
025DE:  CLRF   xB6
025E0:  CLRF   xB7
025E2:  CLRF   xB8
025E4:  MOVLW  09
025E6:  MOVWF  xB9
025E8:  CLRF   xBA
025EA:  CLRF   xBB
025EC:  CLRF   xBC
025EE:  MOVLW  0A
025F0:  MOVWF  xBD
025F2:  CLRF   xBE
025F4:  CLRF   xBF
025F6:  CLRF   xC0
025F8:  MOVLW  0B
025FA:  MOVWF  xC1
025FC:  CLRF   xC2
025FE:  CLRF   xC3
02600:  CLRF   xC4
02602:  MOVLW  0C
02604:  MOVWF  xC5
02606:  CLRF   xC6
02608:  CLRF   xC7
0260A:  CLRF   xC8
0260C:  MOVLW  0D
0260E:  MOVWF  xC9
02610:  CLRF   xCA
02612:  CLRF   xCB
02614:  CLRF   xCC
02616:  MOVLW  0E
02618:  MOVWF  xCD
0261A:  CLRF   xCE
0261C:  CLRF   xCF
0261E:  CLRF   xD0
02620:  MOVLW  0F
02622:  MOVWF  xD1
02624:  CLRF   xD2
02626:  CLRF   xD3
02628:  CLRF   xD4
0262A:  CLRF   xD5
0262C:  CLRF   xD6
....................    clock = 0; 
0262E:  MOVLB  3
02630:  CLRF   xF8
02632:  CLRF   xF7
02634:  CLRF   xF6
02636:  CLRF   xF5
....................    can_init () ; 
02638:  MOVLB  0
0263A:  GOTO   1724
....................    can_set_mode (CAN_OP_CONFIG) ; 
0263E:  MOVLW  04
02640:  MOVLB  4
02642:  MOVWF  xA2
02644:  MOVLB  0
02646:  CALL   16CE
....................     
....................    BRGCON1.brp = 4; 
0264A:  MOVLW  C0
0264C:  ANDWF  F70,W
0264E:  IORLW  04
02650:  MOVWF  F70
....................    BRGCON1.sjw = 0; 
02652:  MOVLW  3F
02654:  ANDWF  F70,W
02656:  MOVWF  F70
....................    BRGCON2.prseg = 2; 
02658:  MOVLW  F8
0265A:  ANDWF  F71,W
0265C:  IORLW  02
0265E:  MOVWF  F71
....................    BRGCON2.seg1ph = 5; 
02660:  MOVLW  C7
02662:  ANDWF  F71,W
02664:  IORLW  28
02666:  MOVWF  F71
....................    BRGCON2.sam = FALSE; 
02668:  BCF    F71.6
....................    BRGCON2.seg2phts = FALSE; 
0266A:  BCF    F71.7
....................    BRGCON3.seg2ph = 5; 
0266C:  MOVLW  F8
0266E:  ANDWF  F72,W
02670:  IORLW  05
02672:  MOVWF  F72
....................    BRGCON3.wakfil = TRUE; 
02674:  BSF    F72.6
....................    can_set_mode (CAN_OP_NORMAL) ; 
02676:  MOVLB  4
02678:  CLRF   xA2
0267A:  MOVLB  0
0267C:  CALL   16CE
....................     
....................    enable_interrupts (int_canrx0); 
02680:  BSF    FA3.0
....................    enable_interrupts (int_canrx1); 
02682:  BSF    FA3.1
....................    enable_interrupts (int_cantx0); 
02684:  BSF    FA3.2
....................    enable_interrupts (int_cantx1); 
02686:  BSF    FA3.3
....................    enable_interrupts (int_cantx2); 
02688:  BSF    FA3.4
....................    enable_interrupts (int_canirx); 
0268A:  BSF    FA3.7
....................    enable_interrupts (int_canerr); 
0268C:  BSF    FA3.5
....................    setup_adc_ports (NO_ANALOGS | VSS_VDD) ; 
0268E:  MOVF   FC1,W
02690:  ANDLW  C0
02692:  IORLW  0F
02694:  MOVWF  FC1
....................    setup_adc (ADC_CLOCK_DIV_2 | ADC_TAD_MUL_0) ; 
02696:  MOVF   FC0,W
02698:  ANDLW  C0
0269A:  MOVWF  FC0
0269C:  BCF    FC0.7
0269E:  BSF    FC2.0
....................    setup_psp (PSP_DISABLED) ; 
026A0:  BCF    F96.4
....................    setup_spi (SPI_SS_DISABLED) ; 
026A2:  BCF    FC6.5
026A4:  MOVLW  01
026A6:  MOVWF  FC6
026A8:  MOVLW  00
026AA:  MOVWF  FC7
....................    //setup_wdt (WDT_ON) ; 
....................    setup_timer_0 (RTCC_INTERNAL | RTCC_DIV_4); //div16 1.6us thick 104ms overflow 
026AC:  MOVLW  81
026AE:  MOVWF  FD5
....................     
....................    //setup_timer_1 (T1_INTERNAL | T1_DIV_BY_2); //div2 0.2us thick overflow 13.1ms 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_2); 
026B0:  MOVLW  95
026B2:  MOVWF  FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
026B4:  MOVLW  00
026B6:  MOVWF  FCA
026B8:  MOVLW  00
026BA:  MOVWF  FCB
....................    setup_ccp1(CCP_COMPARE_INT); 
026BC:  MOVLW  0A
026BE:  MOVWF  FBD
....................    enable_interrupts(INT_CCP1); 
026C0:  BSF    F9D.2
....................    ext_int_edge(l_to_h); 
026C2:  BSF    FF1.6
....................     
....................    setup_timer_2 (T2_DISABLED, 0, 1) ; 
026C4:  MOVLW  00
026C6:  MOVWF  FCA
026C8:  MOVLW  00
026CA:  MOVWF  FCB
....................    setup_timer_3 (T3_DISABLED | T3_DIV_BY_1) ; 
026CC:  CLRF   FB1
....................     
....................   // setup_ccp1 (CCP_OFF) ; 
....................    setup_comparator (NC_NC_NC_NC) ; 
026CE:  MOVLW  07
026D0:  MOVWF  FB4
026D2:  MOVF   F95,W
026D4:  MOVWF  F95
026D6:  MOVF   F96,W
026D8:  MOVWF  F96
026DA:  CLRWDT
026DC:  MOVLW  20
026DE:  MOVWF  00
026E0:  DECFSZ 00,F
026E2:  BRA    26E0
026E4:  BRA    26E6
026E6:  MOVF   FB4,W
026E8:  BCF    FA1.6
....................    setup_vref (FALSE) ; 
026EA:  CLRF   FB5
....................     
....................    enable_interrupts (int_TIMER0) ; 
026EC:  BSF    FF2.5
....................    enable_interrupts (int_EXT) ; 
026EE:  BSF    FF2.4
....................    //enable_interrupts (int_TBE) ; 
....................    //enable_interrupts (int_BUSCOL) ; 
....................    //enable_interrupts (int_CANIRX) ; 
....................    //enable_interrupts (int_CANERR) ; 
....................    //enable_interrupts (int_CANTX2) ; 
....................    //enable_interrupts (int_CANTX1) ; 
....................    //enable_interrupts (int_CANTX0) ; 
....................    //enable_interrupts (int_CANRX1) ; 
....................    //enable_interrupts (int_CANRX0) ; 
....................    //enable_interrupts (int_OSCF) ; 
....................    
....................    //TODO: User Code 
....................    struct switches array[NUMBER_OF_SWITCHES]; 
....................    msw.previous_state=button_depressed; 
026F0:  MOVLB  4
026F2:  BSF    x0D.1
....................    msw.outstate=off; 
026F4:  MOVLW  01
026F6:  MOVWF  x0E
....................  
....................    trisc=0x00; //tudo saidas 
026F8:  CLRF   F94
....................    trisd=0x00; //tudo saidas 
026FA:  CLRF   F95
....................    actmat=0; 
026FC:  MOVLB  0
026FE:  BCF    xB1.3
....................    pointer=delays1; 
02700:  MOVLB  1
02702:  MOVWF  x3C
02704:  MOVLW  4F
02706:  MOVWF  x3B
....................    org(); 
02708:  MOVLB  0
0270A:  CALL   1AC6
....................    pointer=delays2; 
0270E:  MOVLW  01
02710:  MOVLB  1
02712:  MOVWF  x3C
02714:  MOVLW  93
02716:  MOVWF  x3B
....................    actmat=1; 
02718:  MOVLB  0
0271A:  BSF    xB1.3
....................    org(); 
0271C:  CALL   1AC6
....................     
....................    test(); 
02720:  BRA    235E
....................     
....................    enable_interrupts (GLOBAL) ; 
02722:  MOVLW  C0
02724:  IORWF  FF2,F
....................    while(true) 
....................    { 
....................    delay_ms (200) ; 
02726:  MOVLW  C8
02728:  MOVLB  4
0272A:  MOVWF  xA3
0272C:  MOVLB  0
0272E:  RCALL  2382
....................    if(mydevices.myinputs[0].device.dim_level.needs_update) 
02730:  MOVLB  1
02732:  BTFSS  xDD.0
02734:  BRA    2790
....................    { 
....................       printf("dim_level %u\n\r",mydevices.myinputs[0].device.dim_level.value); 
02736:  MOVLW  92
02738:  MOVWF  FF6
0273A:  MOVLW  16
0273C:  MOVWF  FF7
0273E:  MOVLW  00
02740:  MOVWF  FF8
02742:  MOVLW  0A
02744:  MOVLB  4
02746:  MOVWF  xED
02748:  MOVLB  0
0274A:  CALL   1942
0274E:  MOVFF  1DC,4A4
02752:  MOVLW  1B
02754:  MOVLB  4
02756:  MOVWF  xA5
02758:  MOVLB  0
0275A:  RCALL  23B2
0275C:  CLRF   1B
0275E:  BTFSC  FF2.7
02760:  BSF    1B.7
02762:  BCF    FF2.7
02764:  MOVLW  0A
02766:  MOVLB  5
02768:  MOVWF  x03
0276A:  MOVLB  0
0276C:  CALL   0372
02770:  BTFSC  1B.7
02772:  BSF    FF2.7
02774:  CLRF   1B
02776:  BTFSC  FF2.7
02778:  BSF    1B.7
0277A:  BCF    FF2.7
0277C:  MOVLW  0D
0277E:  MOVLB  5
02780:  MOVWF  x03
02782:  MOVLB  0
02784:  CALL   0372
02788:  BTFSC  1B.7
0278A:  BSF    FF2.7
....................       mydevices.myinputs[0].device.dim_level.needs_update=false; 
0278C:  MOVLB  1
0278E:  BCF    xDD.0
....................    } 
....................    if(mydevices.myinputs[0].device.on.needs_update) 
02790:  BTFSS  xE0.0
02792:  BRA    281E
02794:  CLRF   1B
02796:  BTFSC  FF2.7
02798:  BSF    1B.7
0279A:  BCF    FF2.7
....................    { 
....................       printf("on %u\n\r",mydevices.myinputs[0].device.on.value); 
0279C:  MOVLW  6F
0279E:  MOVLB  5
027A0:  MOVWF  x03
027A2:  MOVLB  0
027A4:  CALL   0372
027A8:  BTFSC  1B.7
027AA:  BSF    FF2.7
027AC:  CLRF   1B
027AE:  BTFSC  FF2.7
027B0:  BSF    1B.7
027B2:  BCF    FF2.7
027B4:  MOVLW  6E
027B6:  MOVLB  5
027B8:  MOVWF  x03
027BA:  MOVLB  0
027BC:  CALL   0372
027C0:  BTFSC  1B.7
027C2:  BSF    FF2.7
027C4:  CLRF   1B
027C6:  BTFSC  FF2.7
027C8:  BSF    1B.7
027CA:  BCF    FF2.7
027CC:  MOVLW  20
027CE:  MOVLB  5
027D0:  MOVWF  x03
027D2:  MOVLB  0
027D4:  CALL   0372
027D8:  BTFSC  1B.7
027DA:  BSF    FF2.7
027DC:  MOVFF  1DF,4A4
027E0:  MOVLW  1B
027E2:  MOVLB  4
027E4:  MOVWF  xA5
027E6:  MOVLB  0
027E8:  RCALL  23B2
027EA:  CLRF   1B
027EC:  BTFSC  FF2.7
027EE:  BSF    1B.7
027F0:  BCF    FF2.7
027F2:  MOVLW  0A
027F4:  MOVLB  5
027F6:  MOVWF  x03
027F8:  MOVLB  0
027FA:  CALL   0372
027FE:  BTFSC  1B.7
02800:  BSF    FF2.7
02802:  CLRF   1B
02804:  BTFSC  FF2.7
02806:  BSF    1B.7
02808:  BCF    FF2.7
0280A:  MOVLW  0D
0280C:  MOVLB  5
0280E:  MOVWF  x03
02810:  MOVLB  0
02812:  CALL   0372
02816:  BTFSC  1B.7
02818:  BSF    FF2.7
....................       mydevices.myinputs[0].device.on.needs_update=false; 
0281A:  MOVLB  1
0281C:  BCF    xE0.0
....................    } 
....................    if(mydevices.myinputs[0].device.off.needs_update) 
0281E:  BTFSS  xE3.0
02820:  BRA    287C
....................    { 
....................       printf("off %u\n\r",mydevices.myinputs[0].device.off.value); 
02822:  MOVLW  A2
02824:  MOVWF  FF6
02826:  MOVLW  16
02828:  MOVWF  FF7
0282A:  MOVLW  00
0282C:  MOVWF  FF8
0282E:  MOVLW  04
02830:  MOVLB  4
02832:  MOVWF  xED
02834:  MOVLB  0
02836:  CALL   1942
0283A:  MOVFF  1E2,4A4
0283E:  MOVLW  1B
02840:  MOVLB  4
02842:  MOVWF  xA5
02844:  MOVLB  0
02846:  RCALL  23B2
02848:  CLRF   1B
0284A:  BTFSC  FF2.7
0284C:  BSF    1B.7
0284E:  BCF    FF2.7
02850:  MOVLW  0A
02852:  MOVLB  5
02854:  MOVWF  x03
02856:  MOVLB  0
02858:  CALL   0372
0285C:  BTFSC  1B.7
0285E:  BSF    FF2.7
02860:  CLRF   1B
02862:  BTFSC  FF2.7
02864:  BSF    1B.7
02866:  BCF    FF2.7
02868:  MOVLW  0D
0286A:  MOVLB  5
0286C:  MOVWF  x03
0286E:  MOVLB  0
02870:  CALL   0372
02874:  BTFSC  1B.7
02876:  BSF    FF2.7
....................       mydevices.myinputs[0].device.off.needs_update=false; 
02878:  MOVLB  1
0287A:  BCF    xE3.0
....................    } 
.................... } 
0287C:  MOVLB  0
0287E:  BRA    2726
....................    while(organizado==0){} 
02880:  BTFSC  xB1.2
02882:  BRA    2886
02884:  BRA    2880
....................    for(temp=0;temp<17;++temp) 
02886:  MOVLB  1
02888:  CLRF   x39
0288A:  MOVF   x39,W
0288C:  SUBLW  10
0288E:  BTFSS  FD8.0
02890:  BRA    29F6
....................    { 
....................       printf("%lu <-> %lu\n\r",fpointer(temp,0),fpointer(temp,1)); 
02892:  MOVFF  139,4F9
02896:  MOVLB  4
02898:  CLRF   xFA
*
02904:  MOVFF  02,4A3
02908:  MOVFF  01,4A2
0290C:  MOVFF  139,4F9
02910:  MOVLW  01
02912:  MOVWF  xFA
*
0297E:  MOVFF  02,4A5
02982:  MOVFF  01,4A4
02986:  MOVLW  10
02988:  MOVWF  FE9
0298A:  MOVFF  4A3,4EE
0298E:  MOVFF  4A2,4ED
02992:  MOVLB  0
02994:  CALL   1878
02998:  MOVLW  AF
0299A:  MOVWF  FF6
0299C:  MOVLW  16
0299E:  MOVWF  FF7
029A0:  MOVLW  00
029A2:  MOVWF  FF8
029A4:  MOVLW  05
029A6:  MOVLB  4
029A8:  MOVWF  xED
029AA:  MOVLB  0
029AC:  CALL   1942
029B0:  MOVLW  10
029B2:  MOVWF  FE9
029B4:  MOVFF  4A5,4EE
029B8:  MOVFF  4A4,4ED
029BC:  CALL   1878
029C0:  CLRF   1B
029C2:  BTFSC  FF2.7
029C4:  BSF    1B.7
029C6:  BCF    FF2.7
029C8:  MOVLW  0A
029CA:  MOVLB  5
029CC:  MOVWF  x03
029CE:  MOVLB  0
029D0:  CALL   0372
029D4:  BTFSC  1B.7
029D6:  BSF    FF2.7
029D8:  CLRF   1B
029DA:  BTFSC  FF2.7
029DC:  BSF    1B.7
029DE:  BCF    FF2.7
029E0:  MOVLW  0D
029E2:  MOVLB  5
029E4:  MOVWF  x03
029E6:  MOVLB  0
029E8:  CALL   0372
029EC:  BTFSC  1B.7
029EE:  BSF    FF2.7
....................    } 
029F0:  MOVLB  1
029F2:  INCF   x39,F
029F4:  BRA    288A
....................     int16 auxccp=fpointer(0,1); 
029F6:  MOVLB  4
029F8:  CLRF   xF9
029FA:  MOVLW  01
029FC:  MOVWF  xFA
*
02A68:  MOVFF  02,4A1
02A6C:  MOVFF  01,4A0
....................       printf("%lu <-> %u <-> %u\n\r",auxccp,MAKE8(auxccp,1),MAKE8(auxccp,0)); 
02A70:  MOVFF  4A1,4A2
02A74:  MOVFF  4A0,4A3
02A78:  MOVLW  10
02A7A:  MOVWF  FE9
02A7C:  MOVFF  4A1,4EE
02A80:  MOVFF  4A0,4ED
02A84:  MOVLB  0
02A86:  CALL   1878
02A8A:  MOVLW  BD
02A8C:  MOVWF  FF6
02A8E:  MOVLW  16
02A90:  MOVWF  FF7
02A92:  MOVLW  00
02A94:  MOVWF  FF8
02A96:  MOVLW  05
02A98:  MOVLB  4
02A9A:  MOVWF  xED
02A9C:  MOVLB  0
02A9E:  CALL   1942
02AA2:  MOVFF  4A2,4A4
02AA6:  MOVLW  1B
02AA8:  MOVLB  4
02AAA:  MOVWF  xA5
02AAC:  MOVLB  0
02AAE:  RCALL  23B2
02AB0:  MOVLW  C4
02AB2:  MOVWF  FF6
02AB4:  MOVLW  16
02AB6:  MOVWF  FF7
02AB8:  MOVLW  00
02ABA:  MOVWF  FF8
02ABC:  MOVLW  05
02ABE:  MOVLB  4
02AC0:  MOVWF  xED
02AC2:  MOVLB  0
02AC4:  CALL   1942
02AC8:  MOVFF  4A3,4A4
02ACC:  MOVLW  1B
02ACE:  MOVLB  4
02AD0:  MOVWF  xA5
02AD2:  MOVLB  0
02AD4:  RCALL  23B2
02AD6:  CLRF   1B
02AD8:  BTFSC  FF2.7
02ADA:  BSF    1B.7
02ADC:  BCF    FF2.7
02ADE:  MOVLW  0A
02AE0:  MOVLB  5
02AE2:  MOVWF  x03
02AE4:  MOVLB  0
02AE6:  CALL   0372
02AEA:  BTFSC  1B.7
02AEC:  BSF    FF2.7
02AEE:  CLRF   1B
02AF0:  BTFSC  FF2.7
02AF2:  BSF    1B.7
02AF4:  BCF    FF2.7
02AF6:  MOVLW  0D
02AF8:  MOVLB  5
02AFA:  MOVWF  x03
02AFC:  MOVLB  0
02AFE:  CALL   0372
02B02:  BTFSC  1B.7
02B04:  BSF    FF2.7
....................    for (;; ) 
....................    {    
....................        
....................       output_high (LED) ; 
02B06:  BCF    F96.2
02B08:  BSF    F8D.2
....................        delay_ms (1000) ; 
02B0A:  MOVLW  04
02B0C:  MOVLB  4
02B0E:  MOVWF  xA2
02B10:  MOVLW  FA
02B12:  MOVWF  xA3
02B14:  MOVLB  0
02B16:  RCALL  2382
02B18:  MOVLB  4
02B1A:  DECFSZ xA2,F
02B1C:  BRA    2B10
....................        
....................      // output_low (LED) ; 
....................        
....................        
....................       delay_ms (200) ; 
02B1E:  MOVLW  C8
02B20:  MOVWF  xA3
02B22:  MOVLB  0
02B24:  RCALL  2382
....................       //   printf("%LX\n\r",temp); 
....................      // printf (" %d %lX\n\r", msw.dim_level.value,porta) ; 
....................    } 
02B26:  BRA    2B06
.................... } 
....................  
....................  
02B28:  BRA    2B28

Configuration Fuses:
   Word  1: C600   H4 IESO FCMEN
   Word  2: 0E19   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0030   NOSTVREN DEBUG NOLVP NOXINST BBSIZ4K
   Word  5: C03F   NOPROTECT NOCPD NOCPB
   Word  6: E03F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 403F   NOEBTR NOEBTRB
