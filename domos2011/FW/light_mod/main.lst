CCS PCH C Compiler, Version 4.106, 23932               03-Jun-11 17:11

               Filename: C:\Users\Xapo\Documents\Electronica\domos2011\FW\light_mod\main.lst

               ROM used: 9600 bytes (10%)
                         Largest free fragment is 55932
               RAM used: 1055 (32%) at main() level
                         1119 (34%) worst case
               Stack:    7 worst case (3 in main + 4 for interrupts)

*
00000:  GOTO   20A2
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0CE8
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0D0C
00074:  BTFSS  F9D.1
00076:  GOTO   0080
0007A:  BTFSC  F9E.1
0007C:  GOTO   0D14
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0D3C
0008C:  BTFSS  F9D.5
0008E:  GOTO   0098
00092:  BTFSC  F9E.5
00094:  GOTO   0E84
00098:  BTFSS  F9D.4
0009A:  GOTO   00A4
0009E:  BTFSC  F9E.4
000A0:  GOTO   0E8A
000A4:  BTFSS  F9D.2
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.2
000AC:  GOTO   1898
000B0:  BTFSS  FA0.3
000B2:  GOTO   00BC
000B6:  BTFSC  FA1.3
000B8:  GOTO   0E90
000BC:  BTFSS  FA3.7
000BE:  GOTO   00C8
000C2:  BTFSC  FA4.7
000C4:  GOTO   188C
000C8:  BTFSS  FA3.5
000CA:  GOTO   00D4
000CE:  BTFSC  FA4.5
000D0:  GOTO   1892
000D4:  BTFSS  FA3.4
000D6:  GOTO   00E0
000DA:  BTFSC  FA4.4
000DC:  GOTO   1884
000E0:  BTFSS  FA3.3
000E2:  GOTO   00EC
000E6:  BTFSC  FA4.3
000E8:  GOTO   187C
000EC:  BTFSS  FA3.2
000EE:  GOTO   00F8
000F2:  BTFSC  FA4.2
000F4:  GOTO   1874
000F8:  BTFSS  FA3.1
000FA:  GOTO   0104
000FE:  BTFSC  FA4.1
00100:  GOTO   144C
00104:  BTFSS  FA3.0
00106:  GOTO   0110
0010A:  BTFSC  FA4.0
0010C:  GOTO   1444
00110:  BTFSS  FA0.7
00112:  GOTO   011C
00116:  BTFSC  FA1.7
00118:  GOTO   0E96
0011C:  MOVFF  0E,00
00120:  MOVFF  0F,01
00124:  MOVFF  10,02
00128:  MOVFF  11,03
0012C:  MOVFF  0C,FE9
00130:  MOVFF  07,FEA
00134:  BSF    07.7
00136:  MOVFF  08,FE1
0013A:  MOVFF  09,FE2
0013E:  MOVFF  0A,FD9
00142:  MOVFF  0B,FDA
00146:  MOVFF  12,FF3
0014A:  MOVFF  13,FF4
0014E:  MOVFF  14,FFA
00152:  MOVFF  15,FF5
00156:  MOVFF  16,FF6
0015A:  MOVFF  17,FF7
0015E:  MOVFF  18,FF8
00162:  MOVFF  19,FFB
00166:  MOVF   04,W
00168:  MOVFF  06,FE0
0016C:  MOVFF  05,FD8
00170:  RETFIE 0
....................  
.................... #include "main.h" 
.................... #include <18F4685.h> 
.................... //////// Standard Header file for the PIC18F4685 device //////////////// 
.................... #device PIC18F4685 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES H4                    	//High speed osc with HW enabled 4X PLL 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT              	//Reset when brownout detected 
.................... #FUSES BORV20                	//Brownout reset at 2.0V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES BBSIZ4K               	//4K words Boot Block size 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=40000000,RESTART_WDT) 
*
01C36:  MOVLW  04
01C38:  MOVWF  FEA
01C3A:  MOVLW  1E
01C3C:  MOVWF  FE9
01C3E:  MOVF   FEF,W
01C40:  BZ    1C64
01C42:  MOVLW  0C
01C44:  MOVWF  01
01C46:  MOVLW  BF
01C48:  MOVWF  00
01C4A:  CLRWDT
01C4C:  DECFSZ 00,F
01C4E:  BRA    1C4A
01C50:  DECFSZ 01,F
01C52:  BRA    1C46
01C54:  MOVLW  F7
01C56:  MOVWF  00
01C58:  DECFSZ 00,F
01C5A:  BRA    1C58
01C5C:  NOP   
01C5E:  CLRWDT
01C60:  DECFSZ FEF,F
01C62:  BRA    1C42
01C64:  GOTO   1D9E (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B5,rcv=PIN_B4,bits=8,restart_wdt) 
01C68:  BCF    F93.5
01C6A:  BCF    F8A.5
01C6C:  MOVLW  08
01C6E:  MOVWF  01
01C70:  BRA    1C72
01C72:  NOP   
01C74:  BSF    01.7
01C76:  BRA    1C98
01C78:  BCF    01.7
01C7A:  MOVLB  4
01C7C:  RRCF   x2A,F
01C7E:  MOVLB  0
01C80:  BTFSC  FD8.0
01C82:  BSF    F8A.5
01C84:  BTFSS  FD8.0
01C86:  BCF    F8A.5
01C88:  BSF    01.6
01C8A:  BRA    1C98
01C8C:  BCF    01.6
01C8E:  DECFSZ 01,F
01C90:  BRA    1C7A
01C92:  BRA    1C94
01C94:  NOP   
01C96:  BSF    F8A.5
01C98:  MOVLW  01
01C9A:  MOVWF  00
01C9C:  CLRF   FE9
01C9E:  DECFSZ FE9,F
01CA0:  BRA    1C9E
01CA2:  DECFSZ 00,F
01CA4:  BRA    1C9C
01CA6:  MOVLW  53
01CA8:  MOVWF  FE9
01CAA:  DECFSZ FE9,F
01CAC:  BRA    1CAA
01CAE:  BRA    1CB0
01CB0:  CLRWDT
01CB2:  BTFSC  01.7
01CB4:  BRA    1C78
01CB6:  BTFSC  01.6
01CB8:  BRA    1C8C
01CBA:  RETLW  00
....................  
....................  
.................... #include "C:\Users\Programacao\Documents\CCS_Projects\18F\LightMod\global_defs.h" 
.................... #define  NUMBER_OF_SWITCHES 8 
.................... #define  LED PIN_E2 
.................... #define  OUT1  PIN_C0 
.................... #define  OUT2  PIN_C1 
.................... #define  OUT3  PIN_C2 
.................... #define  OUT4  PIN_C3 
.................... #define  OUT5  PIN_C4 
.................... #define  OUT6  PIN_C5 
.................... #define  OUT7  PIN_C6 
.................... #define  OUT8  PIN_C7 
.................... #define  OUT9  PIN_D1 
.................... #define  OUT10  PIN_D0 
.................... #define  OUT11  PIN_D2 
.................... #define  OUT12  PIN_D3 
.................... #define  OUT13  PIN_D7 
.................... #define  OUT14  PIN_D6 
.................... #define  OUT15  PIN_D5 
.................... #define  OUT16  PIN_D4 
.................... #define  INP1  PIN_A0 
.................... #define  INP2  PIN_A1 
.................... #define  INP3  PIN_A2 
.................... #define  INP4  PIN_A3 
.................... #define  INP5  PIN_A4 
.................... #define  INP6  PIN_A5 
.................... #define  INP7  PIN_E0 
.................... #define  INP8  PIN_E1 
....................  
.................... #byte porta=0xf80 
.................... #byte portb=0xf81 
.................... #byte portc=0xf82 
.................... #byte portd=0xf83 
.................... #byte porte=0xf84 
.................... #byte trisa=0xf92 
.................... #byte trisb=0xf93 
.................... #byte trisc=0xf94 
.................... #byte trisd=0xf95 
.................... #byte trise=0xf96 
....................  
.................... static int inputs[8]={INP1,INP2,INP3,INP4,INP5,INP6,INP7,INP8}; 
....................  
.................... #include "C:\Users\Programacao\Documents\CCS_Projects\18F\LightMod\can_functions.c" 
.................... #define CAN_USE_EXTENDED_ID FALSE 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = 0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = 0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT=0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1=0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2=0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3=0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive caputre 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON=0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON=0xF40 
.................... #byte   TXB1CON=0xF30 
.................... #byte   TXB2CON=0xF20 
.................... #byte TXBaCON=0xF60 //txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH=0xF41 
.................... #byte TXB0SIDL=0xF42 
.................... #byte TXB1SIDH=0xF31 
.................... #byte TXB1SIDL=0xF32 
.................... #byte TXB2SIDH=0xF21 
.................... #byte TXB2SIDL=0xF22 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH=0xF43 
.................... #byte TXB0EIDL=0xF44 
.................... #byte TXB1EIDH=0xF33 
.................... #byte TXB1EIDL=0xF34 
.................... #byte TXB2EIDH=0xF23 
.................... #byte TXB2EIDL=0xF24 
....................  
.................... #define RX0MASK      0xF1B    //rxm0eidl 
.................... #define RX1MASK      0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   0xF03    //rxf0eidl 
.................... #define RX0FILTER1   0xF07    //rxf1eidl 
.................... #define RX1FILTER2   0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   0xF13    //rxf4eidl 
.................... #define RX1FILTER5   0xF17    //rxf5eidl 
.................... #define RXB0ID       0xF64    //rxb0eidl 
.................... #define RXB1ID       0xF54    //rxb1eidl 
.................... #define TXB0ID       0xF44    //txb0eidl 
.................... #define TXB1ID       0xF34    //txb1eidl 
.................... #define TXB2ID       0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0=0xF46 
.................... #byte TXB0D7=0xF4D 
.................... #byte TXB1D0=0xF36 
.................... #byte TXB1D7=0xF3D 
.................... #byte TXB2D0=0xF26 
.................... #byte TXB2D7=0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC=0xF45 
.................... #byte TXB1DLC=0xF35 
.................... #byte TXB2DLC=0xF25 
.................... #byte TXBaDLC=0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON=0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON=0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH=0xF61 
.................... #byte   RXB0SIDL=0xF62 
.................... #byte   RXB1SIDH=0xF51 
.................... #byte   RXB1SIDL=0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH=0xF63 
.................... #byte   RXB0EIDL=0xF64 
.................... #byte   RXB1EIDH=0xF53 
.................... #byte   RXB1EIDL=0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC=0xF65 
.................... #byte   RXB1DLC=0xF55 
.................... #byte   RXBaDLC=0xF65 
....................  
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0=0xF66 
.................... #byte RXB0D7=0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT=0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH=0xF00 
.................... #byte RXF0SIDL=0xF01 
.................... #byte RXF1SIDH=0xF04 
.................... #byte RXF1SIDL=0xF05 
.................... #byte RXF2SIDH=0xF08 
.................... #byte RXF2SIDL=0xF09 
.................... #byte RXF3SIDH=0xF0C 
.................... #byte RXF3SIDL=0xF0D 
.................... #byte RXF4SIDH=0xF10 
.................... #byte RXF4SIDL=0xF11 
.................... #byte RXF5SIDH=0xF14 
.................... #byte RXF5SIDL=0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH=0xF02 
.................... #byte RXF0EIDL=0xF03 
.................... #byte RXF1EIDH=0xF06 
.................... #byte RXF1EIDL=0xF07 
.................... #byte RXF2EIDH=0xF0A 
.................... #byte RXF2EIDL=0xF0B 
.................... #byte RXF3EIDH=0xF0E 
.................... #byte RXF3EIDL=0xF0F 
.................... #byte RXF4EIDH=0xF12 
.................... #byte RXF4EIDL=0xF13 
.................... #byte RXF5EIDH=0xF16 
.................... #byte RXF5EIDL=0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH=0xF18 
.................... #byte RXM0SIDL=0xF19 
.................... #byte RXM1SIDH=0xF1C 
.................... #byte RXM1SIDL=0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH=0xF1A 
.................... #byte RXM0EIDL=0xF1B 
.................... #byte RXM1EIDH=0xF1E 
.................... #byte RXM1EIDL=0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = 0xFA4.7 
.................... #bit CAN_INT_WAKIF = 0xFA4.6 
.................... #bit CAN_INT_ERRIF = 0xFA4.5 
.................... #bit CAN_INT_TXB2IF = 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(int* addr, int32 id, int1 ext); 
.................... int32 can_get_id(int * addr, int1 ext); 
.................... int   can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(int32 & id, int * data, int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
01A44:  MOVLW  04
01A46:  MOVLB  4
01A48:  MOVWF  x1D
01A4A:  MOVLB  0
01A4C:  RCALL  19EE
....................    can_set_baud(); 
01A4E:  BRA    1A14
....................  
....................    RXB0CON=0; 
01A50:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
01A52:  MOVLW  9F
01A54:  ANDWF  F60,W
01A56:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
01A58:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
01A5A:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
01A5E:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
01A60:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
01A62:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
01A64:  BCF    F73.6
01A66:  CLRF   1B
01A68:  BTFSC  FF2.7
01A6A:  BSF    1B.7
01A6C:  BCF    FF2.7
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
01A6E:  MOVLW  0F
01A70:  MOVLB  4
01A72:  MOVWF  x53
01A74:  MOVLW  1B
01A76:  MOVWF  x52
01A78:  CLRF   x57
01A7A:  CLRF   x56
01A7C:  CLRF   x55
01A7E:  CLRF   x54
01A80:  CLRF   x58
01A82:  MOVLB  0
01A84:  RCALL  1454
01A86:  BTFSC  1B.7
01A88:  BSF    FF2.7
01A8A:  CLRF   1B
01A8C:  BTFSC  FF2.7
01A8E:  BSF    1B.7
01A90:  BCF    FF2.7
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
01A92:  MOVLW  0F
01A94:  MOVLB  4
01A96:  MOVWF  x53
01A98:  MOVLW  03
01A9A:  MOVWF  x52
01A9C:  CLRF   x57
01A9E:  CLRF   x56
01AA0:  CLRF   x55
01AA2:  CLRF   x54
01AA4:  CLRF   x58
01AA6:  MOVLB  0
01AA8:  RCALL  1454
01AAA:  BTFSC  1B.7
01AAC:  BSF    FF2.7
01AAE:  CLRF   1B
01AB0:  BTFSC  FF2.7
01AB2:  BSF    1B.7
01AB4:  BCF    FF2.7
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
01AB6:  MOVLW  0F
01AB8:  MOVLB  4
01ABA:  MOVWF  x53
01ABC:  MOVLW  07
01ABE:  MOVWF  x52
01AC0:  CLRF   x57
01AC2:  CLRF   x56
01AC4:  CLRF   x55
01AC6:  CLRF   x54
01AC8:  CLRF   x58
01ACA:  MOVLB  0
01ACC:  RCALL  1454
01ACE:  BTFSC  1B.7
01AD0:  BSF    FF2.7
01AD2:  CLRF   1B
01AD4:  BTFSC  FF2.7
01AD6:  BSF    1B.7
01AD8:  BCF    FF2.7
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
01ADA:  MOVLW  0F
01ADC:  MOVLB  4
01ADE:  MOVWF  x53
01AE0:  MOVLW  1F
01AE2:  MOVWF  x52
01AE4:  CLRF   x57
01AE6:  CLRF   x56
01AE8:  CLRF   x55
01AEA:  CLRF   x54
01AEC:  CLRF   x58
01AEE:  MOVLB  0
01AF0:  RCALL  1454
01AF2:  BTFSC  1B.7
01AF4:  BSF    FF2.7
01AF6:  CLRF   1B
01AF8:  BTFSC  FF2.7
01AFA:  BSF    1B.7
01AFC:  BCF    FF2.7
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
01AFE:  MOVLW  0F
01B00:  MOVLB  4
01B02:  MOVWF  x53
01B04:  MOVLW  0B
01B06:  MOVWF  x52
01B08:  CLRF   x57
01B0A:  CLRF   x56
01B0C:  CLRF   x55
01B0E:  CLRF   x54
01B10:  CLRF   x58
01B12:  MOVLB  0
01B14:  RCALL  1454
01B16:  BTFSC  1B.7
01B18:  BSF    FF2.7
01B1A:  CLRF   1B
01B1C:  BTFSC  FF2.7
01B1E:  BSF    1B.7
01B20:  BCF    FF2.7
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
01B22:  MOVLW  0F
01B24:  MOVLB  4
01B26:  MOVWF  x53
01B28:  MOVWF  x52
01B2A:  CLRF   x57
01B2C:  CLRF   x56
01B2E:  CLRF   x55
01B30:  CLRF   x54
01B32:  CLRF   x58
01B34:  MOVLB  0
01B36:  RCALL  1454
01B38:  BTFSC  1B.7
01B3A:  BSF    FF2.7
01B3C:  CLRF   1B
01B3E:  BTFSC  FF2.7
01B40:  BSF    1B.7
01B42:  BCF    FF2.7
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
01B44:  MOVLW  0F
01B46:  MOVLB  4
01B48:  MOVWF  x53
01B4A:  MOVLW  13
01B4C:  MOVWF  x52
01B4E:  CLRF   x57
01B50:  CLRF   x56
01B52:  CLRF   x55
01B54:  CLRF   x54
01B56:  CLRF   x58
01B58:  MOVLB  0
01B5A:  RCALL  1454
01B5C:  BTFSC  1B.7
01B5E:  BSF    FF2.7
01B60:  CLRF   1B
01B62:  BTFSC  FF2.7
01B64:  BSF    1B.7
01B66:  BCF    FF2.7
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
01B68:  MOVLW  0F
01B6A:  MOVLB  4
01B6C:  MOVWF  x53
01B6E:  MOVLW  17
01B70:  MOVWF  x52
01B72:  CLRF   x57
01B74:  CLRF   x56
01B76:  CLRF   x55
01B78:  CLRF   x54
01B7A:  CLRF   x58
01B7C:  MOVLB  0
01B7E:  RCALL  1454
01B80:  BTFSC  1B.7
01B82:  BSF    FF2.7
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
01B84:  MOVF   F93,W
01B86:  ANDLW  FB
01B88:  IORLW  08
01B8A:  MOVLB  4
01B8C:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
01B8E:  CLRF   x1D
01B90:  MOVLB  0
01B92:  RCALL  19EE
.................... } 
01B94:  GOTO   2292 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
01A14:  MOVLW  C0
01A16:  ANDWF  F70,W
01A18:  IORLW  04
01A1A:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
01A1C:  MOVLW  3F
01A1E:  ANDWF  F70,W
01A20:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
01A22:  MOVLW  F8
01A24:  ANDWF  F71,W
01A26:  IORLW  02
01A28:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
01A2A:  MOVLW  C7
01A2C:  ANDWF  F71,W
01A2E:  IORLW  28
01A30:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
01A32:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
01A34:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
01A36:  MOVLW  F8
01A38:  ANDWF  F72,W
01A3A:  IORLW  05
01A3C:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
01A3E:  BCF    F72.6
.................... } 
01A40:  GOTO   1A50 (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
019EE:  MOVLB  4
019F0:  SWAPF  x1D,W
019F2:  ANDLW  70
019F4:  MOVWF  00
019F6:  BCF    FD8.0
019F8:  RLCF   00,F
019FA:  MOVLW  1F
019FC:  ANDWF  F6F,W
019FE:  IORWF  00,W
01A00:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
01A02:  MOVFF  F6E,00
01A06:  SWAPF  00,F
01A08:  RRCF   00,W
01A0A:  ANDLW  07
01A0C:  SUBWF  x1D,W
01A0E:  BNZ   1A02
.................... } 
01A10:  MOVLB  0
01A12:  RETLW  00
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(int* addr, int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
01454:  MOVFF  453,45A
01458:  MOVFF  452,459
....................  
....................    if (ext) {  //extended 
0145C:  MOVLB  4
0145E:  MOVF   x58,F
01460:  BZ    1506
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
01462:  MOVFF  459,FE9
01466:  MOVFF  45A,FEA
0146A:  MOVFF  454,FEF
....................  
....................       //eidh 
....................       ptr--; 
0146E:  MOVF   x59,W
01470:  BTFSC  FD8.2
01472:  DECF   x5A,F
01474:  DECF   x59,F
....................       *ptr=make8(id,1); //8:15 
01476:  MOVFF  459,FE9
0147A:  MOVFF  45A,FEA
0147E:  MOVFF  455,FEF
....................  
....................       //sidl 
....................       ptr--; 
01482:  MOVF   x59,W
01484:  BTFSC  FD8.2
01486:  DECF   x5A,F
01488:  DECF   x59,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
0148A:  MOVFF  459,FE9
0148E:  MOVFF  45A,FEA
01492:  MOVF   x56,W
01494:  ANDLW  03
01496:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
01498:  MOVFF  459,FE9
0149C:  MOVFF  45A,FEA
014A0:  MOVFF  456,00
014A4:  RLCF   00,F
014A6:  RLCF   00,F
014A8:  RLCF   00,F
014AA:  MOVLW  F8
014AC:  ANDWF  00,F
014AE:  MOVF   00,W
014B0:  ANDLW  E0
014B2:  IORWF  FEF,W
014B4:  MOVWF  FEF
....................       *ptr|=0x08; 
014B6:  MOVFF  459,FE9
014BA:  MOVFF  45A,FEA
014BE:  MOVF   FEF,W
014C0:  IORLW  08
014C2:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
014C4:  MOVF   x59,W
014C6:  BTFSC  FD8.2
014C8:  DECF   x5A,F
014CA:  DECF   x59,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
014CC:  MOVFF  459,FE9
014D0:  MOVFF  45A,FEA
014D4:  MOVFF  456,00
014D8:  SWAPF  00,F
014DA:  RRCF   00,F
014DC:  MOVLW  07
014DE:  ANDWF  00,F
014E0:  MOVF   00,W
014E2:  ANDLW  07
014E4:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
014E6:  MOVFF  459,FE9
014EA:  MOVFF  45A,FEA
014EE:  MOVFF  457,00
014F2:  RLCF   00,F
014F4:  RLCF   00,F
014F6:  RLCF   00,F
014F8:  MOVLW  F8
014FA:  ANDWF  00,F
014FC:  MOVF   00,W
014FE:  ANDLW  F8
01500:  IORWF  FEF,W
01502:  MOVWF  FEF
....................    } 
....................    else {   //standard 
01504:  BRA    1584
....................       //eidl 
....................       *ptr=0; 
01506:  MOVFF  459,FE9
0150A:  MOVFF  45A,FEA
0150E:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
01510:  MOVF   x59,W
01512:  BTFSC  FD8.2
01514:  DECF   x5A,F
01516:  DECF   x59,F
....................       *ptr=0; 
01518:  MOVFF  459,FE9
0151C:  MOVFF  45A,FEA
01520:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
01522:  MOVF   x59,W
01524:  BTFSC  FD8.2
01526:  DECF   x5A,F
01528:  DECF   x59,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
0152A:  MOVFF  459,FE9
0152E:  MOVFF  45A,FEA
01532:  MOVFF  454,00
01536:  SWAPF  00,F
01538:  RLCF   00,F
0153A:  MOVLW  E0
0153C:  ANDWF  00,F
0153E:  MOVF   00,W
01540:  ANDLW  E0
01542:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
01544:  MOVF   x59,W
01546:  BTFSC  FD8.2
01548:  DECF   x5A,F
0154A:  DECF   x59,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
0154C:  MOVFF  459,FE9
01550:  MOVFF  45A,FEA
01554:  MOVFF  454,00
01558:  RRCF   00,F
0155A:  RRCF   00,F
0155C:  RRCF   00,F
0155E:  MOVLW  1F
01560:  ANDWF  00,F
01562:  MOVF   00,W
01564:  ANDLW  1F
01566:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
01568:  MOVFF  459,FE9
0156C:  MOVFF  45A,FEA
01570:  MOVFF  455,00
01574:  SWAPF  00,F
01576:  RLCF   00,F
01578:  MOVLW  E0
0157A:  ANDWF  00,F
0157C:  MOVF   00,W
0157E:  ANDLW  E0
01580:  IORWF  FEF,W
01582:  MOVWF  FEF
....................    } 
.................... } 
01584:  MOVLB  0
01586:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int32 can_get_id(int * addr, int1 ext) { 
....................    int32 ret; 
....................    int * ptr; 
....................  
....................    ret=0; 
*
00E9C:  MOVLB  4
00E9E:  CLRF   x54
00EA0:  CLRF   x53
00EA2:  CLRF   x52
00EA4:  CLRF   x51
....................    ptr=addr; 
00EA6:  MOVFF  44F,456
00EAA:  MOVFF  44E,455
....................  
....................    if (ext) { 
00EAE:  MOVF   x50,F
00EB0:  BTFSC  FD8.2
00EB2:  BRA    0FDA
....................       ret=*ptr;  //eidl 
00EB4:  MOVFF  456,03
00EB8:  MOVFF  455,FE9
00EBC:  MOVFF  456,FEA
00EC0:  MOVFF  FEF,00
00EC4:  CLRF   01
00EC6:  CLRF   02
00EC8:  CLRF   03
00ECA:  MOVFF  03,454
00ECE:  MOVFF  02,453
00ED2:  MOVFF  01,452
00ED6:  MOVFF  00,451
....................  
....................       ptr--;     //eidh 
00EDA:  MOVF   x55,W
00EDC:  BTFSC  FD8.2
00EDE:  DECF   x56,F
00EE0:  DECF   x55,F
....................       ret|=((int32)*ptr << 8); 
00EE2:  MOVFF  455,FE9
00EE6:  MOVFF  456,FEA
00EEA:  MOVF   FEF,W
00EEC:  CLRF   x59
00EEE:  CLRF   x58
00EF0:  MOVWF  x57
00EF2:  CLRF   00
00EF4:  MOVF   00,W
00EF6:  IORWF  x51,F
00EF8:  MOVF   x57,W
00EFA:  IORWF  x52,F
00EFC:  MOVF   x58,W
00EFE:  IORWF  x53,F
00F00:  MOVF   x59,W
00F02:  IORWF  x54,F
....................  
....................       ptr--;     //sidl 
00F04:  MOVF   x55,W
00F06:  BTFSC  FD8.2
00F08:  DECF   x56,F
00F0A:  DECF   x55,F
....................       ret|=((int32)*ptr & 0x03) << 16; 
00F0C:  MOVFF  455,FE9
00F10:  MOVFF  456,FEA
00F14:  MOVF   FEF,W
00F16:  CLRF   x5A
00F18:  CLRF   x59
00F1A:  CLRF   x58
00F1C:  MOVWF  x57
00F1E:  MOVLW  03
00F20:  ANDWF  x57,F
00F22:  CLRF   x58
00F24:  CLRF   x59
00F26:  CLRF   x5A
00F28:  CLRF   00
00F2A:  CLRF   01
00F2C:  MOVF   00,W
00F2E:  IORWF  x51,F
00F30:  MOVF   01,W
00F32:  IORWF  x52,F
00F34:  MOVF   x57,W
00F36:  IORWF  x53,F
00F38:  MOVF   x58,W
00F3A:  IORWF  x54,F
....................       ret|=((int32)*ptr & 0xE0) << 13; 
00F3C:  MOVFF  455,FE9
00F40:  MOVFF  456,FEA
00F44:  MOVF   FEF,W
00F46:  CLRF   x5A
00F48:  CLRF   x59
00F4A:  CLRF   x58
00F4C:  MOVWF  x57
00F4E:  MOVLW  E0
00F50:  ANDWF  x57,F
00F52:  CLRF   x58
00F54:  CLRF   x59
00F56:  CLRF   x5A
00F58:  CLRF   00
00F5A:  RLCF   x57,W
00F5C:  MOVWF  01
00F5E:  RLCF   x58,W
00F60:  MOVWF  02
00F62:  RLCF   x59,W
00F64:  MOVWF  03
00F66:  RLCF   01,F
00F68:  RLCF   02,F
00F6A:  RLCF   03,F
00F6C:  RLCF   01,F
00F6E:  RLCF   02,F
00F70:  RLCF   03,F
00F72:  RLCF   01,F
00F74:  RLCF   02,F
00F76:  RLCF   03,F
00F78:  RLCF   01,F
00F7A:  RLCF   02,F
00F7C:  RLCF   03,F
00F7E:  MOVLW  E0
00F80:  ANDWF  01,F
00F82:  MOVF   00,W
00F84:  IORWF  x51,F
00F86:  MOVF   01,W
00F88:  IORWF  x52,F
00F8A:  MOVF   02,W
00F8C:  IORWF  x53,F
00F8E:  MOVF   03,W
00F90:  IORWF  x54,F
....................  
....................       ptr--;     //sidh 
00F92:  MOVF   x55,W
00F94:  BTFSC  FD8.2
00F96:  DECF   x56,F
00F98:  DECF   x55,F
....................       ret|=((int32)*ptr << 21); 
00F9A:  MOVFF  455,FE9
00F9E:  MOVFF  456,FEA
00FA2:  MOVF   FEF,W
00FA4:  CLRF   x58
00FA6:  MOVWF  x57
00FA8:  CLRF   00
00FAA:  CLRF   01
00FAC:  RLCF   x57,W
00FAE:  MOVWF  02
00FB0:  RLCF   x58,W
00FB2:  MOVWF  03
00FB4:  RLCF   02,F
00FB6:  RLCF   03,F
00FB8:  RLCF   02,F
00FBA:  RLCF   03,F
00FBC:  RLCF   02,F
00FBE:  RLCF   03,F
00FC0:  RLCF   02,F
00FC2:  RLCF   03,F
00FC4:  MOVLW  E0
00FC6:  ANDWF  02,F
00FC8:  MOVF   00,W
00FCA:  IORWF  x51,F
00FCC:  MOVF   01,W
00FCE:  IORWF  x52,F
00FD0:  MOVF   02,W
00FD2:  IORWF  x53,F
00FD4:  MOVF   03,W
00FD6:  IORWF  x54,F
....................  
....................    } 
....................    else { 
00FD8:  BRA    1080
....................       ptr-=2;    //sidl 
00FDA:  MOVLW  02
00FDC:  SUBWF  x55,F
00FDE:  MOVLW  00
00FE0:  SUBWFB x56,F
....................       ret=((int32)*ptr & 0xE0) >> 5; 
00FE2:  MOVFF  455,FE9
00FE6:  MOVFF  456,FEA
00FEA:  MOVF   FEF,W
00FEC:  CLRF   x5A
00FEE:  CLRF   x59
00FF0:  CLRF   x58
00FF2:  MOVWF  x57
00FF4:  MOVLW  E0
00FF6:  ANDWF  x57,F
00FF8:  CLRF   x58
00FFA:  CLRF   x59
00FFC:  CLRF   x5A
00FFE:  RRCF   x5A,W
01000:  MOVWF  x54
01002:  RRCF   x59,W
01004:  MOVWF  x53
01006:  RRCF   x58,W
01008:  MOVWF  x52
0100A:  RRCF   x57,W
0100C:  MOVWF  x51
0100E:  RRCF   x54,F
01010:  RRCF   x53,F
01012:  RRCF   x52,F
01014:  RRCF   x51,F
01016:  RRCF   x54,F
01018:  RRCF   x53,F
0101A:  RRCF   x52,F
0101C:  RRCF   x51,F
0101E:  RRCF   x54,F
01020:  RRCF   x53,F
01022:  RRCF   x52,F
01024:  RRCF   x51,F
01026:  RRCF   x54,F
01028:  RRCF   x53,F
0102A:  RRCF   x52,F
0102C:  RRCF   x51,F
0102E:  MOVLW  07
01030:  ANDWF  x54,F
....................  
....................       ptr--;     //sidh 
01032:  MOVF   x55,W
01034:  BTFSC  FD8.2
01036:  DECF   x56,F
01038:  DECF   x55,F
....................       ret|=((int32)*ptr << 3); 
0103A:  MOVFF  455,FE9
0103E:  MOVFF  456,FEA
01042:  MOVF   FEF,W
01044:  CLRF   x5A
01046:  CLRF   x59
01048:  CLRF   x58
0104A:  MOVWF  x57
0104C:  RLCF   x57,W
0104E:  MOVWF  00
01050:  RLCF   x58,W
01052:  MOVWF  01
01054:  RLCF   x59,W
01056:  MOVWF  02
01058:  RLCF   x5A,W
0105A:  MOVWF  03
0105C:  RLCF   00,F
0105E:  RLCF   01,F
01060:  RLCF   02,F
01062:  RLCF   03,F
01064:  RLCF   00,F
01066:  RLCF   01,F
01068:  RLCF   02,F
0106A:  RLCF   03,F
0106C:  MOVLW  F8
0106E:  ANDWF  00,F
01070:  MOVF   00,W
01072:  IORWF  x51,F
01074:  MOVF   01,W
01076:  IORWF  x52,F
01078:  MOVF   02,W
0107A:  IORWF  x53,F
0107C:  MOVF   03,W
0107E:  IORWF  x54,F
....................    } 
....................  
....................    return(ret); 
01080:  MOVFF  451,00
01084:  MOVFF  452,01
01088:  MOVFF  453,02
0108C:  MOVFF  454,03
.................... } 
01090:  MOVLB  0
01092:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr) { 
....................    int i; 
....................    int * txd0; 
....................    int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
01588:  MOVLW  0F
0158A:  MOVLB  4
0158C:  MOVWF  x50
0158E:  MOVLW  66
01590:  MOVWF  x4F
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
01592:  MOVLB  F
01594:  BTFSC  x40.3
01596:  BRA    15A8
....................       CANCON.win=CAN_WIN_TX0; 
01598:  MOVLW  F1
0159A:  ANDWF  F6F,W
0159C:  IORLW  08
0159E:  MOVWF  F6F
....................       port=0; 
015A0:  MOVLB  4
015A2:  CLRF   x51
....................    } 
....................    else if (!TXB1CON.txreq) { 
015A4:  BRA    15DC
015A6:  MOVLB  F
015A8:  BTFSC  x30.3
015AA:  BRA    15BE
....................       CANCON.win=CAN_WIN_TX1; 
015AC:  MOVLW  F1
015AE:  ANDWF  F6F,W
015B0:  IORLW  06
015B2:  MOVWF  F6F
....................       port=1; 
015B4:  MOVLW  01
015B6:  MOVLB  4
015B8:  MOVWF  x51
....................    } 
....................    else if (!TXB2CON.txreq) { 
015BA:  BRA    15DC
015BC:  MOVLB  F
015BE:  BTFSC  x20.3
015C0:  BRA    15D4
....................       CANCON.win=CAN_WIN_TX2; 
015C2:  MOVLW  F1
015C4:  ANDWF  F6F,W
015C6:  IORLW  04
015C8:  MOVWF  F6F
....................       port=2; 
015CA:  MOVLW  02
015CC:  MOVLB  4
015CE:  MOVWF  x51
....................    } 
....................    else { 
015D0:  BRA    15DC
015D2:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
015D4:  MOVLW  00
015D6:  MOVWF  01
015D8:  BRA    1654
015DA:  MOVLB  4
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
015DC:  MOVF   x4B,W
015DE:  ANDLW  03
015E0:  MOVWF  00
015E2:  MOVLW  FC
015E4:  ANDWF  F60,W
015E6:  IORWF  00,W
015E8:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
015EA:  MOVLW  0F
015EC:  MOVWF  x53
015EE:  MOVLW  64
015F0:  MOVWF  x52
015F2:  MOVFF  447,457
015F6:  MOVFF  446,456
015FA:  MOVFF  445,455
015FE:  MOVFF  444,454
01602:  MOVFF  44C,458
01606:  MOVLB  0
01608:  RCALL  1454
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
0160A:  MOVFF  44A,F65
....................    TXBaDLC.rtr=rtr; 
0160E:  BCF    F65.6
01610:  MOVLB  4
01612:  BTFSC  x4D.0
01614:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
01616:  CLRF   x4E
01618:  MOVF   x4A,W
0161A:  SUBWF  x4E,W
0161C:  BC    1646
....................       *txd0=*data; 
0161E:  MOVFF  448,FE9
01622:  MOVFF  449,FEA
01626:  MOVFF  FEF,454
0162A:  MOVFF  450,FEA
0162E:  MOVFF  44F,FE9
01632:  MOVFF  454,FEF
....................       txd0++; 
01636:  INCF   x4F,F
01638:  BTFSC  FD8.2
0163A:  INCF   x50,F
....................       data++; 
0163C:  INCF   x48,F
0163E:  BTFSC  FD8.2
01640:  INCF   x49,F
....................     } 
01642:  INCF   x4E,F
01644:  BRA    1618
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
01646:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
01648:  MOVLW  F1
0164A:  ANDWF  F6F,W
0164C:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
0164E:  MOVLW  01
01650:  MOVWF  01
01652:  MOVLB  F
.................... } 
01654:  MOVLB  0
01656:  GOTO   186C (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(int32 & id, int * data, int & len, struct rx_stat & stat) 
.................... { 
....................     int i; 
....................     int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
010AE:  BTFSS  F60.7
010B0:  BRA    10E0
*
01336:  BTFSS  F60.7
01338:  BRA    1368
....................         CANCON.win=CAN_WIN_RX0; 
*
010B2:  MOVLW  F1
010B4:  ANDWF  F6F,W
010B6:  MOVWF  F6F
*
0133A:  MOVLW  F1
0133C:  ANDWF  F6F,W
0133E:  MOVWF  F6F
....................         stat.buffer=0; 
*
010B8:  BCF    x37.4
*
01340:  BCF    x37.4
....................  
....................         CAN_INT_RXB0IF=0; 
*
010BA:  BCF    FA4.0
*
01342:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
*
010BC:  BCF    x37.0
010BE:  BTFSC  F74.7
010C0:  BSF    x37.0
*
01344:  BCF    x37.0
01346:  BTFSC  F74.7
01348:  BSF    x37.0
....................         COMSTAT.rx0ovfl=0; 
*
010C2:  BCF    F74.7
*
0134A:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
*
010C4:  BTFSS  F60.2
010C6:  BRA    10DE
*
0134C:  BTFSS  F60.2
0134E:  BRA    1366
....................          stat.filthit=RXB0CON.filthit0; 
*
010C8:  MOVLW  00
010CA:  BTFSC  F60.0
010CC:  MOVLW  01
010CE:  ANDLW  07
010D0:  MOVWF  00
010D2:  BCF    FD8.0
010D4:  RLCF   00,F
010D6:  MOVLW  F1
010D8:  ANDWF  x37,W
010DA:  IORWF  00,W
010DC:  MOVWF  x37
*
01350:  MOVLW  00
01352:  BTFSC  F60.0
01354:  MOVLW  01
01356:  ANDLW  07
01358:  MOVWF  00
0135A:  BCF    FD8.0
0135C:  RLCF   00,F
0135E:  MOVLW  F1
01360:  ANDWF  x37,W
01362:  IORWF  00,W
01364:  MOVWF  x37
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
*
010DE:  BRA    1120
010E0:  MOVLB  F
010E2:  BTFSS  x50.7
010E4:  BRA    1118
*
01366:  BRA    13A8
01368:  MOVLB  F
0136A:  BTFSS  x50.7
0136C:  BRA    13A0
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
*
010E6:  MOVLW  F1
010E8:  ANDWF  F6F,W
010EA:  IORLW  0A
010EC:  MOVWF  F6F
*
0136E:  MOVLW  F1
01370:  ANDWF  F6F,W
01372:  IORLW  0A
01374:  MOVWF  F6F
....................         stat.buffer=1; 
*
010EE:  MOVLB  4
010F0:  BSF    x37.4
*
01376:  MOVLB  4
01378:  BSF    x37.4
....................  
....................         CAN_INT_RXB1IF=0; 
*
010F2:  BCF    FA4.1
*
0137A:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
*
010F4:  BCF    x37.0
010F6:  BTFSC  F74.6
010F8:  BSF    x37.0
*
0137C:  BCF    x37.0
0137E:  BTFSC  F74.6
01380:  BSF    x37.0
....................         COMSTAT.rx1ovfl=0; 
*
010FA:  BCF    F74.6
*
01382:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
*
010FC:  MOVLB  F
010FE:  MOVF   x50,W
01100:  ANDLW  07
01102:  ANDLW  07
01104:  MOVWF  00
01106:  BCF    FD8.0
01108:  RLCF   00,F
0110A:  MOVLW  F1
0110C:  MOVLB  4
0110E:  ANDWF  x37,W
01110:  IORWF  00,W
01112:  MOVWF  x37
*
01384:  MOVLB  F
01386:  MOVF   x50,W
01388:  ANDLW  07
0138A:  ANDLW  07
0138C:  MOVWF  00
0138E:  BCF    FD8.0
01390:  RLCF   00,F
01392:  MOVLW  F1
01394:  MOVLB  4
01396:  ANDWF  x37,W
01398:  IORWF  00,W
0139A:  MOVWF  x37
....................     } 
....................     else { 
*
01114:  BRA    1120
01116:  MOVLB  F
*
0139C:  BRA    13A8
0139E:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
01118:  MOVLW  00
0111A:  MOVWF  01
0111C:  BRA    11B6
0111E:  MOVLB  4
*
013A0:  MOVLW  00
013A2:  MOVWF  01
013A4:  BRA    143E
013A6:  MOVLB  4
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
*
01120:  MOVF   F65,W
01122:  ANDLW  0F
01124:  MOVWF  x36
*
013A8:  MOVF   F65,W
013AA:  ANDLW  0F
013AC:  MOVWF  x36
....................     stat.rtr=RXBaDLC.rtr; 
*
01126:  BCF    x37.5
01128:  BTFSC  F65.6
0112A:  BSF    x37.5
*
013AE:  BCF    x37.5
013B0:  BTFSC  F65.6
013B2:  BSF    x37.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
*
0112C:  BCF    x37.6
0112E:  BTFSC  F62.3
01130:  BSF    x37.6
*
013B4:  BCF    x37.6
013B6:  BTFSC  F62.3
013B8:  BSF    x37.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
*
01132:  MOVLW  00
01134:  BTFSC  x37.6
01136:  MOVLW  01
01138:  MOVWF  x47
0113A:  MOVLW  0F
0113C:  MOVWF  x4F
0113E:  MOVLW  64
01140:  MOVWF  x4E
01142:  MOVFF  447,450
01146:  MOVLB  0
01148:  RCALL  0E9C
0114A:  MOVFF  03,435
0114E:  MOVFF  02,434
01152:  MOVFF  01,433
01156:  MOVFF  00,432
*
013BA:  MOVLW  00
013BC:  BTFSC  x37.6
013BE:  MOVLW  01
013C0:  MOVWF  x47
013C2:  MOVLW  0F
013C4:  MOVWF  x4F
013C6:  MOVLW  64
013C8:  MOVWF  x4E
013CA:  MOVFF  447,450
013CE:  MOVLB  0
013D0:  RCALL  0E9C
013D2:  MOVFF  03,435
013D6:  MOVFF  02,434
013DA:  MOVFF  01,433
013DE:  MOVFF  00,432
....................  
....................     ptr = &TXRXBaD0; 
*
0115A:  MOVLW  0F
0115C:  MOVLB  4
0115E:  MOVWF  x46
01160:  MOVLW  66
01162:  MOVWF  x45
*
013E2:  MOVLW  0F
013E4:  MOVLB  4
013E6:  MOVWF  x46
013E8:  MOVLW  66
013EA:  MOVWF  x45
....................     for ( i = 0; i < len; i++ ) { 
*
01164:  CLRF   x44
01166:  MOVF   x36,W
01168:  SUBWF  x44,W
0116A:  BC    1194
*
013EC:  CLRF   x44
013EE:  MOVF   x36,W
013F0:  SUBWF  x44,W
013F2:  BC    141C
....................         *data = *ptr; 
*
0116C:  MOVFF  445,FE9
01170:  MOVFF  446,FEA
01174:  MOVFF  FEF,449
01178:  MOVFF  443,FEA
0117C:  MOVFF  442,FE9
01180:  MOVFF  449,FEF
*
013F4:  MOVFF  445,FE9
013F8:  MOVFF  446,FEA
013FC:  MOVFF  FEF,449
01400:  MOVFF  443,FEA
01404:  MOVFF  442,FE9
01408:  MOVFF  449,FEF
....................         data++; 
*
01184:  INCF   x42,F
01186:  BTFSC  FD8.2
01188:  INCF   x43,F
*
0140C:  INCF   x42,F
0140E:  BTFSC  FD8.2
01410:  INCF   x43,F
....................         ptr++; 
*
0118A:  INCF   x45,F
0118C:  BTFSC  FD8.2
0118E:  INCF   x46,F
*
01412:  INCF   x45,F
01414:  BTFSC  FD8.2
01416:  INCF   x46,F
....................     } 
*
01190:  INCF   x44,F
01192:  BRA    1166
*
01418:  INCF   x44,F
0141A:  BRA    13EE
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
*
01194:  MOVLW  F1
01196:  ANDWF  F6F,W
01198:  MOVWF  F6F
*
0141C:  MOVLW  F1
0141E:  ANDWF  F6F,W
01420:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
*
0119A:  BCF    x37.7
0119C:  BTFSC  FA4.7
0119E:  BSF    x37.7
*
01422:  BCF    x37.7
01424:  BTFSC  FA4.7
01426:  BSF    x37.7
....................     CAN_INT_IRXIF = 0; 
*
011A0:  BCF    FA4.7
*
01428:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
*
011A2:  BTFSS  x37.4
011A4:  BRA    11AE
*
0142A:  BTFSS  x37.4
0142C:  BRA    1436
....................       RXB1CON.rxful=0; 
*
011A6:  MOVLB  F
011A8:  BCF    x50.7
*
0142E:  MOVLB  F
01430:  BCF    x50.7
....................     } 
....................     else { 
*
011AA:  BRA    11B2
011AC:  MOVLB  4
*
01432:  BRA    143A
01434:  MOVLB  4
....................       RXB0CON.rxful=0; 
*
011AE:  BCF    F60.7
011B0:  MOVLB  F
*
01436:  BCF    F60.7
01438:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
*
011B2:  MOVLW  01
011B4:  MOVWF  01
*
0143A:  MOVLW  01
0143C:  MOVWF  01
0143E:  MOVLB  4
.................... } 
....................  
....................  
....................  
....................  
.................... /** 
....................  * no comments 
....................  */ 
.................... #define dev1_ze 10 
....................  
.................... #define CAN_RECEIVE_STACK_SIZE 10 
.................... int can_rspoint=0; 
.................... int can_rstack [CAN_RECEIVE_STACK_SIZE] [14]; 
.................... int1 can_rsfull=FALSE; 
.................... #define can_receiver_full() can_rsfull 
.................... #define CAN_TRANSMIT_STACK_SIZE 10 
.................... int can_tspoint=0; 
.................... int can_tstack [CAN_TRANSMIT_STACK_SIZE] [13]; 
.................... int1 can_tsempty=TRUE; 
.................... #define can_transmitter_empty() can_tsempty 
.................... #define CAN_FILTER_SIZE 1 
.................... int32 can_filter [CAN_FILTER_SIZE] = {11}; 
....................  
....................  
.................... void canReceive ( ) 
.................... { 
....................    int32 rx_id; 
....................    int8  rx_len, rx_stat; 
....................    int8  buffer [8]; 
....................    int8  i; 
....................  
....................    if(can_rspoint==-1) 
*
01094:  MOVF   24,W
01096:  SUBLW  FF
01098:  BNZ   109C
....................       can_rspoint++; 
0109A:  INCF   24,F
....................  
....................    if(can_rspoint < CAN_RECEIVE_STACK_SIZE) 
0109C:  MOVF   24,W
0109E:  SUBLW  09
010A0:  BTFSS  FD8.0
010A2:  BRA    132C
....................    { 
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
010A4:  MOVLW  04
010A6:  MOVLB  4
010A8:  MOVWF  x43
010AA:  MOVLW  38
010AC:  MOVWF  x42
....................    { 
....................       int8 j; 
....................       for(j=0;j<CAN_FILTER_SIZE;j++) 
*
011B6:  MOVLB  4
011B8:  CLRF   x41
011BA:  MOVF   x41,F
011BC:  BNZ   11FE
....................          if(rx_id==can_filter[j]) 
011BE:  MOVF   x41,W
011C0:  MULLW  04
011C2:  MOVF   FF3,W
011C4:  CLRF   03
011C6:  ADDLW  35
011C8:  MOVWF  FE9
011CA:  MOVLW  01
011CC:  ADDWFC 03,W
011CE:  MOVWF  FEA
011D0:  MOVFF  FEF,00
011D4:  MOVFF  FEC,01
011D8:  MOVFF  FEC,02
011DC:  MOVFF  FEC,03
011E0:  MOVF   00,W
011E2:  SUBWF  x32,W
011E4:  BNZ   11FA
011E6:  MOVF   01,W
011E8:  SUBWF  x33,W
011EA:  BNZ   11FA
011EC:  MOVF   02,W
011EE:  SUBWF  x34,W
011F0:  BNZ   11FA
011F2:  MOVF   03,W
011F4:  SUBWF  x35,W
011F6:  BNZ   11FA
....................             return; 
011F8:  BRA    1440
011FA:  INCF   x41,F
011FC:  BRA    11BA
....................    } 
....................       can_rstack[can_rspoint][0]=make8(rx_id,3); 
011FE:  MOVF   24,W
01200:  MULLW  0E
01202:  MOVF   FF3,W
01204:  CLRF   x43
01206:  MOVWF  x42
01208:  MOVLW  25
0120A:  ADDWF  x42,W
0120C:  MOVWF  FE9
0120E:  MOVLW  00
01210:  ADDWFC x43,W
01212:  MOVWF  FEA
01214:  MOVFF  435,FEF
....................       can_rstack[can_rspoint][1]=make8(rx_id,2); 
01218:  MOVF   24,W
0121A:  MULLW  0E
0121C:  MOVF   FF3,W
0121E:  CLRF   x43
01220:  MOVWF  x42
01222:  MOVLW  01
01224:  ADDWF  x42,W
01226:  MOVWF  01
01228:  MOVLW  00
0122A:  ADDWFC x43,W
0122C:  MOVWF  03
0122E:  MOVF   01,W
01230:  ADDLW  25
01232:  MOVWF  FE9
01234:  MOVLW  00
01236:  ADDWFC 03,W
01238:  MOVWF  FEA
0123A:  MOVFF  434,FEF
....................       can_rstack[can_rspoint][2]=make8(rx_id,1); 
0123E:  MOVF   24,W
01240:  MULLW  0E
01242:  MOVF   FF3,W
01244:  CLRF   x43
01246:  MOVWF  x42
01248:  MOVLW  02
0124A:  ADDWF  x42,W
0124C:  MOVWF  01
0124E:  MOVLW  00
01250:  ADDWFC x43,W
01252:  MOVWF  03
01254:  MOVF   01,W
01256:  ADDLW  25
01258:  MOVWF  FE9
0125A:  MOVLW  00
0125C:  ADDWFC 03,W
0125E:  MOVWF  FEA
01260:  MOVFF  433,FEF
....................       can_rstack[can_rspoint][3]=make8(rx_id,0); 
01264:  MOVF   24,W
01266:  MULLW  0E
01268:  MOVF   FF3,W
0126A:  CLRF   x43
0126C:  MOVWF  x42
0126E:  MOVLW  03
01270:  ADDWF  x42,W
01272:  MOVWF  01
01274:  MOVLW  00
01276:  ADDWFC x43,W
01278:  MOVWF  03
0127A:  MOVF   01,W
0127C:  ADDLW  25
0127E:  MOVWF  FE9
01280:  MOVLW  00
01282:  ADDWFC 03,W
01284:  MOVWF  FEA
01286:  MOVFF  432,FEF
....................  
....................       can_rstack[can_rspoint][4]=rx_len; 
0128A:  MOVF   24,W
0128C:  MULLW  0E
0128E:  MOVF   FF3,W
01290:  CLRF   x43
01292:  MOVWF  x42
01294:  MOVLW  04
01296:  ADDWF  x42,W
01298:  MOVWF  01
0129A:  MOVLW  00
0129C:  ADDWFC x43,W
0129E:  MOVWF  03
012A0:  MOVF   01,W
012A2:  ADDLW  25
012A4:  MOVWF  FE9
012A6:  MOVLW  00
012A8:  ADDWFC 03,W
012AA:  MOVWF  FEA
012AC:  MOVFF  436,FEF
....................       can_rstack[can_rspoint][5]=rx_stat; 
012B0:  MOVF   24,W
012B2:  MULLW  0E
012B4:  MOVF   FF3,W
012B6:  CLRF   x43
012B8:  MOVWF  x42
012BA:  MOVLW  05
012BC:  ADDWF  x42,W
012BE:  MOVWF  01
012C0:  MOVLW  00
012C2:  ADDWFC x43,W
012C4:  MOVWF  03
012C6:  MOVF   01,W
012C8:  ADDLW  25
012CA:  MOVWF  FE9
012CC:  MOVLW  00
012CE:  ADDWFC 03,W
012D0:  MOVWF  FEA
012D2:  MOVFF  437,FEF
....................  
....................       for(i=0;i<rx_len;i++) 
012D6:  CLRF   x40
012D8:  MOVF   x36,W
012DA:  SUBWF  x40,W
012DC:  BC    1326
....................       { 
....................          can_rstack[can_rspoint][i+6]=buffer[i]; 
012DE:  MOVF   24,W
012E0:  MULLW  0E
012E2:  MOVF   FF3,W
012E4:  CLRF   x43
012E6:  MOVWF  x42
012E8:  MOVLW  06
012EA:  ADDWF  x40,W
012EC:  CLRF   03
012EE:  ADDWF  x42,W
012F0:  MOVWF  01
012F2:  MOVF   x43,W
012F4:  ADDWFC 03,F
012F6:  MOVF   01,W
012F8:  ADDLW  25
012FA:  MOVWF  01
012FC:  MOVLW  00
012FE:  ADDWFC 03,F
01300:  MOVFF  03,443
01304:  CLRF   03
01306:  MOVF   x40,W
01308:  ADDLW  38
0130A:  MOVWF  FE9
0130C:  MOVLW  04
0130E:  ADDWFC 03,W
01310:  MOVWF  FEA
01312:  MOVFF  FEF,444
01316:  MOVFF  443,FEA
0131A:  MOVFF  01,FE9
0131E:  MOVFF  444,FEF
....................       } 
01322:  INCF   x40,F
01324:  BRA    12D8
....................  
....................       can_rspoint++; 
01326:  INCF   24,F
....................    } 
....................    else 
01328:  BRA    1440
0132A:  MOVLB  0
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
0132C:  MOVLW  04
0132E:  MOVLB  4
01330:  MOVWF  x43
01332:  MOVLW  38
01334:  MOVWF  x42
.................... } 
*
01440:  MOVLB  0
01442:  RETLW  00
....................  
....................  
.................... int1 can_Pop ( int32 & rx_id, int * buffer, int & rx_len, int & rx_stat ) 
.................... { 
....................    int i; 
....................  
....................    if(can_rspoint==CAN_RECEIVE_STACK_SIZE) 
....................       can_rspoint--; 
....................  
....................    if(can_rspoint!=-1) 
....................    { 
....................       rx_id=make32(can_rstack[can_rspoint][0], 
....................                   can_rstack[can_rspoint][1], 
....................                   can_rstack[can_rspoint][2], 
....................                   can_rstack[can_rspoint][3]); 
....................  
....................       rx_len=can_rstack[can_rspoint][4]; 
....................       rx_stat=can_rstack[can_rspoint][5]; 
....................  
....................       for(i=0;i<rx_len;i++) 
....................       { 
....................          buffer[i]=can_rstack[can_rspoint][i+6]; 
....................       } 
....................       can_rspoint--; 
....................  
....................       return TRUE; 
....................    }    
....................    else 
....................    return FALSE; 
.................... } 
....................  
.................... void canTransmit ( ) 
.................... { 
....................    int32 tx_id; 
....................    int8  tx_length; 
....................    int8  tx_priority; 
....................    int8  tx_buffer[8]; 
....................    int1  tx_extendedID; 
....................    int1  tx_emptyframe; 
....................    int8  i; 
....................  
....................    if(can_tspoint==CAN_TRANSMIT_STACK_SIZE) 
*
0165A:  MOVF   xB2,W
0165C:  SUBLW  0A
0165E:  BNZ   1662
....................    { 
....................       can_tspoint--; 
01660:  DECF   xB2,F
....................    } 
....................  
....................    if(can_tspoint!=-1) 
01662:  MOVF   xB2,W
01664:  SUBLW  FF
01666:  BTFSC  FD8.2
01668:  BRA    1870
....................    { 
....................  
....................       tx_id=make32(can_tstack[can_tspoint][0], 
....................                   can_tstack[can_tspoint][1], 
....................                   can_tstack[can_tspoint][2], 
....................                   can_tstack[can_tspoint][3]); 
0166A:  MOVF   xB2,W
0166C:  MULLW  0D
0166E:  MOVF   FF3,W
01670:  MOVLB  4
01672:  CLRF   x43
01674:  MOVWF  x42
01676:  MOVLW  B3
01678:  ADDWF  x42,W
0167A:  MOVWF  FE9
0167C:  MOVLW  00
0167E:  ADDWFC x43,W
01680:  MOVWF  FEA
01682:  MOVFF  FEF,442
01686:  MOVLB  0
01688:  MOVF   xB2,W
0168A:  MULLW  0D
0168C:  MOVF   FF3,W
0168E:  MOVLB  4
01690:  CLRF   x44
01692:  MOVWF  x43
01694:  MOVLW  01
01696:  ADDWF  x43,W
01698:  MOVWF  01
0169A:  MOVLW  00
0169C:  ADDWFC x44,W
0169E:  MOVWF  03
016A0:  MOVF   01,W
016A2:  ADDLW  B3
016A4:  MOVWF  FE9
016A6:  MOVLW  00
016A8:  ADDWFC 03,W
016AA:  MOVWF  FEA
016AC:  MOVFF  FEF,443
016B0:  MOVLB  0
016B2:  MOVF   xB2,W
016B4:  MULLW  0D
016B6:  MOVF   FF3,W
016B8:  MOVLB  4
016BA:  CLRF   x45
016BC:  MOVWF  x44
016BE:  MOVLW  02
016C0:  ADDWF  x44,W
016C2:  MOVWF  01
016C4:  MOVLW  00
016C6:  ADDWFC x45,W
016C8:  MOVWF  03
016CA:  MOVF   01,W
016CC:  ADDLW  B3
016CE:  MOVWF  FE9
016D0:  MOVLW  00
016D2:  ADDWFC 03,W
016D4:  MOVWF  FEA
016D6:  MOVFF  FEF,444
016DA:  MOVLB  0
016DC:  MOVF   xB2,W
016DE:  MULLW  0D
016E0:  MOVF   FF3,W
016E2:  MOVLB  4
016E4:  CLRF   x46
016E6:  MOVWF  x45
016E8:  MOVLW  03
016EA:  ADDWF  x45,W
016EC:  MOVWF  01
016EE:  MOVLW  00
016F0:  ADDWFC x46,W
016F2:  MOVWF  03
016F4:  MOVF   01,W
016F6:  ADDLW  B3
016F8:  MOVWF  FE9
016FA:  MOVLW  00
016FC:  ADDWFC 03,W
016FE:  MOVWF  FEA
01700:  MOVFF  FEF,445
01704:  MOVFF  442,435
01708:  MOVFF  443,434
0170C:  MOVFF  444,433
01710:  MOVFF  445,432
....................  
....................       tx_length=can_tstack[can_tspoint][12]>>4; 
01714:  MOVLB  0
01716:  MOVF   xB2,W
01718:  MULLW  0D
0171A:  MOVF   FF3,W
0171C:  MOVLB  4
0171E:  CLRF   x43
01720:  MOVWF  x42
01722:  MOVLW  0C
01724:  ADDWF  x42,W
01726:  MOVWF  01
01728:  MOVLW  00
0172A:  ADDWFC x43,W
0172C:  MOVWF  03
0172E:  MOVF   01,W
01730:  ADDLW  B3
01732:  MOVWF  FE9
01734:  MOVLW  00
01736:  ADDWFC 03,W
01738:  MOVWF  FEA
0173A:  SWAPF  FEF,W
0173C:  MOVWF  x36
0173E:  MOVLW  0F
01740:  ANDWF  x36,F
....................       tx_priority=(can_tstack[can_tspoint][12]&0x0c)>>2; 
01742:  MOVLB  0
01744:  MOVF   xB2,W
01746:  MULLW  0D
01748:  MOVF   FF3,W
0174A:  MOVLB  4
0174C:  CLRF   x43
0174E:  MOVWF  x42
01750:  MOVLW  0C
01752:  ADDWF  x42,W
01754:  MOVWF  01
01756:  MOVLW  00
01758:  ADDWFC x43,W
0175A:  MOVWF  03
0175C:  MOVF   01,W
0175E:  ADDLW  B3
01760:  MOVWF  FE9
01762:  MOVLW  00
01764:  ADDWFC 03,W
01766:  MOVWF  FEA
01768:  MOVF   FEF,W
0176A:  ANDLW  0C
0176C:  MOVWF  00
0176E:  RRCF   00,W
01770:  MOVWF  x37
01772:  RRCF   x37,F
01774:  MOVLW  3F
01776:  ANDWF  x37,F
....................       tx_extendedID=bit_test(can_tstack[can_tspoint][12],1); 
01778:  MOVLB  0
0177A:  MOVF   xB2,W
0177C:  MULLW  0D
0177E:  MOVF   FF3,W
01780:  MOVLB  4
01782:  CLRF   x43
01784:  MOVWF  x42
01786:  MOVLW  0C
01788:  ADDWF  x42,W
0178A:  MOVWF  01
0178C:  MOVLW  00
0178E:  ADDWFC x43,W
01790:  MOVWF  03
01792:  MOVF   01,W
01794:  ADDLW  B3
01796:  MOVWF  FE9
01798:  MOVLW  00
0179A:  ADDWFC 03,W
0179C:  MOVWF  FEA
0179E:  MOVFF  FEF,442
017A2:  BCF    x40.0
017A4:  BTFSC  x42.1
017A6:  BSF    x40.0
....................       tx_emptyframe=bit_test(can_tstack[can_tspoint][12],0); 
017A8:  MOVLB  0
017AA:  MOVF   xB2,W
017AC:  MULLW  0D
017AE:  MOVF   FF3,W
017B0:  MOVLB  4
017B2:  CLRF   x43
017B4:  MOVWF  x42
017B6:  MOVLW  0C
017B8:  ADDWF  x42,W
017BA:  MOVWF  01
017BC:  MOVLW  00
017BE:  ADDWFC x43,W
017C0:  MOVWF  03
017C2:  MOVF   01,W
017C4:  ADDLW  B3
017C6:  MOVWF  FE9
017C8:  MOVLW  00
017CA:  ADDWFC 03,W
017CC:  MOVWF  FEA
017CE:  MOVFF  FEF,442
017D2:  BCF    x40.1
017D4:  BTFSC  x42.0
017D6:  BSF    x40.1
....................  
....................       for(i=0;i<tx_length;i++) 
017D8:  CLRF   x41
017DA:  MOVF   x36,W
017DC:  SUBWF  x41,W
017DE:  BC    1830
....................       { 
....................          tx_buffer[i]=can_tstack[can_tspoint][i+4]; 
017E0:  CLRF   03
017E2:  MOVF   x41,W
017E4:  ADDLW  38
017E6:  MOVWF  01
017E8:  MOVLW  04
017EA:  ADDWFC 03,F
017EC:  MOVFF  01,442
017F0:  MOVFF  03,443
017F4:  MOVLB  0
017F6:  MOVF   xB2,W
017F8:  MULLW  0D
017FA:  MOVF   FF3,W
017FC:  MOVLB  4
017FE:  CLRF   x45
01800:  MOVWF  x44
01802:  MOVLW  04
01804:  ADDWF  x41,W
01806:  CLRF   03
01808:  ADDWF  x44,W
0180A:  MOVWF  01
0180C:  MOVF   x45,W
0180E:  ADDWFC 03,F
01810:  MOVF   01,W
01812:  ADDLW  B3
01814:  MOVWF  FE9
01816:  MOVLW  00
01818:  ADDWFC 03,W
0181A:  MOVWF  FEA
0181C:  MOVFF  FEF,444
01820:  MOVFF  443,FEA
01824:  MOVFF  442,FE9
01828:  MOVFF  444,FEF
....................       } 
0182C:  INCF   x41,F
0182E:  BRA    17DA
....................  
....................       can_putd(tx_id,tx_buffer,tx_length,tx_priority,tx_extendedID,tx_emptyframe); 
01830:  MOVLW  00
01832:  BTFSC  x40.0
01834:  MOVLW  01
01836:  MOVWF  x42
01838:  MOVLW  00
0183A:  BTFSC  x40.1
0183C:  MOVLW  01
0183E:  MOVWF  x43
01840:  MOVFF  435,447
01844:  MOVFF  434,446
01848:  MOVFF  433,445
0184C:  MOVFF  432,444
01850:  MOVLW  04
01852:  MOVWF  x49
01854:  MOVLW  38
01856:  MOVWF  x48
01858:  MOVFF  436,44A
0185C:  MOVFF  437,44B
01860:  MOVFF  442,44C
01864:  MOVFF  443,44D
01868:  MOVLB  0
0186A:  BRA    1588
....................  
....................       can_tspoint--; 
0186C:  DECF   xB2,F
....................    } 
....................    else 
0186E:  BRA    1872
....................       return; 
01870:  BRA    1872
.................... } 
01872:  RETLW  00
....................  
....................  
.................... int1 can_push (int32 tx_id, int8 * tx_buffer, int8 tx_length, int8 tx_priority, int1 tx_extendedID, int1 tx_emptyframe) 
.................... { 
....................    int8  i; 
....................    if(can_tspoint==-1) 
....................       can_tspoint++; 
....................  
....................    if(can_tspoint < CAN_TRANSMIT_STACK_SIZE) 
....................    { 
....................       can_tstack[can_tspoint][0]=make8(tx_id,3); 
....................       can_tstack[can_tspoint][1]=make8(tx_id,2); 
....................       can_tstack[can_tspoint][2]=make8(tx_id,1); 
....................       can_tstack[can_tspoint][3]=make8(tx_id,0); 
....................  
....................       for(i=0;i<tx_length;i++) 
....................       { 
....................          can_tstack[can_tspoint][i+4]=tx_buffer[i]; 
....................       } 
....................  
....................       can_tstack[can_tspoint][12]=(tx_length<<4)|(tx_priority<<2)|((int8)tx_extendedID<<1)|((int8)tx_emptyframe); 
....................  
....................       can_tspoint++; 
....................    } 
.................... } 
....................  
.................... int temp; 
.................... #include "struct_and_enums.c" 
.................... void copy_array(unsigned int *origin,unsigned int *destination, unsigned int n_elements) 
.................... { 
....................    int x; 
....................    for (x=0;x<n_elements;++x) 
....................    { 
....................       *destination=*origin; 
....................    } 
.................... } 
.................... enum switch_outstate {on, off, dimming, dimmed, maxed}; 
.................... enum switch_direction {up, down}; 
.................... enum switch_state {button_pressed, button_depressed}; 
.................... enum output_type {_on_off, dimmer,shutter}; 
.................... enum output_state {_on, _off, _dimmed}; 
.................... enum timer_type {time_on, time_off, periodic_on}; 
.................... enum input_type {dimmer_switch,on_off_switch,button_switch,timer,none}; 
....................  
.................... void dimmer_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input); 
.................... typedef struct data_point_out 
.................... { 
....................    unsigned int adress; 
....................    unsigned int value; 
....................    int1 needs_update; 
.................... }; 
.................... typedef struct data_point_in 
.................... { 
....................    unsigned int adress[8]; 
....................    unsigned int value; 
....................    int1 needs_update; 
.................... }; 
.................... ///////////////////////INPUTS////////////////////////////////////// 
.................... typedef struct dimmer_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out dim_level; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    unsigned int current_level; 
....................    int32  timer; 
....................    switch_state current_state; 
....................    switch_state previous_state; 
....................    switch_direction direction; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
.................... typedef struct on_off_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................     switch_state current_state; 
....................    switch_state previous_state; 
....................    int32  timer; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
....................  
.................... typedef struct button_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    switch_state current_state; 
....................    switch_state previous_state; 
....................    int32  timer; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
....................  
.................... typedef struct timer 
.................... { 
....................    timer_type type; 
....................    int32 timeToAct; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    int32  timer; 
.................... }; 
.................... union input 
.................... { 
....................    struct on_off_switch; 
....................    struct dimmer_switch; 
....................    struct timer; 
....................    struct button_switch; 
.................... }; 
....................  
.................... typedef struct inputs 
.................... { 
....................    enum input_type type; 
....................    union input device; 
.................... }; 
.................... ///////////////////////OUTPUTS////////////////////////////////////// 
.................... struct light 
.................... { 
....................    struct data_point_in on; 
....................    struct data_point_in off; 
....................    struct data_point_in dim_value; 
....................    enum output_state out_state; 
....................    unsigned int output_pin; 
....................    int internal_order; 
....................    int1  needs_update; 
.................... }; 
....................  
.................... union output 
.................... { 
....................    struct light; 
.................... }; 
....................  
.................... typedef struct outputs 
.................... { 
....................    enum output_type type; 
....................    union output device; 
.................... }; 
....................  
.................... typedef struct devices 
.................... { 
....................       unsigned int numberOfInputs; 
....................       unsigned int numberOfOutputs; 
....................       struct inputs myinputs[10]; 
....................       struct outputs myoutputs[10]; 
.................... }devicestype; 
....................  
.................... devicestype mydevices; 
....................  
.................... ///////INPUTS INITIALIZATION////////////////////////////////////////////////// 
.................... void dimmer_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input,unsigned int real_button) 
.................... { 
....................       struct dimmer_switch sw; 
....................       input->type=dimmer_switch; 
....................       sw.dim_level.adress=dim_adr; 
....................       sw.on.adress=on_adr; 
....................       sw.off.adress=off_adr; 
....................       sw.previous_state=button_depressed; 
....................       sw.outstate=off; 
....................       sw.current_level=0; 
....................       sw.direction=up; 
....................       sw.dim_level.needs_update=0; 
....................       sw.on.needs_update=0; 
....................       sw.off.needs_update=0; 
....................       sw.dim_level.value=0; 
....................       sw.on.value=0; 
....................       sw.off.value=0; 
....................       sw.realbutton=inputs[real_button]; 
....................       sw.timer=0; 
....................       input->device=sw; 
.................... } 
.................... void on_off_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input,unsigned int real_button) 
.................... { 
....................       struct on_off_switch sw; 
....................       input->type=on_off_switch; 
....................       sw.on.adress=on_adr; 
....................       sw.off.adress=off_adr; 
....................       sw.previous_state=button_depressed; 
....................       sw.outstate=off; 
....................       sw.on.needs_update=0; 
....................       sw.off.needs_update=0; 
....................       sw.on.value=0; 
....................       sw.off.value=0; 
....................       sw.realbutton=inputs[real_button]; 
....................       input->device=sw; 
.................... } 
.................... void button_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input,unsigned int real_button) 
.................... { 
....................       struct button_switch sw; 
....................       input->type=button_switch; 
*
01B98:  MOVLB  4
01B9A:  MOVFF  420,FE9
01B9E:  MOVFF  421,FEA
01BA2:  MOVLW  02
01BA4:  MOVWF  FEF
....................       sw.on.adress=on_adr; 
01BA6:  MOVFF  41E,423
....................       sw.off.adress=off_adr; 
01BAA:  MOVFF  41F,426
....................       sw.previous_state=button_depressed; 
01BAE:  BSF    x29.1
....................       sw.outstate=off; 
01BB0:  MOVLW  01
01BB2:  MOVWF  x2E
....................       sw.on.needs_update=0; 
01BB4:  BCF    x25.0
....................       sw.off.needs_update=0; 
01BB6:  BCF    x28.0
....................       sw.on.value=0; 
01BB8:  CLRF   x24
....................       sw.off.value=0; 
01BBA:  CLRF   x27
....................       sw.realbutton=inputs[real_button]; 
01BBC:  CLRF   03
01BBE:  MOVF   x22,W
01BC0:  ADDLW  1C
01BC2:  MOVWF  FE9
01BC4:  MOVLW  00
01BC6:  ADDWFC 03,W
01BC8:  MOVWF  FEA
01BCA:  MOVFF  FEF,42F
....................       input->device=sw; 
01BCE:  MOVLW  01
01BD0:  ADDWF  x20,W
01BD2:  MOVWF  FE9
01BD4:  MOVLW  00
01BD6:  ADDWFC x21,W
01BD8:  MOVWF  FEA
01BDA:  MOVLW  04
01BDC:  MOVWF  FE2
01BDE:  MOVLW  23
01BE0:  MOVWF  FE1
01BE2:  MOVLW  11
01BE4:  MOVWF  01
01BE6:  MOVFF  FE6,FEE
01BEA:  DECFSZ 01,F
01BEC:  BRA    1BE6
.................... } 
01BEE:  MOVLB  0
01BF0:  GOTO   1C14 (RETURN)
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... ///////INPUTS INITIALIZATION////////////////////////////////////////////////// 
.................... void dimmer_out_init(unsigned int *dim_adr,unsigned int *on_adr,unsigned int *off_adr,struct outputs* output,unsigned int output_pin) 
.................... { 
....................    struct light lg; 
....................    output->type=dimmer; 
....................    lg.dim_value.needs_update=0; 
....................    lg.on.needs_update=0; 
....................    lg.off.needs_update=0; 
....................    lg.dim_value.value=0; 
....................    lg.on.value=0; 
....................    lg.off.value=0; 
....................    lg.output_pin=output_pin; 
....................    copy_array(dim_adr,&lg.dim_value.adress,8); 
....................    copy_array(on_adr,&lg.on.adress,8); 
....................    copy_array(off_adr,&lg.off.adress,8); 
....................    lg.out_state=_off; 
....................    output->device=lg; 
.................... } 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void test() 
.................... {     mydevices.numberOfInputs=1; 
01BF4:  MOVLW  01
01BF6:  MOVLB  1
01BF8:  MOVWF  x3A
....................     //  struct dimmer_switch sw; 
....................     //  sw.dim_level.value=69; 
....................     //  mydevices.myinputs[0].device=sw; 
....................     //  printf("VALUE=%u\n\r",mydevices.myinputs[0].device.dim_level.value); 
....................     //  on_off_init(1,2,3,&mydevices.myinputs[0],0); 
....................     button_init(1,2,3,&mydevices.myinputs[0],0); 
01BFA:  MOVLB  4
01BFC:  MOVWF  x1D
01BFE:  MOVLW  02
01C00:  MOVWF  x1E
01C02:  MOVLW  03
01C04:  MOVWF  x1F
01C06:  MOVLW  01
01C08:  MOVWF  x21
01C0A:  MOVLW  3C
01C0C:  MOVWF  x20
01C0E:  CLRF   x22
01C10:  MOVLB  0
01C12:  BRA    1B98
....................      // dimmer_init(1,2,3,&mydevices.myinputs[0],0); 
....................       //printf("VALUE=%u\n\r",mydevices.myinputs[0].device.dim_level.value); 
....................      // while(true){}; 
.................... } 
01C14:  GOTO   232C (RETURN)
....................  
....................  
....................  
.................... #include "dimming_functions.c" 
.................... #define N_LUZES 16 //numero maximo de dimmers 
.................... int used_dimmers=0; 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
....................  
.................... int1 organizado;//flag que diz se os dimmings estao organizados 
.................... int1 actmat=0;//matriz em uso 
.................... int16 pointer;//apontador para matriz em uso 
.................... int vez;//indice da matriz de dimming corrente 
.................... int mnumluzes;//quantos valores de dimming diferentes temos 
.................... int16 dimmers_off_value; 
.................... int ltlevel[N_LUZES]={10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10}; 
.................... int16 delays1[N_LUZES+1][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15}; 
.................... int16 delays2[N_LUZES+1][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15}; 
.................... const int16 light_pins[N_LUZES]={0b1111111011111111,0b1111110111111111,0b1111101111111111,0b1111011111111111,0b1110111111111111,0b1101111111111111,0b1011111111111111,0b0111111111111111, 
....................          /*<........................................................................portC..................................................................................>*/ 
.................... 0b1111111111111110,0b1111111111111101,0b1111111111111011,0b1111111111110111,0b1111111111101111,0b1111111111011111,0b1111111110111111,0b1111111101111111}; 
.................... /*<.................................................................................portD.............................................................>*/ 
.................... int16 lights[N_LUZES]; 
.................... const long Matrizluz[128]={ 
.................... 38400,38731 , 38492 , 38253 , 38014 , 37775 , 37536 , 37297 , 37058 , 36819 , 36580 
.................... , 36341 , 36102 , 35863 , 35624 , 35385 , 35146 , 34907 , 34668 , 34429 , 34190 , 33951 
....................  , 33712 , 33473 , 33234 , 32995 , 32756 , 32517 , 32278 , 32039 , 31800 , 31561 , 31322 
....................  , 31083 , 30844 , 30605 , 30366 , 30127 , 29888 , 29649 , 29410 , 29171 , 28932 , 28693 
....................  , 28454 , 28215 , 27976 , 27737 , 27498 , 27259 , 27020 , 26781 , 26542 , 26303 , 26064 
....................  , 25825 , 25586 , 25347 , 25108 , 24869 , 24630 , 24391 , 24152 , 23913 , 23674 , 23435 
....................  , 23196 , 22957 , 22718 , 22479 , 22240 , 22001 , 21762 , 21523 , 21284 , 21045 , 20806 
....................  , 20567 , 20328 , 20089 , 19850 , 19611 , 19372 , 19133 , 18894 , 18655 , 18416 , 18177 
....................  , 17938 , 17699 , 17460 , 17221 , 16982 , 16743 , 16504 , 16265 , 16026 , 15787 , 15548 
....................  , 15309 , 15070 , 14831 , 14592 , 14353 , 14114 , 13875 , 13636 , 13397 , 13158 , 12919 
....................  , 12680 , 12441 , 12202 , 11963 , 11724 , 11485 , 11246 , 11007 , 10768 , 10529 , 10290 
....................  , 10051 , 9812 , 9573 , 9334 , 9095 , 8856 , 617 }; 
....................   
....................   
....................  #INLINE 
....................   INT16 fpointer(int ax,int ay) 
....................    { 
....................       int16 * p; 
....................       p=(pointer + 2* ax * 2 + 2*ay); 
*
00D72:  BCF    FD8.0
00D74:  RLCF   x34,W
00D76:  MOVWF  00
00D78:  BCF    FD8.0
00D7A:  RLCF   00,F
00D7C:  MOVF   00,W
00D7E:  MOVLB  3
00D80:  ADDWF  x4F,W
00D82:  MOVLB  4
00D84:  MOVWF  x38
00D86:  MOVLW  00
00D88:  MOVLB  3
00D8A:  ADDWFC x50,W
00D8C:  MOVLB  4
00D8E:  MOVWF  x39
00D90:  BCF    FD8.0
00D92:  RLCF   x35,W
00D94:  ADDWF  x38,W
00D96:  MOVWF  x36
00D98:  MOVLW  00
00D9A:  ADDWFC x39,W
00D9C:  MOVWF  x37
*
00E0A:  BCF    FD8.0
00E0C:  RLCF   x34,W
00E0E:  MOVWF  00
00E10:  BCF    FD8.0
00E12:  RLCF   00,F
00E14:  MOVF   00,W
00E16:  MOVLB  3
00E18:  ADDWF  x4F,W
00E1A:  MOVLB  4
00E1C:  MOVWF  x38
00E1E:  MOVLW  00
00E20:  MOVLB  3
00E22:  ADDWFC x50,W
00E24:  MOVLB  4
00E26:  MOVWF  x39
00E28:  BCF    FD8.0
00E2A:  RLCF   x35,W
00E2C:  ADDWF  x38,W
00E2E:  MOVWF  x36
00E30:  MOVLW  00
00E32:  ADDWFC x39,W
00E34:  MOVWF  x37
*
018AA:  BCF    FD8.0
018AC:  RLCF   x34,W
018AE:  MOVWF  00
018B0:  BCF    FD8.0
018B2:  RLCF   00,F
018B4:  MOVF   00,W
018B6:  MOVLB  3
018B8:  ADDWF  x4F,W
018BA:  MOVLB  4
018BC:  MOVWF  x38
018BE:  MOVLW  00
018C0:  MOVLB  3
018C2:  ADDWFC x50,W
018C4:  MOVLB  4
018C6:  MOVWF  x39
018C8:  BCF    FD8.0
018CA:  RLCF   x35,W
018CC:  ADDWF  x38,W
018CE:  MOVWF  x36
018D0:  MOVLW  00
018D2:  ADDWFC x39,W
018D4:  MOVWF  x37
*
01932:  BCF    FD8.0
01934:  RLCF   x34,W
01936:  MOVWF  00
01938:  BCF    FD8.0
0193A:  RLCF   00,F
0193C:  MOVF   00,W
0193E:  MOVLB  3
01940:  ADDWF  x4F,W
01942:  MOVLB  4
01944:  MOVWF  x38
01946:  MOVLW  00
01948:  MOVLB  3
0194A:  ADDWFC x50,W
0194C:  MOVLB  4
0194E:  MOVWF  x39
01950:  BCF    FD8.0
01952:  RLCF   x35,W
01954:  ADDWF  x38,W
01956:  MOVWF  x36
01958:  MOVLW  00
0195A:  ADDWFC x39,W
0195C:  MOVWF  x37
*
0234A:  BCF    FD8.0
0234C:  RLCF   x34,W
0234E:  MOVWF  00
02350:  BCF    FD8.0
02352:  RLCF   00,F
02354:  MOVF   00,W
02356:  MOVLB  3
02358:  ADDWF  x4F,W
0235A:  MOVLB  4
0235C:  MOVWF  x38
0235E:  MOVLW  00
02360:  MOVLB  3
02362:  ADDWFC x50,W
02364:  MOVLB  4
02366:  MOVWF  x39
02368:  BCF    FD8.0
0236A:  RLCF   x35,W
0236C:  ADDWF  x38,W
0236E:  MOVWF  x36
02370:  MOVLW  00
02372:  ADDWFC x39,W
02374:  MOVWF  x37
*
023C4:  BCF    FD8.0
023C6:  RLCF   x34,W
023C8:  MOVWF  00
023CA:  BCF    FD8.0
023CC:  RLCF   00,F
023CE:  MOVF   00,W
023D0:  MOVLB  3
023D2:  ADDWF  x4F,W
023D4:  MOVLB  4
023D6:  MOVWF  x38
023D8:  MOVLW  00
023DA:  MOVLB  3
023DC:  ADDWFC x50,W
023DE:  MOVLB  4
023E0:  MOVWF  x39
023E2:  BCF    FD8.0
023E4:  RLCF   x35,W
023E6:  ADDWF  x38,W
023E8:  MOVWF  x36
023EA:  MOVLW  00
023EC:  ADDWFC x39,W
023EE:  MOVWF  x37
*
02490:  BCF    FD8.0
02492:  RLCF   x34,W
02494:  MOVWF  00
02496:  BCF    FD8.0
02498:  RLCF   00,F
0249A:  MOVF   00,W
0249C:  MOVLB  3
0249E:  ADDWF  x4F,W
024A0:  MOVLB  4
024A2:  MOVWF  x38
024A4:  MOVLW  00
024A6:  MOVLB  3
024A8:  ADDWFC x50,W
024AA:  MOVLB  4
024AC:  MOVWF  x39
024AE:  BCF    FD8.0
024B0:  RLCF   x35,W
024B2:  ADDWF  x38,W
024B4:  MOVWF  x36
024B6:  MOVLW  00
024B8:  ADDWFC x39,W
024BA:  MOVWF  x37
....................      RETURN *(int16*)(pointer + 2* ax * 2 + 2*ay); 
*
00D9E:  BCF    FD8.0
00DA0:  RLCF   x34,W
00DA2:  MOVWF  00
00DA4:  BCF    FD8.0
00DA6:  RLCF   00,F
00DA8:  MOVF   00,W
00DAA:  MOVLB  3
00DAC:  ADDWF  x4F,W
00DAE:  MOVLB  4
00DB0:  MOVWF  x38
00DB2:  MOVLW  00
00DB4:  MOVLB  3
00DB6:  ADDWFC x50,W
00DB8:  MOVLB  4
00DBA:  MOVWF  x39
00DBC:  BCF    FD8.0
00DBE:  RLCF   x35,W
00DC0:  ADDWF  x38,W
00DC2:  MOVWF  01
00DC4:  MOVLW  00
00DC6:  ADDWFC x39,W
00DC8:  MOVWF  03
00DCA:  MOVFF  01,FE9
00DCE:  MOVWF  FEA
00DD0:  MOVFF  FEF,01
00DD4:  INCF   FE9,F
00DD6:  MOVF   FEF,W
00DD8:  DECF   FE9,F
00DDA:  MOVWF  02
*
00E36:  BCF    FD8.0
00E38:  RLCF   x34,W
00E3A:  MOVWF  00
00E3C:  BCF    FD8.0
00E3E:  RLCF   00,F
00E40:  MOVF   00,W
00E42:  MOVLB  3
00E44:  ADDWF  x4F,W
00E46:  MOVLB  4
00E48:  MOVWF  x38
00E4A:  MOVLW  00
00E4C:  MOVLB  3
00E4E:  ADDWFC x50,W
00E50:  MOVLB  4
00E52:  MOVWF  x39
00E54:  BCF    FD8.0
00E56:  RLCF   x35,W
00E58:  ADDWF  x38,W
00E5A:  MOVWF  01
00E5C:  MOVLW  00
00E5E:  ADDWFC x39,W
00E60:  MOVWF  03
00E62:  MOVFF  01,FE9
00E66:  MOVWF  FEA
00E68:  MOVFF  FEF,01
00E6C:  INCF   FE9,F
00E6E:  MOVF   FEF,W
00E70:  DECF   FE9,F
00E72:  MOVWF  02
*
018D6:  BCF    FD8.0
018D8:  RLCF   x34,W
018DA:  MOVWF  00
018DC:  BCF    FD8.0
018DE:  RLCF   00,F
018E0:  MOVF   00,W
018E2:  MOVLB  3
018E4:  ADDWF  x4F,W
018E6:  MOVLB  4
018E8:  MOVWF  x38
018EA:  MOVLW  00
018EC:  MOVLB  3
018EE:  ADDWFC x50,W
018F0:  MOVLB  4
018F2:  MOVWF  x39
018F4:  BCF    FD8.0
018F6:  RLCF   x35,W
018F8:  ADDWF  x38,W
018FA:  MOVWF  01
018FC:  MOVLW  00
018FE:  ADDWFC x39,W
01900:  MOVWF  03
01902:  MOVFF  01,FE9
01906:  MOVWF  FEA
01908:  MOVFF  FEF,01
0190C:  INCF   FE9,F
0190E:  MOVF   FEF,W
01910:  DECF   FE9,F
01912:  MOVWF  02
*
0195E:  BCF    FD8.0
01960:  RLCF   x34,W
01962:  MOVWF  00
01964:  BCF    FD8.0
01966:  RLCF   00,F
01968:  MOVF   00,W
0196A:  MOVLB  3
0196C:  ADDWF  x4F,W
0196E:  MOVLB  4
01970:  MOVWF  x38
01972:  MOVLW  00
01974:  MOVLB  3
01976:  ADDWFC x50,W
01978:  MOVLB  4
0197A:  MOVWF  x39
0197C:  BCF    FD8.0
0197E:  RLCF   x35,W
01980:  ADDWF  x38,W
01982:  MOVWF  01
01984:  MOVLW  00
01986:  ADDWFC x39,W
01988:  MOVWF  03
0198A:  MOVFF  01,FE9
0198E:  MOVWF  FEA
01990:  MOVFF  FEF,01
01994:  INCF   FE9,F
01996:  MOVF   FEF,W
01998:  DECF   FE9,F
0199A:  MOVWF  02
*
02376:  BCF    FD8.0
02378:  RLCF   x34,W
0237A:  MOVWF  00
0237C:  BCF    FD8.0
0237E:  RLCF   00,F
02380:  MOVF   00,W
02382:  MOVLB  3
02384:  ADDWF  x4F,W
02386:  MOVLB  4
02388:  MOVWF  x38
0238A:  MOVLW  00
0238C:  MOVLB  3
0238E:  ADDWFC x50,W
02390:  MOVLB  4
02392:  MOVWF  x39
02394:  BCF    FD8.0
02396:  RLCF   x35,W
02398:  ADDWF  x38,W
0239A:  MOVWF  01
0239C:  MOVLW  00
0239E:  ADDWFC x39,W
023A0:  MOVWF  03
023A2:  MOVFF  01,FE9
023A6:  MOVWF  FEA
023A8:  MOVFF  FEF,01
023AC:  INCF   FE9,F
023AE:  MOVF   FEF,W
023B0:  DECF   FE9,F
023B2:  MOVWF  02
*
023F0:  BCF    FD8.0
023F2:  RLCF   x34,W
023F4:  MOVWF  00
023F6:  BCF    FD8.0
023F8:  RLCF   00,F
023FA:  MOVF   00,W
023FC:  MOVLB  3
023FE:  ADDWF  x4F,W
02400:  MOVLB  4
02402:  MOVWF  x38
02404:  MOVLW  00
02406:  MOVLB  3
02408:  ADDWFC x50,W
0240A:  MOVLB  4
0240C:  MOVWF  x39
0240E:  BCF    FD8.0
02410:  RLCF   x35,W
02412:  ADDWF  x38,W
02414:  MOVWF  01
02416:  MOVLW  00
02418:  ADDWFC x39,W
0241A:  MOVWF  03
0241C:  MOVFF  01,FE9
02420:  MOVWF  FEA
02422:  MOVFF  FEF,01
02426:  INCF   FE9,F
02428:  MOVF   FEF,W
0242A:  DECF   FE9,F
0242C:  MOVWF  02
*
024BC:  BCF    FD8.0
024BE:  RLCF   x34,W
024C0:  MOVWF  00
024C2:  BCF    FD8.0
024C4:  RLCF   00,F
024C6:  MOVF   00,W
024C8:  MOVLB  3
024CA:  ADDWF  x4F,W
024CC:  MOVLB  4
024CE:  MOVWF  x38
024D0:  MOVLW  00
024D2:  MOVLB  3
024D4:  ADDWFC x50,W
024D6:  MOVLB  4
024D8:  MOVWF  x39
024DA:  BCF    FD8.0
024DC:  RLCF   x35,W
024DE:  ADDWF  x38,W
024E0:  MOVWF  01
024E2:  MOVLW  00
024E4:  ADDWFC x39,W
024E6:  MOVWF  03
024E8:  MOVFF  01,FE9
024EC:  MOVWF  FEA
024EE:  MOVFF  FEF,01
024F2:  INCF   FE9,F
024F4:  MOVF   FEF,W
024F6:  DECF   FE9,F
024F8:  MOVWF  02
....................    } 
....................  
....................    
....................   VOID org(void) 
....................   { 
....................      INT16 tempd[N_LUZES][2]; 
....................      INT numluzes; 
....................      INT1 again = 1; 
....................      INT fa; 
....................      INT16 fl; 
....................      INT afa; 
....................      FOR(fa = 0;fa < used_dimmers;++fa) 
....................      { 
....................         tempd[fa][0] = ltlevel[fa];//tempd[x][0] fica com o valor de dimming 0...127 
....................         tempd[fa][1] = lights[fa];//tempd[x][1] fica com o valor binario DO porto de saida 
....................      } 
....................  
....................      WHILE(again) 
....................      { 
....................         again = 0; 
....................         FOR(fa = 0;fa < used_dimmers-1;++fa) 
....................         { 
....................            //coloca valores por ordem tempd[0][0] o maior 
....................            IF(tempd[fa][0] < tempd[fa + 1][0]) 
....................            { 
....................               again = 1; 
....................               fl = tempd[fa][0]; 
....................               tempd[fa][0] = tempd[fa + 1][0]; 
....................               tempd[fa + 1][0] = fl; 
....................               fl = tempd[fa][1]; 
....................               tempd[fa][1] = tempd[fa + 1][1]; 
....................               tempd[fa + 1][1] = fl; 
....................            } 
....................         } 
....................      } 
....................       for(temp=0;temp<17;++temp) 
....................    { 
....................       printf("%lu <-> %lu\n\r",tempd[temp][0],tempd[temp][1]); 
....................    } 
....................      IF(tempd[0][0] == 0)numluzes = 0;//luzes todas off 
....................      ELSE 
....................      { 
....................         numluzes = 1; 
....................         afa = 0; 
....................         IF(actmat) 
....................         { 
....................            delays1[0][0] = tempd[0][0]; 
....................            delays1[0][1] = tempd[0][1]; 
....................         } 
....................  
....................         ELSE 
....................         { 
....................            delays2[0][0] = tempd[0][0]; 
....................            delays2[0][1] = tempd[0][1]; 
....................         } 
....................  
....................         FOR(fa = 1;fa < used_dimmers;++fa) 
....................         { 
....................            IF((tempd[fa][0] == tempd[fa - 1][0])&( ! tempd[fa][0] == 0)) 
....................            { 
....................               IF(actmat)delays1[afa][1] = delays1[afa][1]&tempd[fa][1]; 
....................               ELSE delays2[afa][1] = delays2[afa][1]&tempd[fa][1]; 
....................            } 
....................  
....................            else IF( ! tempd[fa][0] == 0) 
....................            { 
....................               ++afa; 
....................               IF(actmat) 
....................               { 
....................                  delays1[afa][0] = tempd[fa][0]; 
....................                  delays1[afa][1] = tempd[fa][1]; 
....................               } 
....................  
....................               ELSE 
....................               { 
....................                  delays2[afa][0] = tempd[fa][0]; 
....................                  delays2[afa][1] = tempd[fa][1]; 
....................               } 
....................  
....................               ++numluzes; 
....................            } 
....................         } 
....................      } 
....................  
....................      IF(actmat)delays1[N_LUZES][0] = numluzes; 
....................      ELSE  delays2[N_LUZES][0] = numluzes; 
....................      printf("numluzes=%d %lu %lu\n\r",numluzes,delays1[0][0],delays1[0][1]); 
....................       
....................      organizado=1; 
....................   } 
....................  
.................... void dimmer_outputs_init() 
.................... { 
....................    int x; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
....................    { 
....................       switch (mydevices.myoutputs[x].type) { 
....................          case dimmer: 
....................             lights[used_dimmers]=light_pins[((struct light)mydevices.myoutputs[x].device).output_pin]; 
....................             ((struct light)mydevices.myoutputs[x].device).internal_order=used_dimmers; 
....................             ++used_dimmers; 
....................              
....................          break; 
....................       } 
....................    } 
....................    dimmers_off_value=0xFFFF; 
....................    for(x=0;x<used_dimmers;++x) 
....................    { 
....................       dimmers_off_value=dimmers_off_value & lights[x]; 
....................    } 
....................    dimmers_off_value=!dimmers_off_value; 
....................    trisc=0x00; //tudo saidas 
....................    trisd=0x00; //tudo saidas 
....................    actmat=0; 
....................    pointer=delays1; 
....................    org(); 
....................    pointer=delays2; 
....................    actmat=1; 
....................    org(); 
.................... } 
....................  
.................... void write_outputs() 
.................... { 
....................    int x; 
....................    int1 update_dimmers=false; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
....................    { 
....................       switch (mydevices.myoutputs[x].type) { 
....................          case dimmer: 
....................             if(((struct light)mydevices.myoutputs[x].device).dim_value.needs_update) 
....................             { 
....................                if(((struct light)mydevices.myoutputs[x].device).out_state==_on) 
....................                { 
....................                   ltlevel[((struct light)mydevices.myoutputs[x].device).internal_order]=((struct light)mydevices.myoutputs[x].device).dim_value.value; 
....................                   update_dimmers=true; 
....................                } 
....................                ((struct light)mydevices.myoutputs[x].device).dim_value.needs_update=false; 
....................             } 
....................              
....................             if(((struct light)mydevices.myoutputs[x].device).off.needs_update) 
....................             { 
....................                if(((struct light)mydevices.myoutputs[x].device).off.value) 
....................                { 
....................                   ((struct light)mydevices.myoutputs[x].device).out_state=_off; 
....................                   ltlevel[((struct light)mydevices.myoutputs[x].device).internal_order]=0; 
....................                   update_dimmers=true; 
....................                } 
....................                ((struct light)mydevices.myoutputs[x].device).off.needs_update=false; 
....................             } 
....................              
....................             if(((struct light)mydevices.myoutputs[x].device).on.needs_update) 
....................             { 
....................                if(((struct light)mydevices.myoutputs[x].device).on.value) 
....................                { 
....................                   ((struct light)mydevices.myoutputs[x].device).out_state=_on; 
....................                   ltlevel[((struct light)mydevices.myoutputs[x].device).internal_order]=((struct light)mydevices.myoutputs[x].device).dim_value.value; 
....................                   update_dimmers=true; 
....................                } 
....................                ((struct light)mydevices.myoutputs[x].device).on.needs_update=false; 
....................             } 
....................          break; 
....................       } 
....................    } 
....................    if(update_dimmers) 
....................       org(); 
.................... } 
....................  
....................  
.................... #include "datapoints.c" 
.................... int1 array_contains(int * array,int & value) 
.................... { 
....................    int x; 
....................    for(x=0;x<8;++x) 
....................    { 
....................       if(&(array)==value) return true; 
....................       ++array; 
....................    } 
....................    return false; 
.................... } 
....................  
.................... void process_outpoint_answer(int adress,int value) 
.................... { 
....................     
.................... } 
....................  
.................... void process_inpoints(int &datapoint, int &value) 
.................... { 
....................    int x; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
....................    { 
....................       switch (mydevices.myoutputs[x].type) { 
....................  
....................     case dimmer: 
....................            if (array_contains(mydevices.myoutputs[x].device.dim_value.adress,datapoint)) 
....................            { 
....................                mydevices.myoutputs[x].device.dim_value.value=value; 
....................                mydevices.myoutputs[x].device.dim_value.needs_update=true; 
....................            } 
....................            else if (array_contains(mydevices.myoutputs[x].device.on.adress,datapoint)) 
....................            { 
....................                mydevices.myoutputs[x].device.on.value=value; 
....................                mydevices.myoutputs[x].device.on.needs_update=true; 
....................            } 
....................            else if (array_contains(mydevices.myoutputs[x].device.off.adress,datapoint)) 
....................            { 
....................                mydevices.myoutputs[x].device.off.value=value; 
....................                mydevices.myoutputs[x].device.off.needs_update=true; 
....................            } 
....................            break; 
....................  
....................     case _on_off: 
....................  
....................            break; 
....................     case shutter: 
....................  
....................            break; 
....................     default: 
....................  
....................             break; } 
....................  
....................    } 
.................... } 
....................  
.................... void process_outpoints() 
.................... { 
....................     int x; 
....................    for(x=0;x<mydevices.numberOfInputs;++x) 
....................    { 
....................       switch (mydevices.myinputs[x].type) { 
....................     case dimmer_switch: 
....................                if(mydevices.myinputs[x].device.dim_level.needs_update) 
....................                { 
....................                   process_outpoint_answer(mydevices.myinputs[x].device.dim_level.adress,mydevices.myinputs[x].device.dim_level.value); 
....................                   mydevices.myinputs[x].device.dim_level.needs_update=false; 
....................                   mydevices.myinputs[x].device.dim_level.value=0; 
....................                } 
....................            if(mydevices.myinputs[x].device.on.needs_update) 
....................                { 
....................                   process_outpoint_answer(mydevices.myinputs[x].device.on.adress,mydevices.myinputs[x].device.on.value); 
....................                   mydevices.myinputs[x].device.on.needs_update=false; 
....................                   mydevices.myinputs[x].device.on.value=0; 
....................                } 
....................                if(mydevices.myinputs[x].device.off.needs_update) 
....................                { 
....................                   process_outpoint_answer(mydevices.myinputs[x].device.off.adress,mydevices.myinputs[x].device.off.value); 
....................                   mydevices.myinputs[x].device.off.needs_update=false; 
....................                   mydevices.myinputs[x].device.off.value=0; 
....................                } 
....................                break; 
....................     case timer: 
....................  
....................            break; 
....................     default: 
....................  
....................             break; } 
....................  
....................    } 
.................... } 
....................  
.................... ////////////////////////////////////////// 
.................... //apagar 
.................... volatile unsigned int32 clock; 
....................  
.................... //dimmer constants 
.................... static int TimeBase=0; 
.................... static int32 reg=39; 
.................... //dimmer end 
....................  
.................... //struct switches msw; 
.................... #include "switch_functions.c" 
.................... void process_onOff(struct on_off_switch *sw) 
.................... { 
.................... //printf("AKI1"); 
....................    if((sw->current_state==button_pressed) && (sw-> previous_state == button_depressed)) 
*
00714:  MOVLW  06
00716:  MOVLB  4
00718:  ADDWF  x35,W
0071A:  MOVWF  FE9
0071C:  MOVLW  00
0071E:  ADDWFC x36,W
00720:  MOVWF  FEA
00722:  MOVLW  00
00724:  BTFSC  FEF.0
00726:  MOVLW  01
00728:  ANDLW  01
0072A:  BNZ   07D0
0072C:  MOVLW  06
0072E:  ADDWF  x35,W
00730:  MOVWF  FE9
00732:  MOVLW  00
00734:  ADDWFC x36,W
00736:  MOVWF  FEA
00738:  MOVLW  00
0073A:  BTFSC  FEF.1
0073C:  MOVLW  01
0073E:  ANDLW  01
00740:  SUBLW  01
00742:  BNZ   07D0
....................    {    
....................       sw-> previous_state = button_pressed; 
00744:  MOVLW  06
00746:  ADDWF  x35,W
00748:  MOVWF  FE9
0074A:  MOVLW  00
0074C:  ADDWFC x36,W
0074E:  MOVWF  FEA
00750:  BCF    FEF.1
....................       if(sw->outstate==off) 
00752:  MOVLW  0B
00754:  ADDWF  x35,W
00756:  MOVWF  FE9
00758:  MOVLW  00
0075A:  ADDWFC x36,W
0075C:  MOVWF  FEA
0075E:  DECFSZ FEF,W
00760:  BRA    0790
....................       { 
....................          sw->outstate=on; 
00762:  MOVLW  0B
00764:  ADDWF  x35,W
00766:  MOVWF  FE9
00768:  MOVLW  00
0076A:  ADDWFC x36,W
0076C:  MOVWF  FEA
0076E:  CLRF   FEF
....................          sw->on.value=1; 
00770:  MOVLW  01
00772:  ADDWF  x35,W
00774:  MOVWF  FE9
00776:  MOVLW  00
00778:  ADDWFC x36,W
0077A:  MOVWF  FEA
0077C:  MOVLW  01
0077E:  MOVWF  FEF
....................          sw->on.needs_update=true; 
00780:  MOVLW  02
00782:  ADDWF  x35,W
00784:  MOVWF  FE9
00786:  MOVLW  00
00788:  ADDWFC x36,W
0078A:  MOVWF  FEA
0078C:  BSF    FEF.0
....................       } 
....................       else if(sw->outstate==on) 
0078E:  BRA    07CE
00790:  MOVLW  0B
00792:  ADDWF  x35,W
00794:  MOVWF  FE9
00796:  MOVLW  00
00798:  ADDWFC x36,W
0079A:  MOVWF  FEA
0079C:  MOVF   FEF,F
0079E:  BNZ   07CE
....................       { 
....................          sw->outstate=off; 
007A0:  MOVLW  0B
007A2:  ADDWF  x35,W
007A4:  MOVWF  FE9
007A6:  MOVLW  00
007A8:  ADDWFC x36,W
007AA:  MOVWF  FEA
007AC:  MOVLW  01
007AE:  MOVWF  FEF
....................          sw->off.value=1; 
007B0:  MOVLW  04
007B2:  ADDWF  x35,W
007B4:  MOVWF  FE9
007B6:  MOVLW  00
007B8:  ADDWFC x36,W
007BA:  MOVWF  FEA
007BC:  MOVLW  01
007BE:  MOVWF  FEF
....................          sw->off.needs_update=true; 
007C0:  MOVLW  05
007C2:  ADDWF  x35,W
007C4:  MOVWF  FE9
007C6:  MOVLW  00
007C8:  ADDWFC x36,W
007CA:  MOVWF  FEA
007CC:  BSF    FEF.0
....................       } 
.................... } 
....................    else if(sw->current_state==button_depressed) 
007CE:  BRA    07F6
007D0:  MOVLW  06
007D2:  ADDWF  x35,W
007D4:  MOVWF  FE9
007D6:  MOVLW  00
007D8:  ADDWFC x36,W
007DA:  MOVWF  FEA
007DC:  MOVLW  00
007DE:  BTFSC  FEF.0
007E0:  MOVLW  01
007E2:  ANDLW  01
007E4:  SUBLW  01
007E6:  BNZ   07F6
....................       sw-> previous_state = button_depressed; 
007E8:  MOVLW  06
007EA:  ADDWF  x35,W
007EC:  MOVWF  FE9
007EE:  MOVLW  00
007F0:  ADDWFC x36,W
007F2:  MOVWF  FEA
007F4:  BSF    FEF.1
.................... } 
007F6:  MOVLB  0
007F8:  GOTO   0CDC (RETURN)
.................... void process_buttons(struct button_switch *sw) 
.................... { 
....................    if(sw->current_state==button_pressed && sw->outstate==off)  
007FC:  MOVLW  06
007FE:  MOVLB  4
00800:  ADDWF  x35,W
00802:  MOVWF  FE9
00804:  MOVLW  00
00806:  ADDWFC x36,W
00808:  MOVWF  FEA
0080A:  MOVLW  00
0080C:  BTFSC  FEF.0
0080E:  MOVLW  01
00810:  ANDLW  01
00812:  BNZ   0852
00814:  MOVLW  0B
00816:  ADDWF  x35,W
00818:  MOVWF  FE9
0081A:  MOVLW  00
0081C:  ADDWFC x36,W
0081E:  MOVWF  FEA
00820:  DECFSZ FEF,W
00822:  BRA    0852
....................    { 
....................          sw->outstate=on; 
00824:  MOVLW  0B
00826:  ADDWF  x35,W
00828:  MOVWF  FE9
0082A:  MOVLW  00
0082C:  ADDWFC x36,W
0082E:  MOVWF  FEA
00830:  CLRF   FEF
....................          sw->on.value=1; 
00832:  MOVLW  01
00834:  ADDWF  x35,W
00836:  MOVWF  FE9
00838:  MOVLW  00
0083A:  ADDWFC x36,W
0083C:  MOVWF  FEA
0083E:  MOVLW  01
00840:  MOVWF  FEF
....................          sw->on.needs_update=true; 
00842:  MOVLW  02
00844:  ADDWF  x35,W
00846:  MOVWF  FE9
00848:  MOVLW  00
0084A:  ADDWFC x36,W
0084C:  MOVWF  FEA
0084E:  BSF    FEF.0
....................    } 
....................    else if(sw->current_state==button_depressed && sw->outstate==on)   
00850:  BRA    08A8
00852:  MOVLW  06
00854:  ADDWF  x35,W
00856:  MOVWF  FE9
00858:  MOVLW  00
0085A:  ADDWFC x36,W
0085C:  MOVWF  FEA
0085E:  MOVLW  00
00860:  BTFSC  FEF.0
00862:  MOVLW  01
00864:  ANDLW  01
00866:  SUBLW  01
00868:  BNZ   08A8
0086A:  MOVLW  0B
0086C:  ADDWF  x35,W
0086E:  MOVWF  FE9
00870:  MOVLW  00
00872:  ADDWFC x36,W
00874:  MOVWF  FEA
00876:  MOVF   FEF,F
00878:  BNZ   08A8
....................    { 
....................          sw->outstate=off; 
0087A:  MOVLW  0B
0087C:  ADDWF  x35,W
0087E:  MOVWF  FE9
00880:  MOVLW  00
00882:  ADDWFC x36,W
00884:  MOVWF  FEA
00886:  MOVLW  01
00888:  MOVWF  FEF
....................          sw->off.value=1; 
0088A:  MOVLW  04
0088C:  ADDWF  x35,W
0088E:  MOVWF  FE9
00890:  MOVLW  00
00892:  ADDWFC x36,W
00894:  MOVWF  FEA
00896:  MOVLW  01
00898:  MOVWF  FEF
....................          sw->off.needs_update=true; 
0089A:  MOVLW  05
0089C:  ADDWF  x35,W
0089E:  MOVWF  FE9
008A0:  MOVLW  00
008A2:  ADDWFC x36,W
008A4:  MOVWF  FEA
008A6:  BSF    FEF.0
....................    } 
.................... } 
008A8:  MOVLB  0
008AA:  GOTO   0CDC (RETURN)
.................... void process_dimmers(struct dimmer_switch *sw) 
.................... { 
*
0036E:  MOVLW  09
00370:  MOVLB  4
00372:  ADDWF  x35,W
00374:  MOVWF  FE9
00376:  MOVLW  00
00378:  ADDWFC x36,W
0037A:  MOVWF  FEA
0037C:  MOVFF  FEF,437
....................    int last_level=sw->current_level; 
....................    if(sw->current_state==button_pressed)//se o botao esta premido 
00380:  MOVLW  0E
00382:  ADDWF  x35,W
00384:  MOVWF  FE9
00386:  MOVLW  00
00388:  ADDWFC x36,W
0038A:  MOVWF  FEA
0038C:  MOVLW  00
0038E:  BTFSC  FEF.0
00390:  MOVLW  01
00392:  ANDLW  01
00394:  BTFSS  FD8.2
00396:  BRA    0566
....................    { 
....................     //  printf("STATE %u",sw->current_state); 
....................      // printf("DIF %LU",clock - sw->timer); 
....................       sw-> previous_state = button_pressed; 
00398:  MOVLW  0E
0039A:  ADDWF  x35,W
0039C:  MOVWF  FE9
0039E:  MOVLW  00
003A0:  ADDWFC x36,W
003A2:  MOVWF  FEA
003A4:  BCF    FEF.1
....................       if ((clock - sw->timer > reg || sw->outstate == dimming) && sw->outstate!=maxed) 
003A6:  MOVLW  0A
003A8:  ADDWF  x35,W
003AA:  MOVWF  FE9
003AC:  MOVLW  00
003AE:  ADDWFC x36,W
003B0:  MOVWF  FEA
003B2:  MOVFF  FEF,00
003B6:  MOVFF  FEC,01
003BA:  MOVFF  FEC,02
003BE:  MOVFF  FEC,03
003C2:  MOVF   00,W
003C4:  SUBWF  x0D,W
003C6:  MOVWF  x38
003C8:  MOVF   01,W
003CA:  SUBWFB x0E,W
003CC:  MOVWF  x39
003CE:  MOVF   02,W
003D0:  SUBWFB x0F,W
003D2:  MOVWF  x3A
003D4:  MOVF   03,W
003D6:  SUBWFB x10,W
003D8:  MOVWF  x3B
003DA:  MOVF   x15,W
003DC:  SUBWF  x3B,W
003DE:  BNC   03F8
003E0:  BNZ   040C
003E2:  MOVF   x14,W
003E4:  SUBWF  x3A,W
003E6:  BNC   03F8
003E8:  BNZ   040C
003EA:  MOVF   x13,W
003EC:  SUBWF  x39,W
003EE:  BNC   03F8
003F0:  BNZ   040C
003F2:  MOVF   x38,W
003F4:  SUBWF  x12,W
003F6:  BNC   040C
003F8:  MOVLW  0F
003FA:  ADDWF  x35,W
003FC:  MOVWF  FE9
003FE:  MOVLW  00
00400:  ADDWFC x36,W
00402:  MOVWF  FEA
00404:  MOVF   FEF,W
00406:  SUBLW  02
00408:  BTFSS  FD8.2
0040A:  BRA    0564
0040C:  MOVLW  0F
0040E:  ADDWF  x35,W
00410:  MOVWF  FE9
00412:  MOVLW  00
00414:  ADDWFC x36,W
00416:  MOVWF  FEA
00418:  MOVF   FEF,W
0041A:  SUBLW  04
0041C:  BTFSC  FD8.2
0041E:  BRA    0564
....................       {  
....................          if(sw->outstate==off) 
00420:  MOVLW  0F
00422:  ADDWF  x35,W
00424:  MOVWF  FE9
00426:  MOVLW  00
00428:  ADDWFC x36,W
0042A:  MOVWF  FEA
0042C:  DECFSZ FEF,W
0042E:  BRA    046E
....................          { 
....................             sw->outstate=maxed; 
00430:  MOVLW  0F
00432:  ADDWF  x35,W
00434:  MOVWF  FE9
00436:  MOVLW  00
00438:  ADDWFC x36,W
0043A:  MOVWF  FEA
0043C:  MOVLW  04
0043E:  MOVWF  FEF
....................             sw->on.value=1; 
00440:  ADDWF  x35,W
00442:  MOVWF  FE9
00444:  MOVLW  00
00446:  ADDWFC x36,W
00448:  MOVWF  FEA
0044A:  MOVLW  01
0044C:  MOVWF  FEF
....................             sw->current_level = 127; 
0044E:  MOVLW  09
00450:  ADDWF  x35,W
00452:  MOVWF  FE9
00454:  MOVLW  00
00456:  ADDWFC x36,W
00458:  MOVWF  FEA
0045A:  MOVLW  7F
0045C:  MOVWF  FEF
....................             sw->on.needs_update=1; 
0045E:  MOVLW  05
00460:  ADDWF  x35,W
00462:  MOVWF  FE9
00464:  MOVLW  00
00466:  ADDWFC x36,W
00468:  MOVWF  FEA
0046A:  BSF    FEF.0
....................          } 
....................         else 
0046C:  BRA    0562
....................         { 
....................          sw->outstate = dimming; 
0046E:  MOVLW  0F
00470:  ADDWF  x35,W
00472:  MOVWF  FE9
00474:  MOVLW  00
00476:  ADDWFC x36,W
00478:  MOVWF  FEA
0047A:  MOVLW  02
0047C:  MOVWF  FEF
....................          if (clock - sw->timer > TimeBase) //regula 
0047E:  MOVLW  0A
00480:  ADDWF  x35,W
00482:  MOVWF  FE9
00484:  MOVLW  00
00486:  ADDWFC x36,W
00488:  MOVWF  FEA
0048A:  MOVFF  FEF,00
0048E:  MOVFF  FEC,01
00492:  MOVFF  FEC,02
00496:  MOVFF  FEC,03
0049A:  MOVF   00,W
0049C:  SUBWF  x0D,W
0049E:  MOVWF  x38
004A0:  MOVF   01,W
004A2:  SUBWFB x0E,W
004A4:  MOVWF  x39
004A6:  MOVF   02,W
004A8:  SUBWFB x0F,W
004AA:  MOVWF  x3A
004AC:  MOVF   03,W
004AE:  SUBWFB x10,W
004B0:  MOVWF  x3B
004B2:  MOVF   x3B,F
004B4:  BNZ   04C4
004B6:  MOVF   x3A,F
004B8:  BNZ   04C4
004BA:  MOVF   x39,F
004BC:  BNZ   04C4
004BE:  MOVF   x38,W
004C0:  SUBWF  x11,W
004C2:  BC    0546
....................          { 
....................             if (sw->direction == up) //para cima 
004C4:  MOVLW  0E
004C6:  ADDWF  x35,W
004C8:  MOVWF  FE9
004CA:  MOVLW  00
004CC:  ADDWFC x36,W
004CE:  MOVWF  FEA
004D0:  MOVLW  00
004D2:  BTFSC  FEF.2
004D4:  MOVLW  01
004D6:  ANDLW  01
004D8:  BNZ   050A
....................             { 
....................                ++sw->current_level; 
004DA:  MOVLW  09
004DC:  ADDWF  x35,W
004DE:  MOVWF  FE9
004E0:  MOVLW  00
004E2:  ADDWFC x36,W
004E4:  MOVWF  FEA
004E6:  INCF   FEF,F
....................                if (sw->current_level == 127) sw->direction = down; 
004E8:  MOVLW  09
004EA:  ADDWF  x35,W
004EC:  MOVWF  FE9
004EE:  MOVLW  00
004F0:  ADDWFC x36,W
004F2:  MOVWF  FEA
004F4:  MOVF   FEF,W
004F6:  SUBLW  7F
004F8:  BNZ   0508
004FA:  MOVLW  0E
004FC:  ADDWF  x35,W
004FE:  MOVWF  FE9
00500:  MOVLW  00
00502:  ADDWFC x36,W
00504:  MOVWF  FEA
00506:  BSF    FEF.2
....................             } 
....................             else//para baixo 
00508:  BRA    0546
....................             { 
....................                --sw->current_level; 
0050A:  MOVLW  09
0050C:  ADDWF  x35,W
0050E:  MOVWF  FE9
00510:  MOVLW  00
00512:  ADDWFC x36,W
00514:  MOVWF  FEA
00516:  DECF   FEF,F
....................                if (sw->current_level == 0)  
00518:  MOVLW  09
0051A:  ADDWF  x35,W
0051C:  MOVWF  FE9
0051E:  MOVLW  00
00520:  ADDWFC x36,W
00522:  MOVWF  FEA
00524:  MOVF   FEF,F
00526:  BNZ   0546
....................                {   
....................                   sw->direction = up; 
00528:  MOVLW  0E
0052A:  ADDWF  x35,W
0052C:  MOVWF  FE9
0052E:  MOVLW  00
00530:  ADDWFC x36,W
00532:  MOVWF  FEA
00534:  BCF    FEF.2
....................                   sw->off.value=1; 
00536:  MOVLW  07
00538:  ADDWF  x35,W
0053A:  MOVWF  FE9
0053C:  MOVLW  00
0053E:  ADDWFC x36,W
00540:  MOVWF  FEA
00542:  MOVLW  01
00544:  MOVWF  FEF
....................                } 
....................             } 
....................          } 
....................          sw->timer = clock; 
00546:  MOVLW  0A
00548:  ADDWF  x35,W
0054A:  MOVWF  FE9
0054C:  MOVLW  00
0054E:  ADDWFC x36,W
00550:  MOVWF  FEA
00552:  MOVFF  40D,FEF
00556:  MOVFF  40E,FEC
0055A:  MOVFF  40F,FEC
0055E:  MOVFF  410,FEC
....................       } 
....................       } 
....................       else 
00562:  BRA    0564
....................       { 
....................          //sw - > timer = clock; 
....................       } 
....................    } 
....................    else//se o botao nao esta premido 
00564:  BRA    06C6
....................    { 
....................       if (sw->previous_state == button_pressed) //se o botao acabou de ser deslargado 
00566:  MOVLW  0E
00568:  ADDWF  x35,W
0056A:  MOVWF  FE9
0056C:  MOVLW  00
0056E:  ADDWFC x36,W
00570:  MOVWF  FEA
00572:  MOVLW  00
00574:  BTFSC  FEF.1
00576:  MOVLW  01
00578:  ANDLW  01
0057A:  BTFSS  FD8.2
0057C:  BRA    06AA
....................       { 
....................          sw->previous_state = button_depressed; 
0057E:  MOVLW  0E
00580:  ADDWF  x35,W
00582:  MOVWF  FE9
00584:  MOVLW  00
00586:  ADDWFC x36,W
00588:  MOVWF  FEA
0058A:  BSF    FEF.1
....................          if (sw->outstate == dimming) //se esteve a regular 
0058C:  MOVLW  0F
0058E:  ADDWF  x35,W
00590:  MOVWF  FE9
00592:  MOVLW  00
00594:  ADDWFC x36,W
00596:  MOVWF  FEA
00598:  MOVF   FEF,W
0059A:  SUBLW  02
0059C:  BNZ   05E2
....................          { 
....................             sw-> outstate = on; 
0059E:  MOVLW  0F
005A0:  ADDWF  x35,W
005A2:  MOVWF  FE9
005A4:  MOVLW  00
005A6:  ADDWFC x36,W
005A8:  MOVWF  FEA
005AA:  CLRF   FEF
....................             if (sw->direction == up) sw->direction = down; //inverte direccao 
005AC:  MOVLW  0E
005AE:  ADDWF  x35,W
005B0:  MOVWF  FE9
005B2:  MOVLW  00
005B4:  ADDWFC x36,W
005B6:  MOVWF  FEA
005B8:  MOVLW  00
005BA:  BTFSC  FEF.2
005BC:  MOVLW  01
005BE:  ANDLW  01
005C0:  BNZ   05D2
005C2:  MOVLW  0E
005C4:  ADDWF  x35,W
005C6:  MOVWF  FE9
005C8:  MOVLW  00
005CA:  ADDWFC x36,W
005CC:  MOVWF  FEA
005CE:  BSF    FEF.2
....................             else sw->direction = up; 
005D0:  BRA    05E0
005D2:  MOVLW  0E
005D4:  ADDWF  x35,W
005D6:  MOVWF  FE9
005D8:  MOVLW  00
005DA:  ADDWFC x36,W
005DC:  MOVWF  FEA
005DE:  BCF    FEF.2
....................          } 
....................          else//se nao esteve a regular 
005E0:  BRA    06AA
....................          { 
....................             if (sw->outstate == off) //se estava desligada 
005E2:  MOVLW  0F
005E4:  ADDWF  x35,W
005E6:  MOVWF  FE9
005E8:  MOVLW  00
005EA:  ADDWFC x36,W
005EC:  MOVWF  FEA
005EE:  DECFSZ FEF,W
005F0:  BRA    062E
....................             { 
....................               // printf("on"); 
....................                sw->outstate=on; 
005F2:  MOVLW  0F
005F4:  ADDWF  x35,W
005F6:  MOVWF  FE9
005F8:  MOVLW  00
005FA:  ADDWFC x36,W
005FC:  MOVWF  FEA
005FE:  CLRF   FEF
....................                sw->on.value=1; 
00600:  MOVLW  04
00602:  ADDWF  x35,W
00604:  MOVWF  FE9
00606:  MOVLW  00
00608:  ADDWFC x36,W
0060A:  MOVWF  FEA
0060C:  MOVLW  01
0060E:  MOVWF  FEF
....................                sw->direction = down; 
00610:  MOVLW  0E
00612:  ADDWF  x35,W
00614:  MOVWF  FE9
00616:  MOVLW  00
00618:  ADDWFC x36,W
0061A:  MOVWF  FEA
0061C:  BSF    FEF.2
....................                sw->on.needs_update=true; 
0061E:  MOVLW  05
00620:  ADDWF  x35,W
00622:  MOVWF  FE9
00624:  MOVLW  00
00626:  ADDWFC x36,W
00628:  MOVWF  FEA
0062A:  BSF    FEF.0
....................             } 
....................             else if (sw->outstate == on) 
0062C:  BRA    06AA
0062E:  MOVLW  0F
00630:  ADDWF  x35,W
00632:  MOVWF  FE9
00634:  MOVLW  00
00636:  ADDWFC x36,W
00638:  MOVWF  FEA
0063A:  MOVF   FEF,F
0063C:  BNZ   067C
....................             { 
....................               // printf("off"); 
....................                //sw->current_level = 0; //senao desliga 
....................                sw->outstate=off; 
0063E:  MOVLW  0F
00640:  ADDWF  x35,W
00642:  MOVWF  FE9
00644:  MOVLW  00
00646:  ADDWFC x36,W
00648:  MOVWF  FEA
0064A:  MOVLW  01
0064C:  MOVWF  FEF
....................                sw->off.value=1; 
0064E:  MOVLW  07
00650:  ADDWF  x35,W
00652:  MOVWF  FE9
00654:  MOVLW  00
00656:  ADDWFC x36,W
00658:  MOVWF  FEA
0065A:  MOVLW  01
0065C:  MOVWF  FEF
....................                sw->direction = up; 
0065E:  MOVLW  0E
00660:  ADDWF  x35,W
00662:  MOVWF  FE9
00664:  MOVLW  00
00666:  ADDWFC x36,W
00668:  MOVWF  FEA
0066A:  BCF    FEF.2
....................                sw->off.needs_update=true; 
0066C:  MOVLW  08
0066E:  ADDWF  x35,W
00670:  MOVWF  FE9
00672:  MOVLW  00
00674:  ADDWFC x36,W
00676:  MOVWF  FEA
00678:  BSF    FEF.0
....................             } 
....................             else if(sw->outstate == maxed) 
0067A:  BRA    06AA
0067C:  MOVLW  0F
0067E:  ADDWF  x35,W
00680:  MOVWF  FE9
00682:  MOVLW  00
00684:  ADDWFC x36,W
00686:  MOVWF  FEA
00688:  MOVF   FEF,W
0068A:  SUBLW  04
0068C:  BNZ   06AA
....................             { 
....................                sw->outstate=on; 
0068E:  MOVLW  0F
00690:  ADDWF  x35,W
00692:  MOVWF  FE9
00694:  MOVLW  00
00696:  ADDWFC x36,W
00698:  MOVWF  FEA
0069A:  CLRF   FEF
....................                sw->direction = down; 
0069C:  MOVLW  0E
0069E:  ADDWF  x35,W
006A0:  MOVWF  FE9
006A2:  MOVLW  00
006A4:  ADDWFC x36,W
006A6:  MOVWF  FEA
006A8:  BSF    FEF.2
....................             } 
....................          } 
....................       } 
....................       sw->timer = clock; 
006AA:  MOVLW  0A
006AC:  ADDWF  x35,W
006AE:  MOVWF  FE9
006B0:  MOVLW  00
006B2:  ADDWFC x36,W
006B4:  MOVWF  FEA
006B6:  MOVFF  40D,FEF
006BA:  MOVFF  40E,FEC
006BE:  MOVFF  40F,FEC
006C2:  MOVFF  410,FEC
....................    } 
....................  //  onOffHelper(sw); 
....................    if (last_level!=sw->current_level)  
006C6:  MOVLW  09
006C8:  ADDWF  x35,W
006CA:  MOVWF  FE9
006CC:  MOVLW  00
006CE:  ADDWFC x36,W
006D0:  MOVWF  FEA
006D2:  MOVF   FEF,W
006D4:  SUBWF  x37,W
006D6:  BZ    070E
....................    { 
....................       sw->dim_level.value=sw->current_level; 
006D8:  MOVLW  01
006DA:  ADDWF  x35,W
006DC:  MOVWF  01
006DE:  MOVLW  00
006E0:  ADDWFC x36,W
006E2:  MOVWF  03
006E4:  MOVLW  09
006E6:  ADDWF  x35,W
006E8:  MOVWF  FE9
006EA:  MOVLW  00
006EC:  ADDWFC x36,W
006EE:  MOVWF  FEA
006F0:  MOVFF  FEF,43A
006F4:  MOVFF  03,FEA
006F8:  MOVFF  01,FE9
006FC:  MOVFF  43A,FEF
....................       sw->dim_level.needs_update=true; 
00700:  MOVLW  02
00702:  ADDWF  x35,W
00704:  MOVWF  FE9
00706:  MOVLW  00
00708:  ADDWFC x36,W
0070A:  MOVWF  FEA
0070C:  BSF    FEF.0
....................    } 
.................... } 
0070E:  MOVLB  0
00710:  GOTO   0CDC (RETURN)
....................  
.................... void read_inputs() 
.................... { 
....................   int x; 
....................    for(x=0;x<mydevices.numberOfInputs;++x) 
*
008AE:  MOVLB  4
008B0:  CLRF   x32
008B2:  MOVLB  1
008B4:  MOVF   x3A,W
008B6:  MOVLB  4
008B8:  SUBWF  x32,W
008BA:  BTFSC  FD8.0
008BC:  BRA    0CE2
....................    { 
....................       switch (mydevices.myinputs[x].type) { 
008BE:  CLRF   x34
008C0:  MOVFF  432,433
008C4:  CLRF   x36
008C6:  MOVLW  12
008C8:  MOVWF  x35
008CA:  MOVLB  0
008CC:  RCALL  02D8
008CE:  MOVFF  02,03
008D2:  MOVF   01,W
008D4:  ADDLW  3C
008D6:  MOVWF  FE9
008D8:  MOVLW  01
008DA:  ADDWFC 02,W
008DC:  MOVWF  FEA
008DE:  MOVF   FEF,W
008E0:  BZ    08F6
008E2:  XORLW  03
008E4:  BTFSC  FD8.2
008E6:  BRA    0A3C
008E8:  XORLW  02
008EA:  BTFSC  FD8.2
008EC:  BRA    0A3E
008EE:  XORLW  03
008F0:  BTFSC  FD8.2
008F2:  BRA    0B88
008F4:  BRA    0CDA
....................     case dimmer_switch: 
....................            // printf("aki"); 
....................             if (input (((struct dimmer_switch)mydevices.myinputs[x].device).realbutton))  
008F6:  MOVLB  4
008F8:  CLRF   x34
008FA:  MOVFF  432,433
008FE:  CLRF   x36
00900:  MOVLW  12
00902:  MOVWF  x35
00904:  MOVLB  0
00906:  RCALL  02D8
00908:  MOVF   01,W
0090A:  ADDLW  02
0090C:  MOVLB  4
0090E:  MOVWF  x33
00910:  MOVLW  00
00912:  ADDWFC 02,W
00914:  MOVWF  x34
00916:  MOVLW  01
00918:  ADDWF  x33,W
0091A:  MOVWF  01
0091C:  MOVLW  00
0091E:  ADDWFC x34,W
00920:  MOVWF  03
00922:  MOVF   01,W
00924:  ADDLW  3A
00926:  MOVWF  01
00928:  MOVLW  01
0092A:  ADDWFC 03,F
0092C:  MOVF   01,W
0092E:  ADDLW  10
00930:  MOVWF  FE9
00932:  MOVLW  00
00934:  ADDWFC 03,W
00936:  MOVWF  FEA
00938:  MOVFF  FEF,435
0093C:  MOVFF  435,436
00940:  MOVLW  01
00942:  MOVWF  x37
00944:  MOVLW  0F
00946:  MOVWF  x39
00948:  MOVLW  92
0094A:  MOVWF  x38
0094C:  MOVLB  0
0094E:  RCALL  02FA
00950:  MOVFF  435,436
00954:  MOVLW  0F
00956:  MOVLB  4
00958:  MOVWF  x38
0095A:  MOVLW  80
0095C:  MOVWF  x37
0095E:  MOVLB  0
00960:  RCALL  033C
00962:  BTFSS  01.0
00964:  BRA    09AE
....................             { 
....................                ((struct dimmer_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
00966:  MOVLB  4
00968:  CLRF   x34
0096A:  MOVFF  432,433
0096E:  CLRF   x36
00970:  MOVLW  12
00972:  MOVWF  x35
00974:  MOVLB  0
00976:  RCALL  02D8
00978:  MOVF   01,W
0097A:  ADDLW  02
0097C:  MOVLB  4
0097E:  MOVWF  x33
00980:  MOVLW  00
00982:  ADDWFC 02,W
00984:  MOVWF  x34
00986:  MOVLW  01
00988:  ADDWF  x33,W
0098A:  MOVWF  01
0098C:  MOVLW  00
0098E:  ADDWFC x34,W
00990:  MOVWF  03
00992:  MOVF   01,W
00994:  ADDLW  3A
00996:  MOVWF  01
00998:  MOVLW  01
0099A:  ADDWFC 03,F
0099C:  MOVF   01,W
0099E:  ADDLW  0E
009A0:  MOVWF  FE9
009A2:  MOVLW  00
009A4:  ADDWFC 03,W
009A6:  MOVWF  FEA
009A8:  BSF    FEF.0
....................             } 
....................             else  
009AA:  BRA    09F2
009AC:  MOVLB  0
....................             { 
....................                ((struct dimmer_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
009AE:  MOVLB  4
009B0:  CLRF   x34
009B2:  MOVFF  432,433
009B6:  CLRF   x36
009B8:  MOVLW  12
009BA:  MOVWF  x35
009BC:  MOVLB  0
009BE:  RCALL  02D8
009C0:  MOVF   01,W
009C2:  ADDLW  02
009C4:  MOVLB  4
009C6:  MOVWF  x33
009C8:  MOVLW  00
009CA:  ADDWFC 02,W
009CC:  MOVWF  x34
009CE:  MOVLW  01
009D0:  ADDWF  x33,W
009D2:  MOVWF  01
009D4:  MOVLW  00
009D6:  ADDWFC x34,W
009D8:  MOVWF  03
009DA:  MOVF   01,W
009DC:  ADDLW  3A
009DE:  MOVWF  01
009E0:  MOVLW  01
009E2:  ADDWFC 03,F
009E4:  MOVF   01,W
009E6:  ADDLW  0E
009E8:  MOVWF  FE9
009EA:  MOVLW  00
009EC:  ADDWFC 03,W
009EE:  MOVWF  FEA
009F0:  BCF    FEF.0
....................             } 
....................             process_dimmers(&mydevices.myinputs[x].device); 
009F2:  CLRF   x34
009F4:  MOVFF  432,433
009F8:  CLRF   x36
009FA:  MOVLW  12
009FC:  MOVWF  x35
009FE:  MOVLB  0
00A00:  RCALL  02D8
00A02:  MOVF   01,W
00A04:  ADDLW  02
00A06:  MOVLB  4
00A08:  MOVWF  x33
00A0A:  MOVLW  00
00A0C:  ADDWFC 02,W
00A0E:  MOVWF  x34
00A10:  MOVLW  01
00A12:  ADDWF  x33,W
00A14:  MOVWF  01
00A16:  MOVLW  00
00A18:  ADDWFC x34,W
00A1A:  MOVWF  03
00A1C:  MOVF   01,W
00A1E:  ADDLW  3A
00A20:  MOVWF  01
00A22:  MOVLW  01
00A24:  ADDWFC 03,F
00A26:  MOVFF  01,433
00A2A:  MOVFF  03,434
00A2E:  MOVFF  03,436
00A32:  MOVFF  01,435
00A36:  MOVLB  0
00A38:  BRA    036E
....................             break; 
00A3A:  BRA    0CDC
....................     case timer: 
....................  
....................            break; 
00A3C:  BRA    0CDC
....................     case on_off_switch: 
....................            // printf("aki"); 
....................             if (input (((struct on_off_switch)mydevices.myinputs[x].device).realbutton))  
00A3E:  MOVLB  4
00A40:  CLRF   x34
00A42:  MOVFF  432,433
00A46:  CLRF   x36
00A48:  MOVLW  12
00A4A:  MOVWF  x35
00A4C:  MOVLB  0
00A4E:  RCALL  02D8
00A50:  MOVF   01,W
00A52:  ADDLW  02
00A54:  MOVLB  4
00A56:  MOVWF  x33
00A58:  MOVLW  00
00A5A:  ADDWFC 02,W
00A5C:  MOVWF  x34
00A5E:  MOVLW  01
00A60:  ADDWF  x33,W
00A62:  MOVWF  01
00A64:  MOVLW  00
00A66:  ADDWFC x34,W
00A68:  MOVWF  03
00A6A:  MOVF   01,W
00A6C:  ADDLW  3A
00A6E:  MOVWF  01
00A70:  MOVLW  01
00A72:  ADDWFC 03,F
00A74:  MOVF   01,W
00A76:  ADDLW  0C
00A78:  MOVWF  FE9
00A7A:  MOVLW  00
00A7C:  ADDWFC 03,W
00A7E:  MOVWF  FEA
00A80:  MOVFF  FEF,435
00A84:  MOVFF  435,436
00A88:  MOVLW  01
00A8A:  MOVWF  x37
00A8C:  MOVLW  0F
00A8E:  MOVWF  x39
00A90:  MOVLW  92
00A92:  MOVWF  x38
00A94:  MOVLB  0
00A96:  RCALL  02FA
00A98:  MOVFF  435,436
00A9C:  MOVLW  0F
00A9E:  MOVLB  4
00AA0:  MOVWF  x38
00AA2:  MOVLW  80
00AA4:  MOVWF  x37
00AA6:  MOVLB  0
00AA8:  RCALL  033C
00AAA:  BTFSS  01.0
00AAC:  BRA    0AF6
....................             { 
....................                ((struct on_off_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
00AAE:  MOVLB  4
00AB0:  CLRF   x34
00AB2:  MOVFF  432,433
00AB6:  CLRF   x36
00AB8:  MOVLW  12
00ABA:  MOVWF  x35
00ABC:  MOVLB  0
00ABE:  RCALL  02D8
00AC0:  MOVF   01,W
00AC2:  ADDLW  02
00AC4:  MOVLB  4
00AC6:  MOVWF  x33
00AC8:  MOVLW  00
00ACA:  ADDWFC 02,W
00ACC:  MOVWF  x34
00ACE:  MOVLW  01
00AD0:  ADDWF  x33,W
00AD2:  MOVWF  01
00AD4:  MOVLW  00
00AD6:  ADDWFC x34,W
00AD8:  MOVWF  03
00ADA:  MOVF   01,W
00ADC:  ADDLW  3A
00ADE:  MOVWF  01
00AE0:  MOVLW  01
00AE2:  ADDWFC 03,F
00AE4:  MOVF   01,W
00AE6:  ADDLW  06
00AE8:  MOVWF  FE9
00AEA:  MOVLW  00
00AEC:  ADDWFC 03,W
00AEE:  MOVWF  FEA
00AF0:  BSF    FEF.0
....................             } 
....................             else  
00AF2:  BRA    0B3C
00AF4:  MOVLB  0
....................             { 
....................                ((struct on_off_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
00AF6:  MOVLB  4
00AF8:  CLRF   x34
00AFA:  MOVFF  432,433
00AFE:  CLRF   x36
00B00:  MOVLW  12
00B02:  MOVWF  x35
00B04:  MOVLB  0
00B06:  CALL   02D8
00B0A:  MOVF   01,W
00B0C:  ADDLW  02
00B0E:  MOVLB  4
00B10:  MOVWF  x33
00B12:  MOVLW  00
00B14:  ADDWFC 02,W
00B16:  MOVWF  x34
00B18:  MOVLW  01
00B1A:  ADDWF  x33,W
00B1C:  MOVWF  01
00B1E:  MOVLW  00
00B20:  ADDWFC x34,W
00B22:  MOVWF  03
00B24:  MOVF   01,W
00B26:  ADDLW  3A
00B28:  MOVWF  01
00B2A:  MOVLW  01
00B2C:  ADDWFC 03,F
00B2E:  MOVF   01,W
00B30:  ADDLW  06
00B32:  MOVWF  FE9
00B34:  MOVLW  00
00B36:  ADDWFC 03,W
00B38:  MOVWF  FEA
00B3A:  BCF    FEF.0
....................             } 
....................             process_onOff(&mydevices.myinputs[x].device); 
00B3C:  CLRF   x34
00B3E:  MOVFF  432,433
00B42:  CLRF   x36
00B44:  MOVLW  12
00B46:  MOVWF  x35
00B48:  MOVLB  0
00B4A:  CALL   02D8
00B4E:  MOVF   01,W
00B50:  ADDLW  02
00B52:  MOVLB  4
00B54:  MOVWF  x33
00B56:  MOVLW  00
00B58:  ADDWFC 02,W
00B5A:  MOVWF  x34
00B5C:  MOVLW  01
00B5E:  ADDWF  x33,W
00B60:  MOVWF  01
00B62:  MOVLW  00
00B64:  ADDWFC x34,W
00B66:  MOVWF  03
00B68:  MOVF   01,W
00B6A:  ADDLW  3A
00B6C:  MOVWF  01
00B6E:  MOVLW  01
00B70:  ADDWFC 03,F
00B72:  MOVFF  01,433
00B76:  MOVFF  03,434
00B7A:  MOVFF  03,436
00B7E:  MOVFF  01,435
00B82:  MOVLB  0
00B84:  BRA    0714
....................     break; 
00B86:  BRA    0CDC
....................     case button_switch: 
....................            // printf("aki"); 
....................             if (input (((struct button_switch)mydevices.myinputs[x].device).realbutton))  
00B88:  MOVLB  4
00B8A:  CLRF   x34
00B8C:  MOVFF  432,433
00B90:  CLRF   x36
00B92:  MOVLW  12
00B94:  MOVWF  x35
00B96:  MOVLB  0
00B98:  CALL   02D8
00B9C:  MOVF   01,W
00B9E:  ADDLW  02
00BA0:  MOVLB  4
00BA2:  MOVWF  x33
00BA4:  MOVLW  00
00BA6:  ADDWFC 02,W
00BA8:  MOVWF  x34
00BAA:  MOVLW  01
00BAC:  ADDWF  x33,W
00BAE:  MOVWF  01
00BB0:  MOVLW  00
00BB2:  ADDWFC x34,W
00BB4:  MOVWF  03
00BB6:  MOVF   01,W
00BB8:  ADDLW  3A
00BBA:  MOVWF  01
00BBC:  MOVLW  01
00BBE:  ADDWFC 03,F
00BC0:  MOVF   01,W
00BC2:  ADDLW  0C
00BC4:  MOVWF  FE9
00BC6:  MOVLW  00
00BC8:  ADDWFC 03,W
00BCA:  MOVWF  FEA
00BCC:  MOVFF  FEF,435
00BD0:  MOVFF  435,436
00BD4:  MOVLW  01
00BD6:  MOVWF  x37
00BD8:  MOVLW  0F
00BDA:  MOVWF  x39
00BDC:  MOVLW  92
00BDE:  MOVWF  x38
00BE0:  MOVLB  0
00BE2:  CALL   02FA
00BE6:  MOVFF  435,436
00BEA:  MOVLW  0F
00BEC:  MOVLB  4
00BEE:  MOVWF  x38
00BF0:  MOVLW  80
00BF2:  MOVWF  x37
00BF4:  MOVLB  0
00BF6:  CALL   033C
00BFA:  BTFSS  01.0
00BFC:  BRA    0C48
....................             { 
....................                ((struct button_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
00BFE:  MOVLB  4
00C00:  CLRF   x34
00C02:  MOVFF  432,433
00C06:  CLRF   x36
00C08:  MOVLW  12
00C0A:  MOVWF  x35
00C0C:  MOVLB  0
00C0E:  CALL   02D8
00C12:  MOVF   01,W
00C14:  ADDLW  02
00C16:  MOVLB  4
00C18:  MOVWF  x33
00C1A:  MOVLW  00
00C1C:  ADDWFC 02,W
00C1E:  MOVWF  x34
00C20:  MOVLW  01
00C22:  ADDWF  x33,W
00C24:  MOVWF  01
00C26:  MOVLW  00
00C28:  ADDWFC x34,W
00C2A:  MOVWF  03
00C2C:  MOVF   01,W
00C2E:  ADDLW  3A
00C30:  MOVWF  01
00C32:  MOVLW  01
00C34:  ADDWFC 03,F
00C36:  MOVF   01,W
00C38:  ADDLW  06
00C3A:  MOVWF  FE9
00C3C:  MOVLW  00
00C3E:  ADDWFC 03,W
00C40:  MOVWF  FEA
00C42:  BSF    FEF.0
....................             } 
....................             else  
00C44:  BRA    0C8E
00C46:  MOVLB  0
....................             { 
....................                ((struct button_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
00C48:  MOVLB  4
00C4A:  CLRF   x34
00C4C:  MOVFF  432,433
00C50:  CLRF   x36
00C52:  MOVLW  12
00C54:  MOVWF  x35
00C56:  MOVLB  0
00C58:  CALL   02D8
00C5C:  MOVF   01,W
00C5E:  ADDLW  02
00C60:  MOVLB  4
00C62:  MOVWF  x33
00C64:  MOVLW  00
00C66:  ADDWFC 02,W
00C68:  MOVWF  x34
00C6A:  MOVLW  01
00C6C:  ADDWF  x33,W
00C6E:  MOVWF  01
00C70:  MOVLW  00
00C72:  ADDWFC x34,W
00C74:  MOVWF  03
00C76:  MOVF   01,W
00C78:  ADDLW  3A
00C7A:  MOVWF  01
00C7C:  MOVLW  01
00C7E:  ADDWFC 03,F
00C80:  MOVF   01,W
00C82:  ADDLW  06
00C84:  MOVWF  FE9
00C86:  MOVLW  00
00C88:  ADDWFC 03,W
00C8A:  MOVWF  FEA
00C8C:  BCF    FEF.0
....................             } 
....................             process_buttons(&mydevices.myinputs[x].device); 
00C8E:  CLRF   x34
00C90:  MOVFF  432,433
00C94:  CLRF   x36
00C96:  MOVLW  12
00C98:  MOVWF  x35
00C9A:  MOVLB  0
00C9C:  CALL   02D8
00CA0:  MOVF   01,W
00CA2:  ADDLW  02
00CA4:  MOVLB  4
00CA6:  MOVWF  x33
00CA8:  MOVLW  00
00CAA:  ADDWFC 02,W
00CAC:  MOVWF  x34
00CAE:  MOVLW  01
00CB0:  ADDWF  x33,W
00CB2:  MOVWF  01
00CB4:  MOVLW  00
00CB6:  ADDWFC x34,W
00CB8:  MOVWF  03
00CBA:  MOVF   01,W
00CBC:  ADDLW  3A
00CBE:  MOVWF  01
00CC0:  MOVLW  01
00CC2:  ADDWFC 03,F
00CC4:  MOVFF  01,433
00CC8:  MOVFF  03,434
00CCC:  MOVFF  03,436
00CD0:  MOVFF  01,435
00CD4:  MOVLB  0
00CD6:  BRA    07FC
....................     break; 
00CD8:  BRA    0CDC
....................     default: 
....................  
....................             break;  
00CDA:  BRA    0CDC
....................             } 
....................  
....................    } 
00CDC:  MOVLB  4
00CDE:  INCF   x32,F
00CE0:  BRA    08B2
.................... } 
00CE2:  MOVLB  0
00CE4:  GOTO   0D02 (RETURN)
.................... void print_inputs() 
.................... { 
....................    int x; 
....................    while(true) 
....................    { 
....................       delay_ms (200) ; 
*
01D94:  MOVLW  C8
01D96:  MOVLB  4
01D98:  MOVWF  x1E
01D9A:  MOVLB  0
01D9C:  BRA    1C36
....................       for(x=0;x<mydevices.numberOfInputs;++x) 
01D9E:  MOVLB  4
01DA0:  CLRF   x1D
01DA2:  MOVLB  1
01DA4:  MOVF   x3A,W
01DA6:  MOVLB  4
01DA8:  SUBWF  x1D,W
01DAA:  BTFSC  FD8.0
01DAC:  BRA    1FDE
01DAE:  CLRF   1B
01DB0:  BTFSC  FF2.7
01DB2:  BSF    1B.7
01DB4:  BCF    FF2.7
....................       { 
....................          switch (mydevices.myinputs[x].type) { 
01DB6:  CLRF   x34
01DB8:  MOVFF  41D,433
01DBC:  CLRF   x36
01DBE:  MOVLW  12
01DC0:  MOVWF  x35
01DC2:  MOVLB  0
01DC4:  CALL   02D8
01DC8:  BTFSC  1B.7
01DCA:  BSF    FF2.7
01DCC:  MOVFF  02,03
01DD0:  MOVF   01,W
01DD2:  ADDLW  3C
01DD4:  MOVWF  FE9
01DD6:  MOVLW  01
01DD8:  ADDWFC 02,W
01DDA:  MOVWF  FEA
01DDC:  MOVF   FEF,W
01DDE:  BZ    1DEE
01DE0:  XORLW  01
01DE2:  BTFSC  FD8.2
01DE4:  BRA    1EBC
01DE6:  XORLW  03
01DE8:  BTFSC  FD8.2
01DEA:  BRA    1F4A
01DEC:  BRA    1FD8
....................             case dimmer_switch: 
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.needs_update) 
01DEE:  MOVLB  1
01DF0:  BTFSS  x3F.0
01DF2:  BRA    1E30
....................                { 
....................                   printf("dim_level %u\n\r"((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.value); 
01DF4:  MOVLW  AA
01DF6:  MOVWF  FF6
01DF8:  MOVLW  02
01DFA:  MOVWF  FF7
01DFC:  MOVLW  00
01DFE:  MOVWF  FF8
01E00:  MOVLW  0A
01E02:  MOVLB  4
01E04:  MOVWF  x21
01E06:  MOVLB  0
01E08:  RCALL  1CBC
01E0A:  MOVFF  13E,41F
01E0E:  MOVLW  1B
01E10:  MOVLB  4
01E12:  MOVWF  x20
01E14:  MOVLB  0
01E16:  RCALL  1D18
01E18:  MOVLW  0A
01E1A:  MOVLB  4
01E1C:  MOVWF  x2A
01E1E:  MOVLB  0
01E20:  RCALL  1C68
01E22:  MOVLW  0D
01E24:  MOVLB  4
01E26:  MOVWF  x2A
01E28:  MOVLB  0
01E2A:  RCALL  1C68
....................                   ((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.needs_update=false; 
01E2C:  MOVLB  1
01E2E:  BCF    x3F.0
....................                } 
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).on.needs_update) 
01E30:  BTFSS  x42.0
01E32:  BRA    1E78
....................                { 
....................                   printf("on %u\n\r",((struct dimmer_switch)mydevices.myinputs[0].device).on.value); 
01E34:  MOVLW  6F
01E36:  MOVLB  4
01E38:  MOVWF  x2A
01E3A:  MOVLB  0
01E3C:  RCALL  1C68
01E3E:  MOVLW  6E
01E40:  MOVLB  4
01E42:  MOVWF  x2A
01E44:  MOVLB  0
01E46:  RCALL  1C68
01E48:  MOVLW  20
01E4A:  MOVLB  4
01E4C:  MOVWF  x2A
01E4E:  MOVLB  0
01E50:  RCALL  1C68
01E52:  MOVFF  141,41F
01E56:  MOVLW  1B
01E58:  MOVLB  4
01E5A:  MOVWF  x20
01E5C:  MOVLB  0
01E5E:  RCALL  1D18
01E60:  MOVLW  0A
01E62:  MOVLB  4
01E64:  MOVWF  x2A
01E66:  MOVLB  0
01E68:  RCALL  1C68
01E6A:  MOVLW  0D
01E6C:  MOVLB  4
01E6E:  MOVWF  x2A
01E70:  MOVLB  0
01E72:  RCALL  1C68
....................                   ((struct dimmer_switch)mydevices.myinputs[0].device).on.needs_update=false; 
01E74:  MOVLB  1
01E76:  BCF    x42.0
....................                }            
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).off.needs_update) 
01E78:  BTFSS  x45.0
01E7A:  BRA    1EB8
....................                { 
....................                   printf("off %u\n\r",((struct dimmer_switch)mydevices.myinputs[0].device).off.value); 
01E7C:  MOVLW  BA
01E7E:  MOVWF  FF6
01E80:  MOVLW  02
01E82:  MOVWF  FF7
01E84:  MOVLW  00
01E86:  MOVWF  FF8
01E88:  MOVLW  04
01E8A:  MOVLB  4
01E8C:  MOVWF  x21
01E8E:  MOVLB  0
01E90:  RCALL  1CBC
01E92:  MOVFF  144,41F
01E96:  MOVLW  1B
01E98:  MOVLB  4
01E9A:  MOVWF  x20
01E9C:  MOVLB  0
01E9E:  RCALL  1D18
01EA0:  MOVLW  0A
01EA2:  MOVLB  4
01EA4:  MOVWF  x2A
01EA6:  MOVLB  0
01EA8:  RCALL  1C68
01EAA:  MOVLW  0D
01EAC:  MOVLB  4
01EAE:  MOVWF  x2A
01EB0:  MOVLB  0
01EB2:  RCALL  1C68
....................                   ((struct dimmer_switch)mydevices.myinputs[0].device).off.needs_update=false; 
01EB4:  MOVLB  1
01EB6:  BCF    x45.0
....................                } 
....................                break; 
01EB8:  MOVLB  0
01EBA:  BRA    1FD8
....................             case on_off_switch: 
....................                if(((struct on_off_switch)mydevices.myinputs[0].device).on.needs_update) 
01EBC:  MOVLB  1
01EBE:  BTFSS  x3F.0
01EC0:  BRA    1F06
....................                { 
....................                   printf("on %u\n\r",((struct on_off_switch)mydevices.myinputs[0].device).on.value); 
01EC2:  MOVLW  6F
01EC4:  MOVLB  4
01EC6:  MOVWF  x2A
01EC8:  MOVLB  0
01ECA:  RCALL  1C68
01ECC:  MOVLW  6E
01ECE:  MOVLB  4
01ED0:  MOVWF  x2A
01ED2:  MOVLB  0
01ED4:  RCALL  1C68
01ED6:  MOVLW  20
01ED8:  MOVLB  4
01EDA:  MOVWF  x2A
01EDC:  MOVLB  0
01EDE:  RCALL  1C68
01EE0:  MOVFF  13E,41F
01EE4:  MOVLW  1B
01EE6:  MOVLB  4
01EE8:  MOVWF  x20
01EEA:  MOVLB  0
01EEC:  RCALL  1D18
01EEE:  MOVLW  0A
01EF0:  MOVLB  4
01EF2:  MOVWF  x2A
01EF4:  MOVLB  0
01EF6:  RCALL  1C68
01EF8:  MOVLW  0D
01EFA:  MOVLB  4
01EFC:  MOVWF  x2A
01EFE:  MOVLB  0
01F00:  RCALL  1C68
....................                   ((struct on_off_switch)mydevices.myinputs[0].device).on.needs_update=false; 
01F02:  MOVLB  1
01F04:  BCF    x3F.0
....................                }            
....................                if(((struct on_off_switch)mydevices.myinputs[0].device).off.needs_update) 
01F06:  BTFSS  x42.0
01F08:  BRA    1F46
....................                { 
....................                   printf("off %u\n\r",((struct on_off_switch)mydevices.myinputs[0].device).off.value); 
01F0A:  MOVLW  C4
01F0C:  MOVWF  FF6
01F0E:  MOVLW  02
01F10:  MOVWF  FF7
01F12:  MOVLW  00
01F14:  MOVWF  FF8
01F16:  MOVLW  04
01F18:  MOVLB  4
01F1A:  MOVWF  x21
01F1C:  MOVLB  0
01F1E:  RCALL  1CBC
01F20:  MOVFF  141,41F
01F24:  MOVLW  1B
01F26:  MOVLB  4
01F28:  MOVWF  x20
01F2A:  MOVLB  0
01F2C:  RCALL  1D18
01F2E:  MOVLW  0A
01F30:  MOVLB  4
01F32:  MOVWF  x2A
01F34:  MOVLB  0
01F36:  RCALL  1C68
01F38:  MOVLW  0D
01F3A:  MOVLB  4
01F3C:  MOVWF  x2A
01F3E:  MOVLB  0
01F40:  RCALL  1C68
....................                   ((struct on_off_switch)mydevices.myinputs[0].device).off.needs_update=false; 
01F42:  MOVLB  1
01F44:  BCF    x42.0
....................                } 
....................             break; 
01F46:  MOVLB  0
01F48:  BRA    1FD8
....................             case button_switch: 
....................                if(((struct button_switch)mydevices.myinputs[0].device).on.needs_update) 
01F4A:  MOVLB  1
01F4C:  BTFSS  x3F.0
01F4E:  BRA    1F94
....................                { 
....................                   printf("on %u\n\r",((struct button_switch)mydevices.myinputs[0].device).on.value); 
01F50:  MOVLW  6F
01F52:  MOVLB  4
01F54:  MOVWF  x2A
01F56:  MOVLB  0
01F58:  RCALL  1C68
01F5A:  MOVLW  6E
01F5C:  MOVLB  4
01F5E:  MOVWF  x2A
01F60:  MOVLB  0
01F62:  RCALL  1C68
01F64:  MOVLW  20
01F66:  MOVLB  4
01F68:  MOVWF  x2A
01F6A:  MOVLB  0
01F6C:  RCALL  1C68
01F6E:  MOVFF  13E,41F
01F72:  MOVLW  1B
01F74:  MOVLB  4
01F76:  MOVWF  x20
01F78:  MOVLB  0
01F7A:  RCALL  1D18
01F7C:  MOVLW  0A
01F7E:  MOVLB  4
01F80:  MOVWF  x2A
01F82:  MOVLB  0
01F84:  RCALL  1C68
01F86:  MOVLW  0D
01F88:  MOVLB  4
01F8A:  MOVWF  x2A
01F8C:  MOVLB  0
01F8E:  RCALL  1C68
....................                   ((struct button_switch)mydevices.myinputs[0].device).on.needs_update=false; 
01F90:  MOVLB  1
01F92:  BCF    x3F.0
....................                }            
....................                if(((struct button_switch)mydevices.myinputs[0].device).off.needs_update) 
01F94:  BTFSS  x42.0
01F96:  BRA    1FD4
....................                { 
....................                   printf("off %u\n\r",((struct button_switch)mydevices.myinputs[0].device).off.value); 
01F98:  MOVLW  CE
01F9A:  MOVWF  FF6
01F9C:  MOVLW  02
01F9E:  MOVWF  FF7
01FA0:  MOVLW  00
01FA2:  MOVWF  FF8
01FA4:  MOVLW  04
01FA6:  MOVLB  4
01FA8:  MOVWF  x21
01FAA:  MOVLB  0
01FAC:  RCALL  1CBC
01FAE:  MOVFF  141,41F
01FB2:  MOVLW  1B
01FB4:  MOVLB  4
01FB6:  MOVWF  x20
01FB8:  MOVLB  0
01FBA:  RCALL  1D18
01FBC:  MOVLW  0A
01FBE:  MOVLB  4
01FC0:  MOVWF  x2A
01FC2:  MOVLB  0
01FC4:  RCALL  1C68
01FC6:  MOVLW  0D
01FC8:  MOVLB  4
01FCA:  MOVWF  x2A
01FCC:  MOVLB  0
01FCE:  RCALL  1C68
....................                   ((struct button_switch)mydevices.myinputs[0].device).off.needs_update=false; 
01FD0:  MOVLB  1
01FD2:  BCF    x42.0
....................                } 
....................             break; 
01FD4:  MOVLB  0
01FD6:  BRA    1FD8
....................          } 
....................       } 
01FD8:  MOVLB  4
01FDA:  INCF   x1D,F
01FDC:  BRA    1DA2
....................    } 
01FDE:  MOVLB  0
01FE0:  BRA    1D94
.................... } 
01FE2:  GOTO   2330 (RETURN)
....................  
.................... #include "interrupt_functions.c" 
.................... int1 flag=0;//mains not detected flag 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  
.................... { 
....................    ++clock; 
*
00CE8:  MOVLW  01
00CEA:  MOVLB  4
00CEC:  ADDWF  x0D,F
00CEE:  BTFSC  FD8.0
00CF0:  INCF   x0E,F
00CF2:  BTFSC  FD8.2
00CF4:  INCF   x0F,F
00CF6:  BTFSC  FD8.2
00CF8:  INCF   x10,F
....................    if (bit_test (clock, 1)) read_inputs(); 
00CFA:  BTFSS  x0D.1
00CFC:  BRA    0D04
00CFE:  MOVLB  0
00D00:  BRA    08AE
00D02:  MOVLB  4
.................... } 
....................  
00D04:  BCF    FF2.2
00D06:  MOVLB  0
00D08:  GOTO   011C
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................    flag = 1; 
00D0C:  BSF    xB1.4
.................... } 
00D0E:  BCF    F9E.0
00D10:  GOTO   011C
.................... #int_TIMER2 
.................... void  TIMER2_isr(void)  
.................... { 
....................    static unsigned int32 clockT2; 
....................    static unsigned int clockT2temp; 
....................    ++clockT2temp; 
00D14:  MOVLB  4
00D16:  INCF   x1A,F
....................    if(clockT2temp==200) 
00D18:  MOVF   x1A,W
00D1A:  SUBLW  C8
00D1C:  BNZ   0D34
....................    { 
....................       output_toggle(LED); 
00D1E:  BCF    F96.2
00D20:  BTG    F8D.2
....................       clockT2temp=0; 
00D22:  CLRF   x1A
....................       ++clockT2; 
00D24:  MOVLW  01
00D26:  ADDWF  x16,F
00D28:  BTFSC  FD8.0
00D2A:  INCF   x17,F
00D2C:  BTFSC  FD8.2
00D2E:  INCF   x18,F
00D30:  BTFSC  FD8.2
00D32:  INCF   x19,F
....................    } 
.................... } 
....................  
00D34:  BCF    F9E.1
00D36:  MOVLB  0
00D38:  GOTO   011C
.................... #int_EXT 
.................... void  EXT_isr(void)  
.................... { 
....................  
....................   // set_timer1 (0) ; 
....................          portc=0xFF; 
00D3C:  MOVLW  FF
00D3E:  MOVWF  F82
....................          portd=0xFF; 
00D40:  MOVWF  F83
....................          if (organizado)  
00D42:  BTFSS  xB1.2
00D44:  BRA    0D68
....................          { 
....................             organizado=0; 
00D46:  BCF    xB1.2
....................             if (actmat)  
00D48:  BTFSS  xB1.3
00D4A:  BRA    0D5C
....................             { 
....................                actmat=0; 
00D4C:  BCF    xB1.3
....................                pointer=delays1; 
00D4E:  MOVLW  03
00D50:  MOVLB  3
00D52:  MOVWF  x50
00D54:  MOVLW  65
00D56:  MOVWF  x4F
....................             } 
....................             else 
00D58:  BRA    0D68
00D5A:  MOVLB  0
....................             { 
....................                actmat=1; 
00D5C:  BSF    xB1.3
....................                pointer=delays2; 
00D5E:  MOVLW  03
00D60:  MOVLB  3
00D62:  MOVWF  x50
00D64:  MOVLW  A9
00D66:  MOVWF  x4F
....................             } 
....................          } 
....................          vez=0; 
00D68:  MOVLB  3
00D6A:  CLRF   x51
....................          CCP_1=matrizluz[fpointer(0,0)]; 
00D6C:  MOVLB  4
00D6E:  CLRF   x34
00D70:  CLRF   x35
*
00DDC:  MOVFF  02,433
00DE0:  MOVFF  01,432
00DE4:  BCF    FD8.0
00DE6:  RLCF   01,W
00DE8:  MOVWF  02
00DEA:  RLCF   x33,W
00DEC:  MOVWF  03
00DEE:  MOVF   02,W
00DF0:  MOVLB  0
00DF2:  CALL   0172
00DF6:  TBLRD*+
00DF8:  MOVFF  FF5,03
00DFC:  MOVWF  FBE
00DFE:  MOVFF  03,FBF
....................          mnumluzes=fpointer(N_LUZES,0); 
00E02:  MOVLW  10
00E04:  MOVLB  4
00E06:  MOVWF  x34
00E08:  CLRF   x35
*
00E74:  MOVFF  01,352
....................          set_timer1(0); 
00E78:  CLRF   FCF
00E7A:  CLRF   FCE
.................... } 
....................  
00E7C:  BCF    FF2.1
00E7E:  MOVLB  0
00E80:  GOTO   011C
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
.................... } 
....................  
00E84:  BCF    F9E.5
00E86:  GOTO   011C
.................... #int_TBE 
.................... void  TBE_isr(void)  
.................... { 
.................... } 
....................  
00E8A:  BCF    F9E.4
00E8C:  GOTO   011C
.................... #int_BUSCOL 
.................... void  BUSCOL_isr(void)  
.................... { 
.................... } 
....................  
00E90:  BCF    FA1.3
00E92:  GOTO   011C
.................... #int_OSCF 
.................... void  OSCF_isr(void)  
.................... { 
.................... } 
....................  
00E96:  BCF    FA1.7
00E98:  GOTO   011C
.................... #int_canrx0 
.................... void canrx0_int ( )  
.................... { 
....................    canReceive (); 
*
01444:  RCALL  1094
....................    // TODO: add CAN recieve code here 
.................... } 
....................  
01446:  BCF    FA4.0
01448:  GOTO   011C
.................... #int_canrx1 
.................... void canrx1_int ( )  
.................... { 
....................    canReceive (); 
0144C:  RCALL  1094
....................    // TODO: add CAN recieve code here 
.................... } 
....................  
0144E:  BCF    FA4.1
01450:  GOTO   011C
.................... #int_cantx0 
.................... void cantx0_int ( )  
.................... { 
....................    canTransmit (); 
*
01874:  RCALL  165A
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
01876:  BCF    FA4.2
01878:  GOTO   011C
.................... #int_cantx1 
.................... void cantx1_int ( )  
.................... { 
....................    canTransmit (); 
0187C:  RCALL  165A
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
0187E:  BCF    FA4.3
01880:  GOTO   011C
.................... #int_cantx2 
.................... void cantx2_int ( )  
.................... { 
....................    canTransmit (); 
01884:  RCALL  165A
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
01886:  BCF    FA4.4
01888:  GOTO   011C
.................... #int_canirx 
.................... void canirx_int ( )  
.................... { 
....................    // TODO: add CAN IRX handling code here 
.................... } 
....................  
0188C:  BCF    FA4.7
0188E:  GOTO   011C
.................... #int_canerr 
.................... void canerr_int ( )  
.................... { 
....................    // TODO: add CAN error handling code here 
.................... } 
....................  
01892:  BCF    FA4.5
01894:  GOTO   011C
.................... #int_CCP1 
.................... void CCP1_isr(void)  
.................... { 
....................    if(mnumluzes!=0) 
01898:  MOVLB  3
0189A:  MOVF   x52,F
0189C:  BTFSC  FD8.2
0189E:  BRA    19C4
....................    { 
....................       int16 auxccp=fpointer(vez,1); 
018A0:  MOVFF  351,434
018A4:  MOVLW  01
018A6:  MOVLB  4
018A8:  MOVWF  x35
*
01914:  MOVFF  02,433
01918:  MOVFF  01,432
....................       portc=(portc & MAKE8(auxccp,1)); 
0191C:  MOVF   x33,W
0191E:  ANDWF  F82,F
....................       portd=(portd & MAKE8(auxccp,0)); 
01920:  MOVF   x32,W
01922:  ANDWF  F83,F
....................       ++vez; 
01924:  MOVLB  3
01926:  INCF   x51,F
....................       --mnumluzes; 
01928:  DECF   x52,F
....................       CCP_1=matrizluz[fpointer(vez,0)]; 
0192A:  MOVFF  351,434
0192E:  MOVLB  4
01930:  CLRF   x35
*
0199C:  MOVFF  02,435
019A0:  MOVFF  01,434
019A4:  BCF    FD8.0
019A6:  RLCF   01,W
019A8:  MOVWF  02
019AA:  RLCF   x35,W
019AC:  MOVWF  03
019AE:  MOVF   02,W
019B0:  MOVLB  0
019B2:  CALL   0172
019B6:  TBLRD*+
019B8:  MOVFF  FF5,03
019BC:  MOVWF  FBE
019BE:  MOVFF  03,FBF
019C2:  MOVLB  3
....................    } 
.................... } 
....................  
019C4:  BCF    F9E.2
019C6:  MOVLB  0
019C8:  GOTO   011C
.................... void interrupts_enable() 
.................... { 
....................    enable_interrupts (int_canrx0); 
*
01C18:  BSF    FA3.0
....................    enable_interrupts (int_canrx1); 
01C1A:  BSF    FA3.1
....................    enable_interrupts (int_cantx0); 
01C1C:  BSF    FA3.2
....................    enable_interrupts (int_cantx1); 
01C1E:  BSF    FA3.3
....................    enable_interrupts (int_cantx2); 
01C20:  BSF    FA3.4
....................    enable_interrupts (int_canirx); 
01C22:  BSF    FA3.7
....................    enable_interrupts (int_canerr); 
01C24:  BSF    FA3.5
....................    enable_interrupts(INT_CCP1); 
01C26:  BSF    F9D.2
....................    enable_interrupts (int_TIMER0) ; 
01C28:  BSF    FF2.5
....................    enable_interrupts (int_TIMER2) ; 
01C2A:  BSF    F9D.1
....................    enable_interrupts (int_EXT) ; 
01C2C:  BSF    FF2.4
....................    //enable_interrupts (int_TBE) ; 
....................    //enable_interrupts (int_BUSCOL) ; 
....................    //enable_interrupts (int_CANIRX) ; 
....................    //enable_interrupts (int_CANERR) ; 
....................    //enable_interrupts (int_CANTX2) ; 
....................    //enable_interrupts (int_CANTX1) ; 
....................    //enable_interrupts (int_CANTX0) ; 
....................    //enable_interrupts (int_CANRX1) ; 
....................    //enable_interrupts (int_CANRX0) ; 
....................    //enable_interrupts (int_OSCF) ; 
....................    enable_interrupts (GLOBAL) ; 
01C2E:  MOVLW  C0
01C30:  IORWF  FF2,F
.................... } 
01C32:  GOTO   232E (RETURN)
....................  
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... void main() 
.................... { 
*
020A2:  CLRF   FF8
020A4:  BCF    FD0.7
020A6:  BSF    07.7
020A8:  CLRF   FEA
020AA:  CLRF   FE9
020AC:  BCF    F93.5
020AE:  BSF    F8A.5
020B0:  CLRF   24
020B2:  BCF    xB1.0
020B4:  CLRF   xB2
020B6:  BSF    xB1.1
020B8:  MOVLB  3
020BA:  CLRF   x4E
020BC:  MOVLB  0
020BE:  BCF    xB1.3
020C0:  MOVLB  4
020C2:  CLRF   x11
020C4:  CLRF   x15
020C6:  CLRF   x14
020C8:  CLRF   x13
020CA:  MOVLW  27
020CC:  MOVWF  x12
020CE:  MOVLB  0
020D0:  BCF    xB1.4
020D2:  MOVF   FC1,W
020D4:  ANDLW  C0
020D6:  IORLW  0F
020D8:  MOVWF  FC1
020DA:  MOVLW  07
020DC:  MOVWF  FB4
020DE:  CLRF   1C
020E0:  MOVLW  01
020E2:  MOVWF  1D
020E4:  MOVLW  02
020E6:  MOVWF  1E
020E8:  MOVLW  03
020EA:  MOVWF  1F
020EC:  MOVLW  04
020EE:  MOVWF  20
020F0:  MOVLW  05
020F2:  MOVWF  21
020F4:  MOVLW  20
020F6:  MOVWF  22
020F8:  MOVLW  21
020FA:  MOVWF  23
020FC:  MOVLW  0B
020FE:  MOVLB  1
02100:  MOVWF  x35
02102:  CLRF   x36
02104:  CLRF   x37
02106:  CLRF   x38
02108:  MOVLW  0A
0210A:  MOVLB  3
0210C:  MOVWF  x55
0210E:  MOVWF  x56
02110:  MOVWF  x57
02112:  MOVWF  x58
02114:  MOVWF  x59
02116:  MOVWF  x5A
02118:  MOVWF  x5B
0211A:  MOVWF  x5C
0211C:  MOVWF  x5D
0211E:  MOVWF  x5E
02120:  MOVWF  x5F
02122:  MOVWF  x60
02124:  MOVWF  x61
02126:  MOVWF  x62
02128:  MOVWF  x63
0212A:  MOVWF  x64
0212C:  CLRF   x65
0212E:  CLRF   x66
02130:  CLRF   x67
02132:  CLRF   x68
02134:  CLRF   x69
02136:  CLRF   x6A
02138:  MOVLW  01
0213A:  MOVWF  x6B
0213C:  CLRF   x6C
0213E:  CLRF   x6D
02140:  CLRF   x6E
02142:  MOVLW  02
02144:  MOVWF  x6F
02146:  CLRF   x70
02148:  CLRF   x71
0214A:  CLRF   x72
0214C:  MOVLW  03
0214E:  MOVWF  x73
02150:  CLRF   x74
02152:  CLRF   x75
02154:  CLRF   x76
02156:  MOVLW  04
02158:  MOVWF  x77
0215A:  CLRF   x78
0215C:  CLRF   x79
0215E:  CLRF   x7A
02160:  MOVLW  05
02162:  MOVWF  x7B
02164:  CLRF   x7C
02166:  CLRF   x7D
02168:  CLRF   x7E
0216A:  MOVLW  06
0216C:  MOVWF  x7F
0216E:  CLRF   x80
02170:  CLRF   x81
02172:  CLRF   x82
02174:  MOVLW  07
02176:  MOVWF  x83
02178:  CLRF   x84
0217A:  CLRF   x85
0217C:  CLRF   x86
0217E:  MOVLW  08
02180:  MOVWF  x87
02182:  CLRF   x88
02184:  CLRF   x89
02186:  CLRF   x8A
02188:  MOVLW  09
0218A:  MOVWF  x8B
0218C:  CLRF   x8C
0218E:  CLRF   x8D
02190:  CLRF   x8E
02192:  MOVLW  0A
02194:  MOVWF  x8F
02196:  CLRF   x90
02198:  CLRF   x91
0219A:  CLRF   x92
0219C:  MOVLW  0B
0219E:  MOVWF  x93
021A0:  CLRF   x94
021A2:  CLRF   x95
021A4:  CLRF   x96
021A6:  MOVLW  0C
021A8:  MOVWF  x97
021AA:  CLRF   x98
021AC:  CLRF   x99
021AE:  CLRF   x9A
021B0:  MOVLW  0D
021B2:  MOVWF  x9B
021B4:  CLRF   x9C
021B6:  CLRF   x9D
021B8:  CLRF   x9E
021BA:  MOVLW  0E
021BC:  MOVWF  x9F
021BE:  CLRF   xA0
021C0:  CLRF   xA1
021C2:  CLRF   xA2
021C4:  MOVLW  0F
021C6:  MOVWF  xA3
021C8:  CLRF   xA4
021CA:  CLRF   xA5
021CC:  CLRF   xA6
021CE:  CLRF   xA7
021D0:  CLRF   xA8
021D2:  CLRF   xA9
021D4:  CLRF   xAA
021D6:  CLRF   xAB
021D8:  CLRF   xAC
021DA:  CLRF   xAD
021DC:  CLRF   xAE
021DE:  MOVLW  01
021E0:  MOVWF  xAF
021E2:  CLRF   xB0
021E4:  CLRF   xB1
021E6:  CLRF   xB2
021E8:  MOVLW  02
021EA:  MOVWF  xB3
021EC:  CLRF   xB4
021EE:  CLRF   xB5
021F0:  CLRF   xB6
021F2:  MOVLW  03
021F4:  MOVWF  xB7
021F6:  CLRF   xB8
021F8:  CLRF   xB9
021FA:  CLRF   xBA
021FC:  MOVLW  04
021FE:  MOVWF  xBB
02200:  CLRF   xBC
02202:  CLRF   xBD
02204:  CLRF   xBE
02206:  MOVLW  05
02208:  MOVWF  xBF
0220A:  CLRF   xC0
0220C:  CLRF   xC1
0220E:  CLRF   xC2
02210:  MOVLW  06
02212:  MOVWF  xC3
02214:  CLRF   xC4
02216:  CLRF   xC5
02218:  CLRF   xC6
0221A:  MOVLW  07
0221C:  MOVWF  xC7
0221E:  CLRF   xC8
02220:  CLRF   xC9
02222:  CLRF   xCA
02224:  MOVLW  08
02226:  MOVWF  xCB
02228:  CLRF   xCC
0222A:  CLRF   xCD
0222C:  CLRF   xCE
0222E:  MOVLW  09
02230:  MOVWF  xCF
02232:  CLRF   xD0
02234:  CLRF   xD1
02236:  CLRF   xD2
02238:  MOVLW  0A
0223A:  MOVWF  xD3
0223C:  CLRF   xD4
0223E:  CLRF   xD5
02240:  CLRF   xD6
02242:  MOVLW  0B
02244:  MOVWF  xD7
02246:  CLRF   xD8
02248:  CLRF   xD9
0224A:  CLRF   xDA
0224C:  MOVLW  0C
0224E:  MOVWF  xDB
02250:  CLRF   xDC
02252:  CLRF   xDD
02254:  CLRF   xDE
02256:  MOVLW  0D
02258:  MOVWF  xDF
0225A:  CLRF   xE0
0225C:  CLRF   xE1
0225E:  CLRF   xE2
02260:  MOVLW  0E
02262:  MOVWF  xE3
02264:  CLRF   xE4
02266:  CLRF   xE5
02268:  CLRF   xE6
0226A:  MOVLW  0F
0226C:  MOVWF  xE7
0226E:  CLRF   xE8
02270:  CLRF   xE9
02272:  CLRF   xEA
02274:  CLRF   xEB
02276:  CLRF   xEC
02278:  MOVLB  4
0227A:  CLRF   x16
0227C:  CLRF   x17
0227E:  CLRF   x18
02280:  CLRF   x19
02282:  CLRF   x1A
....................    clock = 0; 
02284:  CLRF   x10
02286:  CLRF   x0F
02288:  CLRF   x0E
0228A:  CLRF   x0D
....................     
....................    #include "hw_setup.c" 
....................  
.................... ////CAN_BUS SETUP 
.................... can_init () ; 
0228C:  MOVLB  0
0228E:  GOTO   1A44
.................... can_set_mode (CAN_OP_CONFIG) ;   
02292:  MOVLW  04
02294:  MOVLB  4
02296:  MOVWF  x1D
02298:  MOVLB  0
0229A:  CALL   19EE
.................... BRGCON1.brp = 4; 
0229E:  MOVLW  C0
022A0:  ANDWF  F70,W
022A2:  IORLW  04
022A4:  MOVWF  F70
.................... BRGCON1.sjw = 0; 
022A6:  MOVLW  3F
022A8:  ANDWF  F70,W
022AA:  MOVWF  F70
.................... BRGCON2.prseg = 2; 
022AC:  MOVLW  F8
022AE:  ANDWF  F71,W
022B0:  IORLW  02
022B2:  MOVWF  F71
.................... BRGCON2.seg1ph = 5; 
022B4:  MOVLW  C7
022B6:  ANDWF  F71,W
022B8:  IORLW  28
022BA:  MOVWF  F71
.................... BRGCON2.sam = FALSE; 
022BC:  BCF    F71.6
.................... BRGCON2.seg2phts = FALSE; 
022BE:  BCF    F71.7
.................... BRGCON3.seg2ph = 5; 
022C0:  MOVLW  F8
022C2:  ANDWF  F72,W
022C4:  IORLW  05
022C6:  MOVWF  F72
.................... BRGCON3.wakfil = TRUE; 
022C8:  BSF    F72.6
.................... can_set_mode (CAN_OP_NORMAL) ; 
022CA:  MOVLB  4
022CC:  CLRF   x1D
022CE:  MOVLB  0
022D0:  CALL   19EE
....................     
.................... ////TIMERS SETUP 
.................... setup_timer_0 (RTCC_INTERNAL | RTCC_DIV_4); //div16 1.6us thick 104ms overflow 
022D4:  MOVLW  81
022D6:  MOVWF  FD5
.................... setup_timer_1(T1_INTERNAL|T1_DIV_BY_2); 
022D8:  MOVLW  95
022DA:  MOVWF  FCD
.................... setup_timer_2(T2_DIV_BY_16,241,13); 
022DC:  MOVLW  60
022DE:  IORLW  06
022E0:  MOVWF  FCA
022E2:  MOVLW  F1
022E4:  MOVWF  FCB
.................... setup_ccp1(CCP_COMPARE_INT); 
022E6:  MOVLW  0A
022E8:  MOVWF  FBD
....................  
....................  
.................... ////OTHERS 
.................... ext_int_edge(l_to_h); 
022EA:  BSF    FF1.6
....................  
....................  
.................... /////DISABLED HW//////// 
.................... setup_adc_ports (NO_ANALOGS | VSS_VDD) ; 
022EC:  MOVF   FC1,W
022EE:  ANDLW  C0
022F0:  IORLW  0F
022F2:  MOVWF  FC1
.................... setup_adc (ADC_CLOCK_DIV_2 | ADC_TAD_MUL_0) ; 
022F4:  MOVF   FC0,W
022F6:  ANDLW  C0
022F8:  MOVWF  FC0
022FA:  BCF    FC0.7
022FC:  BSF    FC2.0
.................... setup_psp (PSP_DISABLED) ; 
022FE:  BCF    F96.4
.................... setup_spi (SPI_SS_DISABLED) ; 
02300:  BCF    FC6.5
02302:  MOVLW  01
02304:  MOVWF  FC6
02306:  MOVLW  00
02308:  MOVWF  FC7
.................... setup_comparator (NC_NC_NC_NC) ; 
0230A:  MOVLW  07
0230C:  MOVWF  FB4
0230E:  MOVF   F95,W
02310:  MOVWF  F95
02312:  MOVF   F96,W
02314:  MOVWF  F96
02316:  CLRWDT
02318:  MOVLW  20
0231A:  MOVWF  00
0231C:  DECFSZ 00,F
0231E:  BRA    231C
02320:  BRA    2322
02322:  MOVF   FB4,W
02324:  BCF    FA1.6
.................... setup_vref (FALSE) ; 
02326:  CLRF   FB5
.................... setup_timer_3 (T3_DISABLED | T3_DIV_BY_1) ; 
02328:  CLRF   FB1
.................... //setup_wdt (WDT_ON) ; 
....................  
....................  
....................    //TODO: User Code 
....................    //struct switches array[NUMBER_OF_SWITCHES]; 
....................    
....................    test(); 
0232A:  BRA    1BF4
....................     
....................    interrupts_enable(); 
0232C:  BRA    1C18
....................     
....................    print_inputs(); 
0232E:  BRA    1D94
....................    while(organizado==0){} 
02330:  BTFSC  xB1.2
02332:  BRA    2336
02334:  BRA    2330
....................    for(temp=0;temp<17;++temp) 
02336:  MOVLB  1
02338:  CLRF   x39
0233A:  MOVF   x39,W
0233C:  SUBLW  10
0233E:  BTFSS  FD8.0
02340:  BRA    2488
....................    { 
....................       printf("%lu <-> %lu\n\r",fpointer(temp,0),fpointer(temp,1)); 
02342:  MOVFF  139,434
02346:  MOVLB  4
02348:  CLRF   x35
*
023B4:  MOVFF  02,41E
023B8:  MOVFF  01,41D
023BC:  MOVFF  139,434
023C0:  MOVLW  01
023C2:  MOVWF  x35
*
0242E:  MOVFF  02,420
02432:  MOVFF  01,41F
02436:  MOVLW  10
02438:  MOVWF  FE9
0243A:  MOVFF  41E,422
0243E:  MOVFF  41D,421
02442:  MOVLB  0
02444:  RCALL  1FE6
02446:  MOVLW  CF
02448:  MOVWF  FF6
0244A:  MOVLW  19
0244C:  MOVWF  FF7
0244E:  MOVLW  00
02450:  MOVWF  FF8
02452:  MOVLW  05
02454:  MOVLB  4
02456:  MOVWF  x21
02458:  MOVLB  0
0245A:  RCALL  1CBC
0245C:  MOVLW  10
0245E:  MOVWF  FE9
02460:  MOVFF  420,422
02464:  MOVFF  41F,421
02468:  RCALL  1FE6
0246A:  MOVLW  0A
0246C:  MOVLB  4
0246E:  MOVWF  x2A
02470:  MOVLB  0
02472:  CALL   1C68
02476:  MOVLW  0D
02478:  MOVLB  4
0247A:  MOVWF  x2A
0247C:  MOVLB  0
0247E:  CALL   1C68
....................    } 
02482:  MOVLB  1
02484:  INCF   x39,F
02486:  BRA    233A
....................     int16 auxccp=fpointer(0,1); 
02488:  MOVLB  4
0248A:  CLRF   x34
0248C:  MOVLW  01
0248E:  MOVWF  x35
*
024FA:  MOVFF  02,41C
024FE:  MOVFF  01,41B
....................       printf("%lu <-> %u <-> %u\n\r",auxccp,MAKE8(auxccp,1),MAKE8(auxccp,0)); 
02502:  MOVFF  41C,41D
02506:  MOVFF  41B,41E
0250A:  MOVLW  10
0250C:  MOVWF  FE9
0250E:  MOVFF  41C,422
02512:  MOVFF  41B,421
02516:  MOVLB  0
02518:  RCALL  1FE6
0251A:  MOVLW  DD
0251C:  MOVWF  FF6
0251E:  MOVLW  19
02520:  MOVWF  FF7
02522:  MOVLW  00
02524:  MOVWF  FF8
02526:  MOVLW  05
02528:  MOVLB  4
0252A:  MOVWF  x21
0252C:  MOVLB  0
0252E:  CALL   1CBC
02532:  MOVFF  41D,41F
02536:  MOVLW  1B
02538:  MOVLB  4
0253A:  MOVWF  x20
0253C:  MOVLB  0
0253E:  CALL   1D18
02542:  MOVLW  E4
02544:  MOVWF  FF6
02546:  MOVLW  19
02548:  MOVWF  FF7
0254A:  MOVLW  00
0254C:  MOVWF  FF8
0254E:  MOVLW  05
02550:  MOVLB  4
02552:  MOVWF  x21
02554:  MOVLB  0
02556:  CALL   1CBC
0255A:  MOVFF  41E,41F
0255E:  MOVLW  1B
02560:  MOVLB  4
02562:  MOVWF  x20
02564:  MOVLB  0
02566:  CALL   1D18
0256A:  MOVLW  0A
0256C:  MOVLB  4
0256E:  MOVWF  x2A
02570:  MOVLB  0
02572:  CALL   1C68
02576:  MOVLW  0D
02578:  MOVLB  4
0257A:  MOVWF  x2A
0257C:  MOVLB  0
0257E:  CALL   1C68
....................  
.................... } 
....................  
....................  
02582:  SLEEP 

Configuration Fuses:
   Word  1: C600   H4 IESO FCMEN
   Word  2: 0E1F   BROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 00B1   STVREN NODEBUG NOLVP NOXINST BBSIZ4K
   Word  5: C03F   NOPROTECT NOCPD NOCPB
   Word  6: E03F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 403F   NOEBTR NOEBTRB
