CCS PCH C Compiler, Version 4.106, 32200               06-Jun-11 16:25

               Filename: C:\Users\Xapo\Documents\Electronica\domos2011\FW\light_mod\main.lst

               ROM used: 16252 bytes (17%)
                         Largest free fragment is 49280
               RAM used: 1055 (32%) at main() level
                         1176 (35%) worst case
               Stack:    9 worst case (5 in main + 4 for interrupts)

*
00000:  GOTO   3B0A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0D24
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0D48
00074:  BTFSS  F9D.1
00076:  GOTO   0080
0007A:  BTFSC  F9E.1
0007C:  GOTO   0D50
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0D78
0008C:  BTFSS  F9D.5
0008E:  GOTO   0098
00092:  BTFSC  F9E.5
00094:  GOTO   0EC0
00098:  BTFSS  F9D.4
0009A:  GOTO   00A4
0009E:  BTFSC  F9E.4
000A0:  GOTO   0EC6
000A4:  BTFSS  F9D.2
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.2
000AC:  GOTO   18D4
000B0:  BTFSS  FA0.3
000B2:  GOTO   00BC
000B6:  BTFSC  FA1.3
000B8:  GOTO   0ECC
000BC:  BTFSS  FA3.7
000BE:  GOTO   00C8
000C2:  BTFSC  FA4.7
000C4:  GOTO   18C8
000C8:  BTFSS  FA3.5
000CA:  GOTO   00D4
000CE:  BTFSC  FA4.5
000D0:  GOTO   18CE
000D4:  BTFSS  FA3.4
000D6:  GOTO   00E0
000DA:  BTFSC  FA4.4
000DC:  GOTO   18C0
000E0:  BTFSS  FA3.3
000E2:  GOTO   00EC
000E6:  BTFSC  FA4.3
000E8:  GOTO   18B8
000EC:  BTFSS  FA3.2
000EE:  GOTO   00F8
000F2:  BTFSC  FA4.2
000F4:  GOTO   18B0
000F8:  BTFSS  FA3.1
000FA:  GOTO   0104
000FE:  BTFSC  FA4.1
00100:  GOTO   1488
00104:  BTFSS  FA3.0
00106:  GOTO   0110
0010A:  BTFSC  FA4.0
0010C:  GOTO   1480
00110:  BTFSS  FA0.7
00112:  GOTO   011C
00116:  BTFSC  FA1.7
00118:  GOTO   0ED2
0011C:  MOVFF  0E,00
00120:  MOVFF  0F,01
00124:  MOVFF  10,02
00128:  MOVFF  11,03
0012C:  MOVFF  0C,FE9
00130:  MOVFF  07,FEA
00134:  BSF    07.7
00136:  MOVFF  08,FE1
0013A:  MOVFF  09,FE2
0013E:  MOVFF  0A,FD9
00142:  MOVFF  0B,FDA
00146:  MOVFF  12,FF3
0014A:  MOVFF  13,FF4
0014E:  MOVFF  14,FFA
00152:  MOVFF  15,FF5
00156:  MOVFF  16,FF6
0015A:  MOVFF  17,FF7
0015E:  MOVFF  18,FF8
00162:  MOVFF  19,FFB
00166:  MOVF   04,W
00168:  MOVFF  06,FE0
0016C:  MOVFF  05,FD8
00170:  RETFIE 0
....................  
.................... #include "main.h" 
.................... #include <18F4685.h> 
.................... //////// Standard Header file for the PIC18F4685 device //////////////// 
.................... #device PIC18F4685 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES H4                    	//High speed osc with HW enabled 4X PLL 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT              	//Reset when brownout detected 
.................... #FUSES BORV20                	//Brownout reset at 2.0V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                	//PORTB pins are configured as analog input channels on RESET 
.................... #FUSES BBSIZ4K               	//4K words Boot Block size 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES LPT1OSC               	//Timer1 configured for low-power operation 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=40000000,RESTART_WDT) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B5,rcv=PIN_B4,bits=8,restart_wdt) 
*
01E56:  BCF    F93.5
01E58:  BCF    F8A.5
01E5A:  MOVLW  08
01E5C:  MOVWF  01
01E5E:  BRA    1E60
01E60:  NOP   
01E62:  BSF    01.7
01E64:  BRA    1E86
01E66:  BCF    01.7
01E68:  MOVLB  4
01E6A:  RRCF   x4E,F
01E6C:  MOVLB  0
01E6E:  BTFSC  FD8.0
01E70:  BSF    F8A.5
01E72:  BTFSS  FD8.0
01E74:  BCF    F8A.5
01E76:  BSF    01.6
01E78:  BRA    1E86
01E7A:  BCF    01.6
01E7C:  DECFSZ 01,F
01E7E:  BRA    1E68
01E80:  BRA    1E82
01E82:  NOP   
01E84:  BSF    F8A.5
01E86:  MOVLW  01
01E88:  MOVWF  00
01E8A:  CLRF   FE9
01E8C:  DECFSZ FE9,F
01E8E:  BRA    1E8C
01E90:  DECFSZ 00,F
01E92:  BRA    1E8A
01E94:  MOVLW  53
01E96:  MOVWF  FE9
01E98:  DECFSZ FE9,F
01E9A:  BRA    1E98
01E9C:  BRA    1E9E
01E9E:  CLRWDT
01EA0:  BTFSC  01.7
01EA2:  BRA    1E66
01EA4:  BTFSC  01.6
01EA6:  BRA    1E7A
01EA8:  RETLW  00
....................  
....................  
.................... #include "C:\Users\Programacao\Documents\CCS_Projects\18F\LightMod\global_defs.h" 
.................... #define  NUMBER_OF_SWITCHES 8 
.................... #define  LED PIN_E2 
.................... #define  OUT1  PIN_C0   //16 
.................... #define  OUT2  PIN_C1   //15 
.................... #define  OUT3  PIN_C2   //14 
.................... #define  OUT4  PIN_C3   //13 
.................... #define  OUT5  PIN_C4   //12 
.................... #define  OUT6  PIN_C5   //11 
.................... #define  OUT7  PIN_C6   //10 
.................... #define  OUT8  PIN_C7   //9 
.................... #define  OUT9  PIN_D1   //8 
.................... #define  OUT10  PIN_D0  //7 
.................... #define  OUT11  PIN_D2  //6 
.................... #define  OUT12  PIN_D3  //5 
.................... #define  OUT13  PIN_D7  //4 
.................... #define  OUT14  PIN_D6  //3 
.................... #define  OUT15  PIN_D5  //2 
.................... #define  OUT16  PIN_D4  //1 
....................  
.................... #define  INP1  PIN_A0 
.................... #define  INP2  PIN_A1 
.................... #define  INP3  PIN_A2 
.................... #define  INP4  PIN_A3 
.................... #define  INP5  PIN_A4 
.................... #define  INP6  PIN_A5 
.................... #define  INP7  PIN_E0 
.................... #define  INP8  PIN_E1 
....................  
.................... #byte porta=0xf80 
.................... #byte portb=0xf81 
.................... #byte portc=0xf82 
.................... #byte portd=0xf83 
.................... #byte porte=0xf84 
.................... #byte trisa=0xf92 
.................... #byte trisb=0xf93 
.................... #byte trisc=0xf94 
.................... #byte trisd=0xf95 
.................... #byte trise=0xf96 
....................  
.................... static int inputs[8]={INP1,INP2,INP3,INP4,INP5,INP6,INP7,INP8}; 
....................  
.................... #include "C:\Users\Programacao\Documents\CCS_Projects\18F\LightMod\can_functions.c" 
.................... #define CAN_USE_EXTENDED_ID FALSE 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = 0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = 0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT=0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1=0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2=0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3=0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive caputre 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON=0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON=0xF40 
.................... #byte   TXB1CON=0xF30 
.................... #byte   TXB2CON=0xF20 
.................... #byte TXBaCON=0xF60 //txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH=0xF41 
.................... #byte TXB0SIDL=0xF42 
.................... #byte TXB1SIDH=0xF31 
.................... #byte TXB1SIDL=0xF32 
.................... #byte TXB2SIDH=0xF21 
.................... #byte TXB2SIDL=0xF22 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH=0xF43 
.................... #byte TXB0EIDL=0xF44 
.................... #byte TXB1EIDH=0xF33 
.................... #byte TXB1EIDL=0xF34 
.................... #byte TXB2EIDH=0xF23 
.................... #byte TXB2EIDL=0xF24 
....................  
.................... #define RX0MASK      0xF1B    //rxm0eidl 
.................... #define RX1MASK      0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   0xF03    //rxf0eidl 
.................... #define RX0FILTER1   0xF07    //rxf1eidl 
.................... #define RX1FILTER2   0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   0xF13    //rxf4eidl 
.................... #define RX1FILTER5   0xF17    //rxf5eidl 
.................... #define RXB0ID       0xF64    //rxb0eidl 
.................... #define RXB1ID       0xF54    //rxb1eidl 
.................... #define TXB0ID       0xF44    //txb0eidl 
.................... #define TXB1ID       0xF34    //txb1eidl 
.................... #define TXB2ID       0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0=0xF46 
.................... #byte TXB0D7=0xF4D 
.................... #byte TXB1D0=0xF36 
.................... #byte TXB1D7=0xF3D 
.................... #byte TXB2D0=0xF26 
.................... #byte TXB2D7=0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC=0xF45 
.................... #byte TXB1DLC=0xF35 
.................... #byte TXB2DLC=0xF25 
.................... #byte TXBaDLC=0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON=0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON=0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH=0xF61 
.................... #byte   RXB0SIDL=0xF62 
.................... #byte   RXB1SIDH=0xF51 
.................... #byte   RXB1SIDL=0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH=0xF63 
.................... #byte   RXB0EIDL=0xF64 
.................... #byte   RXB1EIDH=0xF53 
.................... #byte   RXB1EIDL=0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC=0xF65 
.................... #byte   RXB1DLC=0xF55 
.................... #byte   RXBaDLC=0xF65 
....................  
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0=0xF66 
.................... #byte RXB0D7=0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT=0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH=0xF00 
.................... #byte RXF0SIDL=0xF01 
.................... #byte RXF1SIDH=0xF04 
.................... #byte RXF1SIDL=0xF05 
.................... #byte RXF2SIDH=0xF08 
.................... #byte RXF2SIDL=0xF09 
.................... #byte RXF3SIDH=0xF0C 
.................... #byte RXF3SIDL=0xF0D 
.................... #byte RXF4SIDH=0xF10 
.................... #byte RXF4SIDL=0xF11 
.................... #byte RXF5SIDH=0xF14 
.................... #byte RXF5SIDL=0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH=0xF02 
.................... #byte RXF0EIDL=0xF03 
.................... #byte RXF1EIDH=0xF06 
.................... #byte RXF1EIDL=0xF07 
.................... #byte RXF2EIDH=0xF0A 
.................... #byte RXF2EIDL=0xF0B 
.................... #byte RXF3EIDH=0xF0E 
.................... #byte RXF3EIDL=0xF0F 
.................... #byte RXF4EIDH=0xF12 
.................... #byte RXF4EIDL=0xF13 
.................... #byte RXF5EIDH=0xF16 
.................... #byte RXF5EIDL=0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH=0xF18 
.................... #byte RXM0SIDL=0xF19 
.................... #byte RXM1SIDH=0xF1C 
.................... #byte RXM1SIDL=0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH=0xF1A 
.................... #byte RXM0EIDL=0xF1B 
.................... #byte RXM1EIDH=0xF1E 
.................... #byte RXM1EIDL=0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = 0xFA4.7 
.................... #bit CAN_INT_WAKIF = 0xFA4.6 
.................... #bit CAN_INT_ERRIF = 0xFA4.5 
.................... #bit CAN_INT_TXB2IF = 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(int* addr, int32 id, int1 ext); 
.................... int32 can_get_id(int * addr, int1 ext); 
.................... int   can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(int32 & id, int * data, int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
01A80:  MOVLW  04
01A82:  MOVLB  4
01A84:  MOVWF  x1D
01A86:  MOVLB  0
01A88:  RCALL  1A2A
....................    can_set_baud(); 
01A8A:  BRA    1A50
....................  
....................    RXB0CON=0; 
01A8C:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
01A8E:  MOVLW  9F
01A90:  ANDWF  F60,W
01A92:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
01A94:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
01A96:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
01A9A:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
01A9C:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
01A9E:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
01AA0:  BCF    F73.6
01AA2:  CLRF   1B
01AA4:  BTFSC  FF2.7
01AA6:  BSF    1B.7
01AA8:  BCF    FF2.7
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
01AAA:  MOVLW  0F
01AAC:  MOVLB  4
01AAE:  MOVWF  x8C
01AB0:  MOVLW  1B
01AB2:  MOVWF  x8B
01AB4:  CLRF   x90
01AB6:  CLRF   x8F
01AB8:  CLRF   x8E
01ABA:  CLRF   x8D
01ABC:  CLRF   x91
01ABE:  MOVLB  0
01AC0:  RCALL  1490
01AC2:  BTFSC  1B.7
01AC4:  BSF    FF2.7
01AC6:  CLRF   1B
01AC8:  BTFSC  FF2.7
01ACA:  BSF    1B.7
01ACC:  BCF    FF2.7
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
01ACE:  MOVLW  0F
01AD0:  MOVLB  4
01AD2:  MOVWF  x8C
01AD4:  MOVLW  03
01AD6:  MOVWF  x8B
01AD8:  CLRF   x90
01ADA:  CLRF   x8F
01ADC:  CLRF   x8E
01ADE:  CLRF   x8D
01AE0:  CLRF   x91
01AE2:  MOVLB  0
01AE4:  RCALL  1490
01AE6:  BTFSC  1B.7
01AE8:  BSF    FF2.7
01AEA:  CLRF   1B
01AEC:  BTFSC  FF2.7
01AEE:  BSF    1B.7
01AF0:  BCF    FF2.7
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
01AF2:  MOVLW  0F
01AF4:  MOVLB  4
01AF6:  MOVWF  x8C
01AF8:  MOVLW  07
01AFA:  MOVWF  x8B
01AFC:  CLRF   x90
01AFE:  CLRF   x8F
01B00:  CLRF   x8E
01B02:  CLRF   x8D
01B04:  CLRF   x91
01B06:  MOVLB  0
01B08:  RCALL  1490
01B0A:  BTFSC  1B.7
01B0C:  BSF    FF2.7
01B0E:  CLRF   1B
01B10:  BTFSC  FF2.7
01B12:  BSF    1B.7
01B14:  BCF    FF2.7
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
01B16:  MOVLW  0F
01B18:  MOVLB  4
01B1A:  MOVWF  x8C
01B1C:  MOVLW  1F
01B1E:  MOVWF  x8B
01B20:  CLRF   x90
01B22:  CLRF   x8F
01B24:  CLRF   x8E
01B26:  CLRF   x8D
01B28:  CLRF   x91
01B2A:  MOVLB  0
01B2C:  RCALL  1490
01B2E:  BTFSC  1B.7
01B30:  BSF    FF2.7
01B32:  CLRF   1B
01B34:  BTFSC  FF2.7
01B36:  BSF    1B.7
01B38:  BCF    FF2.7
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
01B3A:  MOVLW  0F
01B3C:  MOVLB  4
01B3E:  MOVWF  x8C
01B40:  MOVLW  0B
01B42:  MOVWF  x8B
01B44:  CLRF   x90
01B46:  CLRF   x8F
01B48:  CLRF   x8E
01B4A:  CLRF   x8D
01B4C:  CLRF   x91
01B4E:  MOVLB  0
01B50:  RCALL  1490
01B52:  BTFSC  1B.7
01B54:  BSF    FF2.7
01B56:  CLRF   1B
01B58:  BTFSC  FF2.7
01B5A:  BSF    1B.7
01B5C:  BCF    FF2.7
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
01B5E:  MOVLW  0F
01B60:  MOVLB  4
01B62:  MOVWF  x8C
01B64:  MOVWF  x8B
01B66:  CLRF   x90
01B68:  CLRF   x8F
01B6A:  CLRF   x8E
01B6C:  CLRF   x8D
01B6E:  CLRF   x91
01B70:  MOVLB  0
01B72:  RCALL  1490
01B74:  BTFSC  1B.7
01B76:  BSF    FF2.7
01B78:  CLRF   1B
01B7A:  BTFSC  FF2.7
01B7C:  BSF    1B.7
01B7E:  BCF    FF2.7
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
01B80:  MOVLW  0F
01B82:  MOVLB  4
01B84:  MOVWF  x8C
01B86:  MOVLW  13
01B88:  MOVWF  x8B
01B8A:  CLRF   x90
01B8C:  CLRF   x8F
01B8E:  CLRF   x8E
01B90:  CLRF   x8D
01B92:  CLRF   x91
01B94:  MOVLB  0
01B96:  RCALL  1490
01B98:  BTFSC  1B.7
01B9A:  BSF    FF2.7
01B9C:  CLRF   1B
01B9E:  BTFSC  FF2.7
01BA0:  BSF    1B.7
01BA2:  BCF    FF2.7
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
01BA4:  MOVLW  0F
01BA6:  MOVLB  4
01BA8:  MOVWF  x8C
01BAA:  MOVLW  17
01BAC:  MOVWF  x8B
01BAE:  CLRF   x90
01BB0:  CLRF   x8F
01BB2:  CLRF   x8E
01BB4:  CLRF   x8D
01BB6:  CLRF   x91
01BB8:  MOVLB  0
01BBA:  RCALL  1490
01BBC:  BTFSC  1B.7
01BBE:  BSF    FF2.7
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
01BC0:  MOVF   F93,W
01BC2:  ANDLW  FB
01BC4:  IORLW  08
01BC6:  MOVLB  4
01BC8:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
01BCA:  CLRF   x1D
01BCC:  MOVLB  0
01BCE:  RCALL  1A2A
.................... } 
01BD0:  GOTO   1BD6 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
01A50:  MOVLW  C0
01A52:  ANDWF  F70,W
01A54:  IORLW  04
01A56:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
01A58:  MOVLW  3F
01A5A:  ANDWF  F70,W
01A5C:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
01A5E:  MOVLW  F8
01A60:  ANDWF  F71,W
01A62:  IORLW  02
01A64:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
01A66:  MOVLW  C7
01A68:  ANDWF  F71,W
01A6A:  IORLW  28
01A6C:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
01A6E:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
01A70:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
01A72:  MOVLW  F8
01A74:  ANDWF  F72,W
01A76:  IORLW  05
01A78:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
01A7A:  BCF    F72.6
.................... } 
01A7C:  GOTO   1A8C (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
01A2A:  MOVLB  4
01A2C:  SWAPF  x1D,W
01A2E:  ANDLW  70
01A30:  MOVWF  00
01A32:  BCF    FD8.0
01A34:  RLCF   00,F
01A36:  MOVLW  1F
01A38:  ANDWF  F6F,W
01A3A:  IORWF  00,W
01A3C:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
01A3E:  MOVFF  F6E,00
01A42:  SWAPF  00,F
01A44:  RRCF   00,W
01A46:  ANDLW  07
01A48:  SUBWF  x1D,W
01A4A:  BNZ   1A3E
.................... } 
01A4C:  MOVLB  0
01A4E:  RETLW  00
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(int* addr, int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
01490:  MOVFF  48C,493
01494:  MOVFF  48B,492
....................  
....................    if (ext) {  //extended 
01498:  MOVLB  4
0149A:  MOVF   x91,F
0149C:  BZ    1542
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
0149E:  MOVFF  492,FE9
014A2:  MOVFF  493,FEA
014A6:  MOVFF  48D,FEF
....................  
....................       //eidh 
....................       ptr--; 
014AA:  MOVF   x92,W
014AC:  BTFSC  FD8.2
014AE:  DECF   x93,F
014B0:  DECF   x92,F
....................       *ptr=make8(id,1); //8:15 
014B2:  MOVFF  492,FE9
014B6:  MOVFF  493,FEA
014BA:  MOVFF  48E,FEF
....................  
....................       //sidl 
....................       ptr--; 
014BE:  MOVF   x92,W
014C0:  BTFSC  FD8.2
014C2:  DECF   x93,F
014C4:  DECF   x92,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
014C6:  MOVFF  492,FE9
014CA:  MOVFF  493,FEA
014CE:  MOVF   x8F,W
014D0:  ANDLW  03
014D2:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
014D4:  MOVFF  492,FE9
014D8:  MOVFF  493,FEA
014DC:  MOVFF  48F,00
014E0:  RLCF   00,F
014E2:  RLCF   00,F
014E4:  RLCF   00,F
014E6:  MOVLW  F8
014E8:  ANDWF  00,F
014EA:  MOVF   00,W
014EC:  ANDLW  E0
014EE:  IORWF  FEF,W
014F0:  MOVWF  FEF
....................       *ptr|=0x08; 
014F2:  MOVFF  492,FE9
014F6:  MOVFF  493,FEA
014FA:  MOVF   FEF,W
014FC:  IORLW  08
014FE:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
01500:  MOVF   x92,W
01502:  BTFSC  FD8.2
01504:  DECF   x93,F
01506:  DECF   x92,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
01508:  MOVFF  492,FE9
0150C:  MOVFF  493,FEA
01510:  MOVFF  48F,00
01514:  SWAPF  00,F
01516:  RRCF   00,F
01518:  MOVLW  07
0151A:  ANDWF  00,F
0151C:  MOVF   00,W
0151E:  ANDLW  07
01520:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
01522:  MOVFF  492,FE9
01526:  MOVFF  493,FEA
0152A:  MOVFF  490,00
0152E:  RLCF   00,F
01530:  RLCF   00,F
01532:  RLCF   00,F
01534:  MOVLW  F8
01536:  ANDWF  00,F
01538:  MOVF   00,W
0153A:  ANDLW  F8
0153C:  IORWF  FEF,W
0153E:  MOVWF  FEF
....................    } 
....................    else {   //standard 
01540:  BRA    15C0
....................       //eidl 
....................       *ptr=0; 
01542:  MOVFF  492,FE9
01546:  MOVFF  493,FEA
0154A:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
0154C:  MOVF   x92,W
0154E:  BTFSC  FD8.2
01550:  DECF   x93,F
01552:  DECF   x92,F
....................       *ptr=0; 
01554:  MOVFF  492,FE9
01558:  MOVFF  493,FEA
0155C:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
0155E:  MOVF   x92,W
01560:  BTFSC  FD8.2
01562:  DECF   x93,F
01564:  DECF   x92,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
01566:  MOVFF  492,FE9
0156A:  MOVFF  493,FEA
0156E:  MOVFF  48D,00
01572:  SWAPF  00,F
01574:  RLCF   00,F
01576:  MOVLW  E0
01578:  ANDWF  00,F
0157A:  MOVF   00,W
0157C:  ANDLW  E0
0157E:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
01580:  MOVF   x92,W
01582:  BTFSC  FD8.2
01584:  DECF   x93,F
01586:  DECF   x92,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
01588:  MOVFF  492,FE9
0158C:  MOVFF  493,FEA
01590:  MOVFF  48D,00
01594:  RRCF   00,F
01596:  RRCF   00,F
01598:  RRCF   00,F
0159A:  MOVLW  1F
0159C:  ANDWF  00,F
0159E:  MOVF   00,W
015A0:  ANDLW  1F
015A2:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
015A4:  MOVFF  492,FE9
015A8:  MOVFF  493,FEA
015AC:  MOVFF  48E,00
015B0:  SWAPF  00,F
015B2:  RLCF   00,F
015B4:  MOVLW  E0
015B6:  ANDWF  00,F
015B8:  MOVF   00,W
015BA:  ANDLW  E0
015BC:  IORWF  FEF,W
015BE:  MOVWF  FEF
....................    } 
.................... } 
015C0:  MOVLB  0
015C2:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int32 can_get_id(int * addr, int1 ext) { 
....................    int32 ret; 
....................    int * ptr; 
....................  
....................    ret=0; 
*
00ED8:  MOVLB  4
00EDA:  CLRF   x8D
00EDC:  CLRF   x8C
00EDE:  CLRF   x8B
00EE0:  CLRF   x8A
....................    ptr=addr; 
00EE2:  MOVFF  488,48F
00EE6:  MOVFF  487,48E
....................  
....................    if (ext) { 
00EEA:  MOVF   x89,F
00EEC:  BTFSC  FD8.2
00EEE:  BRA    1016
....................       ret=*ptr;  //eidl 
00EF0:  MOVFF  48F,03
00EF4:  MOVFF  48E,FE9
00EF8:  MOVFF  48F,FEA
00EFC:  MOVFF  FEF,00
00F00:  CLRF   01
00F02:  CLRF   02
00F04:  CLRF   03
00F06:  MOVFF  03,48D
00F0A:  MOVFF  02,48C
00F0E:  MOVFF  01,48B
00F12:  MOVFF  00,48A
....................  
....................       ptr--;     //eidh 
00F16:  MOVF   x8E,W
00F18:  BTFSC  FD8.2
00F1A:  DECF   x8F,F
00F1C:  DECF   x8E,F
....................       ret|=((int32)*ptr << 8); 
00F1E:  MOVFF  48E,FE9
00F22:  MOVFF  48F,FEA
00F26:  MOVF   FEF,W
00F28:  CLRF   x92
00F2A:  CLRF   x91
00F2C:  MOVWF  x90
00F2E:  CLRF   00
00F30:  MOVF   00,W
00F32:  IORWF  x8A,F
00F34:  MOVF   x90,W
00F36:  IORWF  x8B,F
00F38:  MOVF   x91,W
00F3A:  IORWF  x8C,F
00F3C:  MOVF   x92,W
00F3E:  IORWF  x8D,F
....................  
....................       ptr--;     //sidl 
00F40:  MOVF   x8E,W
00F42:  BTFSC  FD8.2
00F44:  DECF   x8F,F
00F46:  DECF   x8E,F
....................       ret|=((int32)*ptr & 0x03) << 16; 
00F48:  MOVFF  48E,FE9
00F4C:  MOVFF  48F,FEA
00F50:  MOVF   FEF,W
00F52:  CLRF   x93
00F54:  CLRF   x92
00F56:  CLRF   x91
00F58:  MOVWF  x90
00F5A:  MOVLW  03
00F5C:  ANDWF  x90,F
00F5E:  CLRF   x91
00F60:  CLRF   x92
00F62:  CLRF   x93
00F64:  CLRF   00
00F66:  CLRF   01
00F68:  MOVF   00,W
00F6A:  IORWF  x8A,F
00F6C:  MOVF   01,W
00F6E:  IORWF  x8B,F
00F70:  MOVF   x90,W
00F72:  IORWF  x8C,F
00F74:  MOVF   x91,W
00F76:  IORWF  x8D,F
....................       ret|=((int32)*ptr & 0xE0) << 13; 
00F78:  MOVFF  48E,FE9
00F7C:  MOVFF  48F,FEA
00F80:  MOVF   FEF,W
00F82:  CLRF   x93
00F84:  CLRF   x92
00F86:  CLRF   x91
00F88:  MOVWF  x90
00F8A:  MOVLW  E0
00F8C:  ANDWF  x90,F
00F8E:  CLRF   x91
00F90:  CLRF   x92
00F92:  CLRF   x93
00F94:  CLRF   00
00F96:  RLCF   x90,W
00F98:  MOVWF  01
00F9A:  RLCF   x91,W
00F9C:  MOVWF  02
00F9E:  RLCF   x92,W
00FA0:  MOVWF  03
00FA2:  RLCF   01,F
00FA4:  RLCF   02,F
00FA6:  RLCF   03,F
00FA8:  RLCF   01,F
00FAA:  RLCF   02,F
00FAC:  RLCF   03,F
00FAE:  RLCF   01,F
00FB0:  RLCF   02,F
00FB2:  RLCF   03,F
00FB4:  RLCF   01,F
00FB6:  RLCF   02,F
00FB8:  RLCF   03,F
00FBA:  MOVLW  E0
00FBC:  ANDWF  01,F
00FBE:  MOVF   00,W
00FC0:  IORWF  x8A,F
00FC2:  MOVF   01,W
00FC4:  IORWF  x8B,F
00FC6:  MOVF   02,W
00FC8:  IORWF  x8C,F
00FCA:  MOVF   03,W
00FCC:  IORWF  x8D,F
....................  
....................       ptr--;     //sidh 
00FCE:  MOVF   x8E,W
00FD0:  BTFSC  FD8.2
00FD2:  DECF   x8F,F
00FD4:  DECF   x8E,F
....................       ret|=((int32)*ptr << 21); 
00FD6:  MOVFF  48E,FE9
00FDA:  MOVFF  48F,FEA
00FDE:  MOVF   FEF,W
00FE0:  CLRF   x91
00FE2:  MOVWF  x90
00FE4:  CLRF   00
00FE6:  CLRF   01
00FE8:  RLCF   x90,W
00FEA:  MOVWF  02
00FEC:  RLCF   x91,W
00FEE:  MOVWF  03
00FF0:  RLCF   02,F
00FF2:  RLCF   03,F
00FF4:  RLCF   02,F
00FF6:  RLCF   03,F
00FF8:  RLCF   02,F
00FFA:  RLCF   03,F
00FFC:  RLCF   02,F
00FFE:  RLCF   03,F
01000:  MOVLW  E0
01002:  ANDWF  02,F
01004:  MOVF   00,W
01006:  IORWF  x8A,F
01008:  MOVF   01,W
0100A:  IORWF  x8B,F
0100C:  MOVF   02,W
0100E:  IORWF  x8C,F
01010:  MOVF   03,W
01012:  IORWF  x8D,F
....................  
....................    } 
....................    else { 
01014:  BRA    10BC
....................       ptr-=2;    //sidl 
01016:  MOVLW  02
01018:  SUBWF  x8E,F
0101A:  MOVLW  00
0101C:  SUBWFB x8F,F
....................       ret=((int32)*ptr & 0xE0) >> 5; 
0101E:  MOVFF  48E,FE9
01022:  MOVFF  48F,FEA
01026:  MOVF   FEF,W
01028:  CLRF   x93
0102A:  CLRF   x92
0102C:  CLRF   x91
0102E:  MOVWF  x90
01030:  MOVLW  E0
01032:  ANDWF  x90,F
01034:  CLRF   x91
01036:  CLRF   x92
01038:  CLRF   x93
0103A:  RRCF   x93,W
0103C:  MOVWF  x8D
0103E:  RRCF   x92,W
01040:  MOVWF  x8C
01042:  RRCF   x91,W
01044:  MOVWF  x8B
01046:  RRCF   x90,W
01048:  MOVWF  x8A
0104A:  RRCF   x8D,F
0104C:  RRCF   x8C,F
0104E:  RRCF   x8B,F
01050:  RRCF   x8A,F
01052:  RRCF   x8D,F
01054:  RRCF   x8C,F
01056:  RRCF   x8B,F
01058:  RRCF   x8A,F
0105A:  RRCF   x8D,F
0105C:  RRCF   x8C,F
0105E:  RRCF   x8B,F
01060:  RRCF   x8A,F
01062:  RRCF   x8D,F
01064:  RRCF   x8C,F
01066:  RRCF   x8B,F
01068:  RRCF   x8A,F
0106A:  MOVLW  07
0106C:  ANDWF  x8D,F
....................  
....................       ptr--;     //sidh 
0106E:  MOVF   x8E,W
01070:  BTFSC  FD8.2
01072:  DECF   x8F,F
01074:  DECF   x8E,F
....................       ret|=((int32)*ptr << 3); 
01076:  MOVFF  48E,FE9
0107A:  MOVFF  48F,FEA
0107E:  MOVF   FEF,W
01080:  CLRF   x93
01082:  CLRF   x92
01084:  CLRF   x91
01086:  MOVWF  x90
01088:  RLCF   x90,W
0108A:  MOVWF  00
0108C:  RLCF   x91,W
0108E:  MOVWF  01
01090:  RLCF   x92,W
01092:  MOVWF  02
01094:  RLCF   x93,W
01096:  MOVWF  03
01098:  RLCF   00,F
0109A:  RLCF   01,F
0109C:  RLCF   02,F
0109E:  RLCF   03,F
010A0:  RLCF   00,F
010A2:  RLCF   01,F
010A4:  RLCF   02,F
010A6:  RLCF   03,F
010A8:  MOVLW  F8
010AA:  ANDWF  00,F
010AC:  MOVF   00,W
010AE:  IORWF  x8A,F
010B0:  MOVF   01,W
010B2:  IORWF  x8B,F
010B4:  MOVF   02,W
010B6:  IORWF  x8C,F
010B8:  MOVF   03,W
010BA:  IORWF  x8D,F
....................    } 
....................  
....................    return(ret); 
010BC:  MOVFF  48A,00
010C0:  MOVFF  48B,01
010C4:  MOVFF  48C,02
010C8:  MOVFF  48D,03
.................... } 
010CC:  MOVLB  0
010CE:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr) { 
....................    int i; 
....................    int * txd0; 
....................    int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
015C4:  MOVLW  0F
015C6:  MOVLB  4
015C8:  MOVWF  x89
015CA:  MOVLW  66
015CC:  MOVWF  x88
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
015CE:  MOVLB  F
015D0:  BTFSC  x40.3
015D2:  BRA    15E4
....................       CANCON.win=CAN_WIN_TX0; 
015D4:  MOVLW  F1
015D6:  ANDWF  F6F,W
015D8:  IORLW  08
015DA:  MOVWF  F6F
....................       port=0; 
015DC:  MOVLB  4
015DE:  CLRF   x8A
....................    } 
....................    else if (!TXB1CON.txreq) { 
015E0:  BRA    1618
015E2:  MOVLB  F
015E4:  BTFSC  x30.3
015E6:  BRA    15FA
....................       CANCON.win=CAN_WIN_TX1; 
015E8:  MOVLW  F1
015EA:  ANDWF  F6F,W
015EC:  IORLW  06
015EE:  MOVWF  F6F
....................       port=1; 
015F0:  MOVLW  01
015F2:  MOVLB  4
015F4:  MOVWF  x8A
....................    } 
....................    else if (!TXB2CON.txreq) { 
015F6:  BRA    1618
015F8:  MOVLB  F
015FA:  BTFSC  x20.3
015FC:  BRA    1610
....................       CANCON.win=CAN_WIN_TX2; 
015FE:  MOVLW  F1
01600:  ANDWF  F6F,W
01602:  IORLW  04
01604:  MOVWF  F6F
....................       port=2; 
01606:  MOVLW  02
01608:  MOVLB  4
0160A:  MOVWF  x8A
....................    } 
....................    else { 
0160C:  BRA    1618
0160E:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
01610:  MOVLW  00
01612:  MOVWF  01
01614:  BRA    1690
01616:  MOVLB  4
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
01618:  MOVF   x84,W
0161A:  ANDLW  03
0161C:  MOVWF  00
0161E:  MOVLW  FC
01620:  ANDWF  F60,W
01622:  IORWF  00,W
01624:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
01626:  MOVLW  0F
01628:  MOVWF  x8C
0162A:  MOVLW  64
0162C:  MOVWF  x8B
0162E:  MOVFF  480,490
01632:  MOVFF  47F,48F
01636:  MOVFF  47E,48E
0163A:  MOVFF  47D,48D
0163E:  MOVFF  485,491
01642:  MOVLB  0
01644:  RCALL  1490
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
01646:  MOVFF  483,F65
....................    TXBaDLC.rtr=rtr; 
0164A:  BCF    F65.6
0164C:  MOVLB  4
0164E:  BTFSC  x86.0
01650:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
01652:  CLRF   x87
01654:  MOVF   x83,W
01656:  SUBWF  x87,W
01658:  BC    1682
....................       *txd0=*data; 
0165A:  MOVFF  481,FE9
0165E:  MOVFF  482,FEA
01662:  MOVFF  FEF,48D
01666:  MOVFF  489,FEA
0166A:  MOVFF  488,FE9
0166E:  MOVFF  48D,FEF
....................       txd0++; 
01672:  INCF   x88,F
01674:  BTFSC  FD8.2
01676:  INCF   x89,F
....................       data++; 
01678:  INCF   x81,F
0167A:  BTFSC  FD8.2
0167C:  INCF   x82,F
....................     } 
0167E:  INCF   x87,F
01680:  BRA    1654
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
01682:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
01684:  MOVLW  F1
01686:  ANDWF  F6F,W
01688:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
0168A:  MOVLW  01
0168C:  MOVWF  01
0168E:  MOVLB  F
.................... } 
01690:  MOVLB  0
01692:  GOTO   18A8 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(int32 & id, int * data, int & len, struct rx_stat & stat) 
.................... { 
....................     int i; 
....................     int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
010EA:  BTFSS  F60.7
010EC:  BRA    111C
*
01372:  BTFSS  F60.7
01374:  BRA    13A4
....................         CANCON.win=CAN_WIN_RX0; 
*
010EE:  MOVLW  F1
010F0:  ANDWF  F6F,W
010F2:  MOVWF  F6F
*
01376:  MOVLW  F1
01378:  ANDWF  F6F,W
0137A:  MOVWF  F6F
....................         stat.buffer=0; 
*
010F4:  BCF    x70.4
*
0137C:  BCF    x70.4
....................  
....................         CAN_INT_RXB0IF=0; 
*
010F6:  BCF    FA4.0
*
0137E:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
*
010F8:  BCF    x70.0
010FA:  BTFSC  F74.7
010FC:  BSF    x70.0
*
01380:  BCF    x70.0
01382:  BTFSC  F74.7
01384:  BSF    x70.0
....................         COMSTAT.rx0ovfl=0; 
*
010FE:  BCF    F74.7
*
01386:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
*
01100:  BTFSS  F60.2
01102:  BRA    111A
*
01388:  BTFSS  F60.2
0138A:  BRA    13A2
....................          stat.filthit=RXB0CON.filthit0; 
*
01104:  MOVLW  00
01106:  BTFSC  F60.0
01108:  MOVLW  01
0110A:  ANDLW  07
0110C:  MOVWF  00
0110E:  BCF    FD8.0
01110:  RLCF   00,F
01112:  MOVLW  F1
01114:  ANDWF  x70,W
01116:  IORWF  00,W
01118:  MOVWF  x70
*
0138C:  MOVLW  00
0138E:  BTFSC  F60.0
01390:  MOVLW  01
01392:  ANDLW  07
01394:  MOVWF  00
01396:  BCF    FD8.0
01398:  RLCF   00,F
0139A:  MOVLW  F1
0139C:  ANDWF  x70,W
0139E:  IORWF  00,W
013A0:  MOVWF  x70
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
*
0111A:  BRA    115C
0111C:  MOVLB  F
0111E:  BTFSS  x50.7
01120:  BRA    1154
*
013A2:  BRA    13E4
013A4:  MOVLB  F
013A6:  BTFSS  x50.7
013A8:  BRA    13DC
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
*
01122:  MOVLW  F1
01124:  ANDWF  F6F,W
01126:  IORLW  0A
01128:  MOVWF  F6F
*
013AA:  MOVLW  F1
013AC:  ANDWF  F6F,W
013AE:  IORLW  0A
013B0:  MOVWF  F6F
....................         stat.buffer=1; 
*
0112A:  MOVLB  4
0112C:  BSF    x70.4
*
013B2:  MOVLB  4
013B4:  BSF    x70.4
....................  
....................         CAN_INT_RXB1IF=0; 
*
0112E:  BCF    FA4.1
*
013B6:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
*
01130:  BCF    x70.0
01132:  BTFSC  F74.6
01134:  BSF    x70.0
*
013B8:  BCF    x70.0
013BA:  BTFSC  F74.6
013BC:  BSF    x70.0
....................         COMSTAT.rx1ovfl=0; 
*
01136:  BCF    F74.6
*
013BE:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
*
01138:  MOVLB  F
0113A:  MOVF   x50,W
0113C:  ANDLW  07
0113E:  ANDLW  07
01140:  MOVWF  00
01142:  BCF    FD8.0
01144:  RLCF   00,F
01146:  MOVLW  F1
01148:  MOVLB  4
0114A:  ANDWF  x70,W
0114C:  IORWF  00,W
0114E:  MOVWF  x70
*
013C0:  MOVLB  F
013C2:  MOVF   x50,W
013C4:  ANDLW  07
013C6:  ANDLW  07
013C8:  MOVWF  00
013CA:  BCF    FD8.0
013CC:  RLCF   00,F
013CE:  MOVLW  F1
013D0:  MOVLB  4
013D2:  ANDWF  x70,W
013D4:  IORWF  00,W
013D6:  MOVWF  x70
....................     } 
....................     else { 
*
01150:  BRA    115C
01152:  MOVLB  F
*
013D8:  BRA    13E4
013DA:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
01154:  MOVLW  00
01156:  MOVWF  01
01158:  BRA    11F2
0115A:  MOVLB  4
*
013DC:  MOVLW  00
013DE:  MOVWF  01
013E0:  BRA    147A
013E2:  MOVLB  4
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
*
0115C:  MOVF   F65,W
0115E:  ANDLW  0F
01160:  MOVWF  x6F
*
013E4:  MOVF   F65,W
013E6:  ANDLW  0F
013E8:  MOVWF  x6F
....................     stat.rtr=RXBaDLC.rtr; 
*
01162:  BCF    x70.5
01164:  BTFSC  F65.6
01166:  BSF    x70.5
*
013EA:  BCF    x70.5
013EC:  BTFSC  F65.6
013EE:  BSF    x70.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
*
01168:  BCF    x70.6
0116A:  BTFSC  F62.3
0116C:  BSF    x70.6
*
013F0:  BCF    x70.6
013F2:  BTFSC  F62.3
013F4:  BSF    x70.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
*
0116E:  MOVLW  00
01170:  BTFSC  x70.6
01172:  MOVLW  01
01174:  MOVWF  x80
01176:  MOVLW  0F
01178:  MOVWF  x88
0117A:  MOVLW  64
0117C:  MOVWF  x87
0117E:  MOVFF  480,489
01182:  MOVLB  0
01184:  RCALL  0ED8
01186:  MOVFF  03,46E
0118A:  MOVFF  02,46D
0118E:  MOVFF  01,46C
01192:  MOVFF  00,46B
*
013F6:  MOVLW  00
013F8:  BTFSC  x70.6
013FA:  MOVLW  01
013FC:  MOVWF  x80
013FE:  MOVLW  0F
01400:  MOVWF  x88
01402:  MOVLW  64
01404:  MOVWF  x87
01406:  MOVFF  480,489
0140A:  MOVLB  0
0140C:  RCALL  0ED8
0140E:  MOVFF  03,46E
01412:  MOVFF  02,46D
01416:  MOVFF  01,46C
0141A:  MOVFF  00,46B
....................  
....................     ptr = &TXRXBaD0; 
*
01196:  MOVLW  0F
01198:  MOVLB  4
0119A:  MOVWF  x7F
0119C:  MOVLW  66
0119E:  MOVWF  x7E
*
0141E:  MOVLW  0F
01420:  MOVLB  4
01422:  MOVWF  x7F
01424:  MOVLW  66
01426:  MOVWF  x7E
....................     for ( i = 0; i < len; i++ ) { 
*
011A0:  CLRF   x7D
011A2:  MOVF   x6F,W
011A4:  SUBWF  x7D,W
011A6:  BC    11D0
*
01428:  CLRF   x7D
0142A:  MOVF   x6F,W
0142C:  SUBWF  x7D,W
0142E:  BC    1458
....................         *data = *ptr; 
*
011A8:  MOVFF  47E,FE9
011AC:  MOVFF  47F,FEA
011B0:  MOVFF  FEF,482
011B4:  MOVFF  47C,FEA
011B8:  MOVFF  47B,FE9
011BC:  MOVFF  482,FEF
*
01430:  MOVFF  47E,FE9
01434:  MOVFF  47F,FEA
01438:  MOVFF  FEF,482
0143C:  MOVFF  47C,FEA
01440:  MOVFF  47B,FE9
01444:  MOVFF  482,FEF
....................         data++; 
*
011C0:  INCF   x7B,F
011C2:  BTFSC  FD8.2
011C4:  INCF   x7C,F
*
01448:  INCF   x7B,F
0144A:  BTFSC  FD8.2
0144C:  INCF   x7C,F
....................         ptr++; 
*
011C6:  INCF   x7E,F
011C8:  BTFSC  FD8.2
011CA:  INCF   x7F,F
*
0144E:  INCF   x7E,F
01450:  BTFSC  FD8.2
01452:  INCF   x7F,F
....................     } 
*
011CC:  INCF   x7D,F
011CE:  BRA    11A2
*
01454:  INCF   x7D,F
01456:  BRA    142A
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
*
011D0:  MOVLW  F1
011D2:  ANDWF  F6F,W
011D4:  MOVWF  F6F
*
01458:  MOVLW  F1
0145A:  ANDWF  F6F,W
0145C:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
*
011D6:  BCF    x70.7
011D8:  BTFSC  FA4.7
011DA:  BSF    x70.7
*
0145E:  BCF    x70.7
01460:  BTFSC  FA4.7
01462:  BSF    x70.7
....................     CAN_INT_IRXIF = 0; 
*
011DC:  BCF    FA4.7
*
01464:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
*
011DE:  BTFSS  x70.4
011E0:  BRA    11EA
*
01466:  BTFSS  x70.4
01468:  BRA    1472
....................       RXB1CON.rxful=0; 
*
011E2:  MOVLB  F
011E4:  BCF    x50.7
*
0146A:  MOVLB  F
0146C:  BCF    x50.7
....................     } 
....................     else { 
*
011E6:  BRA    11EE
011E8:  MOVLB  4
*
0146E:  BRA    1476
01470:  MOVLB  4
....................       RXB0CON.rxful=0; 
*
011EA:  BCF    F60.7
011EC:  MOVLB  F
*
01472:  BCF    F60.7
01474:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
*
011EE:  MOVLW  01
011F0:  MOVWF  01
*
01476:  MOVLW  01
01478:  MOVWF  01
0147A:  MOVLB  4
.................... } 
....................  
....................  
....................  
....................  
.................... /** 
....................  * no comments 
....................  */ 
.................... #define dev1_ze 10 
....................  
.................... #define CAN_RECEIVE_STACK_SIZE 10 
.................... int can_rspoint=0; 
.................... int can_rstack [CAN_RECEIVE_STACK_SIZE] [14]; 
.................... int1 can_rsfull=FALSE; 
.................... #define can_receiver_full() can_rsfull 
.................... #define CAN_TRANSMIT_STACK_SIZE 10 
.................... int can_tspoint=0; 
.................... int can_tstack [CAN_TRANSMIT_STACK_SIZE] [13]; 
.................... int1 can_tsempty=TRUE; 
.................... #define can_transmitter_empty() can_tsempty 
.................... #define CAN_FILTER_SIZE 1 
.................... int32 can_filter [CAN_FILTER_SIZE] = {11}; 
....................  
....................  
.................... void canReceive ( ) 
.................... { 
....................    int32 rx_id; 
....................    int8  rx_len, rx_stat; 
....................    int8  buffer [8]; 
....................    int8  i; 
....................  
....................    if(can_rspoint==-1) 
*
010D0:  MOVF   24,W
010D2:  SUBLW  FF
010D4:  BNZ   10D8
....................       can_rspoint++; 
010D6:  INCF   24,F
....................  
....................    if(can_rspoint < CAN_RECEIVE_STACK_SIZE) 
010D8:  MOVF   24,W
010DA:  SUBLW  09
010DC:  BTFSS  FD8.0
010DE:  BRA    1368
....................    { 
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
010E0:  MOVLW  04
010E2:  MOVLB  4
010E4:  MOVWF  x7C
010E6:  MOVLW  71
010E8:  MOVWF  x7B
....................    { 
....................       int8 j; 
....................       for(j=0;j<CAN_FILTER_SIZE;j++) 
*
011F2:  MOVLB  4
011F4:  CLRF   x7A
011F6:  MOVF   x7A,F
011F8:  BNZ   123A
....................          if(rx_id==can_filter[j]) 
011FA:  MOVF   x7A,W
011FC:  MULLW  04
011FE:  MOVF   FF3,W
01200:  CLRF   03
01202:  ADDLW  35
01204:  MOVWF  FE9
01206:  MOVLW  01
01208:  ADDWFC 03,W
0120A:  MOVWF  FEA
0120C:  MOVFF  FEF,00
01210:  MOVFF  FEC,01
01214:  MOVFF  FEC,02
01218:  MOVFF  FEC,03
0121C:  MOVF   00,W
0121E:  SUBWF  x6B,W
01220:  BNZ   1236
01222:  MOVF   01,W
01224:  SUBWF  x6C,W
01226:  BNZ   1236
01228:  MOVF   02,W
0122A:  SUBWF  x6D,W
0122C:  BNZ   1236
0122E:  MOVF   03,W
01230:  SUBWF  x6E,W
01232:  BNZ   1236
....................             return; 
01234:  BRA    147C
01236:  INCF   x7A,F
01238:  BRA    11F6
....................    } 
....................       can_rstack[can_rspoint][0]=make8(rx_id,3); 
0123A:  MOVF   24,W
0123C:  MULLW  0E
0123E:  MOVF   FF3,W
01240:  CLRF   x7C
01242:  MOVWF  x7B
01244:  MOVLW  25
01246:  ADDWF  x7B,W
01248:  MOVWF  FE9
0124A:  MOVLW  00
0124C:  ADDWFC x7C,W
0124E:  MOVWF  FEA
01250:  MOVFF  46E,FEF
....................       can_rstack[can_rspoint][1]=make8(rx_id,2); 
01254:  MOVF   24,W
01256:  MULLW  0E
01258:  MOVF   FF3,W
0125A:  CLRF   x7C
0125C:  MOVWF  x7B
0125E:  MOVLW  01
01260:  ADDWF  x7B,W
01262:  MOVWF  01
01264:  MOVLW  00
01266:  ADDWFC x7C,W
01268:  MOVWF  03
0126A:  MOVF   01,W
0126C:  ADDLW  25
0126E:  MOVWF  FE9
01270:  MOVLW  00
01272:  ADDWFC 03,W
01274:  MOVWF  FEA
01276:  MOVFF  46D,FEF
....................       can_rstack[can_rspoint][2]=make8(rx_id,1); 
0127A:  MOVF   24,W
0127C:  MULLW  0E
0127E:  MOVF   FF3,W
01280:  CLRF   x7C
01282:  MOVWF  x7B
01284:  MOVLW  02
01286:  ADDWF  x7B,W
01288:  MOVWF  01
0128A:  MOVLW  00
0128C:  ADDWFC x7C,W
0128E:  MOVWF  03
01290:  MOVF   01,W
01292:  ADDLW  25
01294:  MOVWF  FE9
01296:  MOVLW  00
01298:  ADDWFC 03,W
0129A:  MOVWF  FEA
0129C:  MOVFF  46C,FEF
....................       can_rstack[can_rspoint][3]=make8(rx_id,0); 
012A0:  MOVF   24,W
012A2:  MULLW  0E
012A4:  MOVF   FF3,W
012A6:  CLRF   x7C
012A8:  MOVWF  x7B
012AA:  MOVLW  03
012AC:  ADDWF  x7B,W
012AE:  MOVWF  01
012B0:  MOVLW  00
012B2:  ADDWFC x7C,W
012B4:  MOVWF  03
012B6:  MOVF   01,W
012B8:  ADDLW  25
012BA:  MOVWF  FE9
012BC:  MOVLW  00
012BE:  ADDWFC 03,W
012C0:  MOVWF  FEA
012C2:  MOVFF  46B,FEF
....................  
....................       can_rstack[can_rspoint][4]=rx_len; 
012C6:  MOVF   24,W
012C8:  MULLW  0E
012CA:  MOVF   FF3,W
012CC:  CLRF   x7C
012CE:  MOVWF  x7B
012D0:  MOVLW  04
012D2:  ADDWF  x7B,W
012D4:  MOVWF  01
012D6:  MOVLW  00
012D8:  ADDWFC x7C,W
012DA:  MOVWF  03
012DC:  MOVF   01,W
012DE:  ADDLW  25
012E0:  MOVWF  FE9
012E2:  MOVLW  00
012E4:  ADDWFC 03,W
012E6:  MOVWF  FEA
012E8:  MOVFF  46F,FEF
....................       can_rstack[can_rspoint][5]=rx_stat; 
012EC:  MOVF   24,W
012EE:  MULLW  0E
012F0:  MOVF   FF3,W
012F2:  CLRF   x7C
012F4:  MOVWF  x7B
012F6:  MOVLW  05
012F8:  ADDWF  x7B,W
012FA:  MOVWF  01
012FC:  MOVLW  00
012FE:  ADDWFC x7C,W
01300:  MOVWF  03
01302:  MOVF   01,W
01304:  ADDLW  25
01306:  MOVWF  FE9
01308:  MOVLW  00
0130A:  ADDWFC 03,W
0130C:  MOVWF  FEA
0130E:  MOVFF  470,FEF
....................  
....................       for(i=0;i<rx_len;i++) 
01312:  CLRF   x79
01314:  MOVF   x6F,W
01316:  SUBWF  x79,W
01318:  BC    1362
....................       { 
....................          can_rstack[can_rspoint][i+6]=buffer[i]; 
0131A:  MOVF   24,W
0131C:  MULLW  0E
0131E:  MOVF   FF3,W
01320:  CLRF   x7C
01322:  MOVWF  x7B
01324:  MOVLW  06
01326:  ADDWF  x79,W
01328:  CLRF   03
0132A:  ADDWF  x7B,W
0132C:  MOVWF  01
0132E:  MOVF   x7C,W
01330:  ADDWFC 03,F
01332:  MOVF   01,W
01334:  ADDLW  25
01336:  MOVWF  01
01338:  MOVLW  00
0133A:  ADDWFC 03,F
0133C:  MOVFF  03,47C
01340:  CLRF   03
01342:  MOVF   x79,W
01344:  ADDLW  71
01346:  MOVWF  FE9
01348:  MOVLW  04
0134A:  ADDWFC 03,W
0134C:  MOVWF  FEA
0134E:  MOVFF  FEF,47D
01352:  MOVFF  47C,FEA
01356:  MOVFF  01,FE9
0135A:  MOVFF  47D,FEF
....................       } 
0135E:  INCF   x79,F
01360:  BRA    1314
....................  
....................       can_rspoint++; 
01362:  INCF   24,F
....................    } 
....................    else 
01364:  BRA    147C
01366:  MOVLB  0
....................       can_getd(rx_id,buffer,rx_len,rx_stat); 
01368:  MOVLW  04
0136A:  MOVLB  4
0136C:  MOVWF  x7C
0136E:  MOVLW  71
01370:  MOVWF  x7B
.................... } 
*
0147C:  MOVLB  0
0147E:  RETLW  00
....................  
....................  
.................... int1 can_Pop ( int32 & rx_id, int * buffer, int & rx_len, int & rx_stat ) 
.................... { 
....................    int i; 
....................  
....................    if(can_rspoint==CAN_RECEIVE_STACK_SIZE) 
....................       can_rspoint--; 
....................  
....................    if(can_rspoint!=-1) 
....................    { 
....................       rx_id=make32(can_rstack[can_rspoint][0], 
....................                   can_rstack[can_rspoint][1], 
....................                   can_rstack[can_rspoint][2], 
....................                   can_rstack[can_rspoint][3]); 
....................  
....................       rx_len=can_rstack[can_rspoint][4]; 
....................       rx_stat=can_rstack[can_rspoint][5]; 
....................  
....................       for(i=0;i<rx_len;i++) 
....................       { 
....................          buffer[i]=can_rstack[can_rspoint][i+6]; 
....................       } 
....................       can_rspoint--; 
....................  
....................       return TRUE; 
....................    }    
....................    else 
....................    return FALSE; 
.................... } 
....................  
.................... void canTransmit ( ) 
.................... { 
....................    int32 tx_id; 
....................    int8  tx_length; 
....................    int8  tx_priority; 
....................    int8  tx_buffer[8]; 
....................    int1  tx_extendedID; 
....................    int1  tx_emptyframe; 
....................    int8  i; 
....................  
....................    if(can_tspoint==CAN_TRANSMIT_STACK_SIZE) 
*
01696:  MOVF   xB2,W
01698:  SUBLW  0A
0169A:  BNZ   169E
....................    { 
....................       can_tspoint--; 
0169C:  DECF   xB2,F
....................    } 
....................  
....................    if(can_tspoint!=-1) 
0169E:  MOVF   xB2,W
016A0:  SUBLW  FF
016A2:  BTFSC  FD8.2
016A4:  BRA    18AC
....................    { 
....................  
....................       tx_id=make32(can_tstack[can_tspoint][0], 
....................                   can_tstack[can_tspoint][1], 
....................                   can_tstack[can_tspoint][2], 
....................                   can_tstack[can_tspoint][3]); 
016A6:  MOVF   xB2,W
016A8:  MULLW  0D
016AA:  MOVF   FF3,W
016AC:  MOVLB  4
016AE:  CLRF   x7C
016B0:  MOVWF  x7B
016B2:  MOVLW  B3
016B4:  ADDWF  x7B,W
016B6:  MOVWF  FE9
016B8:  MOVLW  00
016BA:  ADDWFC x7C,W
016BC:  MOVWF  FEA
016BE:  MOVFF  FEF,47B
016C2:  MOVLB  0
016C4:  MOVF   xB2,W
016C6:  MULLW  0D
016C8:  MOVF   FF3,W
016CA:  MOVLB  4
016CC:  CLRF   x7D
016CE:  MOVWF  x7C
016D0:  MOVLW  01
016D2:  ADDWF  x7C,W
016D4:  MOVWF  01
016D6:  MOVLW  00
016D8:  ADDWFC x7D,W
016DA:  MOVWF  03
016DC:  MOVF   01,W
016DE:  ADDLW  B3
016E0:  MOVWF  FE9
016E2:  MOVLW  00
016E4:  ADDWFC 03,W
016E6:  MOVWF  FEA
016E8:  MOVFF  FEF,47C
016EC:  MOVLB  0
016EE:  MOVF   xB2,W
016F0:  MULLW  0D
016F2:  MOVF   FF3,W
016F4:  MOVLB  4
016F6:  CLRF   x7E
016F8:  MOVWF  x7D
016FA:  MOVLW  02
016FC:  ADDWF  x7D,W
016FE:  MOVWF  01
01700:  MOVLW  00
01702:  ADDWFC x7E,W
01704:  MOVWF  03
01706:  MOVF   01,W
01708:  ADDLW  B3
0170A:  MOVWF  FE9
0170C:  MOVLW  00
0170E:  ADDWFC 03,W
01710:  MOVWF  FEA
01712:  MOVFF  FEF,47D
01716:  MOVLB  0
01718:  MOVF   xB2,W
0171A:  MULLW  0D
0171C:  MOVF   FF3,W
0171E:  MOVLB  4
01720:  CLRF   x7F
01722:  MOVWF  x7E
01724:  MOVLW  03
01726:  ADDWF  x7E,W
01728:  MOVWF  01
0172A:  MOVLW  00
0172C:  ADDWFC x7F,W
0172E:  MOVWF  03
01730:  MOVF   01,W
01732:  ADDLW  B3
01734:  MOVWF  FE9
01736:  MOVLW  00
01738:  ADDWFC 03,W
0173A:  MOVWF  FEA
0173C:  MOVFF  FEF,47E
01740:  MOVFF  47B,46E
01744:  MOVFF  47C,46D
01748:  MOVFF  47D,46C
0174C:  MOVFF  47E,46B
....................  
....................       tx_length=can_tstack[can_tspoint][12]>>4; 
01750:  MOVLB  0
01752:  MOVF   xB2,W
01754:  MULLW  0D
01756:  MOVF   FF3,W
01758:  MOVLB  4
0175A:  CLRF   x7C
0175C:  MOVWF  x7B
0175E:  MOVLW  0C
01760:  ADDWF  x7B,W
01762:  MOVWF  01
01764:  MOVLW  00
01766:  ADDWFC x7C,W
01768:  MOVWF  03
0176A:  MOVF   01,W
0176C:  ADDLW  B3
0176E:  MOVWF  FE9
01770:  MOVLW  00
01772:  ADDWFC 03,W
01774:  MOVWF  FEA
01776:  SWAPF  FEF,W
01778:  MOVWF  x6F
0177A:  MOVLW  0F
0177C:  ANDWF  x6F,F
....................       tx_priority=(can_tstack[can_tspoint][12]&0x0c)>>2; 
0177E:  MOVLB  0
01780:  MOVF   xB2,W
01782:  MULLW  0D
01784:  MOVF   FF3,W
01786:  MOVLB  4
01788:  CLRF   x7C
0178A:  MOVWF  x7B
0178C:  MOVLW  0C
0178E:  ADDWF  x7B,W
01790:  MOVWF  01
01792:  MOVLW  00
01794:  ADDWFC x7C,W
01796:  MOVWF  03
01798:  MOVF   01,W
0179A:  ADDLW  B3
0179C:  MOVWF  FE9
0179E:  MOVLW  00
017A0:  ADDWFC 03,W
017A2:  MOVWF  FEA
017A4:  MOVF   FEF,W
017A6:  ANDLW  0C
017A8:  MOVWF  00
017AA:  RRCF   00,W
017AC:  MOVWF  x70
017AE:  RRCF   x70,F
017B0:  MOVLW  3F
017B2:  ANDWF  x70,F
....................       tx_extendedID=bit_test(can_tstack[can_tspoint][12],1); 
017B4:  MOVLB  0
017B6:  MOVF   xB2,W
017B8:  MULLW  0D
017BA:  MOVF   FF3,W
017BC:  MOVLB  4
017BE:  CLRF   x7C
017C0:  MOVWF  x7B
017C2:  MOVLW  0C
017C4:  ADDWF  x7B,W
017C6:  MOVWF  01
017C8:  MOVLW  00
017CA:  ADDWFC x7C,W
017CC:  MOVWF  03
017CE:  MOVF   01,W
017D0:  ADDLW  B3
017D2:  MOVWF  FE9
017D4:  MOVLW  00
017D6:  ADDWFC 03,W
017D8:  MOVWF  FEA
017DA:  MOVFF  FEF,47B
017DE:  BCF    x79.0
017E0:  BTFSC  x7B.1
017E2:  BSF    x79.0
....................       tx_emptyframe=bit_test(can_tstack[can_tspoint][12],0); 
017E4:  MOVLB  0
017E6:  MOVF   xB2,W
017E8:  MULLW  0D
017EA:  MOVF   FF3,W
017EC:  MOVLB  4
017EE:  CLRF   x7C
017F0:  MOVWF  x7B
017F2:  MOVLW  0C
017F4:  ADDWF  x7B,W
017F6:  MOVWF  01
017F8:  MOVLW  00
017FA:  ADDWFC x7C,W
017FC:  MOVWF  03
017FE:  MOVF   01,W
01800:  ADDLW  B3
01802:  MOVWF  FE9
01804:  MOVLW  00
01806:  ADDWFC 03,W
01808:  MOVWF  FEA
0180A:  MOVFF  FEF,47B
0180E:  BCF    x79.1
01810:  BTFSC  x7B.0
01812:  BSF    x79.1
....................  
....................       for(i=0;i<tx_length;i++) 
01814:  CLRF   x7A
01816:  MOVF   x6F,W
01818:  SUBWF  x7A,W
0181A:  BC    186C
....................       { 
....................          tx_buffer[i]=can_tstack[can_tspoint][i+4]; 
0181C:  CLRF   03
0181E:  MOVF   x7A,W
01820:  ADDLW  71
01822:  MOVWF  01
01824:  MOVLW  04
01826:  ADDWFC 03,F
01828:  MOVFF  01,47B
0182C:  MOVFF  03,47C
01830:  MOVLB  0
01832:  MOVF   xB2,W
01834:  MULLW  0D
01836:  MOVF   FF3,W
01838:  MOVLB  4
0183A:  CLRF   x7E
0183C:  MOVWF  x7D
0183E:  MOVLW  04
01840:  ADDWF  x7A,W
01842:  CLRF   03
01844:  ADDWF  x7D,W
01846:  MOVWF  01
01848:  MOVF   x7E,W
0184A:  ADDWFC 03,F
0184C:  MOVF   01,W
0184E:  ADDLW  B3
01850:  MOVWF  FE9
01852:  MOVLW  00
01854:  ADDWFC 03,W
01856:  MOVWF  FEA
01858:  MOVFF  FEF,47D
0185C:  MOVFF  47C,FEA
01860:  MOVFF  47B,FE9
01864:  MOVFF  47D,FEF
....................       } 
01868:  INCF   x7A,F
0186A:  BRA    1816
....................  
....................       can_putd(tx_id,tx_buffer,tx_length,tx_priority,tx_extendedID,tx_emptyframe); 
0186C:  MOVLW  00
0186E:  BTFSC  x79.0
01870:  MOVLW  01
01872:  MOVWF  x7B
01874:  MOVLW  00
01876:  BTFSC  x79.1
01878:  MOVLW  01
0187A:  MOVWF  x7C
0187C:  MOVFF  46E,480
01880:  MOVFF  46D,47F
01884:  MOVFF  46C,47E
01888:  MOVFF  46B,47D
0188C:  MOVLW  04
0188E:  MOVWF  x82
01890:  MOVLW  71
01892:  MOVWF  x81
01894:  MOVFF  46F,483
01898:  MOVFF  470,484
0189C:  MOVFF  47B,485
018A0:  MOVFF  47C,486
018A4:  MOVLB  0
018A6:  BRA    15C4
....................  
....................       can_tspoint--; 
018A8:  DECF   xB2,F
....................    } 
....................    else 
018AA:  BRA    18AE
....................       return; 
018AC:  BRA    18AE
.................... } 
018AE:  RETLW  00
....................  
....................  
.................... int1 can_push (int32 tx_id, int8 * tx_buffer, int8 tx_length, int8 tx_priority, int1 tx_extendedID, int1 tx_emptyframe) 
.................... { 
....................    int8  i; 
....................    if(can_tspoint==-1) 
....................       can_tspoint++; 
....................  
....................    if(can_tspoint < CAN_TRANSMIT_STACK_SIZE) 
....................    { 
....................       can_tstack[can_tspoint][0]=make8(tx_id,3); 
....................       can_tstack[can_tspoint][1]=make8(tx_id,2); 
....................       can_tstack[can_tspoint][2]=make8(tx_id,1); 
....................       can_tstack[can_tspoint][3]=make8(tx_id,0); 
....................  
....................       for(i=0;i<tx_length;i++) 
....................       { 
....................          can_tstack[can_tspoint][i+4]=tx_buffer[i]; 
....................       } 
....................  
....................       can_tstack[can_tspoint][12]=(tx_length<<4)|(tx_priority<<2)|((int8)tx_extendedID<<1)|((int8)tx_emptyframe); 
....................  
....................       can_tspoint++; 
....................    } 
.................... } 
....................  
.................... int temp; 
.................... #include "struct_and_enums.c" 
....................  
.................... enum switch_outstate {on, off, dimming, dimmed, maxed}; 
.................... enum switch_direction {up, down}; 
.................... enum switch_state {button_pressed, button_depressed}; 
.................... enum output_type {_on_off, dimmer,shutter}; 
.................... enum output_state {_on, _off, _dimmed}; 
.................... enum timer_type {time_on, time_off, periodic_on}; 
.................... enum input_type {dimmer_switch,on_off_switch,button_switch,timer,none}; 
....................  
.................... void dimmer_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input); 
.................... typedef struct data_point_out 
.................... { 
....................    unsigned int adress; 
....................    unsigned int value; 
....................    int1 needs_update; 
.................... }; 
.................... typedef struct data_point_in 
.................... { 
....................    unsigned int adress[8]; 
....................    unsigned int value; 
....................    int1 needs_update; 
.................... }; 
.................... ///////////////////////INPUTS////////////////////////////////////// 
.................... typedef struct dimmer_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out dim_level; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    unsigned int current_level; 
....................    int32  timer; 
....................    switch_state current_state; 
....................    switch_state previous_state; 
....................    switch_direction direction; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
.................... typedef struct on_off_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................     switch_state current_state; 
....................    switch_state previous_state; 
....................    int32  timer; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
....................  
.................... typedef struct button_switch 
.................... { 
....................  //  switch_type type; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    switch_state current_state; 
....................    switch_state previous_state; 
....................    int32  timer; 
....................    switch_outstate outstate; 
....................    unsigned int realbutton; 
.................... }; 
....................  
.................... typedef struct timer 
.................... { 
....................    timer_type type; 
....................    int32 timeToAct; 
....................    struct data_point_out on; 
....................    struct data_point_out off; 
....................    int32  timer; 
.................... }; 
.................... union input 
.................... { 
....................    struct on_off_switch; 
....................    struct dimmer_switch; 
....................    struct timer; 
....................    struct button_switch; 
.................... }; 
....................  
.................... typedef struct inputs 
.................... { 
....................    enum input_type type; 
....................    union input device; 
.................... }; 
.................... ///////////////////////OUTPUTS////////////////////////////////////// 
.................... struct light 
.................... { 
....................    struct data_point_in on; 
....................    struct data_point_in off; 
....................    struct data_point_in dim_value; 
....................    enum output_state out_state; 
....................    unsigned int output_pin; 
....................    int internal_order; 
....................    int1  needs_update; 
.................... }; 
....................  
.................... union output 
.................... { 
....................    struct light; 
.................... }; 
....................  
.................... typedef struct outputs 
.................... { 
....................    enum output_type type; 
....................    union output device; 
.................... }; 
....................  
.................... typedef struct devices 
.................... { 
....................       unsigned int numberOfInputs; 
....................       unsigned int numberOfOutputs; 
....................       struct inputs myinputs[10]; 
....................       struct outputs myoutputs[10]; 
.................... }devicestype; 
....................  
.................... devicestype mydevices; 
....................  
.................... void copy_array(unsigned int *origin,struct data_point_in* destination , unsigned int n_elements) 
.................... { 
....................    int x; 
....................    for (x=0;x<n_elements;++x) 
*
01F82:  MOVLB  4
01F84:  CLRF   x47
01F86:  MOVF   x46,W
01F88:  SUBWF  x47,W
01F8A:  BC    203E
....................    { 
....................       ((struct data_point_in*)destination)->adress[x]=*origin; 
01F8C:  CLRF   03
01F8E:  MOVF   x47,W
01F90:  ADDWF  x44,W
01F92:  MOVWF  01
01F94:  MOVF   x45,W
01F96:  ADDWFC 03,F
01F98:  MOVFF  03,449
01F9C:  MOVFF  442,FE9
01FA0:  MOVFF  443,FEA
01FA4:  MOVFF  FEF,44A
01FA8:  MOVFF  449,FEA
01FAC:  MOVFF  01,FE9
01FB0:  MOVFF  44A,FEF
....................       printf("%u:%u<----->%u\n\r",x,((struct data_point_in*)destination)->adress[x],*origin); 
01FB4:  CLRF   03
01FB6:  MOVF   x47,W
01FB8:  ADDWF  x44,W
01FBA:  MOVWF  FE9
01FBC:  MOVF   x45,W
01FBE:  ADDWFC 03,W
01FC0:  MOVWF  FEA
01FC2:  MOVFF  FEF,448
01FC6:  MOVFF  443,03
01FCA:  MOVFF  442,FE9
01FCE:  MOVFF  443,FEA
01FD2:  MOVFF  FEF,449
01FD6:  MOVFF  447,44A
01FDA:  MOVLW  1B
01FDC:  MOVWF  x4B
01FDE:  MOVLB  0
01FE0:  RCALL  1F06
01FE2:  MOVLW  3A
01FE4:  MOVLB  4
01FE6:  MOVWF  x4E
01FE8:  MOVLB  0
01FEA:  RCALL  1E56
01FEC:  MOVFF  448,44A
01FF0:  MOVLW  1B
01FF2:  MOVLB  4
01FF4:  MOVWF  x4B
01FF6:  MOVLB  0
01FF8:  RCALL  1F06
01FFA:  MOVLW  BF
01FFC:  MOVWF  FF6
01FFE:  MOVLW  02
02000:  MOVWF  FF7
02002:  MOVLW  00
02004:  MOVWF  FF8
02006:  MOVLW  07
02008:  MOVLB  4
0200A:  MOVWF  x4A
0200C:  MOVLB  0
0200E:  RCALL  1EAA
02010:  MOVFF  449,44A
02014:  MOVLW  1B
02016:  MOVLB  4
02018:  MOVWF  x4B
0201A:  MOVLB  0
0201C:  RCALL  1F06
0201E:  MOVLW  0A
02020:  MOVLB  4
02022:  MOVWF  x4E
02024:  MOVLB  0
02026:  RCALL  1E56
02028:  MOVLW  0D
0202A:  MOVLB  4
0202C:  MOVWF  x4E
0202E:  MOVLB  0
02030:  RCALL  1E56
....................       ++origin; 
02032:  MOVLB  4
02034:  INCF   x42,F
02036:  BTFSC  FD8.2
02038:  INCF   x43,F
....................    } 
0203A:  INCF   x47,F
0203C:  BRA    1F86
.................... } 
0203E:  MOVLB  0
02040:  RETLW  00
....................  
....................  
.................... ///////INPUTS INITIALIZATION////////////////////////////////////////////////// 
.................... void dimmer_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input,unsigned int real_button) 
.................... { 
....................       input->type=dimmer_switch; 
*
01C6E:  MOVLB  4
01C70:  MOVFF  420,FE9
01C74:  MOVFF  421,FEA
01C78:  CLRF   FEF
....................       ((struct dimmer_switch)input->device).dim_level.adress=dim_adr; 
01C7A:  MOVLW  01
01C7C:  ADDWF  x20,W
01C7E:  MOVWF  01
01C80:  MOVLW  00
01C82:  ADDWFC x21,W
01C84:  MOVFF  01,FE9
01C88:  MOVWF  FEA
01C8A:  MOVFF  41D,FEF
....................       ((struct dimmer_switch)input->device).on.adress=on_adr; 
01C8E:  MOVLW  01
01C90:  ADDWF  x20,W
01C92:  MOVWF  01
01C94:  MOVLW  00
01C96:  ADDWFC x21,W
01C98:  MOVWF  03
01C9A:  MOVF   01,W
01C9C:  ADDLW  03
01C9E:  MOVWF  FE9
01CA0:  MOVLW  00
01CA2:  ADDWFC 03,W
01CA4:  MOVWF  FEA
01CA6:  MOVFF  41E,FEF
....................       ((struct dimmer_switch)input->device).off.adress=off_adr; 
01CAA:  MOVLW  01
01CAC:  ADDWF  x20,W
01CAE:  MOVWF  01
01CB0:  MOVLW  00
01CB2:  ADDWFC x21,W
01CB4:  MOVWF  03
01CB6:  MOVF   01,W
01CB8:  ADDLW  06
01CBA:  MOVWF  FE9
01CBC:  MOVLW  00
01CBE:  ADDWFC 03,W
01CC0:  MOVWF  FEA
01CC2:  MOVFF  41F,FEF
....................       ((struct dimmer_switch)input->device).previous_state=button_depressed; 
01CC6:  MOVLW  01
01CC8:  ADDWF  x20,W
01CCA:  MOVWF  01
01CCC:  MOVLW  00
01CCE:  ADDWFC x21,W
01CD0:  MOVWF  03
01CD2:  MOVF   01,W
01CD4:  ADDLW  0E
01CD6:  MOVWF  FE9
01CD8:  MOVLW  00
01CDA:  ADDWFC 03,W
01CDC:  MOVWF  FEA
01CDE:  BSF    FEF.1
....................       ((struct dimmer_switch)input->device).outstate=off; 
01CE0:  MOVLW  01
01CE2:  ADDWF  x20,W
01CE4:  MOVWF  01
01CE6:  MOVLW  00
01CE8:  ADDWFC x21,W
01CEA:  MOVWF  03
01CEC:  MOVF   01,W
01CEE:  ADDLW  0F
01CF0:  MOVWF  FE9
01CF2:  MOVLW  00
01CF4:  ADDWFC 03,W
01CF6:  MOVWF  FEA
01CF8:  MOVLW  01
01CFA:  MOVWF  FEF
....................       ((struct dimmer_switch)input->device).current_level=0; 
01CFC:  ADDWF  x20,W
01CFE:  MOVWF  01
01D00:  MOVLW  00
01D02:  ADDWFC x21,W
01D04:  MOVWF  03
01D06:  MOVF   01,W
01D08:  ADDLW  09
01D0A:  MOVWF  FE9
01D0C:  MOVLW  00
01D0E:  ADDWFC 03,W
01D10:  MOVWF  FEA
01D12:  CLRF   FEF
....................       ((struct dimmer_switch)input->device).direction=up; 
01D14:  MOVLW  01
01D16:  ADDWF  x20,W
01D18:  MOVWF  01
01D1A:  MOVLW  00
01D1C:  ADDWFC x21,W
01D1E:  MOVWF  03
01D20:  MOVF   01,W
01D22:  ADDLW  0E
01D24:  MOVWF  FE9
01D26:  MOVLW  00
01D28:  ADDWFC 03,W
01D2A:  MOVWF  FEA
01D2C:  BCF    FEF.2
....................       ((struct dimmer_switch)input->device).dim_level.needs_update=0; 
01D2E:  MOVLW  01
01D30:  ADDWF  x20,W
01D32:  MOVWF  01
01D34:  MOVLW  00
01D36:  ADDWFC x21,W
01D38:  MOVWF  03
01D3A:  MOVF   01,W
01D3C:  ADDLW  02
01D3E:  MOVWF  FE9
01D40:  MOVLW  00
01D42:  ADDWFC 03,W
01D44:  MOVWF  FEA
01D46:  BCF    FEF.0
....................       ((struct dimmer_switch)input->device).on.needs_update=0; 
01D48:  MOVLW  01
01D4A:  ADDWF  x20,W
01D4C:  MOVWF  01
01D4E:  MOVLW  00
01D50:  ADDWFC x21,W
01D52:  MOVWF  03
01D54:  MOVF   01,W
01D56:  ADDLW  05
01D58:  MOVWF  FE9
01D5A:  MOVLW  00
01D5C:  ADDWFC 03,W
01D5E:  MOVWF  FEA
01D60:  BCF    FEF.0
....................       ((struct dimmer_switch)input->device).off.needs_update=0; 
01D62:  MOVLW  01
01D64:  ADDWF  x20,W
01D66:  MOVWF  01
01D68:  MOVLW  00
01D6A:  ADDWFC x21,W
01D6C:  MOVWF  03
01D6E:  MOVF   01,W
01D70:  ADDLW  08
01D72:  MOVWF  FE9
01D74:  MOVLW  00
01D76:  ADDWFC 03,W
01D78:  MOVWF  FEA
01D7A:  BCF    FEF.0
....................       ((struct dimmer_switch)input->device).dim_level.value=0; 
01D7C:  MOVLW  01
01D7E:  ADDWF  x20,W
01D80:  MOVWF  01
01D82:  MOVLW  00
01D84:  ADDWFC x21,W
01D86:  MOVWF  03
01D88:  MOVF   01,W
01D8A:  ADDLW  01
01D8C:  MOVWF  FE9
01D8E:  MOVLW  00
01D90:  ADDWFC 03,W
01D92:  MOVWF  FEA
01D94:  CLRF   FEF
....................       ((struct dimmer_switch)input->device).on.value=0; 
01D96:  MOVLW  01
01D98:  ADDWF  x20,W
01D9A:  MOVWF  01
01D9C:  MOVLW  00
01D9E:  ADDWFC x21,W
01DA0:  MOVWF  03
01DA2:  MOVF   01,W
01DA4:  ADDLW  04
01DA6:  MOVWF  FE9
01DA8:  MOVLW  00
01DAA:  ADDWFC 03,W
01DAC:  MOVWF  FEA
01DAE:  CLRF   FEF
....................       ((struct dimmer_switch)input->device).off.value=0; 
01DB0:  MOVLW  01
01DB2:  ADDWF  x20,W
01DB4:  MOVWF  01
01DB6:  MOVLW  00
01DB8:  ADDWFC x21,W
01DBA:  MOVWF  03
01DBC:  MOVF   01,W
01DBE:  ADDLW  07
01DC0:  MOVWF  FE9
01DC2:  MOVLW  00
01DC4:  ADDWFC 03,W
01DC6:  MOVWF  FEA
01DC8:  CLRF   FEF
....................       ((struct dimmer_switch)input->device).realbutton=inputs[real_button]; 
01DCA:  MOVLW  01
01DCC:  ADDWF  x20,W
01DCE:  MOVWF  01
01DD0:  MOVLW  00
01DD2:  ADDWFC x21,W
01DD4:  MOVWF  03
01DD6:  MOVF   01,W
01DD8:  ADDLW  10
01DDA:  MOVWF  01
01DDC:  MOVLW  00
01DDE:  ADDWFC 03,F
01DE0:  MOVFF  03,426
01DE4:  CLRF   03
01DE6:  MOVF   x22,W
01DE8:  ADDLW  1C
01DEA:  MOVWF  FE9
01DEC:  MOVLW  00
01DEE:  ADDWFC 03,W
01DF0:  MOVWF  FEA
01DF2:  MOVFF  FEF,427
01DF6:  MOVFF  426,FEA
01DFA:  MOVFF  01,FE9
01DFE:  MOVFF  427,FEF
....................       ((struct dimmer_switch)input->device).timer=0; 
01E02:  MOVLW  01
01E04:  ADDWF  x20,W
01E06:  MOVWF  01
01E08:  MOVLW  00
01E0A:  ADDWFC x21,W
01E0C:  MOVWF  03
01E0E:  MOVF   01,W
01E10:  ADDLW  0A
01E12:  MOVWF  FE9
01E14:  MOVLW  00
01E16:  ADDWFC 03,W
01E18:  MOVWF  FEA
01E1A:  MOVF   FEE,F
01E1C:  MOVF   FEE,F
01E1E:  CLRF   FEC
01E20:  MOVF   FED,F
01E22:  CLRF   FEF
01E24:  MOVF   FED,F
01E26:  CLRF   FEF
01E28:  MOVF   FED,F
01E2A:  CLRF   FEF
.................... } 
01E2C:  MOVLB  0
01E2E:  GOTO   1E52 (RETURN)
.................... void on_off_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input,unsigned int real_button) 
.................... { 
....................       struct on_off_switch sw; 
....................       input->type=on_off_switch; 
....................       sw.on.adress=on_adr; 
....................       sw.off.adress=off_adr; 
....................       sw.previous_state=button_depressed; 
....................       sw.outstate=off; 
....................       sw.on.needs_update=0; 
....................       sw.off.needs_update=0; 
....................       sw.on.value=0; 
....................       sw.off.value=0; 
....................       sw.realbutton=inputs[real_button]; 
....................       input->device=sw; 
.................... } 
.................... void button_init(unsigned int dim_adr,unsigned int on_adr,unsigned int off_adr,struct inputs* input,unsigned int real_button) 
.................... { 
....................       struct button_switch sw; 
....................       input->type=button_switch; 
....................       sw.on.adress=on_adr; 
....................       sw.off.adress=off_adr; 
....................       sw.previous_state=button_depressed; 
....................       sw.outstate=off; 
....................       sw.on.needs_update=0; 
....................       sw.off.needs_update=0; 
....................       sw.on.value=0; 
....................       sw.off.value=0; 
....................       sw.realbutton=inputs[real_button]; 
....................       input->device=sw; 
.................... } 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... ///////INPUTS INITIALIZATION////////////////////////////////////////////////// 
.................... void dimmer_out_init(unsigned int *dim_adr,unsigned int *on_adr,unsigned int *off_adr,struct outputs* output,unsigned int output_pin) 
.................... { 
....................    ((struct outputs *)output)->type=dimmer; 
*
02042:  MOVLB  4
02044:  MOVFF  43B,FE9
02048:  MOVFF  43C,FEA
0204C:  MOVLW  01
0204E:  MOVWF  FEF
....................    ((struct light)output->device).dim_value.needs_update=0; 
02050:  ADDWF  x3B,W
02052:  MOVWF  01
02054:  MOVLW  00
02056:  ADDWFC x3C,W
02058:  MOVWF  03
0205A:  MOVF   01,W
0205C:  ADDLW  1D
0205E:  MOVWF  FE9
02060:  MOVLW  00
02062:  ADDWFC 03,W
02064:  MOVWF  FEA
02066:  BCF    FEF.0
....................    ((struct light)output->device).on.needs_update=0; 
02068:  MOVLW  01
0206A:  ADDWF  x3B,W
0206C:  MOVWF  01
0206E:  MOVLW  00
02070:  ADDWFC x3C,W
02072:  MOVWF  03
02074:  MOVF   01,W
02076:  ADDLW  09
02078:  MOVWF  FE9
0207A:  MOVLW  00
0207C:  ADDWFC 03,W
0207E:  MOVWF  FEA
02080:  BCF    FEF.0
....................    ((struct light)output->device).off.needs_update=0; 
02082:  MOVLW  01
02084:  ADDWF  x3B,W
02086:  MOVWF  01
02088:  MOVLW  00
0208A:  ADDWFC x3C,W
0208C:  MOVWF  03
0208E:  MOVF   01,W
02090:  ADDLW  13
02092:  MOVWF  FE9
02094:  MOVLW  00
02096:  ADDWFC 03,W
02098:  MOVWF  FEA
0209A:  BCF    FEF.0
....................    ((struct light)output->device).dim_value.value=0; 
0209C:  MOVLW  01
0209E:  ADDWF  x3B,W
020A0:  MOVWF  01
020A2:  MOVLW  00
020A4:  ADDWFC x3C,W
020A6:  MOVWF  03
020A8:  MOVF   01,W
020AA:  ADDLW  1C
020AC:  MOVWF  FE9
020AE:  MOVLW  00
020B0:  ADDWFC 03,W
020B2:  MOVWF  FEA
020B4:  CLRF   FEF
....................    ((struct light)output->device).on.value=0; 
020B6:  MOVLW  01
020B8:  ADDWF  x3B,W
020BA:  MOVWF  01
020BC:  MOVLW  00
020BE:  ADDWFC x3C,W
020C0:  MOVWF  03
020C2:  MOVF   01,W
020C4:  ADDLW  08
020C6:  MOVWF  FE9
020C8:  MOVLW  00
020CA:  ADDWFC 03,W
020CC:  MOVWF  FEA
020CE:  CLRF   FEF
....................    ((struct light)output->device).off.value=0; 
020D0:  MOVLW  01
020D2:  ADDWF  x3B,W
020D4:  MOVWF  01
020D6:  MOVLW  00
020D8:  ADDWFC x3C,W
020DA:  MOVWF  03
020DC:  MOVF   01,W
020DE:  ADDLW  12
020E0:  MOVWF  FE9
020E2:  MOVLW  00
020E4:  ADDWFC 03,W
020E6:  MOVWF  FEA
020E8:  CLRF   FEF
....................    ((struct light)output->device).output_pin=output_pin; 
020EA:  MOVLW  01
020EC:  ADDWF  x3B,W
020EE:  MOVWF  01
020F0:  MOVLW  00
020F2:  ADDWFC x3C,W
020F4:  MOVWF  03
020F6:  MOVF   01,W
020F8:  ADDLW  1F
020FA:  MOVWF  FE9
020FC:  MOVLW  00
020FE:  ADDWFC 03,W
02100:  MOVWF  FEA
02102:  MOVFF  43D,FEF
....................    ((struct light)output->device).dim_value.adress[0]=1; 
02106:  MOVLW  01
02108:  ADDWF  x3B,W
0210A:  MOVWF  01
0210C:  MOVLW  00
0210E:  ADDWFC x3C,W
02110:  MOVWF  03
02112:  MOVF   01,W
02114:  ADDLW  14
02116:  MOVWF  FE9
02118:  MOVLW  00
0211A:  ADDWFC 03,W
0211C:  MOVWF  FEA
0211E:  MOVLW  01
02120:  MOVWF  FEF
....................    ((struct light)output->device).dim_value.adress[1]=2; 
02122:  ADDWF  x3B,W
02124:  MOVWF  01
02126:  MOVLW  00
02128:  ADDWFC x3C,W
0212A:  MOVWF  03
0212C:  MOVF   01,W
0212E:  ADDLW  15
02130:  MOVWF  FE9
02132:  MOVLW  00
02134:  ADDWFC 03,W
02136:  MOVWF  FEA
02138:  MOVLW  02
0213A:  MOVWF  FEF
....................    printf("adress test:%u %u\n\r",((struct light)output->device).dim_value.adress[0],((struct light)output->device).dim_value.adress[1]); 
0213C:  MOVLW  01
0213E:  ADDWF  x3B,W
02140:  MOVWF  01
02142:  MOVLW  00
02144:  ADDWFC x3C,W
02146:  MOVWF  03
02148:  MOVF   01,W
0214A:  ADDLW  14
0214C:  MOVWF  FE9
0214E:  MOVLW  00
02150:  ADDWFC 03,W
02152:  MOVWF  FEA
02154:  MOVFF  FEF,440
02158:  MOVLW  01
0215A:  ADDWF  x3B,W
0215C:  MOVWF  01
0215E:  MOVLW  00
02160:  ADDWFC x3C,W
02162:  MOVWF  03
02164:  MOVF   01,W
02166:  ADDLW  15
02168:  MOVWF  FE9
0216A:  MOVLW  00
0216C:  ADDWFC 03,W
0216E:  MOVWF  FEA
02170:  MOVFF  FEF,443
02174:  MOVLW  CC
02176:  MOVWF  FF6
02178:  MOVLW  02
0217A:  MOVWF  FF7
0217C:  MOVLW  00
0217E:  MOVWF  FF8
02180:  MOVLW  0C
02182:  MOVWF  x4A
02184:  MOVLB  0
02186:  RCALL  1EAA
02188:  MOVFF  440,44A
0218C:  MOVLW  1B
0218E:  MOVLB  4
02190:  MOVWF  x4B
02192:  MOVLB  0
02194:  RCALL  1F06
02196:  MOVLW  20
02198:  MOVLB  4
0219A:  MOVWF  x4E
0219C:  MOVLB  0
0219E:  RCALL  1E56
021A0:  MOVFF  443,44A
021A4:  MOVLW  1B
021A6:  MOVLB  4
021A8:  MOVWF  x4B
021AA:  MOVLB  0
021AC:  RCALL  1F06
021AE:  MOVLW  0A
021B0:  MOVLB  4
021B2:  MOVWF  x4E
021B4:  MOVLB  0
021B6:  RCALL  1E56
021B8:  MOVLW  0D
021BA:  MOVLB  4
021BC:  MOVWF  x4E
021BE:  MOVLB  0
021C0:  RCALL  1E56
....................    copy_array(dim_adr,((struct light)output->device).dim_value,8); 
021C2:  MOVLW  01
021C4:  MOVLB  4
021C6:  ADDWF  x3B,W
021C8:  MOVWF  01
021CA:  MOVLW  00
021CC:  ADDWFC x3C,W
021CE:  MOVWF  03
021D0:  MOVF   01,W
021D2:  ADDLW  14
021D4:  MOVWF  FE9
021D6:  MOVLW  00
021D8:  ADDWFC 03,W
021DA:  MOVWF  FEA
021DC:  MOVFF  FEC,441
021E0:  MOVF   FED,F
021E2:  MOVFF  FEF,440
021E6:  MOVFF  436,443
021EA:  MOVFF  435,442
021EE:  MOVFF  441,445
021F2:  MOVFF  440,444
021F6:  MOVLW  08
021F8:  MOVWF  x46
021FA:  MOVLB  0
021FC:  RCALL  1F82
....................    copy_array(on_adr,((struct light)output->device).on,8); 
021FE:  MOVLW  01
02200:  MOVLB  4
02202:  ADDWF  x3B,W
02204:  MOVWF  01
02206:  MOVLW  00
02208:  ADDWFC x3C,W
0220A:  MOVWF  03
0220C:  MOVFF  01,FE9
02210:  MOVWF  FEA
02212:  MOVFF  FEC,441
02216:  MOVF   FED,F
02218:  MOVFF  FEF,440
0221C:  MOVFF  438,443
02220:  MOVFF  437,442
02224:  MOVFF  441,445
02228:  MOVFF  440,444
0222C:  MOVLW  08
0222E:  MOVWF  x46
02230:  MOVLB  0
02232:  RCALL  1F82
....................    copy_array(off_adr,((struct light)output->device).off,8); 
02234:  MOVLW  01
02236:  MOVLB  4
02238:  ADDWF  x3B,W
0223A:  MOVWF  01
0223C:  MOVLW  00
0223E:  ADDWFC x3C,W
02240:  MOVWF  03
02242:  MOVF   01,W
02244:  ADDLW  0A
02246:  MOVWF  FE9
02248:  MOVLW  00
0224A:  ADDWFC 03,W
0224C:  MOVWF  FEA
0224E:  MOVFF  FEC,441
02252:  MOVF   FED,F
02254:  MOVFF  FEF,440
02258:  MOVFF  43A,443
0225C:  MOVFF  439,442
02260:  MOVFF  441,445
02264:  MOVFF  440,444
02268:  MOVLW  08
0226A:  MOVWF  x46
0226C:  MOVLB  0
0226E:  RCALL  1F82
....................   ((struct light)output->device).out_state=_off; 
02270:  MOVLW  01
02272:  MOVLB  4
02274:  ADDWF  x3B,W
02276:  MOVWF  01
02278:  MOVLW  00
0227A:  ADDWFC x3C,W
0227C:  MOVWF  03
0227E:  MOVF   01,W
02280:  ADDLW  1E
02282:  MOVWF  FE9
02284:  MOVLW  00
02286:  ADDWFC 03,W
02288:  MOVWF  FEA
0228A:  MOVLW  01
0228C:  MOVWF  FEF
.................... } 
0228E:  MOVLB  0
02290:  GOTO   2308 (RETURN)
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void button_test() 
.................... {     mydevices.numberOfInputs=1; 
*
01E32:  MOVLW  01
01E34:  MOVLB  1
01E36:  MOVWF  x3A
....................     //  struct dimmer_switch sw; 
....................     //  sw.dim_level.value=69; 
....................     //  mydevices.myinputs[0].device=sw; 
....................     //  printf("VALUE=%u\n\r",mydevices.myinputs[0].device.dim_level.value); 
....................     //  on_off_init(1,2,3,&mydevices.myinputs[0],0); 
....................     //button_init(1,2,3,&mydevices.myinputs[0],0); 
....................       dimmer_init(1,2,3,&mydevices.myinputs[0],0); 
01E38:  MOVLB  4
01E3A:  MOVWF  x1D
01E3C:  MOVLW  02
01E3E:  MOVWF  x1E
01E40:  MOVLW  03
01E42:  MOVWF  x1F
01E44:  MOVLW  01
01E46:  MOVWF  x21
01E48:  MOVLW  3C
01E4A:  MOVWF  x20
01E4C:  CLRF   x22
01E4E:  MOVLB  0
01E50:  BRA    1C6E
....................       //printf("VALUE=%u\n\r",mydevices.myinputs[0].device.dim_level.value); 
....................      // while(true){}; 
.................... } 
01E52:  GOTO   3CFE (RETURN)
....................  
....................  
....................  
.................... #include "dimming_functions.c" 
.................... #define N_LUZES 16 //numero maximo de dimmers 
.................... int used_dimmers=0; 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
....................  
.................... int1 organizado;//flag que diz se os dimmings estao organizados 
.................... int1 actmat=0;//matriz em uso 
.................... int16 pointer;//apontador para matriz em uso 
.................... int vez;//indice da matriz de dimming corrente 
.................... int mnumluzes;//quantos valores de dimming diferentes temos 
.................... int16 dimmers_off_value; 
.................... int ltlevel[N_LUZES]={10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10}; 
.................... int16 delays1[N_LUZES+1][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15}; 
.................... int16 delays2[N_LUZES+1][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15}; 
.................... const int16 light_pins[N_LUZES]={ 
.................... 0b1111111111101111,0b1111111111011111,0b1111111110111111,0b1111111101111111,0b1111111111110111,0b1111111111111011,0b1111111111111110,0b1111111111111101, 
.................... /*<........................................................................portD..................................................................................>*/ 
.................... 0b0111111111111111,0b1011111111111111,0b1101111111111111,0b1110111111111111,0b1111011111111111,0b1111101111111111,0b1111110111111111,0b1111111011111111}; 
.................... /*<.................................................................................portC.............................................................>*/ 
....................  
.................... int16 lights[N_LUZES]; 
.................... const long Matrizluz[128]={ 
.................... 38400,38731 , 38492 , 38253 , 38014 , 37775 , 37536 , 37297 , 37058 , 36819 , 36580 
.................... , 36341 , 36102 , 35863 , 35624 , 35385 , 35146 , 34907 , 34668 , 34429 , 34190 , 33951 
....................  , 33712 , 33473 , 33234 , 32995 , 32756 , 32517 , 32278 , 32039 , 31800 , 31561 , 31322 
....................  , 31083 , 30844 , 30605 , 30366 , 30127 , 29888 , 29649 , 29410 , 29171 , 28932 , 28693 
....................  , 28454 , 28215 , 27976 , 27737 , 27498 , 27259 , 27020 , 26781 , 26542 , 26303 , 26064 
....................  , 25825 , 25586 , 25347 , 25108 , 24869 , 24630 , 24391 , 24152 , 23913 , 23674 , 23435 
....................  , 23196 , 22957 , 22718 , 22479 , 22240 , 22001 , 21762 , 21523 , 21284 , 21045 , 20806 
....................  , 20567 , 20328 , 20089 , 19850 , 19611 , 19372 , 19133 , 18894 , 18655 , 18416 , 18177 
....................  , 17938 , 17699 , 17460 , 17221 , 16982 , 16743 , 16504 , 16265 , 16026 , 15787 , 15548 
....................  , 15309 , 15070 , 14831 , 14592 , 14353 , 14114 , 13875 , 13636 , 13397 , 13158 , 12919 
....................  , 12680 , 12441 , 12202 , 11963 , 11724 , 11485 , 11246 , 11007 , 10768 , 10529 , 10290 
....................  , 10051 , 9812 , 9573 , 9334 , 9095 , 8856 , 617 }; 
....................   
....................   
....................  #INLINE 
....................   INT16 fpointer(int ax,int ay) 
....................    { 
....................       int16 * p; 
....................       p=(pointer + 2* ax * 2 + 2*ay); 
*
00DAE:  BCF    FD8.0
00DB0:  RLCF   x6D,W
00DB2:  MOVWF  00
00DB4:  BCF    FD8.0
00DB6:  RLCF   00,F
00DB8:  MOVF   00,W
00DBA:  MOVLB  3
00DBC:  ADDWF  x4F,W
00DBE:  MOVLB  4
00DC0:  MOVWF  x71
00DC2:  MOVLW  00
00DC4:  MOVLB  3
00DC6:  ADDWFC x50,W
00DC8:  MOVLB  4
00DCA:  MOVWF  x72
00DCC:  BCF    FD8.0
00DCE:  RLCF   x6E,W
00DD0:  ADDWF  x71,W
00DD2:  MOVWF  x6F
00DD4:  MOVLW  00
00DD6:  ADDWFC x72,W
00DD8:  MOVWF  x70
*
00E46:  BCF    FD8.0
00E48:  RLCF   x6D,W
00E4A:  MOVWF  00
00E4C:  BCF    FD8.0
00E4E:  RLCF   00,F
00E50:  MOVF   00,W
00E52:  MOVLB  3
00E54:  ADDWF  x4F,W
00E56:  MOVLB  4
00E58:  MOVWF  x71
00E5A:  MOVLW  00
00E5C:  MOVLB  3
00E5E:  ADDWFC x50,W
00E60:  MOVLB  4
00E62:  MOVWF  x72
00E64:  BCF    FD8.0
00E66:  RLCF   x6E,W
00E68:  ADDWF  x71,W
00E6A:  MOVWF  x6F
00E6C:  MOVLW  00
00E6E:  ADDWFC x72,W
00E70:  MOVWF  x70
*
018E6:  BCF    FD8.0
018E8:  RLCF   x6D,W
018EA:  MOVWF  00
018EC:  BCF    FD8.0
018EE:  RLCF   00,F
018F0:  MOVF   00,W
018F2:  MOVLB  3
018F4:  ADDWF  x4F,W
018F6:  MOVLB  4
018F8:  MOVWF  x71
018FA:  MOVLW  00
018FC:  MOVLB  3
018FE:  ADDWFC x50,W
01900:  MOVLB  4
01902:  MOVWF  x72
01904:  BCF    FD8.0
01906:  RLCF   x6E,W
01908:  ADDWF  x71,W
0190A:  MOVWF  x6F
0190C:  MOVLW  00
0190E:  ADDWFC x72,W
01910:  MOVWF  x70
*
0196E:  BCF    FD8.0
01970:  RLCF   x6D,W
01972:  MOVWF  00
01974:  BCF    FD8.0
01976:  RLCF   00,F
01978:  MOVF   00,W
0197A:  MOVLB  3
0197C:  ADDWF  x4F,W
0197E:  MOVLB  4
01980:  MOVWF  x71
01982:  MOVLW  00
01984:  MOVLB  3
01986:  ADDWFC x50,W
01988:  MOVLB  4
0198A:  MOVWF  x72
0198C:  BCF    FD8.0
0198E:  RLCF   x6E,W
01990:  ADDWF  x71,W
01992:  MOVWF  x6F
01994:  MOVLW  00
01996:  ADDWFC x72,W
01998:  MOVWF  x70
*
03D44:  BCF    FD8.0
03D46:  RLCF   x6D,W
03D48:  MOVWF  00
03D4A:  BCF    FD8.0
03D4C:  RLCF   00,F
03D4E:  MOVF   00,W
03D50:  MOVLB  3
03D52:  ADDWF  x4F,W
03D54:  MOVLB  4
03D56:  MOVWF  x71
03D58:  MOVLW  00
03D5A:  MOVLB  3
03D5C:  ADDWFC x50,W
03D5E:  MOVLB  4
03D60:  MOVWF  x72
03D62:  BCF    FD8.0
03D64:  RLCF   x6E,W
03D66:  ADDWF  x71,W
03D68:  MOVWF  x6F
03D6A:  MOVLW  00
03D6C:  ADDWFC x72,W
03D6E:  MOVWF  x70
*
03DBE:  BCF    FD8.0
03DC0:  RLCF   x6D,W
03DC2:  MOVWF  00
03DC4:  BCF    FD8.0
03DC6:  RLCF   00,F
03DC8:  MOVF   00,W
03DCA:  MOVLB  3
03DCC:  ADDWF  x4F,W
03DCE:  MOVLB  4
03DD0:  MOVWF  x71
03DD2:  MOVLW  00
03DD4:  MOVLB  3
03DD6:  ADDWFC x50,W
03DD8:  MOVLB  4
03DDA:  MOVWF  x72
03DDC:  BCF    FD8.0
03DDE:  RLCF   x6E,W
03DE0:  ADDWF  x71,W
03DE2:  MOVWF  x6F
03DE4:  MOVLW  00
03DE6:  ADDWFC x72,W
03DE8:  MOVWF  x70
*
03E8C:  BCF    FD8.0
03E8E:  RLCF   x6D,W
03E90:  MOVWF  00
03E92:  BCF    FD8.0
03E94:  RLCF   00,F
03E96:  MOVF   00,W
03E98:  MOVLB  3
03E9A:  ADDWF  x4F,W
03E9C:  MOVLB  4
03E9E:  MOVWF  x71
03EA0:  MOVLW  00
03EA2:  MOVLB  3
03EA4:  ADDWFC x50,W
03EA6:  MOVLB  4
03EA8:  MOVWF  x72
03EAA:  BCF    FD8.0
03EAC:  RLCF   x6E,W
03EAE:  ADDWF  x71,W
03EB0:  MOVWF  x6F
03EB2:  MOVLW  00
03EB4:  ADDWFC x72,W
03EB6:  MOVWF  x70
....................      RETURN *(int16*)(pointer + 2* ax * 2 + 2*ay); 
*
00DDA:  BCF    FD8.0
00DDC:  RLCF   x6D,W
00DDE:  MOVWF  00
00DE0:  BCF    FD8.0
00DE2:  RLCF   00,F
00DE4:  MOVF   00,W
00DE6:  MOVLB  3
00DE8:  ADDWF  x4F,W
00DEA:  MOVLB  4
00DEC:  MOVWF  x71
00DEE:  MOVLW  00
00DF0:  MOVLB  3
00DF2:  ADDWFC x50,W
00DF4:  MOVLB  4
00DF6:  MOVWF  x72
00DF8:  BCF    FD8.0
00DFA:  RLCF   x6E,W
00DFC:  ADDWF  x71,W
00DFE:  MOVWF  01
00E00:  MOVLW  00
00E02:  ADDWFC x72,W
00E04:  MOVWF  03
00E06:  MOVFF  01,FE9
00E0A:  MOVWF  FEA
00E0C:  MOVFF  FEF,01
00E10:  INCF   FE9,F
00E12:  MOVF   FEF,W
00E14:  DECF   FE9,F
00E16:  MOVWF  02
*
00E72:  BCF    FD8.0
00E74:  RLCF   x6D,W
00E76:  MOVWF  00
00E78:  BCF    FD8.0
00E7A:  RLCF   00,F
00E7C:  MOVF   00,W
00E7E:  MOVLB  3
00E80:  ADDWF  x4F,W
00E82:  MOVLB  4
00E84:  MOVWF  x71
00E86:  MOVLW  00
00E88:  MOVLB  3
00E8A:  ADDWFC x50,W
00E8C:  MOVLB  4
00E8E:  MOVWF  x72
00E90:  BCF    FD8.0
00E92:  RLCF   x6E,W
00E94:  ADDWF  x71,W
00E96:  MOVWF  01
00E98:  MOVLW  00
00E9A:  ADDWFC x72,W
00E9C:  MOVWF  03
00E9E:  MOVFF  01,FE9
00EA2:  MOVWF  FEA
00EA4:  MOVFF  FEF,01
00EA8:  INCF   FE9,F
00EAA:  MOVF   FEF,W
00EAC:  DECF   FE9,F
00EAE:  MOVWF  02
*
01912:  BCF    FD8.0
01914:  RLCF   x6D,W
01916:  MOVWF  00
01918:  BCF    FD8.0
0191A:  RLCF   00,F
0191C:  MOVF   00,W
0191E:  MOVLB  3
01920:  ADDWF  x4F,W
01922:  MOVLB  4
01924:  MOVWF  x71
01926:  MOVLW  00
01928:  MOVLB  3
0192A:  ADDWFC x50,W
0192C:  MOVLB  4
0192E:  MOVWF  x72
01930:  BCF    FD8.0
01932:  RLCF   x6E,W
01934:  ADDWF  x71,W
01936:  MOVWF  01
01938:  MOVLW  00
0193A:  ADDWFC x72,W
0193C:  MOVWF  03
0193E:  MOVFF  01,FE9
01942:  MOVWF  FEA
01944:  MOVFF  FEF,01
01948:  INCF   FE9,F
0194A:  MOVF   FEF,W
0194C:  DECF   FE9,F
0194E:  MOVWF  02
*
0199A:  BCF    FD8.0
0199C:  RLCF   x6D,W
0199E:  MOVWF  00
019A0:  BCF    FD8.0
019A2:  RLCF   00,F
019A4:  MOVF   00,W
019A6:  MOVLB  3
019A8:  ADDWF  x4F,W
019AA:  MOVLB  4
019AC:  MOVWF  x71
019AE:  MOVLW  00
019B0:  MOVLB  3
019B2:  ADDWFC x50,W
019B4:  MOVLB  4
019B6:  MOVWF  x72
019B8:  BCF    FD8.0
019BA:  RLCF   x6E,W
019BC:  ADDWF  x71,W
019BE:  MOVWF  01
019C0:  MOVLW  00
019C2:  ADDWFC x72,W
019C4:  MOVWF  03
019C6:  MOVFF  01,FE9
019CA:  MOVWF  FEA
019CC:  MOVFF  FEF,01
019D0:  INCF   FE9,F
019D2:  MOVF   FEF,W
019D4:  DECF   FE9,F
019D6:  MOVWF  02
*
03D70:  BCF    FD8.0
03D72:  RLCF   x6D,W
03D74:  MOVWF  00
03D76:  BCF    FD8.0
03D78:  RLCF   00,F
03D7A:  MOVF   00,W
03D7C:  MOVLB  3
03D7E:  ADDWF  x4F,W
03D80:  MOVLB  4
03D82:  MOVWF  x71
03D84:  MOVLW  00
03D86:  MOVLB  3
03D88:  ADDWFC x50,W
03D8A:  MOVLB  4
03D8C:  MOVWF  x72
03D8E:  BCF    FD8.0
03D90:  RLCF   x6E,W
03D92:  ADDWF  x71,W
03D94:  MOVWF  01
03D96:  MOVLW  00
03D98:  ADDWFC x72,W
03D9A:  MOVWF  03
03D9C:  MOVFF  01,FE9
03DA0:  MOVWF  FEA
03DA2:  MOVFF  FEF,01
03DA6:  INCF   FE9,F
03DA8:  MOVF   FEF,W
03DAA:  DECF   FE9,F
03DAC:  MOVWF  02
*
03DEA:  BCF    FD8.0
03DEC:  RLCF   x6D,W
03DEE:  MOVWF  00
03DF0:  BCF    FD8.0
03DF2:  RLCF   00,F
03DF4:  MOVF   00,W
03DF6:  MOVLB  3
03DF8:  ADDWF  x4F,W
03DFA:  MOVLB  4
03DFC:  MOVWF  x71
03DFE:  MOVLW  00
03E00:  MOVLB  3
03E02:  ADDWFC x50,W
03E04:  MOVLB  4
03E06:  MOVWF  x72
03E08:  BCF    FD8.0
03E0A:  RLCF   x6E,W
03E0C:  ADDWF  x71,W
03E0E:  MOVWF  01
03E10:  MOVLW  00
03E12:  ADDWFC x72,W
03E14:  MOVWF  03
03E16:  MOVFF  01,FE9
03E1A:  MOVWF  FEA
03E1C:  MOVFF  FEF,01
03E20:  INCF   FE9,F
03E22:  MOVF   FEF,W
03E24:  DECF   FE9,F
03E26:  MOVWF  02
*
03EB8:  BCF    FD8.0
03EBA:  RLCF   x6D,W
03EBC:  MOVWF  00
03EBE:  BCF    FD8.0
03EC0:  RLCF   00,F
03EC2:  MOVF   00,W
03EC4:  MOVLB  3
03EC6:  ADDWF  x4F,W
03EC8:  MOVLB  4
03ECA:  MOVWF  x71
03ECC:  MOVLW  00
03ECE:  MOVLB  3
03ED0:  ADDWFC x50,W
03ED2:  MOVLB  4
03ED4:  MOVWF  x72
03ED6:  BCF    FD8.0
03ED8:  RLCF   x6E,W
03EDA:  ADDWF  x71,W
03EDC:  MOVWF  01
03EDE:  MOVLW  00
03EE0:  ADDWFC x72,W
03EE2:  MOVWF  03
03EE4:  MOVFF  01,FE9
03EE8:  MOVWF  FEA
03EEA:  MOVFF  FEF,01
03EEE:  INCF   FE9,F
03EF0:  MOVF   FEF,W
03EF2:  DECF   FE9,F
03EF4:  MOVWF  02
....................    } 
....................  
....................    
....................   VOID org(void) 
....................   { 
*
0230C:  MOVLB  4
0230E:  BSF    x60.0
....................      INT16 tempd[N_LUZES][2]; 
....................      INT numluzes; 
....................      INT1 again = 1; 
....................      INT fa; 
....................      INT16 fl; 
....................      INT afa; 
....................      FOR(fa = 0;fa < used_dimmers;++fa) 
02310:  CLRF   x61
02312:  MOVLB  3
02314:  MOVF   x4E,W
02316:  MOVLB  4
02318:  SUBWF  x61,W
0231A:  BC    23AA
....................      { 
....................         tempd[fa][0] = ltlevel[fa];//tempd[x][0] fica com o valor de dimming 0...127 
0231C:  MOVF   x61,W
0231E:  MULLW  04
02320:  MOVF   FF3,W
02322:  CLRF   x66
02324:  MOVWF  x65
02326:  MOVLW  1F
02328:  ADDWF  x65,W
0232A:  MOVWF  01
0232C:  MOVLW  04
0232E:  ADDWFC x66,W
02330:  MOVWF  03
02332:  MOVWF  x66
02334:  CLRF   03
02336:  MOVF   x61,W
02338:  ADDLW  55
0233A:  MOVWF  FE9
0233C:  MOVLW  03
0233E:  ADDWFC 03,W
02340:  MOVWF  FEA
02342:  MOVF   FEF,W
02344:  CLRF   03
02346:  MOVFF  466,FEA
0234A:  MOVFF  01,FE9
0234E:  MOVFF  03,FEC
02352:  MOVF   FED,F
02354:  MOVWF  FEF
....................         tempd[fa][1] = lights[fa];//tempd[x][1] fica com o valor binario DO porto de saida 
02356:  MOVF   x61,W
02358:  MULLW  04
0235A:  MOVF   FF3,W
0235C:  CLRF   x66
0235E:  MOVWF  x65
02360:  MOVLW  02
02362:  ADDWF  x65,W
02364:  MOVWF  01
02366:  MOVLW  00
02368:  ADDWFC x66,W
0236A:  MOVWF  03
0236C:  MOVF   01,W
0236E:  ADDLW  1F
02370:  MOVWF  01
02372:  MOVLW  04
02374:  ADDWFC 03,F
02376:  MOVFF  03,466
0237A:  BCF    FD8.0
0237C:  RLCF   x61,W
0237E:  CLRF   03
02380:  ADDLW  ED
02382:  MOVWF  FE9
02384:  MOVLW  03
02386:  ADDWFC 03,W
02388:  MOVWF  FEA
0238A:  MOVFF  FEC,03
0238E:  MOVF   FED,F
02390:  MOVFF  FEF,467
02394:  MOVFF  466,FEA
02398:  MOVFF  01,FE9
0239C:  MOVFF  03,FEC
023A0:  MOVF   FED,F
023A2:  MOVFF  467,FEF
....................      } 
023A6:  INCF   x61,F
023A8:  BRA    2312
....................  
....................      WHILE(again) 
....................      { 
023AA:  BTFSS  x60.0
023AC:  BRA    2574
....................         again = 0; 
023AE:  BCF    x60.0
....................         FOR(fa = 0;fa < used_dimmers-1;++fa) 
023B0:  CLRF   x61
023B2:  MOVLW  01
023B4:  MOVLB  3
023B6:  SUBWF  x4E,W
023B8:  MOVLB  4
023BA:  SUBWF  x61,W
023BC:  BTFSC  FD8.0
023BE:  BRA    2572
....................         { 
....................            //coloca valores por ordem tempd[0][0] o maior 
....................            IF(tempd[fa][0] < tempd[fa + 1][0]) 
023C0:  MOVF   x61,W
023C2:  MULLW  04
023C4:  MOVF   FF3,W
023C6:  CLRF   x66
023C8:  MOVWF  x65
023CA:  MOVLW  1F
023CC:  ADDWF  x65,W
023CE:  MOVWF  FE9
023D0:  MOVLW  04
023D2:  ADDWFC x66,W
023D4:  MOVWF  FEA
023D6:  MOVFF  FEC,466
023DA:  MOVF   FED,F
023DC:  MOVFF  FEF,465
023E0:  MOVLW  01
023E2:  ADDWF  x61,W
023E4:  MULLW  04
023E6:  MOVF   FF3,W
023E8:  CLRF   x68
023EA:  MOVWF  x67
023EC:  MOVLW  1F
023EE:  ADDWF  x67,W
023F0:  MOVWF  FE9
023F2:  MOVLW  04
023F4:  ADDWFC x68,W
023F6:  MOVWF  FEA
023F8:  MOVFF  FEC,03
023FC:  MOVF   FED,F
023FE:  MOVFF  FEF,01
02402:  MOVF   x66,W
02404:  SUBWF  03,W
02406:  BTFSS  FD8.0
02408:  BRA    256E
0240A:  BNZ   2414
0240C:  MOVF   01,W
0240E:  SUBWF  x65,W
02410:  BTFSC  FD8.0
02412:  BRA    256E
....................            { 
....................               again = 1; 
02414:  BSF    x60.0
....................               fl = tempd[fa][0]; 
02416:  MOVF   x61,W
02418:  MULLW  04
0241A:  MOVF   FF3,W
0241C:  CLRF   x66
0241E:  MOVWF  x65
02420:  MOVLW  1F
02422:  ADDWF  x65,W
02424:  MOVWF  FE9
02426:  MOVLW  04
02428:  ADDWFC x66,W
0242A:  MOVWF  FEA
0242C:  MOVFF  FEC,03
02430:  MOVF   FED,F
02432:  MOVFF  FEF,462
02436:  MOVFF  03,463
....................               tempd[fa][0] = tempd[fa + 1][0]; 
0243A:  MOVF   x61,W
0243C:  MULLW  04
0243E:  MOVF   FF3,W
02440:  CLRF   x66
02442:  MOVWF  x65
02444:  MOVLW  1F
02446:  ADDWF  x65,W
02448:  MOVWF  01
0244A:  MOVLW  04
0244C:  ADDWFC x66,W
0244E:  MOVWF  03
02450:  MOVWF  x66
02452:  MOVLW  01
02454:  ADDWF  x61,W
02456:  MULLW  04
02458:  MOVF   FF3,W
0245A:  CLRF   x68
0245C:  MOVWF  x67
0245E:  MOVLW  1F
02460:  ADDWF  x67,W
02462:  MOVWF  FE9
02464:  MOVLW  04
02466:  ADDWFC x68,W
02468:  MOVWF  FEA
0246A:  MOVFF  FEC,03
0246E:  MOVF   FED,F
02470:  MOVFF  FEF,467
02474:  MOVFF  466,FEA
02478:  MOVFF  01,FE9
0247C:  MOVFF  03,FEC
02480:  MOVF   FED,F
02482:  MOVFF  467,FEF
....................               tempd[fa + 1][0] = fl; 
02486:  MOVLW  01
02488:  ADDWF  x61,W
0248A:  MULLW  04
0248C:  MOVF   FF3,W
0248E:  CLRF   x66
02490:  MOVWF  x65
02492:  MOVLW  1F
02494:  ADDWF  x65,W
02496:  MOVWF  FE9
02498:  MOVLW  04
0249A:  ADDWFC x66,W
0249C:  MOVWF  FEA
0249E:  MOVFF  463,FEC
024A2:  MOVF   FED,F
024A4:  MOVFF  462,FEF
....................               fl = tempd[fa][1]; 
024A8:  MOVF   x61,W
024AA:  MULLW  04
024AC:  MOVF   FF3,W
024AE:  CLRF   x66
024B0:  MOVWF  x65
024B2:  MOVLW  02
024B4:  ADDWF  x65,W
024B6:  MOVWF  01
024B8:  MOVLW  00
024BA:  ADDWFC x66,W
024BC:  MOVWF  03
024BE:  MOVF   01,W
024C0:  ADDLW  1F
024C2:  MOVWF  FE9
024C4:  MOVLW  04
024C6:  ADDWFC 03,W
024C8:  MOVWF  FEA
024CA:  MOVFF  FEC,03
024CE:  MOVF   FED,F
024D0:  MOVFF  FEF,462
024D4:  MOVFF  03,463
....................               tempd[fa][1] = tempd[fa + 1][1]; 
024D8:  MOVF   x61,W
024DA:  MULLW  04
024DC:  MOVF   FF3,W
024DE:  CLRF   x66
024E0:  MOVWF  x65
024E2:  MOVLW  02
024E4:  ADDWF  x65,W
024E6:  MOVWF  01
024E8:  MOVLW  00
024EA:  ADDWFC x66,W
024EC:  MOVWF  03
024EE:  MOVF   01,W
024F0:  ADDLW  1F
024F2:  MOVWF  01
024F4:  MOVLW  04
024F6:  ADDWFC 03,F
024F8:  MOVFF  01,465
024FC:  MOVFF  03,466
02500:  MOVLW  01
02502:  ADDWF  x61,W
02504:  MULLW  04
02506:  MOVF   FF3,W
02508:  CLRF   x68
0250A:  MOVWF  x67
0250C:  MOVLW  02
0250E:  ADDWF  x67,W
02510:  MOVWF  01
02512:  MOVLW  00
02514:  ADDWFC x68,W
02516:  MOVWF  03
02518:  MOVF   01,W
0251A:  ADDLW  1F
0251C:  MOVWF  FE9
0251E:  MOVLW  04
02520:  ADDWFC 03,W
02522:  MOVWF  FEA
02524:  MOVFF  FEC,03
02528:  MOVF   FED,F
0252A:  MOVFF  FEF,467
0252E:  MOVFF  466,FEA
02532:  MOVFF  465,FE9
02536:  MOVFF  03,FEC
0253A:  MOVF   FED,F
0253C:  MOVFF  467,FEF
....................               tempd[fa + 1][1] = fl; 
02540:  MOVLW  01
02542:  ADDWF  x61,W
02544:  MULLW  04
02546:  MOVF   FF3,W
02548:  CLRF   x66
0254A:  MOVWF  x65
0254C:  MOVLW  02
0254E:  ADDWF  x65,W
02550:  MOVWF  01
02552:  MOVLW  00
02554:  ADDWFC x66,W
02556:  MOVWF  03
02558:  MOVF   01,W
0255A:  ADDLW  1F
0255C:  MOVWF  FE9
0255E:  MOVLW  04
02560:  ADDWFC 03,W
02562:  MOVWF  FEA
02564:  MOVFF  463,FEC
02568:  MOVF   FED,F
0256A:  MOVFF  462,FEF
....................            } 
....................         } 
0256E:  INCF   x61,F
02570:  BRA    23B2
....................      } 
02572:  BRA    23AA
....................      /* for(temp=0;temp<used_dimmers;++temp) 
....................    { 
....................       printf("DIMMER:%u value=%lu <-> portWrite=%lu\n\r",temp,tempd[temp][0],tempd[temp][1]); 
....................    }*/ 
....................      IF(tempd[0][0] == 0)numluzes = 0;//luzes todas off 
02574:  MOVF   x1F,F
02576:  BNZ   2580
02578:  MOVF   x20,F
0257A:  BNZ   2580
0257C:  CLRF   x5F
....................      ELSE 
0257E:  BRA    2920
....................      { 
....................         numluzes = 1; 
02580:  MOVLW  01
02582:  MOVWF  x5F
....................         afa = 0; 
02584:  CLRF   x64
....................         IF(actmat) 
02586:  MOVLB  0
02588:  BTFSS  xB1.3
0258A:  BRA    259E
....................         { 
....................            delays1[0][0] = tempd[0][0]; 
0258C:  MOVFF  420,366
02590:  MOVFF  41F,365
....................            delays1[0][1] = tempd[0][1]; 
02594:  MOVFF  422,368
02598:  MOVFF  421,367
....................         } 
....................  
....................         ELSE 
0259C:  BRA    25AE
....................         { 
....................            delays2[0][0] = tempd[0][0]; 
0259E:  MOVFF  420,3AA
025A2:  MOVFF  41F,3A9
....................            delays2[0][1] = tempd[0][1]; 
025A6:  MOVFF  422,3AC
025AA:  MOVFF  421,3AB
....................         } 
....................  
....................         FOR(fa = 1;fa < used_dimmers;++fa) 
025AE:  MOVLW  01
025B0:  MOVLB  4
025B2:  MOVWF  x61
025B4:  MOVLB  3
025B6:  MOVF   x4E,W
025B8:  MOVLB  4
025BA:  SUBWF  x61,W
025BC:  BTFSC  FD8.0
025BE:  BRA    2920
....................         { 
....................            IF((tempd[fa][0] == tempd[fa - 1][0])&( ! tempd[fa][0] == 0)) 
025C0:  MOVF   x61,W
025C2:  MULLW  04
025C4:  MOVF   FF3,W
025C6:  CLRF   x66
025C8:  MOVWF  x65
025CA:  MOVLW  1F
025CC:  ADDWF  x65,W
025CE:  MOVWF  FE9
025D0:  MOVLW  04
025D2:  ADDWFC x66,W
025D4:  MOVWF  FEA
025D6:  MOVFF  FEC,466
025DA:  MOVF   FED,F
025DC:  MOVFF  FEF,465
025E0:  MOVLW  01
025E2:  SUBWF  x61,W
025E4:  MULLW  04
025E6:  MOVF   FF3,W
025E8:  CLRF   x68
025EA:  MOVWF  x67
025EC:  MOVLW  1F
025EE:  ADDWF  x67,W
025F0:  MOVWF  FE9
025F2:  MOVLW  04
025F4:  ADDWFC x68,W
025F6:  MOVWF  FEA
025F8:  MOVFF  FEC,03
025FC:  MOVF   FED,F
025FE:  MOVF   FEF,W
02600:  SUBWF  x65,W
02602:  BNZ   260A
02604:  MOVF   03,W
02606:  SUBWF  x66,W
02608:  BZ    260E
0260A:  MOVLW  00
0260C:  BRA    2610
0260E:  MOVLW  01
02610:  MOVWF  x65
02612:  MOVF   x61,W
02614:  MULLW  04
02616:  MOVF   FF3,W
02618:  CLRF   x67
0261A:  MOVWF  x66
0261C:  MOVLW  1F
0261E:  ADDWF  x66,W
02620:  MOVWF  FE9
02622:  MOVLW  04
02624:  ADDWFC x67,W
02626:  MOVWF  FEA
02628:  MOVF   FEF,F
0262A:  BNZ   2630
0262C:  MOVF   FEC,F
0262E:  BZ    2634
02630:  MOVLW  00
02632:  BRA    2636
02634:  MOVLW  01
02636:  XORLW  00
02638:  BZ    263E
0263A:  MOVLW  00
0263C:  BRA    2640
0263E:  MOVLW  01
02640:  ANDWF  x65,W
02642:  BTFSC  FD8.2
02644:  BRA    2780
....................            { 
....................               IF(actmat)delays1[afa][1] = delays1[afa][1]&tempd[fa][1]; 
02646:  MOVLB  0
02648:  BTFSS  xB1.3
0264A:  BRA    26E6
0264C:  MOVLB  4
0264E:  MOVF   x64,W
02650:  MULLW  04
02652:  MOVF   FF3,W
02654:  CLRF   x66
02656:  MOVWF  x65
02658:  MOVLW  02
0265A:  ADDWF  x65,W
0265C:  MOVWF  01
0265E:  MOVLW  00
02660:  ADDWFC x66,W
02662:  MOVWF  03
02664:  MOVF   01,W
02666:  ADDLW  65
02668:  MOVWF  01
0266A:  MOVLW  03
0266C:  ADDWFC 03,F
0266E:  MOVFF  01,465
02672:  MOVFF  03,466
02676:  MOVF   x64,W
02678:  MULLW  04
0267A:  MOVF   FF3,W
0267C:  CLRF   x68
0267E:  MOVWF  x67
02680:  MOVLW  02
02682:  ADDWF  x67,W
02684:  MOVWF  01
02686:  MOVLW  00
02688:  ADDWFC x68,W
0268A:  MOVWF  03
0268C:  MOVF   01,W
0268E:  ADDLW  65
02690:  MOVWF  FE9
02692:  MOVLW  03
02694:  ADDWFC 03,W
02696:  MOVWF  FEA
02698:  MOVFF  FEC,468
0269C:  MOVF   FED,F
0269E:  MOVFF  FEF,467
026A2:  MOVF   x61,W
026A4:  MULLW  04
026A6:  MOVF   FF3,W
026A8:  CLRF   x6A
026AA:  MOVWF  x69
026AC:  MOVLW  02
026AE:  ADDWF  x69,W
026B0:  MOVWF  01
026B2:  MOVLW  00
026B4:  ADDWFC x6A,W
026B6:  MOVWF  03
026B8:  MOVF   01,W
026BA:  ADDLW  1F
026BC:  MOVWF  FE9
026BE:  MOVLW  04
026C0:  ADDWFC 03,W
026C2:  MOVWF  FEA
026C4:  MOVFF  FEC,03
026C8:  MOVF   FED,F
026CA:  MOVF   FEF,W
026CC:  ANDWF  x67,W
026CE:  MOVWF  00
026D0:  MOVF   03,W
026D2:  ANDWF  x68,W
026D4:  MOVFF  466,FEA
026D8:  MOVFF  465,FE9
026DC:  MOVWF  FEC
026DE:  MOVF   FED,F
026E0:  MOVFF  00,FEF
....................               ELSE delays2[afa][1] = delays2[afa][1]&tempd[fa][1]; 
026E4:  BRA    277E
026E6:  MOVLB  4
026E8:  MOVF   x64,W
026EA:  MULLW  04
026EC:  MOVF   FF3,W
026EE:  CLRF   x66
026F0:  MOVWF  x65
026F2:  MOVLW  02
026F4:  ADDWF  x65,W
026F6:  MOVWF  01
026F8:  MOVLW  00
026FA:  ADDWFC x66,W
026FC:  MOVWF  03
026FE:  MOVF   01,W
02700:  ADDLW  A9
02702:  MOVWF  01
02704:  MOVLW  03
02706:  ADDWFC 03,F
02708:  MOVFF  01,465
0270C:  MOVFF  03,466
02710:  MOVF   x64,W
02712:  MULLW  04
02714:  MOVF   FF3,W
02716:  CLRF   x68
02718:  MOVWF  x67
0271A:  MOVLW  02
0271C:  ADDWF  x67,W
0271E:  MOVWF  01
02720:  MOVLW  00
02722:  ADDWFC x68,W
02724:  MOVWF  03
02726:  MOVF   01,W
02728:  ADDLW  A9
0272A:  MOVWF  FE9
0272C:  MOVLW  03
0272E:  ADDWFC 03,W
02730:  MOVWF  FEA
02732:  MOVFF  FEC,468
02736:  MOVF   FED,F
02738:  MOVFF  FEF,467
0273C:  MOVF   x61,W
0273E:  MULLW  04
02740:  MOVF   FF3,W
02742:  CLRF   x6A
02744:  MOVWF  x69
02746:  MOVLW  02
02748:  ADDWF  x69,W
0274A:  MOVWF  01
0274C:  MOVLW  00
0274E:  ADDWFC x6A,W
02750:  MOVWF  03
02752:  MOVF   01,W
02754:  ADDLW  1F
02756:  MOVWF  FE9
02758:  MOVLW  04
0275A:  ADDWFC 03,W
0275C:  MOVWF  FEA
0275E:  MOVFF  FEC,03
02762:  MOVF   FED,F
02764:  MOVF   FEF,W
02766:  ANDWF  x67,W
02768:  MOVWF  00
0276A:  MOVF   03,W
0276C:  ANDWF  x68,W
0276E:  MOVFF  466,FEA
02772:  MOVFF  465,FE9
02776:  MOVWF  FEC
02778:  MOVF   FED,F
0277A:  MOVFF  00,FEF
....................            } 
....................  
....................            else IF( ! tempd[fa][0] == 0) 
0277E:  BRA    291C
02780:  MOVF   x61,W
02782:  MULLW  04
02784:  MOVF   FF3,W
02786:  CLRF   x66
02788:  MOVWF  x65
0278A:  MOVLW  1F
0278C:  ADDWF  x65,W
0278E:  MOVWF  FE9
02790:  MOVLW  04
02792:  ADDWFC x66,W
02794:  MOVWF  FEA
02796:  MOVF   FEF,F
02798:  BNZ   279E
0279A:  MOVF   FEC,F
0279C:  BZ    27A2
0279E:  MOVLW  00
027A0:  BRA    27A4
027A2:  MOVLW  01
027A4:  XORLW  00
027A6:  BTFSS  FD8.2
027A8:  BRA    291C
....................            { 
....................               ++afa; 
027AA:  INCF   x64,F
....................               IF(actmat) 
027AC:  MOVLB  0
027AE:  BTFSS  xB1.3
027B0:  BRA    2868
....................               { 
....................                  delays1[afa][0] = tempd[fa][0]; 
027B2:  MOVLB  4
027B4:  MOVF   x64,W
027B6:  MULLW  04
027B8:  MOVF   FF3,W
027BA:  CLRF   x66
027BC:  MOVWF  x65
027BE:  MOVLW  65
027C0:  ADDWF  x65,W
027C2:  MOVWF  01
027C4:  MOVLW  03
027C6:  ADDWFC x66,W
027C8:  MOVWF  03
027CA:  MOVWF  x66
027CC:  MOVF   x61,W
027CE:  MULLW  04
027D0:  MOVF   FF3,W
027D2:  CLRF   x68
027D4:  MOVWF  x67
027D6:  MOVLW  1F
027D8:  ADDWF  x67,W
027DA:  MOVWF  FE9
027DC:  MOVLW  04
027DE:  ADDWFC x68,W
027E0:  MOVWF  FEA
027E2:  MOVFF  FEC,03
027E6:  MOVF   FED,F
027E8:  MOVFF  FEF,467
027EC:  MOVFF  466,FEA
027F0:  MOVFF  01,FE9
027F4:  MOVFF  03,FEC
027F8:  MOVF   FED,F
027FA:  MOVFF  467,FEF
....................                  delays1[afa][1] = tempd[fa][1]; 
027FE:  MOVF   x64,W
02800:  MULLW  04
02802:  MOVF   FF3,W
02804:  CLRF   x66
02806:  MOVWF  x65
02808:  MOVLW  02
0280A:  ADDWF  x65,W
0280C:  MOVWF  01
0280E:  MOVLW  00
02810:  ADDWFC x66,W
02812:  MOVWF  03
02814:  MOVF   01,W
02816:  ADDLW  65
02818:  MOVWF  01
0281A:  MOVLW  03
0281C:  ADDWFC 03,F
0281E:  MOVFF  01,465
02822:  MOVFF  03,466
02826:  MOVF   x61,W
02828:  MULLW  04
0282A:  MOVF   FF3,W
0282C:  CLRF   x68
0282E:  MOVWF  x67
02830:  MOVLW  02
02832:  ADDWF  x67,W
02834:  MOVWF  01
02836:  MOVLW  00
02838:  ADDWFC x68,W
0283A:  MOVWF  03
0283C:  MOVF   01,W
0283E:  ADDLW  1F
02840:  MOVWF  FE9
02842:  MOVLW  04
02844:  ADDWFC 03,W
02846:  MOVWF  FEA
02848:  MOVFF  FEC,03
0284C:  MOVF   FED,F
0284E:  MOVFF  FEF,467
02852:  MOVFF  466,FEA
02856:  MOVFF  465,FE9
0285A:  MOVFF  03,FEC
0285E:  MOVF   FED,F
02860:  MOVFF  467,FEF
....................               } 
....................  
....................               ELSE 
02864:  BRA    291A
02866:  MOVLB  0
....................               { 
....................                  delays2[afa][0] = tempd[fa][0]; 
02868:  MOVLB  4
0286A:  MOVF   x64,W
0286C:  MULLW  04
0286E:  MOVF   FF3,W
02870:  CLRF   x66
02872:  MOVWF  x65
02874:  MOVLW  A9
02876:  ADDWF  x65,W
02878:  MOVWF  01
0287A:  MOVLW  03
0287C:  ADDWFC x66,W
0287E:  MOVWF  03
02880:  MOVWF  x66
02882:  MOVF   x61,W
02884:  MULLW  04
02886:  MOVF   FF3,W
02888:  CLRF   x68
0288A:  MOVWF  x67
0288C:  MOVLW  1F
0288E:  ADDWF  x67,W
02890:  MOVWF  FE9
02892:  MOVLW  04
02894:  ADDWFC x68,W
02896:  MOVWF  FEA
02898:  MOVFF  FEC,03
0289C:  MOVF   FED,F
0289E:  MOVFF  FEF,467
028A2:  MOVFF  466,FEA
028A6:  MOVFF  01,FE9
028AA:  MOVFF  03,FEC
028AE:  MOVF   FED,F
028B0:  MOVFF  467,FEF
....................                  delays2[afa][1] = tempd[fa][1]; 
028B4:  MOVF   x64,W
028B6:  MULLW  04
028B8:  MOVF   FF3,W
028BA:  CLRF   x66
028BC:  MOVWF  x65
028BE:  MOVLW  02
028C0:  ADDWF  x65,W
028C2:  MOVWF  01
028C4:  MOVLW  00
028C6:  ADDWFC x66,W
028C8:  MOVWF  03
028CA:  MOVF   01,W
028CC:  ADDLW  A9
028CE:  MOVWF  01
028D0:  MOVLW  03
028D2:  ADDWFC 03,F
028D4:  MOVFF  01,465
028D8:  MOVFF  03,466
028DC:  MOVF   x61,W
028DE:  MULLW  04
028E0:  MOVF   FF3,W
028E2:  CLRF   x68
028E4:  MOVWF  x67
028E6:  MOVLW  02
028E8:  ADDWF  x67,W
028EA:  MOVWF  01
028EC:  MOVLW  00
028EE:  ADDWFC x68,W
028F0:  MOVWF  03
028F2:  MOVF   01,W
028F4:  ADDLW  1F
028F6:  MOVWF  FE9
028F8:  MOVLW  04
028FA:  ADDWFC 03,W
028FC:  MOVWF  FEA
028FE:  MOVFF  FEC,03
02902:  MOVF   FED,F
02904:  MOVFF  FEF,467
02908:  MOVFF  466,FEA
0290C:  MOVFF  465,FE9
02910:  MOVFF  03,FEC
02914:  MOVF   FED,F
02916:  MOVFF  467,FEF
....................               } 
....................  
....................               ++numluzes; 
0291A:  INCF   x5F,F
....................            } 
....................         } 
0291C:  INCF   x61,F
0291E:  BRA    25B4
....................      } 
....................  
....................      IF(actmat)delays1[N_LUZES][0] = numluzes; 
02920:  MOVLB  0
02922:  BTFSS  xB1.3
02924:  BRA    2930
02926:  MOVLB  3
02928:  CLRF   xA6
0292A:  MOVFF  45F,3A5
....................      ELSE  delays2[N_LUZES][0] = numluzes; 
0292E:  BRA    2938
02930:  MOVLB  3
02932:  CLRF   xEA
02934:  MOVFF  45F,3E9
....................     // printf("num luzes activas=%d valor primeira=%lu portWrite=%lu\n\r",numluzes,delays1[0][0],delays1[0][1]); 
....................       
....................      organizado=1; 
02938:  MOVLB  0
0293A:  BSF    xB1.2
....................   } 
0293C:  RETLW  00
....................  
.................... void dimmer_outputs_init() 
.................... { 
....................    int x; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
0293E:  MOVLB  4
02940:  CLRF   x1D
02942:  MOVLB  1
02944:  MOVF   x3B,W
02946:  MOVLB  4
02948:  SUBWF  x1D,W
0294A:  BTFSC  FD8.0
0294C:  BRA    2A76
0294E:  CLRF   1B
02950:  BTFSC  FF2.7
02952:  BSF    1B.7
02954:  BCF    FF2.7
....................    { 
....................       switch (((struct outputs)mydevices.myoutputs[x]).type) { 
02956:  CLRF   x6D
02958:  MOVFF  41D,46C
0295C:  CLRF   x6F
0295E:  MOVLW  23
02960:  MOVWF  x6E
02962:  MOVLB  0
02964:  CALL   030E
02968:  BTFSC  1B.7
0296A:  BSF    FF2.7
0296C:  MOVFF  02,03
02970:  MOVF   01,W
02972:  ADDLW  F0
02974:  MOVWF  01
02976:  MOVLW  01
02978:  ADDWFC 03,F
0297A:  MOVFF  01,FE9
0297E:  MOVFF  03,FEA
02982:  MOVF   FEF,W
02984:  XORLW  01
02986:  BZ    298A
02988:  BRA    2A70
....................          case dimmer: 
....................             lights[used_dimmers]=light_pins[((struct light)mydevices.myoutputs[x].device).output_pin]; 
0298A:  BCF    FD8.0
0298C:  MOVLB  3
0298E:  RLCF   x4E,W
02990:  CLRF   03
02992:  ADDLW  ED
02994:  MOVWF  01
02996:  MOVLW  03
02998:  ADDWFC 03,F
0299A:  MOVFF  01,41E
0299E:  MOVLB  4
029A0:  MOVFF  03,41F
029A4:  CLRF   1B
029A6:  BTFSC  FF2.7
029A8:  BSF    1B.7
029AA:  BCF    FF2.7
029AC:  CLRF   x6D
029AE:  MOVFF  41D,46C
029B2:  CLRF   x6F
029B4:  MOVLW  23
029B6:  MOVWF  x6E
029B8:  MOVLB  0
029BA:  CALL   030E
029BE:  BTFSC  1B.7
029C0:  BSF    FF2.7
029C2:  MOVF   01,W
029C4:  ADDLW  B6
029C6:  MOVLB  4
029C8:  MOVWF  x20
029CA:  MOVLW  00
029CC:  ADDWFC 02,W
029CE:  MOVWF  x21
029D0:  MOVLW  01
029D2:  ADDWF  x20,W
029D4:  MOVWF  01
029D6:  MOVLW  00
029D8:  ADDWFC x21,W
029DA:  MOVWF  03
029DC:  MOVF   01,W
029DE:  ADDLW  3A
029E0:  MOVWF  01
029E2:  MOVLW  01
029E4:  ADDWFC 03,F
029E6:  MOVF   01,W
029E8:  ADDLW  1F
029EA:  MOVWF  FE9
029EC:  MOVLW  00
029EE:  ADDWFC 03,W
029F0:  MOVWF  FEA
029F2:  BCF    FD8.0
029F4:  RLCF   FEF,W
029F6:  CLRF   03
029F8:  MOVLB  0
029FA:  CALL   0172
029FE:  TBLRD*+
02A00:  MOVFF  FF5,03
02A04:  MOVLB  4
02A06:  MOVFF  41F,FEA
02A0A:  MOVFF  41E,FE9
02A0E:  MOVFF  03,FEC
02A12:  MOVF   FED,F
02A14:  MOVWF  FEF
02A16:  CLRF   1B
02A18:  BTFSC  FF2.7
02A1A:  BSF    1B.7
02A1C:  BCF    FF2.7
....................             ((struct light)mydevices.myoutputs[x].device).internal_order=used_dimmers; 
02A1E:  CLRF   x6D
02A20:  MOVFF  41D,46C
02A24:  CLRF   x6F
02A26:  MOVLW  23
02A28:  MOVWF  x6E
02A2A:  MOVLB  0
02A2C:  CALL   030E
02A30:  BTFSC  1B.7
02A32:  BSF    FF2.7
02A34:  MOVF   01,W
02A36:  ADDLW  B6
02A38:  MOVLB  4
02A3A:  MOVWF  x1E
02A3C:  MOVLW  00
02A3E:  ADDWFC 02,W
02A40:  MOVWF  x1F
02A42:  MOVLW  01
02A44:  ADDWF  x1E,W
02A46:  MOVWF  01
02A48:  MOVLW  00
02A4A:  ADDWFC x1F,W
02A4C:  MOVWF  03
02A4E:  MOVF   01,W
02A50:  ADDLW  3A
02A52:  MOVWF  01
02A54:  MOVLW  01
02A56:  ADDWFC 03,F
02A58:  MOVF   01,W
02A5A:  ADDLW  20
02A5C:  MOVWF  FE9
02A5E:  MOVLW  00
02A60:  ADDWFC 03,W
02A62:  MOVWF  FEA
02A64:  MOVFF  34E,FEF
....................             ++used_dimmers; 
02A68:  MOVLB  3
02A6A:  INCF   x4E,F
....................              
....................          break; 
02A6C:  MOVLB  0
02A6E:  BRA    2A70
....................       } 
....................    } 
02A70:  MOVLB  4
02A72:  INCF   x1D,F
02A74:  BRA    2942
....................    dimmers_off_value=0xFFFF; 
02A76:  MOVLW  FF
02A78:  MOVLB  3
02A7A:  MOVWF  x54
02A7C:  MOVWF  x53
....................    for(x=0;x<used_dimmers;++x) 
02A7E:  MOVLB  4
02A80:  CLRF   x1D
02A82:  MOVLB  3
02A84:  MOVF   x4E,W
02A86:  MOVLB  4
02A88:  SUBWF  x1D,W
02A8A:  BC    2AB2
....................    { 
....................       dimmers_off_value=dimmers_off_value & lights[x]; 
02A8C:  BCF    FD8.0
02A8E:  RLCF   x1D,W
02A90:  CLRF   03
02A92:  ADDLW  ED
02A94:  MOVWF  FE9
02A96:  MOVLW  03
02A98:  ADDWFC 03,W
02A9A:  MOVWF  FEA
02A9C:  MOVFF  FEC,03
02AA0:  MOVF   FED,F
02AA2:  MOVF   FEF,W
02AA4:  MOVLB  3
02AA6:  ANDWF  x53,F
02AA8:  MOVF   03,W
02AAA:  ANDWF  x54,F
....................    } 
02AAC:  MOVLB  4
02AAE:  INCF   x1D,F
02AB0:  BRA    2A82
....................    dimmers_off_value=!dimmers_off_value; 
02AB2:  MOVLB  3
02AB4:  MOVF   x53,W
02AB6:  IORWF  x54,W
02AB8:  MOVLW  00
02ABA:  BTFSC  FD8.2
02ABC:  XORLW  01
02ABE:  MOVWF  x53
02AC0:  MOVLW  00
....................    trisc=0x00; //tudo saidas 
02AC2:  CLRF   F94
....................    trisd=0x00; //tudo saidas 
02AC4:  CLRF   F95
....................    actmat=0; 
02AC6:  MOVLB  0
02AC8:  BCF    xB1.3
....................    pointer=delays1; 
02ACA:  MOVLW  03
02ACC:  MOVLB  3
02ACE:  MOVWF  x50
02AD0:  MOVLW  65
02AD2:  MOVWF  x4F
....................    org(); 
02AD4:  MOVLB  0
02AD6:  RCALL  230C
....................    pointer=delays2; 
02AD8:  MOVLW  03
02ADA:  MOVLB  3
02ADC:  MOVWF  x50
02ADE:  MOVLW  A9
02AE0:  MOVWF  x4F
....................    actmat=1; 
02AE2:  MOVLB  0
02AE4:  BSF    xB1.3
....................    org(); 
02AE6:  RCALL  230C
.................... } 
02AE8:  GOTO   3D06 (RETURN)
....................  
.................... void write_outputs() 
.................... { 
02AEC:  MOVLB  4
02AEE:  BCF    x1E.0
....................    int x; 
....................    int1 update_dimmers=false; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
02AF0:  CLRF   x1D
02AF2:  MOVLB  1
02AF4:  MOVF   x3B,W
02AF6:  MOVLB  4
02AF8:  SUBWF  x1D,W
02AFA:  BTFSC  FD8.0
02AFC:  BRA    30AA
02AFE:  CLRF   1B
02B00:  BTFSC  FF2.7
02B02:  BSF    1B.7
02B04:  BCF    FF2.7
....................    { 
....................       switch (((struct outputs)mydevices.myoutputs[x]).type) { 
02B06:  CLRF   x6D
02B08:  MOVFF  41D,46C
02B0C:  CLRF   x6F
02B0E:  MOVLW  23
02B10:  MOVWF  x6E
02B12:  MOVLB  0
02B14:  CALL   030E
02B18:  BTFSC  1B.7
02B1A:  BSF    FF2.7
02B1C:  MOVFF  02,03
02B20:  MOVF   01,W
02B22:  ADDLW  F0
02B24:  MOVWF  01
02B26:  MOVLW  01
02B28:  ADDWFC 03,F
02B2A:  MOVFF  01,FE9
02B2E:  MOVFF  03,FEA
02B32:  MOVF   FEF,W
02B34:  XORLW  01
02B36:  BZ    2B3A
02B38:  BRA    30A4
....................          case dimmer: 
02B3A:  CLRF   1B
02B3C:  BTFSC  FF2.7
02B3E:  BSF    1B.7
02B40:  BCF    FF2.7
....................             //printf("dimmer"); 
....................             if(((struct light)mydevices.myoutputs[x].device).dim_value.needs_update) 
02B42:  MOVLB  4
02B44:  CLRF   x6D
02B46:  MOVFF  41D,46C
02B4A:  CLRF   x6F
02B4C:  MOVLW  23
02B4E:  MOVWF  x6E
02B50:  MOVLB  0
02B52:  CALL   030E
02B56:  BTFSC  1B.7
02B58:  BSF    FF2.7
02B5A:  MOVF   01,W
02B5C:  ADDLW  B6
02B5E:  MOVLB  4
02B60:  MOVWF  x1F
02B62:  MOVLW  00
02B64:  ADDWFC 02,W
02B66:  MOVWF  x20
02B68:  MOVLW  01
02B6A:  ADDWF  x1F,W
02B6C:  MOVWF  01
02B6E:  MOVLW  00
02B70:  ADDWFC x20,W
02B72:  MOVWF  03
02B74:  MOVF   01,W
02B76:  ADDLW  3A
02B78:  MOVWF  01
02B7A:  MOVLW  01
02B7C:  ADDWFC 03,F
02B7E:  MOVF   01,W
02B80:  ADDLW  1D
02B82:  MOVWF  FE9
02B84:  MOVLW  00
02B86:  ADDWFC 03,W
02B88:  MOVWF  FEA
02B8A:  BTFSS  FEF.0
02B8C:  BRA    2CF2
02B8E:  CLRF   1B
02B90:  BTFSC  FF2.7
02B92:  BSF    1B.7
02B94:  BCF    FF2.7
....................             { 
....................                if(((struct light)mydevices.myoutputs[x].device).out_state==_on) 
02B96:  CLRF   x6D
02B98:  MOVFF  41D,46C
02B9C:  CLRF   x6F
02B9E:  MOVLW  23
02BA0:  MOVWF  x6E
02BA2:  MOVLB  0
02BA4:  CALL   030E
02BA8:  BTFSC  1B.7
02BAA:  BSF    FF2.7
02BAC:  MOVF   01,W
02BAE:  ADDLW  B6
02BB0:  MOVLB  4
02BB2:  MOVWF  x1F
02BB4:  MOVLW  00
02BB6:  ADDWFC 02,W
02BB8:  MOVWF  x20
02BBA:  MOVLW  01
02BBC:  ADDWF  x1F,W
02BBE:  MOVWF  01
02BC0:  MOVLW  00
02BC2:  ADDWFC x20,W
02BC4:  MOVWF  03
02BC6:  MOVF   01,W
02BC8:  ADDLW  3A
02BCA:  MOVWF  01
02BCC:  MOVLW  01
02BCE:  ADDWFC 03,F
02BD0:  MOVF   01,W
02BD2:  ADDLW  1E
02BD4:  MOVWF  FE9
02BD6:  MOVLW  00
02BD8:  ADDWFC 03,W
02BDA:  MOVWF  FEA
02BDC:  MOVF   FEF,F
02BDE:  BNZ   2CA2
02BE0:  CLRF   1B
02BE2:  BTFSC  FF2.7
02BE4:  BSF    1B.7
02BE6:  BCF    FF2.7
....................                { 
....................                   ltlevel[((struct light)mydevices.myoutputs[x].device).internal_order]=((struct light)mydevices.myoutputs[x].device).dim_value.value; 
02BE8:  CLRF   x6D
02BEA:  MOVFF  41D,46C
02BEE:  CLRF   x6F
02BF0:  MOVLW  23
02BF2:  MOVWF  x6E
02BF4:  MOVLB  0
02BF6:  CALL   030E
02BFA:  BTFSC  1B.7
02BFC:  BSF    FF2.7
02BFE:  MOVF   01,W
02C00:  ADDLW  B6
02C02:  MOVLB  4
02C04:  MOVWF  x1F
02C06:  MOVLW  00
02C08:  ADDWFC 02,W
02C0A:  MOVWF  x20
02C0C:  MOVLW  01
02C0E:  ADDWF  x1F,W
02C10:  MOVWF  01
02C12:  MOVLW  00
02C14:  ADDWFC x20,W
02C16:  MOVWF  03
02C18:  MOVF   01,W
02C1A:  ADDLW  3A
02C1C:  MOVWF  01
02C1E:  MOVLW  01
02C20:  ADDWFC 03,F
02C22:  MOVF   01,W
02C24:  ADDLW  20
02C26:  MOVWF  FE9
02C28:  MOVLW  00
02C2A:  ADDWFC 03,W
02C2C:  MOVWF  FEA
02C2E:  CLRF   03
02C30:  MOVF   FEF,W
02C32:  ADDLW  55
02C34:  MOVWF  01
02C36:  MOVLW  03
02C38:  ADDWFC 03,F
02C3A:  MOVFF  01,421
02C3E:  MOVFF  03,422
02C42:  CLRF   1B
02C44:  BTFSC  FF2.7
02C46:  BSF    1B.7
02C48:  BCF    FF2.7
02C4A:  CLRF   x6D
02C4C:  MOVFF  41D,46C
02C50:  CLRF   x6F
02C52:  MOVLW  23
02C54:  MOVWF  x6E
02C56:  MOVLB  0
02C58:  CALL   030E
02C5C:  BTFSC  1B.7
02C5E:  BSF    FF2.7
02C60:  MOVF   01,W
02C62:  ADDLW  B6
02C64:  MOVLB  4
02C66:  MOVWF  x23
02C68:  MOVLW  00
02C6A:  ADDWFC 02,W
02C6C:  MOVWF  x24
02C6E:  MOVLW  01
02C70:  ADDWF  x23,W
02C72:  MOVWF  01
02C74:  MOVLW  00
02C76:  ADDWFC x24,W
02C78:  MOVWF  03
02C7A:  MOVF   01,W
02C7C:  ADDLW  3A
02C7E:  MOVWF  01
02C80:  MOVLW  01
02C82:  ADDWFC 03,F
02C84:  MOVF   01,W
02C86:  ADDLW  1C
02C88:  MOVWF  FE9
02C8A:  MOVLW  00
02C8C:  ADDWFC 03,W
02C8E:  MOVWF  FEA
02C90:  MOVFF  FEF,425
02C94:  MOVFF  422,FEA
02C98:  MOVFF  421,FE9
02C9C:  MOVFF  425,FEF
....................                   update_dimmers=true; 
02CA0:  BSF    x1E.0
02CA2:  CLRF   1B
02CA4:  BTFSC  FF2.7
02CA6:  BSF    1B.7
02CA8:  BCF    FF2.7
....................                } 
....................                ((struct light)mydevices.myoutputs[x].device).dim_value.needs_update=false; 
02CAA:  CLRF   x6D
02CAC:  MOVFF  41D,46C
02CB0:  CLRF   x6F
02CB2:  MOVLW  23
02CB4:  MOVWF  x6E
02CB6:  MOVLB  0
02CB8:  CALL   030E
02CBC:  BTFSC  1B.7
02CBE:  BSF    FF2.7
02CC0:  MOVF   01,W
02CC2:  ADDLW  B6
02CC4:  MOVLB  4
02CC6:  MOVWF  x1F
02CC8:  MOVLW  00
02CCA:  ADDWFC 02,W
02CCC:  MOVWF  x20
02CCE:  MOVLW  01
02CD0:  ADDWF  x1F,W
02CD2:  MOVWF  01
02CD4:  MOVLW  00
02CD6:  ADDWFC x20,W
02CD8:  MOVWF  03
02CDA:  MOVF   01,W
02CDC:  ADDLW  3A
02CDE:  MOVWF  01
02CE0:  MOVLW  01
02CE2:  ADDWFC 03,F
02CE4:  MOVF   01,W
02CE6:  ADDLW  1D
02CE8:  MOVWF  FE9
02CEA:  MOVLW  00
02CEC:  ADDWFC 03,W
02CEE:  MOVWF  FEA
02CF0:  BCF    FEF.0
02CF2:  CLRF   1B
02CF4:  BTFSC  FF2.7
02CF6:  BSF    1B.7
02CF8:  BCF    FF2.7
....................             } 
....................              
....................             if(((struct light)mydevices.myoutputs[x].device).off.needs_update) 
02CFA:  CLRF   x6D
02CFC:  MOVFF  41D,46C
02D00:  CLRF   x6F
02D02:  MOVLW  23
02D04:  MOVWF  x6E
02D06:  MOVLB  0
02D08:  CALL   030E
02D0C:  BTFSC  1B.7
02D0E:  BSF    FF2.7
02D10:  MOVF   01,W
02D12:  ADDLW  B6
02D14:  MOVLB  4
02D16:  MOVWF  x1F
02D18:  MOVLW  00
02D1A:  ADDWFC 02,W
02D1C:  MOVWF  x20
02D1E:  MOVLW  01
02D20:  ADDWF  x1F,W
02D22:  MOVWF  01
02D24:  MOVLW  00
02D26:  ADDWFC x20,W
02D28:  MOVWF  03
02D2A:  MOVF   01,W
02D2C:  ADDLW  3A
02D2E:  MOVWF  01
02D30:  MOVLW  01
02D32:  ADDWFC 03,F
02D34:  MOVF   01,W
02D36:  ADDLW  13
02D38:  MOVWF  FE9
02D3A:  MOVLW  00
02D3C:  ADDWFC 03,W
02D3E:  MOVWF  FEA
02D40:  BTFSS  FEF.0
02D42:  BRA    2E98
02D44:  CLRF   1B
02D46:  BTFSC  FF2.7
02D48:  BSF    1B.7
02D4A:  BCF    FF2.7
....................             { 
....................                if(((struct light)mydevices.myoutputs[x].device).off.value) 
02D4C:  CLRF   x6D
02D4E:  MOVFF  41D,46C
02D52:  CLRF   x6F
02D54:  MOVLW  23
02D56:  MOVWF  x6E
02D58:  MOVLB  0
02D5A:  CALL   030E
02D5E:  BTFSC  1B.7
02D60:  BSF    FF2.7
02D62:  MOVF   01,W
02D64:  ADDLW  B6
02D66:  MOVLB  4
02D68:  MOVWF  x1F
02D6A:  MOVLW  00
02D6C:  ADDWFC 02,W
02D6E:  MOVWF  x20
02D70:  MOVLW  01
02D72:  ADDWF  x1F,W
02D74:  MOVWF  01
02D76:  MOVLW  00
02D78:  ADDWFC x20,W
02D7A:  MOVWF  03
02D7C:  MOVF   01,W
02D7E:  ADDLW  3A
02D80:  MOVWF  01
02D82:  MOVLW  01
02D84:  ADDWFC 03,F
02D86:  MOVF   01,W
02D88:  ADDLW  12
02D8A:  MOVWF  FE9
02D8C:  MOVLW  00
02D8E:  ADDWFC 03,W
02D90:  MOVWF  FEA
02D92:  MOVF   FEF,F
02D94:  BZ    2E48
02D96:  CLRF   1B
02D98:  BTFSC  FF2.7
02D9A:  BSF    1B.7
02D9C:  BCF    FF2.7
....................                { 
....................                   ((struct light)mydevices.myoutputs[x].device).out_state=_off; 
02D9E:  CLRF   x6D
02DA0:  MOVFF  41D,46C
02DA4:  CLRF   x6F
02DA6:  MOVLW  23
02DA8:  MOVWF  x6E
02DAA:  MOVLB  0
02DAC:  CALL   030E
02DB0:  BTFSC  1B.7
02DB2:  BSF    FF2.7
02DB4:  MOVF   01,W
02DB6:  ADDLW  B6
02DB8:  MOVLB  4
02DBA:  MOVWF  x1F
02DBC:  MOVLW  00
02DBE:  ADDWFC 02,W
02DC0:  MOVWF  x20
02DC2:  MOVLW  01
02DC4:  ADDWF  x1F,W
02DC6:  MOVWF  01
02DC8:  MOVLW  00
02DCA:  ADDWFC x20,W
02DCC:  MOVWF  03
02DCE:  MOVF   01,W
02DD0:  ADDLW  3A
02DD2:  MOVWF  01
02DD4:  MOVLW  01
02DD6:  ADDWFC 03,F
02DD8:  MOVF   01,W
02DDA:  ADDLW  1E
02DDC:  MOVWF  FE9
02DDE:  MOVLW  00
02DE0:  ADDWFC 03,W
02DE2:  MOVWF  FEA
02DE4:  MOVLW  01
02DE6:  MOVWF  FEF
02DE8:  CLRF   1B
02DEA:  BTFSC  FF2.7
02DEC:  BSF    1B.7
02DEE:  BCF    FF2.7
....................                   ltlevel[((struct light)mydevices.myoutputs[x].device).internal_order]=0; 
02DF0:  CLRF   x6D
02DF2:  MOVFF  41D,46C
02DF6:  CLRF   x6F
02DF8:  MOVLW  23
02DFA:  MOVWF  x6E
02DFC:  MOVLB  0
02DFE:  CALL   030E
02E02:  BTFSC  1B.7
02E04:  BSF    FF2.7
02E06:  MOVF   01,W
02E08:  ADDLW  B6
02E0A:  MOVLB  4
02E0C:  MOVWF  x1F
02E0E:  MOVLW  00
02E10:  ADDWFC 02,W
02E12:  MOVWF  x20
02E14:  MOVLW  01
02E16:  ADDWF  x1F,W
02E18:  MOVWF  01
02E1A:  MOVLW  00
02E1C:  ADDWFC x20,W
02E1E:  MOVWF  03
02E20:  MOVF   01,W
02E22:  ADDLW  3A
02E24:  MOVWF  01
02E26:  MOVLW  01
02E28:  ADDWFC 03,F
02E2A:  MOVF   01,W
02E2C:  ADDLW  20
02E2E:  MOVWF  FE9
02E30:  MOVLW  00
02E32:  ADDWFC 03,W
02E34:  MOVWF  FEA
02E36:  CLRF   03
02E38:  MOVF   FEF,W
02E3A:  ADDLW  55
02E3C:  MOVWF  FE9
02E3E:  MOVLW  03
02E40:  ADDWFC 03,W
02E42:  MOVWF  FEA
02E44:  CLRF   FEF
....................                   update_dimmers=true; 
02E46:  BSF    x1E.0
02E48:  CLRF   1B
02E4A:  BTFSC  FF2.7
02E4C:  BSF    1B.7
02E4E:  BCF    FF2.7
....................                } 
....................                ((struct light)mydevices.myoutputs[x].device).off.needs_update=false; 
02E50:  CLRF   x6D
02E52:  MOVFF  41D,46C
02E56:  CLRF   x6F
02E58:  MOVLW  23
02E5A:  MOVWF  x6E
02E5C:  MOVLB  0
02E5E:  CALL   030E
02E62:  BTFSC  1B.7
02E64:  BSF    FF2.7
02E66:  MOVF   01,W
02E68:  ADDLW  B6
02E6A:  MOVLB  4
02E6C:  MOVWF  x1F
02E6E:  MOVLW  00
02E70:  ADDWFC 02,W
02E72:  MOVWF  x20
02E74:  MOVLW  01
02E76:  ADDWF  x1F,W
02E78:  MOVWF  01
02E7A:  MOVLW  00
02E7C:  ADDWFC x20,W
02E7E:  MOVWF  03
02E80:  MOVF   01,W
02E82:  ADDLW  3A
02E84:  MOVWF  01
02E86:  MOVLW  01
02E88:  ADDWFC 03,F
02E8A:  MOVF   01,W
02E8C:  ADDLW  13
02E8E:  MOVWF  FE9
02E90:  MOVLW  00
02E92:  ADDWFC 03,W
02E94:  MOVWF  FEA
02E96:  BCF    FEF.0
02E98:  CLRF   1B
02E9A:  BTFSC  FF2.7
02E9C:  BSF    1B.7
02E9E:  BCF    FF2.7
....................             } 
....................              
....................             if(((struct light)mydevices.myoutputs[x].device).on.needs_update) 
02EA0:  CLRF   x6D
02EA2:  MOVFF  41D,46C
02EA6:  CLRF   x6F
02EA8:  MOVLW  23
02EAA:  MOVWF  x6E
02EAC:  MOVLB  0
02EAE:  CALL   030E
02EB2:  BTFSC  1B.7
02EB4:  BSF    FF2.7
02EB6:  MOVF   01,W
02EB8:  ADDLW  B6
02EBA:  MOVLB  4
02EBC:  MOVWF  x1F
02EBE:  MOVLW  00
02EC0:  ADDWFC 02,W
02EC2:  MOVWF  x20
02EC4:  MOVLW  01
02EC6:  ADDWF  x1F,W
02EC8:  MOVWF  01
02ECA:  MOVLW  00
02ECC:  ADDWFC x20,W
02ECE:  MOVWF  03
02ED0:  MOVF   01,W
02ED2:  ADDLW  3A
02ED4:  MOVWF  01
02ED6:  MOVLW  01
02ED8:  ADDWFC 03,F
02EDA:  MOVF   01,W
02EDC:  ADDLW  09
02EDE:  MOVWF  FE9
02EE0:  MOVLW  00
02EE2:  ADDWFC 03,W
02EE4:  MOVWF  FEA
02EE6:  BTFSS  FEF.0
02EE8:  BRA    30A0
02EEA:  CLRF   1B
02EEC:  BTFSC  FF2.7
02EEE:  BSF    1B.7
02EF0:  BCF    FF2.7
....................             { 
....................                if(((struct light)mydevices.myoutputs[x].device).on.value) 
02EF2:  CLRF   x6D
02EF4:  MOVFF  41D,46C
02EF8:  CLRF   x6F
02EFA:  MOVLW  23
02EFC:  MOVWF  x6E
02EFE:  MOVLB  0
02F00:  CALL   030E
02F04:  BTFSC  1B.7
02F06:  BSF    FF2.7
02F08:  MOVF   01,W
02F0A:  ADDLW  B6
02F0C:  MOVLB  4
02F0E:  MOVWF  x1F
02F10:  MOVLW  00
02F12:  ADDWFC 02,W
02F14:  MOVWF  x20
02F16:  MOVLW  01
02F18:  ADDWF  x1F,W
02F1A:  MOVWF  01
02F1C:  MOVLW  00
02F1E:  ADDWFC x20,W
02F20:  MOVWF  03
02F22:  MOVF   01,W
02F24:  ADDLW  3A
02F26:  MOVWF  01
02F28:  MOVLW  01
02F2A:  ADDWFC 03,F
02F2C:  MOVF   01,W
02F2E:  ADDLW  08
02F30:  MOVWF  FE9
02F32:  MOVLW  00
02F34:  ADDWFC 03,W
02F36:  MOVWF  FEA
02F38:  MOVF   FEF,F
02F3A:  BTFSC  FD8.2
02F3C:  BRA    3050
02F3E:  CLRF   1B
02F40:  BTFSC  FF2.7
02F42:  BSF    1B.7
02F44:  BCF    FF2.7
....................                { 
....................                   ((struct light)mydevices.myoutputs[x].device).out_state=_on; 
02F46:  CLRF   x6D
02F48:  MOVFF  41D,46C
02F4C:  CLRF   x6F
02F4E:  MOVLW  23
02F50:  MOVWF  x6E
02F52:  MOVLB  0
02F54:  CALL   030E
02F58:  BTFSC  1B.7
02F5A:  BSF    FF2.7
02F5C:  MOVF   01,W
02F5E:  ADDLW  B6
02F60:  MOVLB  4
02F62:  MOVWF  x1F
02F64:  MOVLW  00
02F66:  ADDWFC 02,W
02F68:  MOVWF  x20
02F6A:  MOVLW  01
02F6C:  ADDWF  x1F,W
02F6E:  MOVWF  01
02F70:  MOVLW  00
02F72:  ADDWFC x20,W
02F74:  MOVWF  03
02F76:  MOVF   01,W
02F78:  ADDLW  3A
02F7A:  MOVWF  01
02F7C:  MOVLW  01
02F7E:  ADDWFC 03,F
02F80:  MOVF   01,W
02F82:  ADDLW  1E
02F84:  MOVWF  FE9
02F86:  MOVLW  00
02F88:  ADDWFC 03,W
02F8A:  MOVWF  FEA
02F8C:  CLRF   FEF
02F8E:  CLRF   1B
02F90:  BTFSC  FF2.7
02F92:  BSF    1B.7
02F94:  BCF    FF2.7
....................                   ltlevel[((struct light)mydevices.myoutputs[x].device).internal_order]=((struct light)mydevices.myoutputs[x].device).dim_value.value; 
02F96:  CLRF   x6D
02F98:  MOVFF  41D,46C
02F9C:  CLRF   x6F
02F9E:  MOVLW  23
02FA0:  MOVWF  x6E
02FA2:  MOVLB  0
02FA4:  CALL   030E
02FA8:  BTFSC  1B.7
02FAA:  BSF    FF2.7
02FAC:  MOVF   01,W
02FAE:  ADDLW  B6
02FB0:  MOVLB  4
02FB2:  MOVWF  x1F
02FB4:  MOVLW  00
02FB6:  ADDWFC 02,W
02FB8:  MOVWF  x20
02FBA:  MOVLW  01
02FBC:  ADDWF  x1F,W
02FBE:  MOVWF  01
02FC0:  MOVLW  00
02FC2:  ADDWFC x20,W
02FC4:  MOVWF  03
02FC6:  MOVF   01,W
02FC8:  ADDLW  3A
02FCA:  MOVWF  01
02FCC:  MOVLW  01
02FCE:  ADDWFC 03,F
02FD0:  MOVF   01,W
02FD2:  ADDLW  20
02FD4:  MOVWF  FE9
02FD6:  MOVLW  00
02FD8:  ADDWFC 03,W
02FDA:  MOVWF  FEA
02FDC:  CLRF   03
02FDE:  MOVF   FEF,W
02FE0:  ADDLW  55
02FE2:  MOVWF  01
02FE4:  MOVLW  03
02FE6:  ADDWFC 03,F
02FE8:  MOVFF  01,421
02FEC:  MOVFF  03,422
02FF0:  CLRF   1B
02FF2:  BTFSC  FF2.7
02FF4:  BSF    1B.7
02FF6:  BCF    FF2.7
02FF8:  CLRF   x6D
02FFA:  MOVFF  41D,46C
02FFE:  CLRF   x6F
03000:  MOVLW  23
03002:  MOVWF  x6E
03004:  MOVLB  0
03006:  CALL   030E
0300A:  BTFSC  1B.7
0300C:  BSF    FF2.7
0300E:  MOVF   01,W
03010:  ADDLW  B6
03012:  MOVLB  4
03014:  MOVWF  x23
03016:  MOVLW  00
03018:  ADDWFC 02,W
0301A:  MOVWF  x24
0301C:  MOVLW  01
0301E:  ADDWF  x23,W
03020:  MOVWF  01
03022:  MOVLW  00
03024:  ADDWFC x24,W
03026:  MOVWF  03
03028:  MOVF   01,W
0302A:  ADDLW  3A
0302C:  MOVWF  01
0302E:  MOVLW  01
03030:  ADDWFC 03,F
03032:  MOVF   01,W
03034:  ADDLW  1C
03036:  MOVWF  FE9
03038:  MOVLW  00
0303A:  ADDWFC 03,W
0303C:  MOVWF  FEA
0303E:  MOVFF  FEF,425
03042:  MOVFF  422,FEA
03046:  MOVFF  421,FE9
0304A:  MOVFF  425,FEF
....................                   update_dimmers=true; 
0304E:  BSF    x1E.0
03050:  CLRF   1B
03052:  BTFSC  FF2.7
03054:  BSF    1B.7
03056:  BCF    FF2.7
....................                } 
....................                ((struct light)mydevices.myoutputs[x].device).on.needs_update=false; 
03058:  CLRF   x6D
0305A:  MOVFF  41D,46C
0305E:  CLRF   x6F
03060:  MOVLW  23
03062:  MOVWF  x6E
03064:  MOVLB  0
03066:  CALL   030E
0306A:  BTFSC  1B.7
0306C:  BSF    FF2.7
0306E:  MOVF   01,W
03070:  ADDLW  B6
03072:  MOVLB  4
03074:  MOVWF  x1F
03076:  MOVLW  00
03078:  ADDWFC 02,W
0307A:  MOVWF  x20
0307C:  MOVLW  01
0307E:  ADDWF  x1F,W
03080:  MOVWF  01
03082:  MOVLW  00
03084:  ADDWFC x20,W
03086:  MOVWF  03
03088:  MOVF   01,W
0308A:  ADDLW  3A
0308C:  MOVWF  01
0308E:  MOVLW  01
03090:  ADDWFC 03,F
03092:  MOVF   01,W
03094:  ADDLW  09
03096:  MOVWF  FE9
03098:  MOVLW  00
0309A:  ADDWFC 03,W
0309C:  MOVWF  FEA
0309E:  BCF    FEF.0
....................             } 
....................          break; 
030A0:  MOVLB  0
030A2:  BRA    30A4
....................       } 
....................    } 
030A4:  MOVLB  4
030A6:  INCF   x1D,F
030A8:  BRA    2AF2
....................    if(update_dimmers) 
030AA:  BTFSS  x1E.0
030AC:  BRA    30B6
....................       org(); 
030AE:  MOVLB  0
030B0:  CALL   230C
030B4:  MOVLB  4
.................... } 
030B6:  MOVLB  0
030B8:  RETLW  00
....................  
.................... void dimmer_test() 
.................... { 
....................    mydevices.numberOfoutputs=1; 
*
02294:  MOVLW  01
02296:  MOVLB  1
02298:  MOVWF  x3B
....................    unsigned int dim_adr[8]={1,21,31,255,255,255,255,255}; 
0229A:  MOVLB  4
0229C:  MOVWF  x1D
0229E:  MOVLW  15
022A0:  MOVWF  x1E
022A2:  MOVLW  1F
022A4:  MOVWF  x1F
022A6:  MOVLW  FF
022A8:  MOVWF  x20
022AA:  MOVWF  x21
022AC:  MOVWF  x22
022AE:  MOVWF  x23
022B0:  MOVWF  x24
....................    unsigned int off_adr[8]={3,51,61,255,255,255,255,255}; 
022B2:  MOVLW  03
022B4:  MOVWF  x25
022B6:  MOVLW  33
022B8:  MOVWF  x26
022BA:  MOVLW  3D
022BC:  MOVWF  x27
022BE:  MOVLW  FF
022C0:  MOVWF  x28
022C2:  MOVWF  x29
022C4:  MOVWF  x2A
022C6:  MOVWF  x2B
022C8:  MOVWF  x2C
....................    unsigned int on_adr[8]={2,81,91,255,255,255,255,255}; 
022CA:  MOVLW  02
022CC:  MOVWF  x2D
022CE:  MOVLW  51
022D0:  MOVWF  x2E
022D2:  MOVLW  5B
022D4:  MOVWF  x2F
022D6:  MOVLW  FF
022D8:  MOVWF  x30
022DA:  MOVWF  x31
022DC:  MOVWF  x32
022DE:  MOVWF  x33
022E0:  MOVWF  x34
....................    dimmer_out_init(dim_adr,on_adr,off_adr,&mydevices.myoutputs[0],0); 
022E2:  MOVLW  04
022E4:  MOVWF  x36
022E6:  MOVLW  1D
022E8:  MOVWF  x35
022EA:  MOVLW  04
022EC:  MOVWF  x38
022EE:  MOVLW  2D
022F0:  MOVWF  x37
022F2:  MOVLW  04
022F4:  MOVWF  x3A
022F6:  MOVLW  25
022F8:  MOVWF  x39
022FA:  MOVLW  01
022FC:  MOVWF  x3C
022FE:  MOVLW  F0
02300:  MOVWF  x3B
02302:  CLRF   x3D
02304:  MOVLB  0
02306:  BRA    2042
.................... } 
02308:  GOTO   3D02 (RETURN)
....................  
....................  
.................... #include "datapoints.c" 
.................... int1 array_contains(struct data_point_in* array,int & value) 
.................... { 
....................    int x; 
....................    for(x=0;x<8;++x) 
*
03196:  CLRF   x2F
03198:  MOVF   x2F,W
0319A:  SUBLW  07
0319C:  BNC   31C4
*
032D0:  CLRF   x2F
032D2:  MOVF   x2F,W
032D4:  SUBLW  07
032D6:  BNC   32FE
*
0340E:  CLRF   x2F
03410:  MOVF   x2F,W
03412:  SUBLW  07
03414:  BNC   343C
....................    { 
....................       if(((struct data_point_in*) array)->adress[x]==value) return true; 
*
0319E:  CLRF   03
031A0:  MOVF   x2F,W
031A2:  ADDWF  x2D,W
031A4:  MOVWF  FE9
031A6:  MOVF   x2E,W
031A8:  ADDWFC 03,W
031AA:  MOVWF  FEA
031AC:  MOVF   x24,W
031AE:  SUBWF  FEF,W
031B0:  BNZ   31B8
031B2:  MOVLW  01
031B4:  MOVWF  01
031B6:  BRA    31C8
*
032D8:  CLRF   03
032DA:  MOVF   x2F,W
032DC:  ADDWF  x2D,W
032DE:  MOVWF  FE9
032E0:  MOVF   x2E,W
032E2:  ADDWFC 03,W
032E4:  MOVWF  FEA
032E6:  MOVF   x24,W
032E8:  SUBWF  FEF,W
032EA:  BNZ   32F2
032EC:  MOVLW  01
032EE:  MOVWF  01
032F0:  BRA    3302
*
03416:  CLRF   03
03418:  MOVF   x2F,W
0341A:  ADDWF  x2D,W
0341C:  MOVWF  FE9
0341E:  MOVF   x2E,W
03420:  ADDWFC 03,W
03422:  MOVWF  FEA
03424:  MOVF   x24,W
03426:  SUBWF  FEF,W
03428:  BNZ   3430
0342A:  MOVLW  01
0342C:  MOVWF  01
0342E:  BRA    3440
....................     //  printf("array[%u]=%u\n\r",x,&(array)); 
....................       ++array; 
*
031B8:  MOVLW  0A
031BA:  ADDWF  x2D,F
031BC:  BTFSC  FD8.0
031BE:  INCF   x2E,F
*
032F2:  MOVLW  0A
032F4:  ADDWF  x2D,F
032F6:  BTFSC  FD8.0
032F8:  INCF   x2E,F
*
03430:  MOVLW  0A
03432:  ADDWF  x2D,F
03434:  BTFSC  FD8.0
03436:  INCF   x2E,F
....................    } 
*
031C0:  INCF   x2F,F
031C2:  BRA    3198
*
032FA:  INCF   x2F,F
032FC:  BRA    32D2
*
03438:  INCF   x2F,F
0343A:  BRA    3410
....................    return false; 
*
031C4:  MOVLW  00
031C6:  MOVWF  01
*
032FE:  MOVLW  00
03300:  MOVWF  01
*
0343C:  MOVLW  00
0343E:  MOVWF  01
.................... } 
....................  
.................... void process_inpoints(unsigned int &datapoint, unsigned int &value)//processa os datapoints de entrada que estao associados a saidas reais 
.................... { 
....................    int x; 
....................    for(x=0;x<mydevices.numberOfOutputs;++x) 
*
030D8:  MOVLB  4
030DA:  CLRF   x26
030DC:  MOVLB  1
030DE:  MOVF   x3B,W
030E0:  MOVLB  4
030E2:  SUBWF  x26,W
030E4:  BTFSC  FD8.0
030E6:  BRA    34F8
030E8:  CLRF   1B
030EA:  BTFSC  FF2.7
030EC:  BSF    1B.7
030EE:  BCF    FF2.7
....................    { 
....................       switch (((struct outputs)mydevices.myoutputs[x]).type) { 
030F0:  CLRF   x6D
030F2:  MOVFF  426,46C
030F6:  CLRF   x6F
030F8:  MOVLW  23
030FA:  MOVWF  x6E
030FC:  MOVLB  0
030FE:  CALL   030E
03102:  BTFSC  1B.7
03104:  BSF    FF2.7
03106:  MOVFF  02,03
0310A:  MOVF   01,W
0310C:  ADDLW  F0
0310E:  MOVWF  01
03110:  MOVLW  01
03112:  ADDWFC 03,F
03114:  MOVFF  01,FE9
03118:  MOVFF  03,FEA
0311C:  MOVF   FEF,W
0311E:  XORLW  01
03120:  BZ    3130
03122:  XORLW  01
03124:  BTFSC  FD8.2
03126:  BRA    34E8
03128:  XORLW  02
0312A:  BTFSC  FD8.2
0312C:  BRA    34EC
0312E:  BRA    34F0
....................  
....................     case dimmer: 
03130:  CLRF   1B
03132:  BTFSC  FF2.7
03134:  BSF    1B.7
03136:  BCF    FF2.7
....................            if (array_contains(((struct light)mydevices.myoutputs[x].device).dim_value,datapoint)) 
03138:  MOVLB  4
0313A:  CLRF   x6D
0313C:  MOVFF  426,46C
03140:  CLRF   x6F
03142:  MOVLW  23
03144:  MOVWF  x6E
03146:  MOVLB  0
03148:  CALL   030E
0314C:  BTFSC  1B.7
0314E:  BSF    FF2.7
03150:  MOVFF  02,03
03154:  MOVF   01,W
03156:  ADDLW  B6
03158:  MOVLB  4
0315A:  MOVWF  x27
0315C:  MOVLW  00
0315E:  ADDWFC 03,W
03160:  MOVWF  x28
03162:  MOVLW  01
03164:  ADDWF  x27,W
03166:  MOVWF  01
03168:  MOVLW  00
0316A:  ADDWFC x28,W
0316C:  MOVWF  03
0316E:  MOVF   01,W
03170:  ADDLW  3A
03172:  MOVWF  01
03174:  MOVLW  01
03176:  ADDWFC 03,F
03178:  MOVF   01,W
0317A:  ADDLW  14
0317C:  MOVWF  FE9
0317E:  MOVLW  00
03180:  ADDWFC 03,W
03182:  MOVWF  FEA
03184:  MOVFF  FEC,42A
03188:  MOVF   FED,F
0318A:  MOVFF  FEF,429
0318E:  MOVFF  42A,42E
03192:  MOVFF  429,42D
*
031C8:  MOVF   01,F
031CA:  BZ    3270
031CC:  CLRF   1B
031CE:  BTFSC  FF2.7
031D0:  BSF    1B.7
031D2:  BCF    FF2.7
....................            { 
....................                ((struct light)mydevices.myoutputs[x].device).dim_value.value=value; 
031D4:  CLRF   x6D
031D6:  MOVFF  426,46C
031DA:  CLRF   x6F
031DC:  MOVLW  23
031DE:  MOVWF  x6E
031E0:  MOVLB  0
031E2:  CALL   030E
031E6:  BTFSC  1B.7
031E8:  BSF    FF2.7
031EA:  MOVF   01,W
031EC:  ADDLW  B6
031EE:  MOVLB  4
031F0:  MOVWF  x27
031F2:  MOVLW  00
031F4:  ADDWFC 02,W
031F6:  MOVWF  x28
031F8:  MOVLW  01
031FA:  ADDWF  x27,W
031FC:  MOVWF  01
031FE:  MOVLW  00
03200:  ADDWFC x28,W
03202:  MOVWF  03
03204:  MOVF   01,W
03206:  ADDLW  3A
03208:  MOVWF  01
0320A:  MOVLW  01
0320C:  ADDWFC 03,F
0320E:  MOVF   01,W
03210:  ADDLW  1C
03212:  MOVWF  FE9
03214:  MOVLW  00
03216:  ADDWFC 03,W
03218:  MOVWF  FEA
0321A:  MOVFF  425,FEF
0321E:  CLRF   1B
03220:  BTFSC  FF2.7
03222:  BSF    1B.7
03224:  BCF    FF2.7
....................                ((struct light)mydevices.myoutputs[x].device).dim_value.needs_update=true; 
03226:  CLRF   x6D
03228:  MOVFF  426,46C
0322C:  CLRF   x6F
0322E:  MOVLW  23
03230:  MOVWF  x6E
03232:  MOVLB  0
03234:  CALL   030E
03238:  BTFSC  1B.7
0323A:  BSF    FF2.7
0323C:  MOVF   01,W
0323E:  ADDLW  B6
03240:  MOVLB  4
03242:  MOVWF  x27
03244:  MOVLW  00
03246:  ADDWFC 02,W
03248:  MOVWF  x28
0324A:  MOVLW  01
0324C:  ADDWF  x27,W
0324E:  MOVWF  01
03250:  MOVLW  00
03252:  ADDWFC x28,W
03254:  MOVWF  03
03256:  MOVF   01,W
03258:  ADDLW  3A
0325A:  MOVWF  01
0325C:  MOVLW  01
0325E:  ADDWFC 03,F
03260:  MOVF   01,W
03262:  ADDLW  1D
03264:  MOVWF  FE9
03266:  MOVLW  00
03268:  ADDWFC 03,W
0326A:  MOVWF  FEA
0326C:  BSF    FEF.0
....................            } 
....................            else if (array_contains(((struct light)mydevices.myoutputs[x].device).on,datapoint)) 
0326E:  BRA    34E6
03270:  CLRF   1B
03272:  BTFSC  FF2.7
03274:  BSF    1B.7
03276:  BCF    FF2.7
03278:  CLRF   x6D
0327A:  MOVFF  426,46C
0327E:  CLRF   x6F
03280:  MOVLW  23
03282:  MOVWF  x6E
03284:  MOVLB  0
03286:  CALL   030E
0328A:  BTFSC  1B.7
0328C:  BSF    FF2.7
0328E:  MOVFF  02,03
03292:  MOVF   01,W
03294:  ADDLW  B6
03296:  MOVLB  4
03298:  MOVWF  x27
0329A:  MOVLW  00
0329C:  ADDWFC 03,W
0329E:  MOVWF  x28
032A0:  MOVLW  01
032A2:  ADDWF  x27,W
032A4:  MOVWF  01
032A6:  MOVLW  00
032A8:  ADDWFC x28,W
032AA:  MOVWF  03
032AC:  MOVF   01,W
032AE:  ADDLW  3A
032B0:  MOVWF  01
032B2:  MOVLW  01
032B4:  ADDWFC 03,F
032B6:  MOVF   01,W
032B8:  MOVWF  FE9
032BA:  MOVF   03,W
032BC:  MOVWF  FEA
032BE:  MOVFF  FEC,42A
032C2:  MOVF   FED,F
032C4:  MOVFF  FEF,429
032C8:  MOVFF  42A,42E
032CC:  MOVFF  429,42D
*
03302:  MOVF   01,F
03304:  BZ    33AA
03306:  CLRF   1B
03308:  BTFSC  FF2.7
0330A:  BSF    1B.7
0330C:  BCF    FF2.7
....................            { 
....................                ((struct light)mydevices.myoutputs[x].device).on.value=value; 
0330E:  CLRF   x6D
03310:  MOVFF  426,46C
03314:  CLRF   x6F
03316:  MOVLW  23
03318:  MOVWF  x6E
0331A:  MOVLB  0
0331C:  CALL   030E
03320:  BTFSC  1B.7
03322:  BSF    FF2.7
03324:  MOVF   01,W
03326:  ADDLW  B6
03328:  MOVLB  4
0332A:  MOVWF  x27
0332C:  MOVLW  00
0332E:  ADDWFC 02,W
03330:  MOVWF  x28
03332:  MOVLW  01
03334:  ADDWF  x27,W
03336:  MOVWF  01
03338:  MOVLW  00
0333A:  ADDWFC x28,W
0333C:  MOVWF  03
0333E:  MOVF   01,W
03340:  ADDLW  3A
03342:  MOVWF  01
03344:  MOVLW  01
03346:  ADDWFC 03,F
03348:  MOVF   01,W
0334A:  ADDLW  08
0334C:  MOVWF  FE9
0334E:  MOVLW  00
03350:  ADDWFC 03,W
03352:  MOVWF  FEA
03354:  MOVFF  425,FEF
03358:  CLRF   1B
0335A:  BTFSC  FF2.7
0335C:  BSF    1B.7
0335E:  BCF    FF2.7
....................                ((struct light)mydevices.myoutputs[x].device).on.needs_update=true; 
03360:  CLRF   x6D
03362:  MOVFF  426,46C
03366:  CLRF   x6F
03368:  MOVLW  23
0336A:  MOVWF  x6E
0336C:  MOVLB  0
0336E:  CALL   030E
03372:  BTFSC  1B.7
03374:  BSF    FF2.7
03376:  MOVF   01,W
03378:  ADDLW  B6
0337A:  MOVLB  4
0337C:  MOVWF  x27
0337E:  MOVLW  00
03380:  ADDWFC 02,W
03382:  MOVWF  x28
03384:  MOVLW  01
03386:  ADDWF  x27,W
03388:  MOVWF  01
0338A:  MOVLW  00
0338C:  ADDWFC x28,W
0338E:  MOVWF  03
03390:  MOVF   01,W
03392:  ADDLW  3A
03394:  MOVWF  01
03396:  MOVLW  01
03398:  ADDWFC 03,F
0339A:  MOVF   01,W
0339C:  ADDLW  09
0339E:  MOVWF  FE9
033A0:  MOVLW  00
033A2:  ADDWFC 03,W
033A4:  MOVWF  FEA
033A6:  BSF    FEF.0
....................            } 
....................            else if (array_contains(((struct light)mydevices.myoutputs[x].device).off,datapoint)) 
033A8:  BRA    34E6
033AA:  CLRF   1B
033AC:  BTFSC  FF2.7
033AE:  BSF    1B.7
033B0:  BCF    FF2.7
033B2:  CLRF   x6D
033B4:  MOVFF  426,46C
033B8:  CLRF   x6F
033BA:  MOVLW  23
033BC:  MOVWF  x6E
033BE:  MOVLB  0
033C0:  CALL   030E
033C4:  BTFSC  1B.7
033C6:  BSF    FF2.7
033C8:  MOVFF  02,03
033CC:  MOVF   01,W
033CE:  ADDLW  B6
033D0:  MOVLB  4
033D2:  MOVWF  x27
033D4:  MOVLW  00
033D6:  ADDWFC 03,W
033D8:  MOVWF  x28
033DA:  MOVLW  01
033DC:  ADDWF  x27,W
033DE:  MOVWF  01
033E0:  MOVLW  00
033E2:  ADDWFC x28,W
033E4:  MOVWF  03
033E6:  MOVF   01,W
033E8:  ADDLW  3A
033EA:  MOVWF  01
033EC:  MOVLW  01
033EE:  ADDWFC 03,F
033F0:  MOVF   01,W
033F2:  ADDLW  0A
033F4:  MOVWF  FE9
033F6:  MOVLW  00
033F8:  ADDWFC 03,W
033FA:  MOVWF  FEA
033FC:  MOVFF  FEC,42A
03400:  MOVF   FED,F
03402:  MOVFF  FEF,429
03406:  MOVFF  42A,42E
0340A:  MOVFF  429,42D
*
03440:  MOVF   01,F
03442:  BZ    34E6
03444:  CLRF   1B
03446:  BTFSC  FF2.7
03448:  BSF    1B.7
0344A:  BCF    FF2.7
....................            { 
....................                ((struct light)mydevices.myoutputs[x].device).off.value=value; 
0344C:  CLRF   x6D
0344E:  MOVFF  426,46C
03452:  CLRF   x6F
03454:  MOVLW  23
03456:  MOVWF  x6E
03458:  MOVLB  0
0345A:  CALL   030E
0345E:  BTFSC  1B.7
03460:  BSF    FF2.7
03462:  MOVF   01,W
03464:  ADDLW  B6
03466:  MOVLB  4
03468:  MOVWF  x27
0346A:  MOVLW  00
0346C:  ADDWFC 02,W
0346E:  MOVWF  x28
03470:  MOVLW  01
03472:  ADDWF  x27,W
03474:  MOVWF  01
03476:  MOVLW  00
03478:  ADDWFC x28,W
0347A:  MOVWF  03
0347C:  MOVF   01,W
0347E:  ADDLW  3A
03480:  MOVWF  01
03482:  MOVLW  01
03484:  ADDWFC 03,F
03486:  MOVF   01,W
03488:  ADDLW  12
0348A:  MOVWF  FE9
0348C:  MOVLW  00
0348E:  ADDWFC 03,W
03490:  MOVWF  FEA
03492:  MOVFF  425,FEF
03496:  CLRF   1B
03498:  BTFSC  FF2.7
0349A:  BSF    1B.7
0349C:  BCF    FF2.7
....................                ((struct light)mydevices.myoutputs[x].device).off.needs_update=true; 
0349E:  CLRF   x6D
034A0:  MOVFF  426,46C
034A4:  CLRF   x6F
034A6:  MOVLW  23
034A8:  MOVWF  x6E
034AA:  MOVLB  0
034AC:  CALL   030E
034B0:  BTFSC  1B.7
034B2:  BSF    FF2.7
034B4:  MOVF   01,W
034B6:  ADDLW  B6
034B8:  MOVLB  4
034BA:  MOVWF  x27
034BC:  MOVLW  00
034BE:  ADDWFC 02,W
034C0:  MOVWF  x28
034C2:  MOVLW  01
034C4:  ADDWF  x27,W
034C6:  MOVWF  01
034C8:  MOVLW  00
034CA:  ADDWFC x28,W
034CC:  MOVWF  03
034CE:  MOVF   01,W
034D0:  ADDLW  3A
034D2:  MOVWF  01
034D4:  MOVLW  01
034D6:  ADDWFC 03,F
034D8:  MOVF   01,W
034DA:  ADDLW  13
034DC:  MOVWF  FE9
034DE:  MOVLW  00
034E0:  ADDWFC 03,W
034E2:  MOVWF  FEA
034E4:  BSF    FEF.0
....................            } 
....................            break; 
034E6:  BRA    34F4
....................  
....................     case _on_off: 
....................  
....................            break; 
034E8:  MOVLB  4
034EA:  BRA    34F4
....................     case shutter: 
....................  
....................            break; 
034EC:  MOVLB  4
034EE:  BRA    34F4
....................     default: 
....................  
....................             break; } 
034F0:  MOVLB  4
034F2:  BRA    34F4
....................  
....................    } 
034F4:  INCF   x26,F
034F6:  BRA    30DC
.................... } 
.................... void process_outpoint_answer(unsigned int adress,unsigned int value) 
.................... { 
....................    //   printf("update answer adress=%u value=%u\n\r",adress,value); 
....................       process_inpoints(adress,value); //internal processing 
....................       //TODO CAN Sending of values 
.................... } 
034F8:  MOVLB  0
034FA:  RETLW  00
....................  
.................... void process_outpoints() 
.................... { 
....................     int x; 
....................    for(x=0;x<mydevices.numberOfInputs;++x) 
034FC:  MOVLB  4
034FE:  CLRF   x1D
03500:  MOVLB  1
03502:  MOVF   x3A,W
03504:  MOVLB  4
03506:  SUBWF  x1D,W
03508:  BTFSC  FD8.0
0350A:  BRA    3A46
0350C:  CLRF   1B
0350E:  BTFSC  FF2.7
03510:  BSF    1B.7
03512:  BCF    FF2.7
....................    { // printf("type=%u\n\r",((struct inputs)mydevices.myinputs[x]).type); 
....................       switch (((struct inputs)mydevices.myinputs[x]).type) { 
03514:  CLRF   x6D
03516:  MOVFF  41D,46C
0351A:  CLRF   x6F
0351C:  MOVLW  12
0351E:  MOVWF  x6E
03520:  MOVLB  0
03522:  CALL   030E
03526:  BTFSC  1B.7
03528:  BSF    FF2.7
0352A:  MOVFF  02,03
0352E:  MOVF   01,W
03530:  ADDLW  3C
03532:  MOVWF  01
03534:  MOVLW  01
03536:  ADDWFC 03,F
03538:  MOVFF  01,FE9
0353C:  MOVFF  03,FEA
03540:  MOVF   FEF,W
03542:  BZ    354C
03544:  XORLW  03
03546:  BTFSC  FD8.2
03548:  BRA    3A3A
0354A:  BRA    3A3E
....................     case dimmer_switch: 
0354C:  CLRF   1B
0354E:  BTFSC  FF2.7
03550:  BSF    1B.7
03552:  BCF    FF2.7
....................              //  printf("dimmer_switch"); 
....................                if( ((struct dimmer_switch)mydevices.myinputs[x].device).dim_level.needs_update) 
03554:  MOVLB  4
03556:  CLRF   x6D
03558:  MOVFF  41D,46C
0355C:  CLRF   x6F
0355E:  MOVLW  12
03560:  MOVWF  x6E
03562:  MOVLB  0
03564:  CALL   030E
03568:  BTFSC  1B.7
0356A:  BSF    FF2.7
0356C:  MOVF   01,W
0356E:  ADDLW  02
03570:  MOVLB  4
03572:  MOVWF  x1E
03574:  MOVLW  00
03576:  ADDWFC 02,W
03578:  MOVWF  x1F
0357A:  MOVLW  01
0357C:  ADDWF  x1E,W
0357E:  MOVWF  01
03580:  MOVLW  00
03582:  ADDWFC x1F,W
03584:  MOVWF  03
03586:  MOVF   01,W
03588:  ADDLW  3A
0358A:  MOVWF  01
0358C:  MOVLW  01
0358E:  ADDWFC 03,F
03590:  MOVF   01,W
03592:  ADDLW  02
03594:  MOVWF  FE9
03596:  MOVLW  00
03598:  ADDWFC 03,W
0359A:  MOVWF  FEA
0359C:  BTFSS  FEF.0
0359E:  BRA    36EE
035A0:  CLRF   1B
035A2:  BTFSC  FF2.7
035A4:  BSF    1B.7
035A6:  BCF    FF2.7
....................                { 
....................                    process_outpoint_answer( ((struct dimmer_switch)mydevices.myinputs[x].device).dim_level.adress, ((struct dimmer_switch)mydevices.myinputs[x].device).dim_level.value); 
035A8:  CLRF   x6D
035AA:  MOVFF  41D,46C
035AE:  CLRF   x6F
035B0:  MOVLW  12
035B2:  MOVWF  x6E
035B4:  MOVLB  0
035B6:  CALL   030E
035BA:  BTFSC  1B.7
035BC:  BSF    FF2.7
035BE:  MOVF   01,W
035C0:  ADDLW  02
035C2:  MOVLB  4
035C4:  MOVWF  x1E
035C6:  MOVLW  00
035C8:  ADDWFC 02,W
035CA:  MOVWF  x1F
035CC:  MOVLW  01
035CE:  ADDWF  x1E,W
035D0:  MOVWF  01
035D2:  MOVLW  00
035D4:  ADDWFC x1F,W
035D6:  MOVWF  03
035D8:  MOVF   01,W
035DA:  ADDLW  3A
035DC:  MOVWF  01
035DE:  MOVLW  01
035E0:  ADDWFC 03,F
035E2:  MOVFF  01,FE9
035E6:  MOVFF  03,FEA
035EA:  MOVFF  FEF,420
035EE:  CLRF   1B
035F0:  BTFSC  FF2.7
035F2:  BSF    1B.7
035F4:  BCF    FF2.7
035F6:  CLRF   x6D
035F8:  MOVFF  41D,46C
035FC:  CLRF   x6F
035FE:  MOVLW  12
03600:  MOVWF  x6E
03602:  MOVLB  0
03604:  CALL   030E
03608:  BTFSC  1B.7
0360A:  BSF    FF2.7
0360C:  MOVF   01,W
0360E:  ADDLW  02
03610:  MOVLB  4
03612:  MOVWF  x21
03614:  MOVLW  00
03616:  ADDWFC 02,W
03618:  MOVWF  x22
0361A:  MOVLW  01
0361C:  ADDWF  x21,W
0361E:  MOVWF  01
03620:  MOVLW  00
03622:  ADDWFC x22,W
03624:  MOVWF  03
03626:  MOVF   01,W
03628:  ADDLW  3A
0362A:  MOVWF  01
0362C:  MOVLW  01
0362E:  ADDWFC 03,F
03630:  MOVF   01,W
03632:  ADDLW  01
03634:  MOVWF  FE9
03636:  MOVLW  00
03638:  ADDWFC 03,W
0363A:  MOVWF  FEA
0363C:  MOVFF  FEF,423
03640:  MOVFF  420,424
03644:  MOVFF  423,425
03648:  MOVLB  0
0364A:  RCALL  30D8
0364C:  CLRF   1B
0364E:  BTFSC  FF2.7
03650:  BSF    1B.7
03652:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).dim_level.needs_update=false; 
03654:  MOVLB  4
03656:  CLRF   x6D
03658:  MOVFF  41D,46C
0365C:  CLRF   x6F
0365E:  MOVLW  12
03660:  MOVWF  x6E
03662:  MOVLB  0
03664:  CALL   030E
03668:  BTFSC  1B.7
0366A:  BSF    FF2.7
0366C:  MOVF   01,W
0366E:  ADDLW  02
03670:  MOVLB  4
03672:  MOVWF  x1E
03674:  MOVLW  00
03676:  ADDWFC 02,W
03678:  MOVWF  x1F
0367A:  MOVLW  01
0367C:  ADDWF  x1E,W
0367E:  MOVWF  01
03680:  MOVLW  00
03682:  ADDWFC x1F,W
03684:  MOVWF  03
03686:  MOVF   01,W
03688:  ADDLW  3A
0368A:  MOVWF  01
0368C:  MOVLW  01
0368E:  ADDWFC 03,F
03690:  MOVF   01,W
03692:  ADDLW  02
03694:  MOVWF  FE9
03696:  MOVLW  00
03698:  ADDWFC 03,W
0369A:  MOVWF  FEA
0369C:  BCF    FEF.0
0369E:  CLRF   1B
036A0:  BTFSC  FF2.7
036A2:  BSF    1B.7
036A4:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).dim_level.value=0; 
036A6:  CLRF   x6D
036A8:  MOVFF  41D,46C
036AC:  CLRF   x6F
036AE:  MOVLW  12
036B0:  MOVWF  x6E
036B2:  MOVLB  0
036B4:  CALL   030E
036B8:  BTFSC  1B.7
036BA:  BSF    FF2.7
036BC:  MOVF   01,W
036BE:  ADDLW  02
036C0:  MOVLB  4
036C2:  MOVWF  x1E
036C4:  MOVLW  00
036C6:  ADDWFC 02,W
036C8:  MOVWF  x1F
036CA:  MOVLW  01
036CC:  ADDWF  x1E,W
036CE:  MOVWF  01
036D0:  MOVLW  00
036D2:  ADDWFC x1F,W
036D4:  MOVWF  03
036D6:  MOVF   01,W
036D8:  ADDLW  3A
036DA:  MOVWF  01
036DC:  MOVLW  01
036DE:  ADDWFC 03,F
036E0:  MOVF   01,W
036E2:  ADDLW  01
036E4:  MOVWF  FE9
036E6:  MOVLW  00
036E8:  ADDWFC 03,W
036EA:  MOVWF  FEA
036EC:  CLRF   FEF
036EE:  CLRF   1B
036F0:  BTFSC  FF2.7
036F2:  BSF    1B.7
036F4:  BCF    FF2.7
....................                } 
....................            if( ((struct dimmer_switch)mydevices.myinputs[x].device).on.needs_update) 
036F6:  CLRF   x6D
036F8:  MOVFF  41D,46C
036FC:  CLRF   x6F
036FE:  MOVLW  12
03700:  MOVWF  x6E
03702:  MOVLB  0
03704:  CALL   030E
03708:  BTFSC  1B.7
0370A:  BSF    FF2.7
0370C:  MOVF   01,W
0370E:  ADDLW  02
03710:  MOVLB  4
03712:  MOVWF  x1E
03714:  MOVLW  00
03716:  ADDWFC 02,W
03718:  MOVWF  x1F
0371A:  MOVLW  01
0371C:  ADDWF  x1E,W
0371E:  MOVWF  01
03720:  MOVLW  00
03722:  ADDWFC x1F,W
03724:  MOVWF  03
03726:  MOVF   01,W
03728:  ADDLW  3A
0372A:  MOVWF  01
0372C:  MOVLW  01
0372E:  ADDWFC 03,F
03730:  MOVF   01,W
03732:  ADDLW  05
03734:  MOVWF  FE9
03736:  MOVLW  00
03738:  ADDWFC 03,W
0373A:  MOVWF  FEA
0373C:  BTFSS  FEF.0
0373E:  BRA    3892
03740:  CLRF   1B
03742:  BTFSC  FF2.7
03744:  BSF    1B.7
03746:  BCF    FF2.7
....................                {   
....................                   process_outpoint_answer( ((struct dimmer_switch)mydevices.myinputs[x].device).on.adress, ((struct dimmer_switch)mydevices.myinputs[x].device).on.value); 
03748:  CLRF   x6D
0374A:  MOVFF  41D,46C
0374E:  CLRF   x6F
03750:  MOVLW  12
03752:  MOVWF  x6E
03754:  MOVLB  0
03756:  CALL   030E
0375A:  BTFSC  1B.7
0375C:  BSF    FF2.7
0375E:  MOVF   01,W
03760:  ADDLW  02
03762:  MOVLB  4
03764:  MOVWF  x1E
03766:  MOVLW  00
03768:  ADDWFC 02,W
0376A:  MOVWF  x1F
0376C:  MOVLW  01
0376E:  ADDWF  x1E,W
03770:  MOVWF  01
03772:  MOVLW  00
03774:  ADDWFC x1F,W
03776:  MOVWF  03
03778:  MOVF   01,W
0377A:  ADDLW  3A
0377C:  MOVWF  01
0377E:  MOVLW  01
03780:  ADDWFC 03,F
03782:  MOVF   01,W
03784:  ADDLW  03
03786:  MOVWF  FE9
03788:  MOVLW  00
0378A:  ADDWFC 03,W
0378C:  MOVWF  FEA
0378E:  MOVFF  FEF,420
03792:  CLRF   1B
03794:  BTFSC  FF2.7
03796:  BSF    1B.7
03798:  BCF    FF2.7
0379A:  CLRF   x6D
0379C:  MOVFF  41D,46C
037A0:  CLRF   x6F
037A2:  MOVLW  12
037A4:  MOVWF  x6E
037A6:  MOVLB  0
037A8:  CALL   030E
037AC:  BTFSC  1B.7
037AE:  BSF    FF2.7
037B0:  MOVF   01,W
037B2:  ADDLW  02
037B4:  MOVLB  4
037B6:  MOVWF  x21
037B8:  MOVLW  00
037BA:  ADDWFC 02,W
037BC:  MOVWF  x22
037BE:  MOVLW  01
037C0:  ADDWF  x21,W
037C2:  MOVWF  01
037C4:  MOVLW  00
037C6:  ADDWFC x22,W
037C8:  MOVWF  03
037CA:  MOVF   01,W
037CC:  ADDLW  3A
037CE:  MOVWF  01
037D0:  MOVLW  01
037D2:  ADDWFC 03,F
037D4:  MOVF   01,W
037D6:  ADDLW  04
037D8:  MOVWF  FE9
037DA:  MOVLW  00
037DC:  ADDWFC 03,W
037DE:  MOVWF  FEA
037E0:  MOVFF  FEF,423
037E4:  MOVFF  420,424
037E8:  MOVFF  423,425
037EC:  MOVLB  0
037EE:  RCALL  30D8
037F0:  CLRF   1B
037F2:  BTFSC  FF2.7
037F4:  BSF    1B.7
037F6:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).on.needs_update=false; 
037F8:  MOVLB  4
037FA:  CLRF   x6D
037FC:  MOVFF  41D,46C
03800:  CLRF   x6F
03802:  MOVLW  12
03804:  MOVWF  x6E
03806:  MOVLB  0
03808:  CALL   030E
0380C:  BTFSC  1B.7
0380E:  BSF    FF2.7
03810:  MOVF   01,W
03812:  ADDLW  02
03814:  MOVLB  4
03816:  MOVWF  x1E
03818:  MOVLW  00
0381A:  ADDWFC 02,W
0381C:  MOVWF  x1F
0381E:  MOVLW  01
03820:  ADDWF  x1E,W
03822:  MOVWF  01
03824:  MOVLW  00
03826:  ADDWFC x1F,W
03828:  MOVWF  03
0382A:  MOVF   01,W
0382C:  ADDLW  3A
0382E:  MOVWF  01
03830:  MOVLW  01
03832:  ADDWFC 03,F
03834:  MOVF   01,W
03836:  ADDLW  05
03838:  MOVWF  FE9
0383A:  MOVLW  00
0383C:  ADDWFC 03,W
0383E:  MOVWF  FEA
03840:  BCF    FEF.0
03842:  CLRF   1B
03844:  BTFSC  FF2.7
03846:  BSF    1B.7
03848:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).on.value=0; 
0384A:  CLRF   x6D
0384C:  MOVFF  41D,46C
03850:  CLRF   x6F
03852:  MOVLW  12
03854:  MOVWF  x6E
03856:  MOVLB  0
03858:  CALL   030E
0385C:  BTFSC  1B.7
0385E:  BSF    FF2.7
03860:  MOVF   01,W
03862:  ADDLW  02
03864:  MOVLB  4
03866:  MOVWF  x1E
03868:  MOVLW  00
0386A:  ADDWFC 02,W
0386C:  MOVWF  x1F
0386E:  MOVLW  01
03870:  ADDWF  x1E,W
03872:  MOVWF  01
03874:  MOVLW  00
03876:  ADDWFC x1F,W
03878:  MOVWF  03
0387A:  MOVF   01,W
0387C:  ADDLW  3A
0387E:  MOVWF  01
03880:  MOVLW  01
03882:  ADDWFC 03,F
03884:  MOVF   01,W
03886:  ADDLW  04
03888:  MOVWF  FE9
0388A:  MOVLW  00
0388C:  ADDWFC 03,W
0388E:  MOVWF  FEA
03890:  CLRF   FEF
03892:  CLRF   1B
03894:  BTFSC  FF2.7
03896:  BSF    1B.7
03898:  BCF    FF2.7
....................                } 
....................                if( ((struct dimmer_switch)mydevices.myinputs[x].device).off.needs_update) 
0389A:  CLRF   x6D
0389C:  MOVFF  41D,46C
038A0:  CLRF   x6F
038A2:  MOVLW  12
038A4:  MOVWF  x6E
038A6:  MOVLB  0
038A8:  CALL   030E
038AC:  BTFSC  1B.7
038AE:  BSF    FF2.7
038B0:  MOVF   01,W
038B2:  ADDLW  02
038B4:  MOVLB  4
038B6:  MOVWF  x1E
038B8:  MOVLW  00
038BA:  ADDWFC 02,W
038BC:  MOVWF  x1F
038BE:  MOVLW  01
038C0:  ADDWF  x1E,W
038C2:  MOVWF  01
038C4:  MOVLW  00
038C6:  ADDWFC x1F,W
038C8:  MOVWF  03
038CA:  MOVF   01,W
038CC:  ADDLW  3A
038CE:  MOVWF  01
038D0:  MOVLW  01
038D2:  ADDWFC 03,F
038D4:  MOVF   01,W
038D6:  ADDLW  08
038D8:  MOVWF  FE9
038DA:  MOVLW  00
038DC:  ADDWFC 03,W
038DE:  MOVWF  FEA
038E0:  BTFSS  FEF.0
038E2:  BRA    3A38
038E4:  CLRF   1B
038E6:  BTFSC  FF2.7
038E8:  BSF    1B.7
038EA:  BCF    FF2.7
....................                { 
....................                   process_outpoint_answer( ((struct dimmer_switch)mydevices.myinputs[x].device).off.adress, ((struct dimmer_switch)mydevices.myinputs[x].device).off.value); 
038EC:  CLRF   x6D
038EE:  MOVFF  41D,46C
038F2:  CLRF   x6F
038F4:  MOVLW  12
038F6:  MOVWF  x6E
038F8:  MOVLB  0
038FA:  CALL   030E
038FE:  BTFSC  1B.7
03900:  BSF    FF2.7
03902:  MOVF   01,W
03904:  ADDLW  02
03906:  MOVLB  4
03908:  MOVWF  x1E
0390A:  MOVLW  00
0390C:  ADDWFC 02,W
0390E:  MOVWF  x1F
03910:  MOVLW  01
03912:  ADDWF  x1E,W
03914:  MOVWF  01
03916:  MOVLW  00
03918:  ADDWFC x1F,W
0391A:  MOVWF  03
0391C:  MOVF   01,W
0391E:  ADDLW  3A
03920:  MOVWF  01
03922:  MOVLW  01
03924:  ADDWFC 03,F
03926:  MOVF   01,W
03928:  ADDLW  06
0392A:  MOVWF  FE9
0392C:  MOVLW  00
0392E:  ADDWFC 03,W
03930:  MOVWF  FEA
03932:  MOVFF  FEF,420
03936:  CLRF   1B
03938:  BTFSC  FF2.7
0393A:  BSF    1B.7
0393C:  BCF    FF2.7
0393E:  CLRF   x6D
03940:  MOVFF  41D,46C
03944:  CLRF   x6F
03946:  MOVLW  12
03948:  MOVWF  x6E
0394A:  MOVLB  0
0394C:  CALL   030E
03950:  BTFSC  1B.7
03952:  BSF    FF2.7
03954:  MOVF   01,W
03956:  ADDLW  02
03958:  MOVLB  4
0395A:  MOVWF  x21
0395C:  MOVLW  00
0395E:  ADDWFC 02,W
03960:  MOVWF  x22
03962:  MOVLW  01
03964:  ADDWF  x21,W
03966:  MOVWF  01
03968:  MOVLW  00
0396A:  ADDWFC x22,W
0396C:  MOVWF  03
0396E:  MOVF   01,W
03970:  ADDLW  3A
03972:  MOVWF  01
03974:  MOVLW  01
03976:  ADDWFC 03,F
03978:  MOVF   01,W
0397A:  ADDLW  07
0397C:  MOVWF  FE9
0397E:  MOVLW  00
03980:  ADDWFC 03,W
03982:  MOVWF  FEA
03984:  MOVFF  FEF,423
03988:  MOVFF  420,424
0398C:  MOVFF  423,425
03990:  MOVLB  0
03992:  CALL   30D8
03996:  CLRF   1B
03998:  BTFSC  FF2.7
0399A:  BSF    1B.7
0399C:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).off.needs_update=false; 
0399E:  MOVLB  4
039A0:  CLRF   x6D
039A2:  MOVFF  41D,46C
039A6:  CLRF   x6F
039A8:  MOVLW  12
039AA:  MOVWF  x6E
039AC:  MOVLB  0
039AE:  CALL   030E
039B2:  BTFSC  1B.7
039B4:  BSF    FF2.7
039B6:  MOVF   01,W
039B8:  ADDLW  02
039BA:  MOVLB  4
039BC:  MOVWF  x1E
039BE:  MOVLW  00
039C0:  ADDWFC 02,W
039C2:  MOVWF  x1F
039C4:  MOVLW  01
039C6:  ADDWF  x1E,W
039C8:  MOVWF  01
039CA:  MOVLW  00
039CC:  ADDWFC x1F,W
039CE:  MOVWF  03
039D0:  MOVF   01,W
039D2:  ADDLW  3A
039D4:  MOVWF  01
039D6:  MOVLW  01
039D8:  ADDWFC 03,F
039DA:  MOVF   01,W
039DC:  ADDLW  08
039DE:  MOVWF  FE9
039E0:  MOVLW  00
039E2:  ADDWFC 03,W
039E4:  MOVWF  FEA
039E6:  BCF    FEF.0
039E8:  CLRF   1B
039EA:  BTFSC  FF2.7
039EC:  BSF    1B.7
039EE:  BCF    FF2.7
....................                    ((struct dimmer_switch)mydevices.myinputs[x].device).off.value=0; 
039F0:  CLRF   x6D
039F2:  MOVFF  41D,46C
039F6:  CLRF   x6F
039F8:  MOVLW  12
039FA:  MOVWF  x6E
039FC:  MOVLB  0
039FE:  CALL   030E
03A02:  BTFSC  1B.7
03A04:  BSF    FF2.7
03A06:  MOVF   01,W
03A08:  ADDLW  02
03A0A:  MOVLB  4
03A0C:  MOVWF  x1E
03A0E:  MOVLW  00
03A10:  ADDWFC 02,W
03A12:  MOVWF  x1F
03A14:  MOVLW  01
03A16:  ADDWF  x1E,W
03A18:  MOVWF  01
03A1A:  MOVLW  00
03A1C:  ADDWFC x1F,W
03A1E:  MOVWF  03
03A20:  MOVF   01,W
03A22:  ADDLW  3A
03A24:  MOVWF  01
03A26:  MOVLW  01
03A28:  ADDWFC 03,F
03A2A:  MOVF   01,W
03A2C:  ADDLW  07
03A2E:  MOVWF  FE9
03A30:  MOVLW  00
03A32:  ADDWFC 03,W
03A34:  MOVWF  FEA
03A36:  CLRF   FEF
....................                } 
....................                break; 
03A38:  BRA    3A42
....................     case timer: 
....................  
....................            break; 
03A3A:  MOVLB  4
03A3C:  BRA    3A42
....................     default: 
....................  
....................             break; } 
03A3E:  MOVLB  4
03A40:  BRA    3A42
....................  
....................    } 
03A42:  INCF   x1D,F
03A44:  BRA    3500
.................... } 
03A46:  MOVLB  0
03A48:  GOTO   3D24 (RETURN)
....................  
....................  
....................  
.................... ////////////////////////////////////////// 
.................... //apagar 
.................... volatile unsigned int32 clock; 
....................  
.................... //dimmer constants 
.................... static int TimeBase=0; 
.................... static int32 reg=39; 
.................... //dimmer end 
....................  
.................... //struct switches msw; 
.................... #include "switch_functions.c" 
.................... void process_onOff(struct on_off_switch *sw) 
.................... { 
.................... //printf("AKI1"); 
....................    if((sw->current_state==button_pressed) && (sw-> previous_state == button_depressed)) 
*
0074A:  MOVLW  06
0074C:  MOVLB  4
0074E:  ADDWF  x6E,W
00750:  MOVWF  FE9
00752:  MOVLW  00
00754:  ADDWFC x6F,W
00756:  MOVWF  FEA
00758:  MOVLW  00
0075A:  BTFSC  FEF.0
0075C:  MOVLW  01
0075E:  ANDLW  01
00760:  BNZ   0806
00762:  MOVLW  06
00764:  ADDWF  x6E,W
00766:  MOVWF  FE9
00768:  MOVLW  00
0076A:  ADDWFC x6F,W
0076C:  MOVWF  FEA
0076E:  MOVLW  00
00770:  BTFSC  FEF.1
00772:  MOVLW  01
00774:  ANDLW  01
00776:  SUBLW  01
00778:  BNZ   0806
....................    {    
....................       sw-> previous_state = button_pressed; 
0077A:  MOVLW  06
0077C:  ADDWF  x6E,W
0077E:  MOVWF  FE9
00780:  MOVLW  00
00782:  ADDWFC x6F,W
00784:  MOVWF  FEA
00786:  BCF    FEF.1
....................       if(sw->outstate==off) 
00788:  MOVLW  0B
0078A:  ADDWF  x6E,W
0078C:  MOVWF  FE9
0078E:  MOVLW  00
00790:  ADDWFC x6F,W
00792:  MOVWF  FEA
00794:  DECFSZ FEF,W
00796:  BRA    07C6
....................       { 
....................          sw->outstate=on; 
00798:  MOVLW  0B
0079A:  ADDWF  x6E,W
0079C:  MOVWF  FE9
0079E:  MOVLW  00
007A0:  ADDWFC x6F,W
007A2:  MOVWF  FEA
007A4:  CLRF   FEF
....................          sw->on.value=1; 
007A6:  MOVLW  01
007A8:  ADDWF  x6E,W
007AA:  MOVWF  FE9
007AC:  MOVLW  00
007AE:  ADDWFC x6F,W
007B0:  MOVWF  FEA
007B2:  MOVLW  01
007B4:  MOVWF  FEF
....................          sw->on.needs_update=true; 
007B6:  MOVLW  02
007B8:  ADDWF  x6E,W
007BA:  MOVWF  FE9
007BC:  MOVLW  00
007BE:  ADDWFC x6F,W
007C0:  MOVWF  FEA
007C2:  BSF    FEF.0
....................       } 
....................       else if(sw->outstate==on) 
007C4:  BRA    0804
007C6:  MOVLW  0B
007C8:  ADDWF  x6E,W
007CA:  MOVWF  FE9
007CC:  MOVLW  00
007CE:  ADDWFC x6F,W
007D0:  MOVWF  FEA
007D2:  MOVF   FEF,F
007D4:  BNZ   0804
....................       { 
....................          sw->outstate=off; 
007D6:  MOVLW  0B
007D8:  ADDWF  x6E,W
007DA:  MOVWF  FE9
007DC:  MOVLW  00
007DE:  ADDWFC x6F,W
007E0:  MOVWF  FEA
007E2:  MOVLW  01
007E4:  MOVWF  FEF
....................          sw->off.value=1; 
007E6:  MOVLW  04
007E8:  ADDWF  x6E,W
007EA:  MOVWF  FE9
007EC:  MOVLW  00
007EE:  ADDWFC x6F,W
007F0:  MOVWF  FEA
007F2:  MOVLW  01
007F4:  MOVWF  FEF
....................          sw->off.needs_update=true; 
007F6:  MOVLW  05
007F8:  ADDWF  x6E,W
007FA:  MOVWF  FE9
007FC:  MOVLW  00
007FE:  ADDWFC x6F,W
00800:  MOVWF  FEA
00802:  BSF    FEF.0
....................       } 
.................... } 
....................    else if(sw->current_state==button_depressed) 
00804:  BRA    082C
00806:  MOVLW  06
00808:  ADDWF  x6E,W
0080A:  MOVWF  FE9
0080C:  MOVLW  00
0080E:  ADDWFC x6F,W
00810:  MOVWF  FEA
00812:  MOVLW  00
00814:  BTFSC  FEF.0
00816:  MOVLW  01
00818:  ANDLW  01
0081A:  SUBLW  01
0081C:  BNZ   082C
....................       sw-> previous_state = button_depressed; 
0081E:  MOVLW  06
00820:  ADDWF  x6E,W
00822:  MOVWF  FE9
00824:  MOVLW  00
00826:  ADDWFC x6F,W
00828:  MOVWF  FEA
0082A:  BSF    FEF.1
.................... } 
0082C:  MOVLB  0
0082E:  GOTO   0D18 (RETURN)
.................... void process_buttons(struct button_switch *sw) 
.................... { 
....................    if(sw->current_state==button_pressed && sw->outstate==off)  
00832:  MOVLW  06
00834:  MOVLB  4
00836:  ADDWF  x6E,W
00838:  MOVWF  FE9
0083A:  MOVLW  00
0083C:  ADDWFC x6F,W
0083E:  MOVWF  FEA
00840:  MOVLW  00
00842:  BTFSC  FEF.0
00844:  MOVLW  01
00846:  ANDLW  01
00848:  BNZ   0888
0084A:  MOVLW  0B
0084C:  ADDWF  x6E,W
0084E:  MOVWF  FE9
00850:  MOVLW  00
00852:  ADDWFC x6F,W
00854:  MOVWF  FEA
00856:  DECFSZ FEF,W
00858:  BRA    0888
....................    { 
....................          sw->outstate=on; 
0085A:  MOVLW  0B
0085C:  ADDWF  x6E,W
0085E:  MOVWF  FE9
00860:  MOVLW  00
00862:  ADDWFC x6F,W
00864:  MOVWF  FEA
00866:  CLRF   FEF
....................          sw->on.value=1; 
00868:  MOVLW  01
0086A:  ADDWF  x6E,W
0086C:  MOVWF  FE9
0086E:  MOVLW  00
00870:  ADDWFC x6F,W
00872:  MOVWF  FEA
00874:  MOVLW  01
00876:  MOVWF  FEF
....................          sw->on.needs_update=true; 
00878:  MOVLW  02
0087A:  ADDWF  x6E,W
0087C:  MOVWF  FE9
0087E:  MOVLW  00
00880:  ADDWFC x6F,W
00882:  MOVWF  FEA
00884:  BSF    FEF.0
....................    } 
....................    else if(sw->current_state==button_depressed && sw->outstate==on)   
00886:  BRA    08DE
00888:  MOVLW  06
0088A:  ADDWF  x6E,W
0088C:  MOVWF  FE9
0088E:  MOVLW  00
00890:  ADDWFC x6F,W
00892:  MOVWF  FEA
00894:  MOVLW  00
00896:  BTFSC  FEF.0
00898:  MOVLW  01
0089A:  ANDLW  01
0089C:  SUBLW  01
0089E:  BNZ   08DE
008A0:  MOVLW  0B
008A2:  ADDWF  x6E,W
008A4:  MOVWF  FE9
008A6:  MOVLW  00
008A8:  ADDWFC x6F,W
008AA:  MOVWF  FEA
008AC:  MOVF   FEF,F
008AE:  BNZ   08DE
....................    { 
....................          sw->outstate=off; 
008B0:  MOVLW  0B
008B2:  ADDWF  x6E,W
008B4:  MOVWF  FE9
008B6:  MOVLW  00
008B8:  ADDWFC x6F,W
008BA:  MOVWF  FEA
008BC:  MOVLW  01
008BE:  MOVWF  FEF
....................          sw->off.value=1; 
008C0:  MOVLW  04
008C2:  ADDWF  x6E,W
008C4:  MOVWF  FE9
008C6:  MOVLW  00
008C8:  ADDWFC x6F,W
008CA:  MOVWF  FEA
008CC:  MOVLW  01
008CE:  MOVWF  FEF
....................          sw->off.needs_update=true; 
008D0:  MOVLW  05
008D2:  ADDWF  x6E,W
008D4:  MOVWF  FE9
008D6:  MOVLW  00
008D8:  ADDWFC x6F,W
008DA:  MOVWF  FEA
008DC:  BSF    FEF.0
....................    } 
.................... } 
008DE:  MOVLB  0
008E0:  GOTO   0D18 (RETURN)
.................... void process_dimmers(struct dimmer_switch *sw) 
.................... { 
*
003A4:  MOVLW  09
003A6:  MOVLB  4
003A8:  ADDWF  x6E,W
003AA:  MOVWF  FE9
003AC:  MOVLW  00
003AE:  ADDWFC x6F,W
003B0:  MOVWF  FEA
003B2:  MOVFF  FEF,470
....................    int last_level=sw->current_level; 
....................    if(sw->current_state==button_pressed)//se o botao esta premido 
003B6:  MOVLW  0E
003B8:  ADDWF  x6E,W
003BA:  MOVWF  FE9
003BC:  MOVLW  00
003BE:  ADDWFC x6F,W
003C0:  MOVWF  FEA
003C2:  MOVLW  00
003C4:  BTFSC  FEF.0
003C6:  MOVLW  01
003C8:  ANDLW  01
003CA:  BTFSS  FD8.2
003CC:  BRA    059C
....................    { 
....................     //  printf("STATE %u",sw->current_state); 
....................      // printf("DIF %LU",clock - sw->timer); 
....................       sw-> previous_state = button_pressed; 
003CE:  MOVLW  0E
003D0:  ADDWF  x6E,W
003D2:  MOVWF  FE9
003D4:  MOVLW  00
003D6:  ADDWFC x6F,W
003D8:  MOVWF  FEA
003DA:  BCF    FEF.1
....................       if ((clock - sw->timer > reg || sw->outstate == dimming) && sw->outstate!=maxed) 
003DC:  MOVLW  0A
003DE:  ADDWF  x6E,W
003E0:  MOVWF  FE9
003E2:  MOVLW  00
003E4:  ADDWFC x6F,W
003E6:  MOVWF  FEA
003E8:  MOVFF  FEF,00
003EC:  MOVFF  FEC,01
003F0:  MOVFF  FEC,02
003F4:  MOVFF  FEC,03
003F8:  MOVF   00,W
003FA:  SUBWF  x0D,W
003FC:  MOVWF  x71
003FE:  MOVF   01,W
00400:  SUBWFB x0E,W
00402:  MOVWF  x72
00404:  MOVF   02,W
00406:  SUBWFB x0F,W
00408:  MOVWF  x73
0040A:  MOVF   03,W
0040C:  SUBWFB x10,W
0040E:  MOVWF  x74
00410:  MOVF   x15,W
00412:  SUBWF  x74,W
00414:  BNC   042E
00416:  BNZ   0442
00418:  MOVF   x14,W
0041A:  SUBWF  x73,W
0041C:  BNC   042E
0041E:  BNZ   0442
00420:  MOVF   x13,W
00422:  SUBWF  x72,W
00424:  BNC   042E
00426:  BNZ   0442
00428:  MOVF   x71,W
0042A:  SUBWF  x12,W
0042C:  BNC   0442
0042E:  MOVLW  0F
00430:  ADDWF  x6E,W
00432:  MOVWF  FE9
00434:  MOVLW  00
00436:  ADDWFC x6F,W
00438:  MOVWF  FEA
0043A:  MOVF   FEF,W
0043C:  SUBLW  02
0043E:  BTFSS  FD8.2
00440:  BRA    059A
00442:  MOVLW  0F
00444:  ADDWF  x6E,W
00446:  MOVWF  FE9
00448:  MOVLW  00
0044A:  ADDWFC x6F,W
0044C:  MOVWF  FEA
0044E:  MOVF   FEF,W
00450:  SUBLW  04
00452:  BTFSC  FD8.2
00454:  BRA    059A
....................       {  
....................          if(sw->outstate==off) 
00456:  MOVLW  0F
00458:  ADDWF  x6E,W
0045A:  MOVWF  FE9
0045C:  MOVLW  00
0045E:  ADDWFC x6F,W
00460:  MOVWF  FEA
00462:  DECFSZ FEF,W
00464:  BRA    04A4
....................          { 
....................             sw->outstate=maxed; 
00466:  MOVLW  0F
00468:  ADDWF  x6E,W
0046A:  MOVWF  FE9
0046C:  MOVLW  00
0046E:  ADDWFC x6F,W
00470:  MOVWF  FEA
00472:  MOVLW  04
00474:  MOVWF  FEF
....................             sw->on.value=1; 
00476:  ADDWF  x6E,W
00478:  MOVWF  FE9
0047A:  MOVLW  00
0047C:  ADDWFC x6F,W
0047E:  MOVWF  FEA
00480:  MOVLW  01
00482:  MOVWF  FEF
....................             sw->current_level = 127; 
00484:  MOVLW  09
00486:  ADDWF  x6E,W
00488:  MOVWF  FE9
0048A:  MOVLW  00
0048C:  ADDWFC x6F,W
0048E:  MOVWF  FEA
00490:  MOVLW  7F
00492:  MOVWF  FEF
....................             sw->on.needs_update=1; 
00494:  MOVLW  05
00496:  ADDWF  x6E,W
00498:  MOVWF  FE9
0049A:  MOVLW  00
0049C:  ADDWFC x6F,W
0049E:  MOVWF  FEA
004A0:  BSF    FEF.0
....................          } 
....................         else 
004A2:  BRA    0598
....................         { 
....................          sw->outstate = dimming; 
004A4:  MOVLW  0F
004A6:  ADDWF  x6E,W
004A8:  MOVWF  FE9
004AA:  MOVLW  00
004AC:  ADDWFC x6F,W
004AE:  MOVWF  FEA
004B0:  MOVLW  02
004B2:  MOVWF  FEF
....................          if (clock - sw->timer > TimeBase) //regula 
004B4:  MOVLW  0A
004B6:  ADDWF  x6E,W
004B8:  MOVWF  FE9
004BA:  MOVLW  00
004BC:  ADDWFC x6F,W
004BE:  MOVWF  FEA
004C0:  MOVFF  FEF,00
004C4:  MOVFF  FEC,01
004C8:  MOVFF  FEC,02
004CC:  MOVFF  FEC,03
004D0:  MOVF   00,W
004D2:  SUBWF  x0D,W
004D4:  MOVWF  x71
004D6:  MOVF   01,W
004D8:  SUBWFB x0E,W
004DA:  MOVWF  x72
004DC:  MOVF   02,W
004DE:  SUBWFB x0F,W
004E0:  MOVWF  x73
004E2:  MOVF   03,W
004E4:  SUBWFB x10,W
004E6:  MOVWF  x74
004E8:  MOVF   x74,F
004EA:  BNZ   04FA
004EC:  MOVF   x73,F
004EE:  BNZ   04FA
004F0:  MOVF   x72,F
004F2:  BNZ   04FA
004F4:  MOVF   x71,W
004F6:  SUBWF  x11,W
004F8:  BC    057C
....................          { 
....................             if (sw->direction == up) //para cima 
004FA:  MOVLW  0E
004FC:  ADDWF  x6E,W
004FE:  MOVWF  FE9
00500:  MOVLW  00
00502:  ADDWFC x6F,W
00504:  MOVWF  FEA
00506:  MOVLW  00
00508:  BTFSC  FEF.2
0050A:  MOVLW  01
0050C:  ANDLW  01
0050E:  BNZ   0540
....................             { 
....................                ++sw->current_level; 
00510:  MOVLW  09
00512:  ADDWF  x6E,W
00514:  MOVWF  FE9
00516:  MOVLW  00
00518:  ADDWFC x6F,W
0051A:  MOVWF  FEA
0051C:  INCF   FEF,F
....................                if (sw->current_level == 127) sw->direction = down; 
0051E:  MOVLW  09
00520:  ADDWF  x6E,W
00522:  MOVWF  FE9
00524:  MOVLW  00
00526:  ADDWFC x6F,W
00528:  MOVWF  FEA
0052A:  MOVF   FEF,W
0052C:  SUBLW  7F
0052E:  BNZ   053E
00530:  MOVLW  0E
00532:  ADDWF  x6E,W
00534:  MOVWF  FE9
00536:  MOVLW  00
00538:  ADDWFC x6F,W
0053A:  MOVWF  FEA
0053C:  BSF    FEF.2
....................             } 
....................             else//para baixo 
0053E:  BRA    057C
....................             { 
....................                --sw->current_level; 
00540:  MOVLW  09
00542:  ADDWF  x6E,W
00544:  MOVWF  FE9
00546:  MOVLW  00
00548:  ADDWFC x6F,W
0054A:  MOVWF  FEA
0054C:  DECF   FEF,F
....................                if (sw->current_level == 0)  
0054E:  MOVLW  09
00550:  ADDWF  x6E,W
00552:  MOVWF  FE9
00554:  MOVLW  00
00556:  ADDWFC x6F,W
00558:  MOVWF  FEA
0055A:  MOVF   FEF,F
0055C:  BNZ   057C
....................                {   
....................                   sw->direction = up; 
0055E:  MOVLW  0E
00560:  ADDWF  x6E,W
00562:  MOVWF  FE9
00564:  MOVLW  00
00566:  ADDWFC x6F,W
00568:  MOVWF  FEA
0056A:  BCF    FEF.2
....................                   sw->off.value=1; 
0056C:  MOVLW  07
0056E:  ADDWF  x6E,W
00570:  MOVWF  FE9
00572:  MOVLW  00
00574:  ADDWFC x6F,W
00576:  MOVWF  FEA
00578:  MOVLW  01
0057A:  MOVWF  FEF
....................                } 
....................             } 
....................          } 
....................          sw->timer = clock; 
0057C:  MOVLW  0A
0057E:  ADDWF  x6E,W
00580:  MOVWF  FE9
00582:  MOVLW  00
00584:  ADDWFC x6F,W
00586:  MOVWF  FEA
00588:  MOVFF  40D,FEF
0058C:  MOVFF  40E,FEC
00590:  MOVFF  40F,FEC
00594:  MOVFF  410,FEC
....................       } 
....................       } 
....................       else 
00598:  BRA    059A
....................       { 
....................          //sw - > timer = clock; 
....................       } 
....................    } 
....................    else//se o botao nao esta premido 
0059A:  BRA    06FC
....................    { 
....................       if (sw->previous_state == button_pressed) //se o botao acabou de ser deslargado 
0059C:  MOVLW  0E
0059E:  ADDWF  x6E,W
005A0:  MOVWF  FE9
005A2:  MOVLW  00
005A4:  ADDWFC x6F,W
005A6:  MOVWF  FEA
005A8:  MOVLW  00
005AA:  BTFSC  FEF.1
005AC:  MOVLW  01
005AE:  ANDLW  01
005B0:  BTFSS  FD8.2
005B2:  BRA    06E0
....................       { 
....................          sw->previous_state = button_depressed; 
005B4:  MOVLW  0E
005B6:  ADDWF  x6E,W
005B8:  MOVWF  FE9
005BA:  MOVLW  00
005BC:  ADDWFC x6F,W
005BE:  MOVWF  FEA
005C0:  BSF    FEF.1
....................          if (sw->outstate == dimming) //se esteve a regular 
005C2:  MOVLW  0F
005C4:  ADDWF  x6E,W
005C6:  MOVWF  FE9
005C8:  MOVLW  00
005CA:  ADDWFC x6F,W
005CC:  MOVWF  FEA
005CE:  MOVF   FEF,W
005D0:  SUBLW  02
005D2:  BNZ   0618
....................          { 
....................             sw-> outstate = on; 
005D4:  MOVLW  0F
005D6:  ADDWF  x6E,W
005D8:  MOVWF  FE9
005DA:  MOVLW  00
005DC:  ADDWFC x6F,W
005DE:  MOVWF  FEA
005E0:  CLRF   FEF
....................             if (sw->direction == up) sw->direction = down; //inverte direccao 
005E2:  MOVLW  0E
005E4:  ADDWF  x6E,W
005E6:  MOVWF  FE9
005E8:  MOVLW  00
005EA:  ADDWFC x6F,W
005EC:  MOVWF  FEA
005EE:  MOVLW  00
005F0:  BTFSC  FEF.2
005F2:  MOVLW  01
005F4:  ANDLW  01
005F6:  BNZ   0608
005F8:  MOVLW  0E
005FA:  ADDWF  x6E,W
005FC:  MOVWF  FE9
005FE:  MOVLW  00
00600:  ADDWFC x6F,W
00602:  MOVWF  FEA
00604:  BSF    FEF.2
....................             else sw->direction = up; 
00606:  BRA    0616
00608:  MOVLW  0E
0060A:  ADDWF  x6E,W
0060C:  MOVWF  FE9
0060E:  MOVLW  00
00610:  ADDWFC x6F,W
00612:  MOVWF  FEA
00614:  BCF    FEF.2
....................          } 
....................          else//se nao esteve a regular 
00616:  BRA    06E0
....................          { 
....................             if (sw->outstate == off) //se estava desligada 
00618:  MOVLW  0F
0061A:  ADDWF  x6E,W
0061C:  MOVWF  FE9
0061E:  MOVLW  00
00620:  ADDWFC x6F,W
00622:  MOVWF  FEA
00624:  DECFSZ FEF,W
00626:  BRA    0664
....................             { 
....................               // printf("on"); 
....................                sw->outstate=on; 
00628:  MOVLW  0F
0062A:  ADDWF  x6E,W
0062C:  MOVWF  FE9
0062E:  MOVLW  00
00630:  ADDWFC x6F,W
00632:  MOVWF  FEA
00634:  CLRF   FEF
....................                sw->on.value=1; 
00636:  MOVLW  04
00638:  ADDWF  x6E,W
0063A:  MOVWF  FE9
0063C:  MOVLW  00
0063E:  ADDWFC x6F,W
00640:  MOVWF  FEA
00642:  MOVLW  01
00644:  MOVWF  FEF
....................                sw->direction = down; 
00646:  MOVLW  0E
00648:  ADDWF  x6E,W
0064A:  MOVWF  FE9
0064C:  MOVLW  00
0064E:  ADDWFC x6F,W
00650:  MOVWF  FEA
00652:  BSF    FEF.2
....................                sw->on.needs_update=true; 
00654:  MOVLW  05
00656:  ADDWF  x6E,W
00658:  MOVWF  FE9
0065A:  MOVLW  00
0065C:  ADDWFC x6F,W
0065E:  MOVWF  FEA
00660:  BSF    FEF.0
....................             } 
....................             else if (sw->outstate == on) 
00662:  BRA    06E0
00664:  MOVLW  0F
00666:  ADDWF  x6E,W
00668:  MOVWF  FE9
0066A:  MOVLW  00
0066C:  ADDWFC x6F,W
0066E:  MOVWF  FEA
00670:  MOVF   FEF,F
00672:  BNZ   06B2
....................             { 
....................               // printf("off"); 
....................                //sw->current_level = 0; //senao desliga 
....................                sw->outstate=off; 
00674:  MOVLW  0F
00676:  ADDWF  x6E,W
00678:  MOVWF  FE9
0067A:  MOVLW  00
0067C:  ADDWFC x6F,W
0067E:  MOVWF  FEA
00680:  MOVLW  01
00682:  MOVWF  FEF
....................                sw->off.value=1; 
00684:  MOVLW  07
00686:  ADDWF  x6E,W
00688:  MOVWF  FE9
0068A:  MOVLW  00
0068C:  ADDWFC x6F,W
0068E:  MOVWF  FEA
00690:  MOVLW  01
00692:  MOVWF  FEF
....................                sw->direction = up; 
00694:  MOVLW  0E
00696:  ADDWF  x6E,W
00698:  MOVWF  FE9
0069A:  MOVLW  00
0069C:  ADDWFC x6F,W
0069E:  MOVWF  FEA
006A0:  BCF    FEF.2
....................                sw->off.needs_update=true; 
006A2:  MOVLW  08
006A4:  ADDWF  x6E,W
006A6:  MOVWF  FE9
006A8:  MOVLW  00
006AA:  ADDWFC x6F,W
006AC:  MOVWF  FEA
006AE:  BSF    FEF.0
....................             } 
....................             else if(sw->outstate == maxed) 
006B0:  BRA    06E0
006B2:  MOVLW  0F
006B4:  ADDWF  x6E,W
006B6:  MOVWF  FE9
006B8:  MOVLW  00
006BA:  ADDWFC x6F,W
006BC:  MOVWF  FEA
006BE:  MOVF   FEF,W
006C0:  SUBLW  04
006C2:  BNZ   06E0
....................             { 
....................                sw->outstate=on; 
006C4:  MOVLW  0F
006C6:  ADDWF  x6E,W
006C8:  MOVWF  FE9
006CA:  MOVLW  00
006CC:  ADDWFC x6F,W
006CE:  MOVWF  FEA
006D0:  CLRF   FEF
....................                sw->direction = down; 
006D2:  MOVLW  0E
006D4:  ADDWF  x6E,W
006D6:  MOVWF  FE9
006D8:  MOVLW  00
006DA:  ADDWFC x6F,W
006DC:  MOVWF  FEA
006DE:  BSF    FEF.2
....................             } 
....................          } 
....................       } 
....................       sw->timer = clock; 
006E0:  MOVLW  0A
006E2:  ADDWF  x6E,W
006E4:  MOVWF  FE9
006E6:  MOVLW  00
006E8:  ADDWFC x6F,W
006EA:  MOVWF  FEA
006EC:  MOVFF  40D,FEF
006F0:  MOVFF  40E,FEC
006F4:  MOVFF  40F,FEC
006F8:  MOVFF  410,FEC
....................    } 
....................  //  onOffHelper(sw); 
....................    if (last_level!=sw->current_level)  
006FC:  MOVLW  09
006FE:  ADDWF  x6E,W
00700:  MOVWF  FE9
00702:  MOVLW  00
00704:  ADDWFC x6F,W
00706:  MOVWF  FEA
00708:  MOVF   FEF,W
0070A:  SUBWF  x70,W
0070C:  BZ    0744
....................    { 
....................       sw->dim_level.value=sw->current_level; 
0070E:  MOVLW  01
00710:  ADDWF  x6E,W
00712:  MOVWF  01
00714:  MOVLW  00
00716:  ADDWFC x6F,W
00718:  MOVWF  03
0071A:  MOVLW  09
0071C:  ADDWF  x6E,W
0071E:  MOVWF  FE9
00720:  MOVLW  00
00722:  ADDWFC x6F,W
00724:  MOVWF  FEA
00726:  MOVFF  FEF,473
0072A:  MOVFF  03,FEA
0072E:  MOVFF  01,FE9
00732:  MOVFF  473,FEF
....................       sw->dim_level.needs_update=true; 
00736:  MOVLW  02
00738:  ADDWF  x6E,W
0073A:  MOVWF  FE9
0073C:  MOVLW  00
0073E:  ADDWFC x6F,W
00740:  MOVWF  FEA
00742:  BSF    FEF.0
....................    } 
.................... } 
00744:  MOVLB  0
00746:  GOTO   0D18 (RETURN)
....................  
.................... void read_inputs() 
.................... { 
....................   int x; 
....................    for(x=0;x<mydevices.numberOfInputs;++x) 
*
008E4:  MOVLB  4
008E6:  CLRF   x6B
008E8:  MOVLB  1
008EA:  MOVF   x3A,W
008EC:  MOVLB  4
008EE:  SUBWF  x6B,W
008F0:  BTFSC  FD8.0
008F2:  BRA    0D1E
....................    { 
....................       switch (((struct inputs)mydevices.myinputs[x]).type) { 
008F4:  CLRF   x6D
008F6:  MOVFF  46B,46C
008FA:  CLRF   x6F
008FC:  MOVLW  12
008FE:  MOVWF  x6E
00900:  MOVLB  0
00902:  RCALL  030E
00904:  MOVFF  02,03
00908:  MOVF   01,W
0090A:  ADDLW  3C
0090C:  MOVWF  01
0090E:  MOVLW  01
00910:  ADDWFC 03,F
00912:  MOVFF  01,FE9
00916:  MOVFF  03,FEA
0091A:  MOVF   FEF,W
0091C:  BZ    0932
0091E:  XORLW  03
00920:  BTFSC  FD8.2
00922:  BRA    0A78
00924:  XORLW  02
00926:  BTFSC  FD8.2
00928:  BRA    0A7A
0092A:  XORLW  03
0092C:  BTFSC  FD8.2
0092E:  BRA    0BC4
00930:  BRA    0D16
....................     case dimmer_switch: 
....................            // printf("aki"); 
....................             if (input (((struct dimmer_switch)mydevices.myinputs[x].device).realbutton))  
00932:  MOVLB  4
00934:  CLRF   x6D
00936:  MOVFF  46B,46C
0093A:  CLRF   x6F
0093C:  MOVLW  12
0093E:  MOVWF  x6E
00940:  MOVLB  0
00942:  RCALL  030E
00944:  MOVF   01,W
00946:  ADDLW  02
00948:  MOVLB  4
0094A:  MOVWF  x6C
0094C:  MOVLW  00
0094E:  ADDWFC 02,W
00950:  MOVWF  x6D
00952:  MOVLW  01
00954:  ADDWF  x6C,W
00956:  MOVWF  01
00958:  MOVLW  00
0095A:  ADDWFC x6D,W
0095C:  MOVWF  03
0095E:  MOVF   01,W
00960:  ADDLW  3A
00962:  MOVWF  01
00964:  MOVLW  01
00966:  ADDWFC 03,F
00968:  MOVF   01,W
0096A:  ADDLW  10
0096C:  MOVWF  FE9
0096E:  MOVLW  00
00970:  ADDWFC 03,W
00972:  MOVWF  FEA
00974:  MOVFF  FEF,46E
00978:  MOVFF  46E,46F
0097C:  MOVLW  01
0097E:  MOVWF  x70
00980:  MOVLW  0F
00982:  MOVWF  x72
00984:  MOVLW  92
00986:  MOVWF  x71
00988:  MOVLB  0
0098A:  RCALL  0330
0098C:  MOVFF  46E,46F
00990:  MOVLW  0F
00992:  MOVLB  4
00994:  MOVWF  x71
00996:  MOVLW  80
00998:  MOVWF  x70
0099A:  MOVLB  0
0099C:  RCALL  0372
0099E:  BTFSS  01.0
009A0:  BRA    09EA
....................             { 
....................                ((struct dimmer_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
009A2:  MOVLB  4
009A4:  CLRF   x6D
009A6:  MOVFF  46B,46C
009AA:  CLRF   x6F
009AC:  MOVLW  12
009AE:  MOVWF  x6E
009B0:  MOVLB  0
009B2:  RCALL  030E
009B4:  MOVF   01,W
009B6:  ADDLW  02
009B8:  MOVLB  4
009BA:  MOVWF  x6C
009BC:  MOVLW  00
009BE:  ADDWFC 02,W
009C0:  MOVWF  x6D
009C2:  MOVLW  01
009C4:  ADDWF  x6C,W
009C6:  MOVWF  01
009C8:  MOVLW  00
009CA:  ADDWFC x6D,W
009CC:  MOVWF  03
009CE:  MOVF   01,W
009D0:  ADDLW  3A
009D2:  MOVWF  01
009D4:  MOVLW  01
009D6:  ADDWFC 03,F
009D8:  MOVF   01,W
009DA:  ADDLW  0E
009DC:  MOVWF  FE9
009DE:  MOVLW  00
009E0:  ADDWFC 03,W
009E2:  MOVWF  FEA
009E4:  BSF    FEF.0
....................             } 
....................             else  
009E6:  BRA    0A2E
009E8:  MOVLB  0
....................             { 
....................                ((struct dimmer_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
009EA:  MOVLB  4
009EC:  CLRF   x6D
009EE:  MOVFF  46B,46C
009F2:  CLRF   x6F
009F4:  MOVLW  12
009F6:  MOVWF  x6E
009F8:  MOVLB  0
009FA:  RCALL  030E
009FC:  MOVF   01,W
009FE:  ADDLW  02
00A00:  MOVLB  4
00A02:  MOVWF  x6C
00A04:  MOVLW  00
00A06:  ADDWFC 02,W
00A08:  MOVWF  x6D
00A0A:  MOVLW  01
00A0C:  ADDWF  x6C,W
00A0E:  MOVWF  01
00A10:  MOVLW  00
00A12:  ADDWFC x6D,W
00A14:  MOVWF  03
00A16:  MOVF   01,W
00A18:  ADDLW  3A
00A1A:  MOVWF  01
00A1C:  MOVLW  01
00A1E:  ADDWFC 03,F
00A20:  MOVF   01,W
00A22:  ADDLW  0E
00A24:  MOVWF  FE9
00A26:  MOVLW  00
00A28:  ADDWFC 03,W
00A2A:  MOVWF  FEA
00A2C:  BCF    FEF.0
....................             } 
....................             process_dimmers(&mydevices.myinputs[x].device); 
00A2E:  CLRF   x6D
00A30:  MOVFF  46B,46C
00A34:  CLRF   x6F
00A36:  MOVLW  12
00A38:  MOVWF  x6E
00A3A:  MOVLB  0
00A3C:  RCALL  030E
00A3E:  MOVF   01,W
00A40:  ADDLW  02
00A42:  MOVLB  4
00A44:  MOVWF  x6C
00A46:  MOVLW  00
00A48:  ADDWFC 02,W
00A4A:  MOVWF  x6D
00A4C:  MOVLW  01
00A4E:  ADDWF  x6C,W
00A50:  MOVWF  01
00A52:  MOVLW  00
00A54:  ADDWFC x6D,W
00A56:  MOVWF  03
00A58:  MOVF   01,W
00A5A:  ADDLW  3A
00A5C:  MOVWF  01
00A5E:  MOVLW  01
00A60:  ADDWFC 03,F
00A62:  MOVFF  01,46C
00A66:  MOVFF  03,46D
00A6A:  MOVFF  03,46F
00A6E:  MOVFF  01,46E
00A72:  MOVLB  0
00A74:  BRA    03A4
....................             break; 
00A76:  BRA    0D18
....................     case timer: 
....................  
....................            break; 
00A78:  BRA    0D18
....................     case on_off_switch: 
....................            // printf("aki"); 
....................             if (input (((struct on_off_switch)mydevices.myinputs[x].device).realbutton))  
00A7A:  MOVLB  4
00A7C:  CLRF   x6D
00A7E:  MOVFF  46B,46C
00A82:  CLRF   x6F
00A84:  MOVLW  12
00A86:  MOVWF  x6E
00A88:  MOVLB  0
00A8A:  RCALL  030E
00A8C:  MOVF   01,W
00A8E:  ADDLW  02
00A90:  MOVLB  4
00A92:  MOVWF  x6C
00A94:  MOVLW  00
00A96:  ADDWFC 02,W
00A98:  MOVWF  x6D
00A9A:  MOVLW  01
00A9C:  ADDWF  x6C,W
00A9E:  MOVWF  01
00AA0:  MOVLW  00
00AA2:  ADDWFC x6D,W
00AA4:  MOVWF  03
00AA6:  MOVF   01,W
00AA8:  ADDLW  3A
00AAA:  MOVWF  01
00AAC:  MOVLW  01
00AAE:  ADDWFC 03,F
00AB0:  MOVF   01,W
00AB2:  ADDLW  0C
00AB4:  MOVWF  FE9
00AB6:  MOVLW  00
00AB8:  ADDWFC 03,W
00ABA:  MOVWF  FEA
00ABC:  MOVFF  FEF,46E
00AC0:  MOVFF  46E,46F
00AC4:  MOVLW  01
00AC6:  MOVWF  x70
00AC8:  MOVLW  0F
00ACA:  MOVWF  x72
00ACC:  MOVLW  92
00ACE:  MOVWF  x71
00AD0:  MOVLB  0
00AD2:  RCALL  0330
00AD4:  MOVFF  46E,46F
00AD8:  MOVLW  0F
00ADA:  MOVLB  4
00ADC:  MOVWF  x71
00ADE:  MOVLW  80
00AE0:  MOVWF  x70
00AE2:  MOVLB  0
00AE4:  RCALL  0372
00AE6:  BTFSS  01.0
00AE8:  BRA    0B32
....................             { 
....................                ((struct on_off_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
00AEA:  MOVLB  4
00AEC:  CLRF   x6D
00AEE:  MOVFF  46B,46C
00AF2:  CLRF   x6F
00AF4:  MOVLW  12
00AF6:  MOVWF  x6E
00AF8:  MOVLB  0
00AFA:  RCALL  030E
00AFC:  MOVF   01,W
00AFE:  ADDLW  02
00B00:  MOVLB  4
00B02:  MOVWF  x6C
00B04:  MOVLW  00
00B06:  ADDWFC 02,W
00B08:  MOVWF  x6D
00B0A:  MOVLW  01
00B0C:  ADDWF  x6C,W
00B0E:  MOVWF  01
00B10:  MOVLW  00
00B12:  ADDWFC x6D,W
00B14:  MOVWF  03
00B16:  MOVF   01,W
00B18:  ADDLW  3A
00B1A:  MOVWF  01
00B1C:  MOVLW  01
00B1E:  ADDWFC 03,F
00B20:  MOVF   01,W
00B22:  ADDLW  06
00B24:  MOVWF  FE9
00B26:  MOVLW  00
00B28:  ADDWFC 03,W
00B2A:  MOVWF  FEA
00B2C:  BSF    FEF.0
....................             } 
....................             else  
00B2E:  BRA    0B78
00B30:  MOVLB  0
....................             { 
....................                ((struct on_off_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
00B32:  MOVLB  4
00B34:  CLRF   x6D
00B36:  MOVFF  46B,46C
00B3A:  CLRF   x6F
00B3C:  MOVLW  12
00B3E:  MOVWF  x6E
00B40:  MOVLB  0
00B42:  CALL   030E
00B46:  MOVF   01,W
00B48:  ADDLW  02
00B4A:  MOVLB  4
00B4C:  MOVWF  x6C
00B4E:  MOVLW  00
00B50:  ADDWFC 02,W
00B52:  MOVWF  x6D
00B54:  MOVLW  01
00B56:  ADDWF  x6C,W
00B58:  MOVWF  01
00B5A:  MOVLW  00
00B5C:  ADDWFC x6D,W
00B5E:  MOVWF  03
00B60:  MOVF   01,W
00B62:  ADDLW  3A
00B64:  MOVWF  01
00B66:  MOVLW  01
00B68:  ADDWFC 03,F
00B6A:  MOVF   01,W
00B6C:  ADDLW  06
00B6E:  MOVWF  FE9
00B70:  MOVLW  00
00B72:  ADDWFC 03,W
00B74:  MOVWF  FEA
00B76:  BCF    FEF.0
....................             } 
....................             process_onOff(&mydevices.myinputs[x].device); 
00B78:  CLRF   x6D
00B7A:  MOVFF  46B,46C
00B7E:  CLRF   x6F
00B80:  MOVLW  12
00B82:  MOVWF  x6E
00B84:  MOVLB  0
00B86:  CALL   030E
00B8A:  MOVF   01,W
00B8C:  ADDLW  02
00B8E:  MOVLB  4
00B90:  MOVWF  x6C
00B92:  MOVLW  00
00B94:  ADDWFC 02,W
00B96:  MOVWF  x6D
00B98:  MOVLW  01
00B9A:  ADDWF  x6C,W
00B9C:  MOVWF  01
00B9E:  MOVLW  00
00BA0:  ADDWFC x6D,W
00BA2:  MOVWF  03
00BA4:  MOVF   01,W
00BA6:  ADDLW  3A
00BA8:  MOVWF  01
00BAA:  MOVLW  01
00BAC:  ADDWFC 03,F
00BAE:  MOVFF  01,46C
00BB2:  MOVFF  03,46D
00BB6:  MOVFF  03,46F
00BBA:  MOVFF  01,46E
00BBE:  MOVLB  0
00BC0:  BRA    074A
....................     break; 
00BC2:  BRA    0D18
....................     case button_switch: 
....................            // printf("aki"); 
....................             if (input (((struct button_switch)mydevices.myinputs[x].device).realbutton))  
00BC4:  MOVLB  4
00BC6:  CLRF   x6D
00BC8:  MOVFF  46B,46C
00BCC:  CLRF   x6F
00BCE:  MOVLW  12
00BD0:  MOVWF  x6E
00BD2:  MOVLB  0
00BD4:  CALL   030E
00BD8:  MOVF   01,W
00BDA:  ADDLW  02
00BDC:  MOVLB  4
00BDE:  MOVWF  x6C
00BE0:  MOVLW  00
00BE2:  ADDWFC 02,W
00BE4:  MOVWF  x6D
00BE6:  MOVLW  01
00BE8:  ADDWF  x6C,W
00BEA:  MOVWF  01
00BEC:  MOVLW  00
00BEE:  ADDWFC x6D,W
00BF0:  MOVWF  03
00BF2:  MOVF   01,W
00BF4:  ADDLW  3A
00BF6:  MOVWF  01
00BF8:  MOVLW  01
00BFA:  ADDWFC 03,F
00BFC:  MOVF   01,W
00BFE:  ADDLW  0C
00C00:  MOVWF  FE9
00C02:  MOVLW  00
00C04:  ADDWFC 03,W
00C06:  MOVWF  FEA
00C08:  MOVFF  FEF,46E
00C0C:  MOVFF  46E,46F
00C10:  MOVLW  01
00C12:  MOVWF  x70
00C14:  MOVLW  0F
00C16:  MOVWF  x72
00C18:  MOVLW  92
00C1A:  MOVWF  x71
00C1C:  MOVLB  0
00C1E:  CALL   0330
00C22:  MOVFF  46E,46F
00C26:  MOVLW  0F
00C28:  MOVLB  4
00C2A:  MOVWF  x71
00C2C:  MOVLW  80
00C2E:  MOVWF  x70
00C30:  MOVLB  0
00C32:  CALL   0372
00C36:  BTFSS  01.0
00C38:  BRA    0C84
....................             { 
....................                ((struct button_switch)mydevices.myinputs[x].device).current_state = button_depressed; 
00C3A:  MOVLB  4
00C3C:  CLRF   x6D
00C3E:  MOVFF  46B,46C
00C42:  CLRF   x6F
00C44:  MOVLW  12
00C46:  MOVWF  x6E
00C48:  MOVLB  0
00C4A:  CALL   030E
00C4E:  MOVF   01,W
00C50:  ADDLW  02
00C52:  MOVLB  4
00C54:  MOVWF  x6C
00C56:  MOVLW  00
00C58:  ADDWFC 02,W
00C5A:  MOVWF  x6D
00C5C:  MOVLW  01
00C5E:  ADDWF  x6C,W
00C60:  MOVWF  01
00C62:  MOVLW  00
00C64:  ADDWFC x6D,W
00C66:  MOVWF  03
00C68:  MOVF   01,W
00C6A:  ADDLW  3A
00C6C:  MOVWF  01
00C6E:  MOVLW  01
00C70:  ADDWFC 03,F
00C72:  MOVF   01,W
00C74:  ADDLW  06
00C76:  MOVWF  FE9
00C78:  MOVLW  00
00C7A:  ADDWFC 03,W
00C7C:  MOVWF  FEA
00C7E:  BSF    FEF.0
....................             } 
....................             else  
00C80:  BRA    0CCA
00C82:  MOVLB  0
....................             { 
....................                ((struct button_switch)mydevices.myinputs[x].device).current_state = button_pressed; 
00C84:  MOVLB  4
00C86:  CLRF   x6D
00C88:  MOVFF  46B,46C
00C8C:  CLRF   x6F
00C8E:  MOVLW  12
00C90:  MOVWF  x6E
00C92:  MOVLB  0
00C94:  CALL   030E
00C98:  MOVF   01,W
00C9A:  ADDLW  02
00C9C:  MOVLB  4
00C9E:  MOVWF  x6C
00CA0:  MOVLW  00
00CA2:  ADDWFC 02,W
00CA4:  MOVWF  x6D
00CA6:  MOVLW  01
00CA8:  ADDWF  x6C,W
00CAA:  MOVWF  01
00CAC:  MOVLW  00
00CAE:  ADDWFC x6D,W
00CB0:  MOVWF  03
00CB2:  MOVF   01,W
00CB4:  ADDLW  3A
00CB6:  MOVWF  01
00CB8:  MOVLW  01
00CBA:  ADDWFC 03,F
00CBC:  MOVF   01,W
00CBE:  ADDLW  06
00CC0:  MOVWF  FE9
00CC2:  MOVLW  00
00CC4:  ADDWFC 03,W
00CC6:  MOVWF  FEA
00CC8:  BCF    FEF.0
....................             } 
....................             process_buttons(&mydevices.myinputs[x].device); 
00CCA:  CLRF   x6D
00CCC:  MOVFF  46B,46C
00CD0:  CLRF   x6F
00CD2:  MOVLW  12
00CD4:  MOVWF  x6E
00CD6:  MOVLB  0
00CD8:  CALL   030E
00CDC:  MOVF   01,W
00CDE:  ADDLW  02
00CE0:  MOVLB  4
00CE2:  MOVWF  x6C
00CE4:  MOVLW  00
00CE6:  ADDWFC 02,W
00CE8:  MOVWF  x6D
00CEA:  MOVLW  01
00CEC:  ADDWF  x6C,W
00CEE:  MOVWF  01
00CF0:  MOVLW  00
00CF2:  ADDWFC x6D,W
00CF4:  MOVWF  03
00CF6:  MOVF   01,W
00CF8:  ADDLW  3A
00CFA:  MOVWF  01
00CFC:  MOVLW  01
00CFE:  ADDWFC 03,F
00D00:  MOVFF  01,46C
00D04:  MOVFF  03,46D
00D08:  MOVFF  03,46F
00D0C:  MOVFF  01,46E
00D10:  MOVLB  0
00D12:  BRA    0832
....................     break; 
00D14:  BRA    0D18
....................     default: 
....................  
....................             break;  
00D16:  BRA    0D18
....................             } 
....................  
....................    } 
00D18:  MOVLB  4
00D1A:  INCF   x6B,F
00D1C:  BRA    08E8
.................... } 
00D1E:  MOVLB  0
00D20:  GOTO   0D3E (RETURN)
.................... void print_inputs(int1 disable_updates) 
.................... { 
....................    int x; 
....................     
....................    { 
....................       delay_ms (200) ; 
....................       for(x=0;x<mydevices.numberOfInputs;++x) 
....................       { 
....................          switch (((struct inputs)mydevices.myinputs[x]).type) { 
....................             case dimmer_switch: 
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.needs_update) 
....................                { 
....................                   printf("dim_level %u\n\r"((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.value); 
....................                   if(disable_updates)((struct dimmer_switch)mydevices.myinputs[0].device).dim_level.needs_update=false; 
....................                } 
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).on.needs_update) 
....................                { 
....................                   printf("on %u\n\r",((struct dimmer_switch)mydevices.myinputs[0].device).on.value); 
....................                   if(disable_updates)((struct dimmer_switch)mydevices.myinputs[0].device).on.needs_update=false; 
....................                }            
....................                if(((struct dimmer_switch)mydevices.myinputs[0].device).off.needs_update) 
....................                { 
....................                   printf("off %u\n\r",((struct dimmer_switch)mydevices.myinputs[0].device).off.value); 
....................                   if(disable_updates)((struct dimmer_switch)mydevices.myinputs[0].device).off.needs_update=false; 
....................                } 
....................                break; 
....................             case on_off_switch: 
....................                if(((struct on_off_switch)mydevices.myinputs[0].device).on.needs_update) 
....................                { 
....................                   printf("on %u\n\r",((struct on_off_switch)mydevices.myinputs[0].device).on.value); 
....................                   if(disable_updates)((struct on_off_switch)mydevices.myinputs[0].device).on.needs_update=false; 
....................                }            
....................                if(((struct on_off_switch)mydevices.myinputs[0].device).off.needs_update) 
....................                { 
....................                   printf("off %u\n\r",((struct on_off_switch)mydevices.myinputs[0].device).off.value); 
....................                   if(disable_updates)((struct on_off_switch)mydevices.myinputs[0].device).off.needs_update=false; 
....................                } 
....................             break; 
....................             case button_switch: 
....................                if(((struct button_switch)mydevices.myinputs[0].device).on.needs_update) 
....................                { 
....................                   printf("on %u\n\r",((struct button_switch)mydevices.myinputs[0].device).on.value); 
....................                   if(disable_updates)((struct button_switch)mydevices.myinputs[0].device).on.needs_update=false; 
....................                }            
....................                if(((struct button_switch)mydevices.myinputs[0].device).off.needs_update) 
....................                { 
....................                   printf("off %u\n\r",((struct button_switch)mydevices.myinputs[0].device).off.value); 
....................                   if(disable_updates)((struct button_switch)mydevices.myinputs[0].device).off.needs_update=false; 
....................                } 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... #include "interrupt_functions.c" 
.................... int1 flag=0;//mains not detected flag 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  
.................... { 
....................    ++clock; 
00D24:  MOVLW  01
00D26:  MOVLB  4
00D28:  ADDWF  x0D,F
00D2A:  BTFSC  FD8.0
00D2C:  INCF   x0E,F
00D2E:  BTFSC  FD8.2
00D30:  INCF   x0F,F
00D32:  BTFSC  FD8.2
00D34:  INCF   x10,F
....................    if (bit_test (clock, 1)) read_inputs(); 
00D36:  BTFSS  x0D.1
00D38:  BRA    0D40
00D3A:  MOVLB  0
00D3C:  BRA    08E4
00D3E:  MOVLB  4
.................... } 
....................  
00D40:  BCF    FF2.2
00D42:  MOVLB  0
00D44:  GOTO   011C
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................    flag = 1; 
00D48:  BSF    xB1.4
.................... } 
00D4A:  BCF    F9E.0
00D4C:  GOTO   011C
.................... #int_TIMER2 
.................... void  TIMER2_isr(void)  
.................... { 
....................    static unsigned int32 clockT2; 
....................    static unsigned int clockT2temp; 
....................    //static int lixo=0; 
....................    ++clockT2temp; 
00D50:  MOVLB  4
00D52:  INCF   x1A,F
....................    if(clockT2temp==200) 
00D54:  MOVF   x1A,W
00D56:  SUBLW  C8
00D58:  BNZ   0D70
....................    { 
....................       output_toggle(LED); 
00D5A:  BCF    F96.2
00D5C:  BTG    F8D.2
....................       clockT2temp=0; 
00D5E:  CLRF   x1A
....................       ++clockT2; 
00D60:  MOVLW  01
00D62:  ADDWF  x16,F
00D64:  BTFSC  FD8.0
00D66:  INCF   x17,F
00D68:  BTFSC  FD8.2
00D6A:  INCF   x18,F
00D6C:  BTFSC  FD8.2
00D6E:  INCF   x19,F
....................       /* 
....................       if(!lixo) 
....................       { 
....................          ++((struct light)mydevices.myoutputs[0].device).dim_value.value; 
....................          ((struct light)mydevices.myoutputs[0].device).dim_value.needs_update=true; 
....................       } 
....................       else 
....................       { 
....................          --((struct light)mydevices.myoutputs[0].device).dim_value.value; 
....................          ((struct light)mydevices.myoutputs[0].device).dim_value.needs_update=true; 
....................       } 
....................       if(((struct light)mydevices.myoutputs[0].device).dim_value.value==127) 
....................          lixo=1; 
....................       else if(((struct light)mydevices.myoutputs[0].device).dim_value.value==0) 
....................          lixo=0; 
....................       */ 
....................    } 
.................... } 
....................  
00D70:  BCF    F9E.1
00D72:  MOVLB  0
00D74:  GOTO   011C
.................... #int_EXT 
.................... void  EXT_isr(void)  
.................... { 
....................           
....................   // set_timer1 (0) ; 
....................          portc=0xFF; 
00D78:  MOVLW  FF
00D7A:  MOVWF  F82
....................          portd=0xFF; 
00D7C:  MOVWF  F83
....................          if (organizado) 
00D7E:  BTFSS  xB1.2
00D80:  BRA    0DA4
....................          { 
....................             organizado=0; 
00D82:  BCF    xB1.2
....................             if (actmat)  
00D84:  BTFSS  xB1.3
00D86:  BRA    0D98
....................             { 
....................                actmat=0; 
00D88:  BCF    xB1.3
....................                pointer=delays1; 
00D8A:  MOVLW  03
00D8C:  MOVLB  3
00D8E:  MOVWF  x50
00D90:  MOVLW  65
00D92:  MOVWF  x4F
....................             } 
....................             else 
00D94:  BRA    0DA4
00D96:  MOVLB  0
....................             { 
....................                actmat=1; 
00D98:  BSF    xB1.3
....................                pointer=delays2; 
00D9A:  MOVLW  03
00D9C:  MOVLB  3
00D9E:  MOVWF  x50
00DA0:  MOVLW  A9
00DA2:  MOVWF  x4F
....................             } 
....................          } 
....................          vez=0; 
00DA4:  MOVLB  3
00DA6:  CLRF   x51
....................          CCP_1=matrizluz[fpointer(0,0)]; 
00DA8:  MOVLB  4
00DAA:  CLRF   x6D
00DAC:  CLRF   x6E
*
00E18:  MOVFF  02,46C
00E1C:  MOVFF  01,46B
00E20:  BCF    FD8.0
00E22:  RLCF   01,W
00E24:  MOVWF  02
00E26:  RLCF   x6C,W
00E28:  MOVWF  03
00E2A:  MOVF   02,W
00E2C:  MOVLB  0
00E2E:  CALL   01A6
00E32:  TBLRD*+
00E34:  MOVFF  FF5,03
00E38:  MOVWF  FBE
00E3A:  MOVFF  03,FBF
....................          mnumluzes=fpointer(N_LUZES,0); 
00E3E:  MOVLW  10
00E40:  MOVLB  4
00E42:  MOVWF  x6D
00E44:  CLRF   x6E
*
00EB0:  MOVFF  01,352
....................          set_timer1(0); 
00EB4:  CLRF   FCF
00EB6:  CLRF   FCE
.................... } 
....................  
00EB8:  BCF    FF2.1
00EBA:  MOVLB  0
00EBC:  GOTO   011C
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
.................... } 
....................  
00EC0:  BCF    F9E.5
00EC2:  GOTO   011C
.................... #int_TBE 
.................... void  TBE_isr(void)  
.................... { 
.................... } 
....................  
00EC6:  BCF    F9E.4
00EC8:  GOTO   011C
.................... #int_BUSCOL 
.................... void  BUSCOL_isr(void)  
.................... { 
.................... } 
....................  
00ECC:  BCF    FA1.3
00ECE:  GOTO   011C
.................... #int_OSCF 
.................... void  OSCF_isr(void)  
.................... { 
.................... } 
....................  
00ED2:  BCF    FA1.7
00ED4:  GOTO   011C
.................... #int_canrx0 
.................... void canrx0_int ( )  
.................... { 
....................    canReceive (); 
*
01480:  RCALL  10D0
....................    // TODO: add CAN recieve code here 
.................... } 
....................  
01482:  BCF    FA4.0
01484:  GOTO   011C
.................... #int_canrx1 
.................... void canrx1_int ( )  
.................... { 
....................    canReceive (); 
01488:  RCALL  10D0
....................    // TODO: add CAN recieve code here 
.................... } 
....................  
0148A:  BCF    FA4.1
0148C:  GOTO   011C
.................... #int_cantx0 
.................... void cantx0_int ( )  
.................... { 
....................    canTransmit (); 
*
018B0:  RCALL  1696
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
018B2:  BCF    FA4.2
018B4:  GOTO   011C
.................... #int_cantx1 
.................... void cantx1_int ( )  
.................... { 
....................    canTransmit (); 
018B8:  RCALL  1696
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
018BA:  BCF    FA4.3
018BC:  GOTO   011C
.................... #int_cantx2 
.................... void cantx2_int ( )  
.................... { 
....................    canTransmit (); 
018C0:  RCALL  1696
....................    // TODO: add CAN transmit code here 
.................... } 
....................  
018C2:  BCF    FA4.4
018C4:  GOTO   011C
.................... #int_canirx 
.................... void canirx_int ( )  
.................... { 
....................    // TODO: add CAN IRX handling code here 
.................... } 
....................  
018C8:  BCF    FA4.7
018CA:  GOTO   011C
.................... #int_canerr 
.................... void canerr_int ( )  
.................... { 
....................    // TODO: add CAN error handling code here 
.................... } 
....................  
018CE:  BCF    FA4.5
018D0:  GOTO   011C
.................... #int_CCP1 
.................... void CCP1_isr(void)  
.................... { 
....................    if(mnumluzes!=0) 
018D4:  MOVLB  3
018D6:  MOVF   x52,F
018D8:  BTFSC  FD8.2
018DA:  BRA    1A00
....................    { 
....................       int16 auxccp=fpointer(vez,1); 
018DC:  MOVFF  351,46D
018E0:  MOVLW  01
018E2:  MOVLB  4
018E4:  MOVWF  x6E
*
01950:  MOVFF  02,46C
01954:  MOVFF  01,46B
....................      // printf("AUXCPP %lu",auxccp); 
....................       portc=(portc & MAKE8(auxccp,1)); 
01958:  MOVF   x6C,W
0195A:  ANDWF  F82,F
....................       portd=(portd & MAKE8(auxccp,0)); 
0195C:  MOVF   x6B,W
0195E:  ANDWF  F83,F
....................       ++vez; 
01960:  MOVLB  3
01962:  INCF   x51,F
....................       --mnumluzes; 
01964:  DECF   x52,F
....................       CCP_1=matrizluz[fpointer(vez,0)]; 
01966:  MOVFF  351,46D
0196A:  MOVLB  4
0196C:  CLRF   x6E
*
019D8:  MOVFF  02,46E
019DC:  MOVFF  01,46D
019E0:  BCF    FD8.0
019E2:  RLCF   01,W
019E4:  MOVWF  02
019E6:  RLCF   x6E,W
019E8:  MOVWF  03
019EA:  MOVF   02,W
019EC:  MOVLB  0
019EE:  CALL   01A6
019F2:  TBLRD*+
019F4:  MOVFF  FF5,03
019F8:  MOVWF  FBE
019FA:  MOVFF  03,FBF
019FE:  MOVLB  3
....................    } 
.................... } 
....................  
01A00:  BCF    F9E.2
01A02:  MOVLB  0
01A04:  GOTO   011C
.................... void interrupts_enable() 
.................... { 
....................    enable_interrupts (int_canrx0); 
*
030BA:  BSF    FA3.0
....................    enable_interrupts (int_canrx1); 
030BC:  BSF    FA3.1
....................    enable_interrupts (int_cantx0); 
030BE:  BSF    FA3.2
....................    enable_interrupts (int_cantx1); 
030C0:  BSF    FA3.3
....................    enable_interrupts (int_cantx2); 
030C2:  BSF    FA3.4
....................    enable_interrupts (int_canirx); 
030C4:  BSF    FA3.7
....................    enable_interrupts (int_canerr); 
030C6:  BSF    FA3.5
....................    enable_interrupts(INT_CCP1); 
030C8:  BSF    F9D.2
....................    enable_interrupts (int_TIMER0) ; 
030CA:  BSF    FF2.5
....................    enable_interrupts (int_TIMER2) ; 
030CC:  BSF    F9D.1
....................    enable_interrupts (int_EXT) ; 
030CE:  BSF    FF2.4
....................    //enable_interrupts (int_TBE) ; 
....................    //enable_interrupts (int_BUSCOL) ; 
....................    //enable_interrupts (int_CANIRX) ; 
....................    //enable_interrupts (int_CANERR) ; 
....................    //enable_interrupts (int_CANTX2) ; 
....................    //enable_interrupts (int_CANTX1) ; 
....................    //enable_interrupts (int_CANTX0) ; 
....................    //enable_interrupts (int_CANRX1) ; 
....................    //enable_interrupts (int_CANRX0) ; 
....................    //enable_interrupts (int_OSCF) ; 
....................    enable_interrupts (GLOBAL) ; 
030D0:  MOVLW  C0
030D2:  IORWF  FF2,F
.................... } 
030D4:  GOTO   3D20 (RETURN)
....................  
.................... #include "hw_setup.c" 
.................... void hw_setup() 
.................... { 
....................    ////CAN_BUS SETUP 
....................    can_init () ; 
*
01BD4:  BRA    1A80
....................    can_set_mode (CAN_OP_CONFIG) ;   
01BD6:  MOVLW  04
01BD8:  MOVLB  4
01BDA:  MOVWF  x1D
01BDC:  MOVLB  0
01BDE:  RCALL  1A2A
....................    BRGCON1.brp = 4; 
01BE0:  MOVLW  C0
01BE2:  ANDWF  F70,W
01BE4:  IORLW  04
01BE6:  MOVWF  F70
....................    BRGCON1.sjw = 0; 
01BE8:  MOVLW  3F
01BEA:  ANDWF  F70,W
01BEC:  MOVWF  F70
....................    BRGCON2.prseg = 2; 
01BEE:  MOVLW  F8
01BF0:  ANDWF  F71,W
01BF2:  IORLW  02
01BF4:  MOVWF  F71
....................    BRGCON2.seg1ph = 5; 
01BF6:  MOVLW  C7
01BF8:  ANDWF  F71,W
01BFA:  IORLW  28
01BFC:  MOVWF  F71
....................    BRGCON2.sam = FALSE; 
01BFE:  BCF    F71.6
....................    BRGCON2.seg2phts = FALSE; 
01C00:  BCF    F71.7
....................    BRGCON3.seg2ph = 5; 
01C02:  MOVLW  F8
01C04:  ANDWF  F72,W
01C06:  IORLW  05
01C08:  MOVWF  F72
....................    BRGCON3.wakfil = TRUE; 
01C0A:  BSF    F72.6
....................    can_set_mode (CAN_OP_NORMAL) ; 
01C0C:  MOVLB  4
01C0E:  CLRF   x1D
01C10:  MOVLB  0
01C12:  RCALL  1A2A
....................        
....................    ////TIMERS SETUP 
....................    setup_timer_0 (RTCC_INTERNAL | RTCC_DIV_4); //div16 1.6us thick 104ms overflow 
01C14:  MOVLW  81
01C16:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_2); 
01C18:  MOVLW  95
01C1A:  MOVWF  FCD
....................    setup_timer_2(T2_DIV_BY_16,241,13); 
01C1C:  MOVLW  60
01C1E:  IORLW  06
01C20:  MOVWF  FCA
01C22:  MOVLW  F1
01C24:  MOVWF  FCB
....................    setup_ccp1(CCP_COMPARE_INT); 
01C26:  MOVLW  0A
01C28:  MOVWF  FBD
....................    ////OTHERS 
....................    ext_int_edge(l_to_h); 
01C2A:  BSF    FF1.6
....................     
....................     
....................    /////DISABLED HW//////// 
....................    setup_adc_ports (NO_ANALOGS | VSS_VDD) ; 
01C2C:  MOVF   FC1,W
01C2E:  ANDLW  C0
01C30:  IORLW  0F
01C32:  MOVWF  FC1
....................    setup_adc (ADC_CLOCK_DIV_2 | ADC_TAD_MUL_0) ; 
01C34:  MOVF   FC0,W
01C36:  ANDLW  C0
01C38:  MOVWF  FC0
01C3A:  BCF    FC0.7
01C3C:  BSF    FC2.0
....................    setup_psp (PSP_DISABLED) ; 
01C3E:  BCF    F96.4
....................    setup_spi (SPI_SS_DISABLED) ; 
01C40:  BCF    FC6.5
01C42:  MOVLW  01
01C44:  MOVWF  FC6
01C46:  MOVLW  00
01C48:  MOVWF  FC7
....................    setup_comparator (NC_NC_NC_NC) ; 
01C4A:  MOVLW  07
01C4C:  MOVWF  FB4
01C4E:  MOVF   F95,W
01C50:  MOVWF  F95
01C52:  MOVF   F96,W
01C54:  MOVWF  F96
01C56:  CLRWDT
01C58:  MOVLW  20
01C5A:  MOVWF  00
01C5C:  DECFSZ 00,F
01C5E:  BRA    1C5C
01C60:  BRA    1C62
01C62:  MOVF   FB4,W
01C64:  BCF    FA1.6
....................    setup_vref (FALSE) ; 
01C66:  CLRF   FB5
....................    setup_timer_3 (T3_DISABLED | T3_DIV_BY_1) ; 
01C68:  CLRF   FB1
....................    //setup_wdt (WDT_ON) ; 
....................    } 
01C6A:  GOTO   3CFA (RETURN)
....................  
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... void main() 
.................... { 
*
03B0A:  CLRF   FF8
03B0C:  BCF    FD0.7
03B0E:  BSF    07.7
03B10:  CLRF   FEA
03B12:  CLRF   FE9
03B14:  BCF    F93.5
03B16:  BSF    F8A.5
03B18:  CLRF   24
03B1A:  BCF    xB1.0
03B1C:  CLRF   xB2
03B1E:  BSF    xB1.1
03B20:  MOVLB  3
03B22:  CLRF   x4E
03B24:  MOVLB  0
03B26:  BCF    xB1.3
03B28:  MOVLB  4
03B2A:  CLRF   x11
03B2C:  CLRF   x15
03B2E:  CLRF   x14
03B30:  CLRF   x13
03B32:  MOVLW  27
03B34:  MOVWF  x12
03B36:  MOVLB  0
03B38:  BCF    xB1.4
03B3A:  MOVF   FC1,W
03B3C:  ANDLW  C0
03B3E:  IORLW  0F
03B40:  MOVWF  FC1
03B42:  MOVLW  07
03B44:  MOVWF  FB4
03B46:  CLRF   1C
03B48:  MOVLW  01
03B4A:  MOVWF  1D
03B4C:  MOVLW  02
03B4E:  MOVWF  1E
03B50:  MOVLW  03
03B52:  MOVWF  1F
03B54:  MOVLW  04
03B56:  MOVWF  20
03B58:  MOVLW  05
03B5A:  MOVWF  21
03B5C:  MOVLW  20
03B5E:  MOVWF  22
03B60:  MOVLW  21
03B62:  MOVWF  23
03B64:  MOVLW  0B
03B66:  MOVLB  1
03B68:  MOVWF  x35
03B6A:  CLRF   x36
03B6C:  CLRF   x37
03B6E:  CLRF   x38
03B70:  MOVLW  0A
03B72:  MOVLB  3
03B74:  MOVWF  x55
03B76:  MOVWF  x56
03B78:  MOVWF  x57
03B7A:  MOVWF  x58
03B7C:  MOVWF  x59
03B7E:  MOVWF  x5A
03B80:  MOVWF  x5B
03B82:  MOVWF  x5C
03B84:  MOVWF  x5D
03B86:  MOVWF  x5E
03B88:  MOVWF  x5F
03B8A:  MOVWF  x60
03B8C:  MOVWF  x61
03B8E:  MOVWF  x62
03B90:  MOVWF  x63
03B92:  MOVWF  x64
03B94:  CLRF   x65
03B96:  CLRF   x66
03B98:  CLRF   x67
03B9A:  CLRF   x68
03B9C:  CLRF   x69
03B9E:  CLRF   x6A
03BA0:  MOVLW  01
03BA2:  MOVWF  x6B
03BA4:  CLRF   x6C
03BA6:  CLRF   x6D
03BA8:  CLRF   x6E
03BAA:  MOVLW  02
03BAC:  MOVWF  x6F
03BAE:  CLRF   x70
03BB0:  CLRF   x71
03BB2:  CLRF   x72
03BB4:  MOVLW  03
03BB6:  MOVWF  x73
03BB8:  CLRF   x74
03BBA:  CLRF   x75
03BBC:  CLRF   x76
03BBE:  MOVLW  04
03BC0:  MOVWF  x77
03BC2:  CLRF   x78
03BC4:  CLRF   x79
03BC6:  CLRF   x7A
03BC8:  MOVLW  05
03BCA:  MOVWF  x7B
03BCC:  CLRF   x7C
03BCE:  CLRF   x7D
03BD0:  CLRF   x7E
03BD2:  MOVLW  06
03BD4:  MOVWF  x7F
03BD6:  CLRF   x80
03BD8:  CLRF   x81
03BDA:  CLRF   x82
03BDC:  MOVLW  07
03BDE:  MOVWF  x83
03BE0:  CLRF   x84
03BE2:  CLRF   x85
03BE4:  CLRF   x86
03BE6:  MOVLW  08
03BE8:  MOVWF  x87
03BEA:  CLRF   x88
03BEC:  CLRF   x89
03BEE:  CLRF   x8A
03BF0:  MOVLW  09
03BF2:  MOVWF  x8B
03BF4:  CLRF   x8C
03BF6:  CLRF   x8D
03BF8:  CLRF   x8E
03BFA:  MOVLW  0A
03BFC:  MOVWF  x8F
03BFE:  CLRF   x90
03C00:  CLRF   x91
03C02:  CLRF   x92
03C04:  MOVLW  0B
03C06:  MOVWF  x93
03C08:  CLRF   x94
03C0A:  CLRF   x95
03C0C:  CLRF   x96
03C0E:  MOVLW  0C
03C10:  MOVWF  x97
03C12:  CLRF   x98
03C14:  CLRF   x99
03C16:  CLRF   x9A
03C18:  MOVLW  0D
03C1A:  MOVWF  x9B
03C1C:  CLRF   x9C
03C1E:  CLRF   x9D
03C20:  CLRF   x9E
03C22:  MOVLW  0E
03C24:  MOVWF  x9F
03C26:  CLRF   xA0
03C28:  CLRF   xA1
03C2A:  CLRF   xA2
03C2C:  MOVLW  0F
03C2E:  MOVWF  xA3
03C30:  CLRF   xA4
03C32:  CLRF   xA5
03C34:  CLRF   xA6
03C36:  CLRF   xA7
03C38:  CLRF   xA8
03C3A:  CLRF   xA9
03C3C:  CLRF   xAA
03C3E:  CLRF   xAB
03C40:  CLRF   xAC
03C42:  CLRF   xAD
03C44:  CLRF   xAE
03C46:  MOVLW  01
03C48:  MOVWF  xAF
03C4A:  CLRF   xB0
03C4C:  CLRF   xB1
03C4E:  CLRF   xB2
03C50:  MOVLW  02
03C52:  MOVWF  xB3
03C54:  CLRF   xB4
03C56:  CLRF   xB5
03C58:  CLRF   xB6
03C5A:  MOVLW  03
03C5C:  MOVWF  xB7
03C5E:  CLRF   xB8
03C60:  CLRF   xB9
03C62:  CLRF   xBA
03C64:  MOVLW  04
03C66:  MOVWF  xBB
03C68:  CLRF   xBC
03C6A:  CLRF   xBD
03C6C:  CLRF   xBE
03C6E:  MOVLW  05
03C70:  MOVWF  xBF
03C72:  CLRF   xC0
03C74:  CLRF   xC1
03C76:  CLRF   xC2
03C78:  MOVLW  06
03C7A:  MOVWF  xC3
03C7C:  CLRF   xC4
03C7E:  CLRF   xC5
03C80:  CLRF   xC6
03C82:  MOVLW  07
03C84:  MOVWF  xC7
03C86:  CLRF   xC8
03C88:  CLRF   xC9
03C8A:  CLRF   xCA
03C8C:  MOVLW  08
03C8E:  MOVWF  xCB
03C90:  CLRF   xCC
03C92:  CLRF   xCD
03C94:  CLRF   xCE
03C96:  MOVLW  09
03C98:  MOVWF  xCF
03C9A:  CLRF   xD0
03C9C:  CLRF   xD1
03C9E:  CLRF   xD2
03CA0:  MOVLW  0A
03CA2:  MOVWF  xD3
03CA4:  CLRF   xD4
03CA6:  CLRF   xD5
03CA8:  CLRF   xD6
03CAA:  MOVLW  0B
03CAC:  MOVWF  xD7
03CAE:  CLRF   xD8
03CB0:  CLRF   xD9
03CB2:  CLRF   xDA
03CB4:  MOVLW  0C
03CB6:  MOVWF  xDB
03CB8:  CLRF   xDC
03CBA:  CLRF   xDD
03CBC:  CLRF   xDE
03CBE:  MOVLW  0D
03CC0:  MOVWF  xDF
03CC2:  CLRF   xE0
03CC4:  CLRF   xE1
03CC6:  CLRF   xE2
03CC8:  MOVLW  0E
03CCA:  MOVWF  xE3
03CCC:  CLRF   xE4
03CCE:  CLRF   xE5
03CD0:  CLRF   xE6
03CD2:  MOVLW  0F
03CD4:  MOVWF  xE7
03CD6:  CLRF   xE8
03CD8:  CLRF   xE9
03CDA:  CLRF   xEA
03CDC:  CLRF   xEB
03CDE:  CLRF   xEC
03CE0:  MOVLB  4
03CE2:  CLRF   x16
03CE4:  CLRF   x17
03CE6:  CLRF   x18
03CE8:  CLRF   x19
03CEA:  CLRF   x1A
....................    clock = 0; 
03CEC:  CLRF   x10
03CEE:  CLRF   x0F
03CF0:  CLRF   x0E
03CF2:  CLRF   x0D
....................        
....................    hw_setup(); 
03CF4:  MOVLB  0
03CF6:  GOTO   1BD4
....................    //TODO: User Code 
....................    //struct switches array[NUMBER_OF_SWITCHES]; 
....................    
....................    button_test(); 
03CFA:  GOTO   1E32
....................    dimmer_test(); 
03CFE:  GOTO   2294
....................    dimmer_outputs_init(); 
03D02:  GOTO   293E
....................    ((struct light)mydevices.myoutputs[0].device).dim_value.value=50; 
03D06:  MOVLW  32
03D08:  MOVLB  2
03D0A:  MOVWF  x0D
....................    ((struct light)mydevices.myoutputs[0].device).dim_value.needs_update=true; 
03D0C:  BSF    x0E.0
....................    ((struct light)mydevices.myoutputs[0].device).on.value=1; 
03D0E:  MOVLW  01
03D10:  MOVLB  1
03D12:  MOVWF  xF9
....................    ((struct light)mydevices.myoutputs[0].device).on.needs_update=true; 
03D14:  BSF    xFA.0
....................   
....................    write_outputs(); 
03D16:  MOVLB  0
03D18:  CALL   2AEC
....................    interrupts_enable(); 
03D1C:  GOTO   30BA
....................    while(true){ 
....................    process_outpoints(); 
03D20:  GOTO   34FC
....................    write_outputs(); 
03D24:  CALL   2AEC
....................   // print_inputs(false); 
....................    }; 
03D28:  BRA    3D20
....................      
....................  
....................    while(organizado==0){} 
03D2A:  BTFSC  xB1.2
03D2C:  BRA    3D30
03D2E:  BRA    3D2A
....................    for(temp=0;temp<17;++temp) 
03D30:  MOVLB  1
03D32:  CLRF   x39
03D34:  MOVF   x39,W
03D36:  SUBLW  10
03D38:  BTFSS  FD8.0
03D3A:  BRA    3E84
....................    { 
....................       printf("%lu <-> %lu\n\r",fpointer(temp,0),fpointer(temp,1)); 
03D3C:  MOVFF  139,46D
03D40:  MOVLB  4
03D42:  CLRF   x6E
*
03DAE:  MOVFF  02,41E
03DB2:  MOVFF  01,41D
03DB6:  MOVFF  139,46D
03DBA:  MOVLW  01
03DBC:  MOVWF  x6E
*
03E28:  MOVFF  02,420
03E2C:  MOVFF  01,41F
03E30:  MOVLW  10
03E32:  MOVWF  FE9
03E34:  MOVFF  41E,422
03E38:  MOVFF  41D,421
03E3C:  MOVLB  0
03E3E:  RCALL  3A4C
03E40:  MOVLW  0B
03E42:  MOVWF  FF6
03E44:  MOVLW  1A
03E46:  MOVWF  FF7
03E48:  MOVLW  00
03E4A:  MOVWF  FF8
03E4C:  MOVLW  05
03E4E:  MOVLB  4
03E50:  MOVWF  x4A
03E52:  MOVLB  0
03E54:  CALL   1EAA
03E58:  MOVLW  10
03E5A:  MOVWF  FE9
03E5C:  MOVFF  420,422
03E60:  MOVFF  41F,421
03E64:  RCALL  3A4C
03E66:  MOVLW  0A
03E68:  MOVLB  4
03E6A:  MOVWF  x4E
03E6C:  MOVLB  0
03E6E:  CALL   1E56
03E72:  MOVLW  0D
03E74:  MOVLB  4
03E76:  MOVWF  x4E
03E78:  MOVLB  0
03E7A:  CALL   1E56
....................    } 
03E7E:  MOVLB  1
03E80:  INCF   x39,F
03E82:  BRA    3D34
....................     int16 auxccp=fpointer(0,1); 
03E84:  MOVLB  4
03E86:  CLRF   x6D
03E88:  MOVLW  01
03E8A:  MOVWF  x6E
*
03EF6:  MOVFF  02,41C
03EFA:  MOVFF  01,41B
....................       printf("%lu <-> %u <-> %u\n\r",auxccp,MAKE8(auxccp,1),MAKE8(auxccp,0)); 
03EFE:  MOVFF  41C,41D
03F02:  MOVFF  41B,41E
03F06:  MOVLW  10
03F08:  MOVWF  FE9
03F0A:  MOVFF  41C,422
03F0E:  MOVFF  41B,421
03F12:  MOVLB  0
03F14:  RCALL  3A4C
03F16:  MOVLW  19
03F18:  MOVWF  FF6
03F1A:  MOVLW  1A
03F1C:  MOVWF  FF7
03F1E:  MOVLW  00
03F20:  MOVWF  FF8
03F22:  MOVLW  05
03F24:  MOVLB  4
03F26:  MOVWF  x4A
03F28:  MOVLB  0
03F2A:  CALL   1EAA
03F2E:  MOVFF  41D,44A
03F32:  MOVLW  1B
03F34:  MOVLB  4
03F36:  MOVWF  x4B
03F38:  MOVLB  0
03F3A:  CALL   1F06
03F3E:  MOVLW  20
03F40:  MOVWF  FF6
03F42:  MOVLW  1A
03F44:  MOVWF  FF7
03F46:  MOVLW  00
03F48:  MOVWF  FF8
03F4A:  MOVLW  05
03F4C:  MOVLB  4
03F4E:  MOVWF  x4A
03F50:  MOVLB  0
03F52:  CALL   1EAA
03F56:  MOVFF  41E,44A
03F5A:  MOVLW  1B
03F5C:  MOVLB  4
03F5E:  MOVWF  x4B
03F60:  MOVLB  0
03F62:  CALL   1F06
03F66:  MOVLW  0A
03F68:  MOVLB  4
03F6A:  MOVWF  x4E
03F6C:  MOVLB  0
03F6E:  CALL   1E56
03F72:  MOVLW  0D
03F74:  MOVLB  4
03F76:  MOVWF  x4E
03F78:  MOVLB  0
03F7A:  CALL   1E56
....................  
.................... } 
....................  
....................  
03F7E:  BRA    3F7E

Configuration Fuses:
   Word  1: C600   H4 IESO FCMEN
   Word  2: 0E19   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0030   NOSTVREN DEBUG NOLVP NOXINST BBSIZ4K
   Word  5: C03F   NOPROTECT NOCPD NOCPB
   Word  6: E03F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 403F   NOEBTR NOEBTRB
