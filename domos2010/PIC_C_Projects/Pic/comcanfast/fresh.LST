CCS PCM C Compiler, Version 4.057, 10706               29-Ago-08 16:42

               Filename: C:\Projecto_Domotica\Pic\comcanfast\fresh.lst

               ROM used: 3466 words (42%)
                         Largest free fragment is 2048
               RAM used: 155 (42%) at main() level
                         190 (52%) worst case
               Stack:    6 worst case (4 in main + 2 for interrupts)

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   49C
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.4
001A:  GOTO   01D
001B:  BTFSC  0B.1
001C:  GOTO   036
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.2
0020:  GOTO   023
0021:  BTFSC  0C.2
0022:  GOTO   039
0023:  MOVF   22,W
0024:  MOVWF  04
0025:  MOVF   23,W
0026:  MOVWF  77
0027:  MOVF   24,W
0028:  MOVWF  78
0029:  MOVF   25,W
002A:  MOVWF  79
002B:  MOVF   26,W
002C:  MOVWF  7A
002D:  MOVF   27,W
002E:  MOVWF  7B
002F:  MOVF   20,W
0030:  MOVWF  0A
0031:  SWAPF  21,W
0032:  MOVWF  03
0033:  SWAPF  7F,F
0034:  SWAPF  7F,W
0035:  RETFIE
0036:  BCF    0A.3
0037:  BCF    0A.4
0038:  GOTO   14F
0039:  BCF    0A.3
003A:  BCF    0A.4
003B:  GOTO   199
.................... #DEFINE CDEBUG 0 
....................  
.................... #define TimeBase 10 
.................... #define reg 200 
.................... #DEFINE ADRESS 3 
.................... #DEFINE baudrate 9600 
.................... //#DEFINE baudrate 57600 
.................... #define save_adr  1 
.................... #define  cfg_adr  2 
.................... #define cfg2_adr  4 
.................... #define cfg3_adr  5 
....................  
.................... #include "fresh.h" 
.................... #include <16F876A.h> 
.................... //////// Standard Header file for the PIC16F876A device //////////////// 
.................... #device PIC16F876A 
.................... #list 
....................  
.................... #device adc=8 
.................... #device *=16 
.................... #use delay(clock=20000000) 
*
0616:  MOVLW  DC
0617:  MOVWF  04
0618:  BCF    03.7
0619:  MOVF   00,W
061A:  BTFSC  03.2
061B:  GOTO   629
061C:  MOVLW  06
061D:  MOVWF  78
061E:  CLRF   77
061F:  DECFSZ 77,F
0620:  GOTO   61F
0621:  DECFSZ 78,F
0622:  GOTO   61E
0623:  MOVLW  7B
0624:  MOVWF  77
0625:  DECFSZ 77,F
0626:  GOTO   625
0627:  DECFSZ 00,F
0628:  GOTO   61C
0629:  RETLW  00
.................... #fuses HS,NOWDT,nolvp,NOBROWNOUT 
.................... #use rs232(baud=baudrate,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................  
.................... #use fast_io(c) 
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #byte porta=0x05 
.................... #byte trisa=0x85 
.................... #byte portb=0x06 
.................... #byte trisb=0x86 
.................... #byte portc=0x07 
.................... #byte trisc=0x87 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float32 atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0CAF:  BCF    03.5
0CB0:  CLRF   28
0CB1:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................  #cdebug5      
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr) { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "mcp2510.inc" 
.................... /* 
.................... ;---------------------------------------------------------------------- 
.................... ;MCP2510.INC 
.................... ; Description:  This file contains the definitions for the MicroChip 
.................... ; standalone CANbus controller. 
.................... ; 
.................... ; 07/17/99 JPF Original Version 
.................... ; 09/11/99 JCT Modified for ASM 
.................... ;---------------------------------------------------------------------- 
.................... */ 
.................... #define RXF0SIDH	0x00 
.................... #define RXF0SIDL	0x01 
.................... #define RXF0EID8	0x02 
.................... #define RXF0EID0	0x03 
.................... #define RXF1SIDH	0x04 
.................... #define RXF1SIDL	0x05 
.................... #define RXF1EID8	0x06 
.................... #define RXF1EID0	0x07 
.................... #define RXF2SIDH	0x08 
.................... #define RXF2SIDL	0x09 
.................... #define RXF2EID8	0x0A 
.................... #define RXF2EID0	0x0B 
.................... #define BFPCTRL	0x0C 
.................... #define TXRTSCTRL	0x0D 
.................... #define CANSTAT	0x0E 
.................... #define CANCTRL	0x0F 
....................  
.................... #define RXF3SIDH	0x10 
.................... #define RXF3SIDL	0x11 
.................... #define RXF3EID8	0x12 
.................... #define RXF3EID0	0x13 
.................... #define RXF4SIDH	0x14 
.................... #define RXF4SIDL	0x15 
.................... #define RXF4EID8	0x16 
.................... #define RXF4EID0	0x17 
.................... #define RXF5SIDH	0x18 
.................... #define RXF5SIDL	0x19 
.................... #define RXF5EID8	0x1A 
.................... #define RXF5EID0	0x1B 
.................... #define TEC	0x1C 
.................... #define REC         0x1D 
.................... #define CANSTAT1	0x1E 
.................... #define CANCTRL1	0x1F 
....................  
.................... #define RXM0SIDH	0x20 
.................... #define RXM0SIDL	0x21 
.................... #define RXM0EID8	0x22 
.................... #define RXM0EID0	0x23 
.................... #define RXM1SIDH	0x24 
.................... #define RXM1SIDL	0x25 
.................... #define RXM1EID8	0x26 
.................... #define RXM1EID0	0x27 
.................... #define CNF3	0x28 
.................... #define CNF2	0x29 
.................... #define CNF1	0x2A 
.................... #define CANINTE	0x2B 
.................... #define CANINTF	0x2C 
.................... #define EFLG	0x2D 
.................... #define CANSTAT2	0x2E 
.................... #define CANCTRL2	0x2F 
....................  
.................... #define TXB0CTRL	0x30 
.................... #define TXB0SIDH	0x31 
.................... #define TXB0SIDL	0x32 
.................... #define TXB0EID8	0x33 
.................... #define TXB0EID0	0x34 
.................... #define TXB0DLC	0x35 
.................... #define TXB0D0	0x36 
.................... #define TXB0D1	0x37 
.................... #define TXB0D2	0x38 
.................... #define TXB0D3	0x39 
.................... #define TXB0D4	0x3A 
.................... #define TXB0D5	0x3B 
.................... #define TXB0D6	0x3C 
.................... #define TXB0D7	0x3D 
.................... #define CANSTAT3	0x3E 
.................... #define CANCTRL3	0x3F 
....................  
.................... #define TXB1CTRL	0x40 
.................... #define TXB1SIDH	0x41 
.................... #define TXB1SIDL	0x42 
.................... #define TXB1EID8	0x43 
.................... #define TXB1EID0	0x44 
.................... #define TXB1DLC	0x45 
.................... #define TXB1D0	0x46 
.................... #define TXB1D1	0x47 
.................... #define TXB1D2	0x48 
.................... #define TXB1D3	0x49 
.................... #define TXB1D4	0x4A 
.................... #define TXB1D5	0x4B 
.................... #define TXB1D6	0x4C 
.................... #define TXB1D7	0x4D 
.................... #define CANSTAT4	0x4E 
.................... #define CANCTRL4	0x4F 
....................  
.................... #define TXB2CTRL	0x50 
.................... #define TXB2SIDH	0x51 
.................... #define TXB2SIDL	0x52 
.................... #define TXB2EID8	0x53 
.................... #define TXB2EID0	0x54 
.................... #define TXB2DLC	0x55 
.................... #define TXB2D0	0x56 
.................... #define TXB2D1	0x57 
.................... #define TXB2D2	0x58 
.................... #define TXB2D3	0x59 
.................... #define TXB2D4	0x5A 
.................... #define TXB2D5	0x5B 
.................... #define TXB2D6	0x5C 
.................... #define TXB2D7	0x5D 
.................... #define CANSTAT5	0x5E 
.................... #define CANCTRL5	0x5F 
....................  
.................... #define RXB0CTRL	0x60 
.................... #define RXB0SIDH	0x61 
.................... #define RXB0SIDL	0x62 
.................... #define RXB0EID8	0x63 
.................... #define RXB0EID0	0x64 
.................... #define RXB0DLC	0x65 
.................... #define RXB0D0	0x66 
.................... #define RXB0D1	0x67 
.................... #define RXB0D2	0x68 
.................... #define RXB0D3	0x69 
.................... #define RXB0D4	0x6A 
.................... #define RXB0D5	0x6B 
.................... #define RXB0D6	0x6C 
.................... #define RXB0D7	0x6D 
.................... #define CANSTAT6	0x6E 
.................... #define CANCTRL6	0x6F 
....................  
.................... #define RXB1CTRL	0x70 
.................... #define RXB1SIDH	0x71 
.................... #define RXB1SIDL	0x72 
.................... #define RXB1EID8	0x73 
.................... #define RXB1EID0	0x74 
.................... #define RXB1DLC	0x75 
.................... #define RXB1D0	0x76 
.................... #define RXB1D1	0x77 
.................... #define RXB1D2	0x78 
.................... #define RXB1D3	0x79 
.................... #define RXB1D4	0x7A 
.................... #define RXB1D5	0x7B 
.................... #define RXB1D6	0x7C 
.................... #define RXB1D7	0x7D 
.................... #define CANSTAT7	0x7E 
.................... #define CANCTRL7	0x7F 
.................... /* 
.................... ;; Bit definitions 
....................  
.................... ;; Bit definitions BFPCTRL*/ 
.................... #define trB1BFS	BFPCTRL,5 
.................... #define trB0BFS	BFPCTRL,4 
.................... #define trB1BFE	BFPCTRL,3 
.................... #define trB0BFE	BFPCTRL,2 
.................... #define trB1BFM	BFPCTRL,1 
.................... #define trB0BFM	BFPCTRL,0 
....................  
.................... /*;; Bit definitions TXRTSCTRL*/ 
.................... #define trB2RTS	BFPCTRL,5 
.................... #define trB1RTS	BFPCTRL,4 
.................... #define trB0RTS	BFPCTRL,3 
.................... #define trB2RTSM	BFPCTRL,2 
.................... #define trB1RTSM	BFPCTRL,1 
.................... #define trB0RTSM	BFPCTRL,0 
....................  
.................... /*;; Bit definitions CANSTAT*/ 
.................... #define trOPMOD2	CANSTAT,7 
.................... #define trOPMOD1	CANSTAT,6 
.................... #define trOPMOD0	CANSTAT,5 
.................... #define trICOD2	CANSTAT,3 
.................... #define trICOD1	CANSTAT,2 
.................... #define trICOD0	CANSTAT,1 
....................  
.................... /*;; Bit definitions CANCTRL*/ 
.................... #define trREQOP2	CANCTRL,7 
.................... #define trREQOP1	CANCTRL,6 
.................... #define trREQOP0	CANCTRL,5 
.................... #define trABAT	CANCTRL,4 
.................... #define trCLKEN	CANCTRL,2 
.................... #define trCLKPRE1	CANCTRL,1 
.................... #define trCLKPRE0	CANCTRL,0 
....................  
.................... /*;; Dit definitions CNF3*/ 
.................... #define trWAKFIL	CNF3,6 
.................... #define trPHSEG22	CNF3,2 
.................... #define trPHSEG21	CNF3,1 
.................... #define trPHSEG20	CNF3,0 
....................  
.................... //;; Bit definitions CNF2 
.................... #define trBTLMODE	CNF2,7 
.................... #define trSAM	CNF2,6 
.................... #define trPHSEG12	CNF2,5 
.................... #define trPHSEG11	CNF2,4 
.................... #define trPHSEG10	CNF2,3 
.................... #define trPHSEG2	CNF2,2 
.................... #define trPHSEG1	CNF2,1 
.................... #define trPHSEG0	CNF2,0 
....................  
.................... //;; Bit definitions CNF1 
.................... #define trSJW1	CNF1,7 
.................... #define trSJW0	CNF1,6 
.................... #define trBRP5	CNF1,5 
.................... #define trBRP4	CNF1,4 
.................... #define trBRP3	CNF1,3 
.................... #define trBRP2	CNF1,2 
.................... #define trBRP1	CNF1,1 
.................... #define trBRP0	CNF1,0 
....................  
.................... //;; Bit definitions CANINTE 
.................... #define trMERRE	CANINTE,7 
.................... #define trWAKIE	CANINTE,6 
.................... #define trERRIE	CANINTE,5 
.................... #define trTX2IE	CANINTE,4 
.................... #define trTX1IE	CANINTE,3 
.................... #define trTX0IE	CANINTE,2 
.................... #define trRX1IE	CANINTE,1 
.................... #define trRX0IE	CANINTE,0 
....................  
.................... //;; Bit definitions CANINTF 
.................... #define trMERRF	CANINTF,7 
.................... #define trWAKIF	CANINTF,6 
.................... #define trERRIF	CANINTF,5 
.................... #define trTX2IF	CANINTF,4 
.................... #define trTX1IF	CANINTF,3 
.................... #define trTX0IF	CANINTF,2 
.................... #define trRX1IF	CANINTF,1 
.................... #define trRX0IF	CANINTF,0 
....................  
.................... //;; Bit definitions EFLG 
.................... #define trRX1OVR	EFLG,7 
.................... #define trRX0OVR	EFLG,6 
.................... #define trTXB0	EFLG,5 
.................... #define trTXEP	EFLG,4 
.................... #define trRXEP	EFLG,3 
.................... #define trTXWAR	EFLG,2 
.................... #define trRXWAR	EFLG,1 
.................... #define trEWARN	EFLG,0 
....................  
.................... //;; Bit definitions TXB0CTRL 
.................... #define trABTF0	TXB0CTRL,6 
.................... #define trMLOA0	TXB0CTRL,5 
.................... #define trTXERR0	TXB0CTRL,4 
.................... #define trTXREQ0	TXB0CTRL,3 
.................... #define trTXP10	TXB0CTRL,1 
.................... #define trTXP00	TXB0CTRL,0 
....................  
.................... //;; Bit definitions TXB1CTRL 
.................... #define trABTF1	TXB1CTRL,6 
.................... #define trMLOA1	TXB1CTRL,5 
.................... #define trTXERR1	TXB1CTRL,4 
.................... #define trTXREQ1	TXB1CTRL,3 
.................... #define trTXP11	TXB1CTRL,1 
.................... #define trTXP01	TXB1CTRL,0 
....................  
.................... //;; Bit definitions TXB2CTRL 
.................... #define trABTF2	TXB2CTRL,6 
.................... #define trMLOA2	TXB2CTRL,5 
.................... #define trTXERR2	TXB2CTRL,4 
.................... #define trTXREQ2	TXB2CTRL,3 
.................... #define trTXP12	TXB2CTRL,1 
.................... #define trTXP02	TXB2CTRL,0 
....................  
.................... //;; Bit definitions RXB0CTRL 
.................... #define trRXM10	RXB0CTRL,6 
.................... #define trRXM00	RXB0CTRL,5 
.................... #define trRXRTR0	RXB0CTRL,3 
.................... #define trBUKT01	RXB0CTRL,2 
.................... #define trBUKT00	RXB0CTRL,1 
.................... #define trFILHIT00	RXB0CTRL,0 
....................  
.................... //;; Bit definitions RXB1CTRL 
.................... #define trRXM11	RXB1CTRL,6 
.................... #define trRXM01	RXB1CTRL,5 
.................... #define trRXRTR1	RXB1CTRL,3 
.................... #define trFILHIT12	RXB1CTRL,2 
.................... #define trFILHIT11	RXB1CTRL,1 
.................... #define trFILHIT10	RXB1CTRL,0 
....................  
....................  
.................... //;; use with SPI_Rts function 
.................... #define RTS0        0x01 
.................... #define RTS1        0x02 
.................... #define RTS2        0x04 
....................  
.................... #define d2510rd     0x03 
.................... #define d2510wrt    0x02 
.................... #define d2510bitmod 0x05 
....................  
.................... #include "mcp.c" 
.................... #define cs pin_c2 
....................  
.................... void f2510wr(int end,int dado); 
.................... int f2510rd(int end); 
.................... void f2510cfg(void); 
.................... int1 f2510tx(int *pilha); 
.................... void f2510bs(int end,int bbit); 
.................... void f2510cfg_end(int end,int1 intr); 
.................... void f2510rst(void); 
.................... int f2510rx(int *bu); 
.................... void f2510bc(int end,int bbit); 
....................  
....................  
....................  
.................... void f2510wr(int end,int dado) 
.................... { 
....................    output_low(cs); 
*
0206:  BCF    07.2
....................    spi_write(d2510wrt); 
0207:  MOVF   13,W
0208:  MOVLW  02
0209:  MOVWF  13
020A:  BSF    03.5
020B:  BTFSS  14.0
020C:  GOTO   20B
....................    spi_write(end); 
020D:  BCF    03.5
020E:  MOVF   13,W
020F:  BSF    03.6
0210:  MOVF   19,W
0211:  BCF    03.6
0212:  MOVWF  13
0213:  BSF    03.5
0214:  BTFSS  14.0
0215:  GOTO   214
....................    spi_write(dado); 
0216:  BCF    03.5
0217:  MOVF   13,W
0218:  BSF    03.6
0219:  MOVF   1A,W
021A:  BCF    03.6
021B:  MOVWF  13
021C:  BSF    03.5
021D:  BTFSS  14.0
021E:  GOTO   21D
....................    output_high(cs); 
021F:  BCF    03.5
0220:  BSF    07.2
.................... } 
0221:  RETLW  00
....................  
.................... int f2510rd(int end) 
.................... { 
....................    int aux; 
....................    output_low(cs); 
*
01E5:  BCF    07.2
....................    spi_write(d2510rd); 
01E6:  MOVF   13,W
01E7:  MOVLW  03
01E8:  MOVWF  13
01E9:  BSF    03.5
01EA:  BTFSS  14.0
01EB:  GOTO   1EA
....................    spi_write(end); 
01EC:  BCF    03.5
01ED:  MOVF   13,W
01EE:  BSF    03.6
01EF:  MOVF   17,W
01F0:  BCF    03.6
01F1:  MOVWF  13
01F2:  BSF    03.5
01F3:  BTFSS  14.0
01F4:  GOTO   1F3
....................    aux=spi_read(0); 
01F5:  BCF    03.5
01F6:  MOVF   13,W
01F7:  CLRF   13
01F8:  BSF    03.5
01F9:  BTFSS  14.0
01FA:  GOTO   1F9
01FB:  BCF    03.5
01FC:  MOVF   13,W
01FD:  BSF    03.6
01FE:  MOVWF  18
....................    output_high(cs); 
01FF:  BCF    03.6
0200:  BSF    07.2
....................    return aux; 
0201:  BSF    03.6
0202:  MOVF   18,W
0203:  MOVWF  78
.................... } 
0204:  BCF    03.6
0205:  RETLW  00
....................  
.................... //1MHz com cristal de 20 MHz 
.................... void f2510cfg(void) 
.................... { 
....................     f2510wr(canctrl,0x80); 
*
0636:  MOVLW  0F
0637:  BSF    03.6
0638:  MOVWF  19
0639:  MOVLW  80
063A:  MOVWF  1A
063B:  BCF    03.6
063C:  CALL   206
....................    //f2510wr(0x25,0x30); 
....................    f2510wr(cnf1,0x00);//BRP=0 
063D:  MOVLW  2A
063E:  BSF    03.6
063F:  MOVWF  19
0640:  CLRF   1A
0641:  BCF    03.6
0642:  CALL   206
....................    f2510wr(cnf2,0x11);//PHSEG1=3 PRSEG=2 
0643:  MOVLW  29
0644:  BSF    03.6
0645:  MOVWF  19
0646:  MOVLW  11
0647:  MOVWF  1A
0648:  BCF    03.6
0649:  CALL   206
....................    f2510wr(cnf3,0x03);//PHSEG2=4 
064A:  MOVLW  28
064B:  BSF    03.6
064C:  MOVWF  19
064D:  MOVLW  03
064E:  MOVWF  1A
064F:  BCF    03.6
0650:  CALL   206
....................    f2510wr(canctrl,0x00); 
0651:  MOVLW  0F
0652:  BSF    03.6
0653:  MOVWF  19
0654:  CLRF   1A
0655:  BCF    03.6
0656:  CALL   206
....................    //f2510wr(canctrl,0x40); 
.................... } 
0657:  BSF    0A.3
0658:  BCF    0A.4
0659:  GOTO   596 (RETURN)
....................  
....................  
.................... int1 f2510tx(int *pilha) 
....................  
.................... {  int   buffer1,buffer,aux1_length,aux2; 
....................  
....................    if      (!bit_test(f2510rd(0x30),3)) buffer1=0x30; 
*
0253:  MOVLW  30
0254:  BSF    03.6
0255:  MOVWF  17
0256:  BCF    03.6
0257:  CALL   1E5
0258:  MOVF   78,W
0259:  BSF    03.6
025A:  MOVWF  17
025B:  BTFSC  17.3
025C:  GOTO   260
025D:  MOVLW  30
025E:  MOVWF  13
....................    else if (!bit_test(f2510rd(0x40),3)) buffer1=0x40; 
025F:  GOTO   27B
0260:  MOVLW  40
0261:  MOVWF  17
0262:  BCF    03.6
0263:  CALL   1E5
0264:  MOVF   78,W
0265:  BSF    03.6
0266:  MOVWF  17
0267:  BTFSC  17.3
0268:  GOTO   26C
0269:  MOVLW  40
026A:  MOVWF  13
....................    else if (!bit_test(f2510rd(0x50),3)) buffer1=0x50; 
026B:  GOTO   27B
026C:  MOVLW  50
026D:  MOVWF  17
026E:  BCF    03.6
026F:  CALL   1E5
0270:  MOVF   78,W
0271:  BSF    03.6
0272:  MOVWF  17
0273:  BTFSC  17.3
0274:  GOTO   278
0275:  MOVLW  50
0276:  MOVWF  13
....................    else return false; 
0277:  GOTO   27B
0278:  MOVLW  00
0279:  MOVWF  78
027A:  GOTO   31C
....................  
....................    buffer=buffer1; 
027B:  MOVF   13,W
027C:  MOVWF  14
....................    f2510wr(buffer+=1,pilha[1]); 
027D:  MOVLW  01
027E:  ADDWF  14,F
027F:  ADDWF  11,W
0280:  MOVWF  04
0281:  BCF    03.7
0282:  BTFSC  12.0
0283:  BSF    03.7
0284:  MOVF   00,W
0285:  MOVWF  17
0286:  MOVF   14,W
0287:  MOVWF  19
0288:  MOVF   17,W
0289:  MOVWF  1A
028A:  BCF    03.6
028B:  CALL   206
....................    f2510wr(buffer+=1,0x00); 
028C:  MOVLW  01
028D:  BSF    03.6
028E:  ADDWF  14,F
028F:  MOVF   14,W
0290:  MOVWF  19
0291:  CLRF   1A
0292:  BCF    03.6
0293:  CALL   206
....................    f2510wr(buffer+=3,pilha[6]+4); 
0294:  MOVLW  03
0295:  BSF    03.6
0296:  ADDWF  14,F
0297:  MOVLW  06
0298:  ADDWF  11,W
0299:  MOVWF  04
029A:  BCF    03.7
029B:  BTFSC  12.0
029C:  BSF    03.7
029D:  MOVLW  04
029E:  ADDWF  00,W
029F:  MOVWF  18
02A0:  MOVF   14,W
02A1:  MOVWF  19
02A2:  MOVF   18,W
02A3:  MOVWF  1A
02A4:  BCF    03.6
02A5:  CALL   206
....................    f2510wr(buffer+=1,pilha[2]); 
02A6:  MOVLW  01
02A7:  BSF    03.6
02A8:  ADDWF  14,F
02A9:  MOVLW  02
02AA:  ADDWF  11,W
02AB:  MOVWF  04
02AC:  BCF    03.7
02AD:  BTFSC  12.0
02AE:  BSF    03.7
02AF:  MOVF   00,W
02B0:  MOVWF  17
02B1:  MOVF   14,W
02B2:  MOVWF  19
02B3:  MOVF   17,W
02B4:  MOVWF  1A
02B5:  BCF    03.6
02B6:  CALL   206
....................    f2510wr(buffer+=1,pilha[3]); 
02B7:  MOVLW  01
02B8:  BSF    03.6
02B9:  ADDWF  14,F
02BA:  MOVLW  03
02BB:  ADDWF  11,W
02BC:  MOVWF  04
02BD:  BCF    03.7
02BE:  BTFSC  12.0
02BF:  BSF    03.7
02C0:  MOVF   00,W
02C1:  MOVWF  17
02C2:  MOVF   14,W
02C3:  MOVWF  19
02C4:  MOVF   17,W
02C5:  MOVWF  1A
02C6:  BCF    03.6
02C7:  CALL   206
....................    f2510wr(buffer+=1,pilha[4]); 
02C8:  MOVLW  01
02C9:  BSF    03.6
02CA:  ADDWF  14,F
02CB:  MOVLW  04
02CC:  ADDWF  11,W
02CD:  MOVWF  04
02CE:  BCF    03.7
02CF:  BTFSC  12.0
02D0:  BSF    03.7
02D1:  MOVF   00,W
02D2:  MOVWF  17
02D3:  MOVF   14,W
02D4:  MOVWF  19
02D5:  MOVF   17,W
02D6:  MOVWF  1A
02D7:  BCF    03.6
02D8:  CALL   206
....................    f2510wr(buffer+=1,pilha[5]); 
02D9:  MOVLW  01
02DA:  BSF    03.6
02DB:  ADDWF  14,F
02DC:  MOVLW  05
02DD:  ADDWF  11,W
02DE:  MOVWF  04
02DF:  BCF    03.7
02E0:  BTFSC  12.0
02E1:  BSF    03.7
02E2:  MOVF   00,W
02E3:  MOVWF  17
02E4:  MOVF   14,W
02E5:  MOVWF  19
02E6:  MOVF   17,W
02E7:  MOVWF  1A
02E8:  BCF    03.6
02E9:  CALL   206
....................  
....................    aux1_length=pilha[6]; 
02EA:  MOVLW  06
02EB:  BSF    03.6
02EC:  ADDWF  11,W
02ED:  MOVWF  04
02EE:  BCF    03.7
02EF:  BTFSC  12.0
02F0:  BSF    03.7
02F1:  MOVF   00,W
02F2:  MOVWF  15
....................  
....................    for (aux2=7;aux2<(aux1_length+7);++aux2) 
02F3:  MOVLW  07
02F4:  MOVWF  16
02F5:  MOVLW  07
02F6:  ADDWF  15,W
02F7:  SUBWF  16,W
02F8:  BTFSC  03.0
02F9:  GOTO   30D
....................    { 
....................    f2510wr(buffer+=1,pilha[aux2]); 
02FA:  MOVLW  01
02FB:  ADDWF  14,F
02FC:  MOVF   16,W
02FD:  ADDWF  11,W
02FE:  MOVWF  04
02FF:  BCF    03.7
0300:  BTFSC  12.0
0301:  BSF    03.7
0302:  MOVF   00,W
0303:  MOVWF  17
0304:  MOVF   14,W
0305:  MOVWF  19
0306:  MOVF   17,W
0307:  MOVWF  1A
0308:  BCF    03.6
0309:  CALL   206
....................    } 
030A:  BSF    03.6
030B:  INCF   16,F
030C:  GOTO   2F5
....................    pilha[0]=0; 
030D:  MOVF   11,W
030E:  MOVWF  04
030F:  BCF    03.7
0310:  BTFSC  12.0
0311:  BSF    03.7
0312:  CLRF   00
....................    f2510bs(buffer1,3); 
0313:  MOVF   13,W
0314:  MOVWF  17
0315:  MOVLW  03
0316:  MOVWF  18
0317:  BCF    03.6
0318:  CALL   222
....................  
....................    return true; 
0319:  MOVLW  01
031A:  MOVWF  78
031B:  BSF    03.6
.................... } 
031C:  BCF    03.6
031D:  RETLW  00
....................  
....................  
.................... void f2510bs(int end,int bbit) 
.................... { 
....................    int aux; 
....................    output_low(cs); 
*
0222:  BCF    07.2
....................    bit_set(aux,bbit); 
0223:  MOVLW  01
0224:  MOVWF  77
0225:  BSF    03.6
0226:  MOVF   18,W
0227:  MOVWF  78
0228:  BTFSC  03.2
0229:  GOTO   22E
022A:  BCF    03.0
022B:  RLF    77,F
022C:  DECFSZ 78,F
022D:  GOTO   22A
022E:  MOVF   77,W
022F:  IORWF  19,F
....................    spi_write(d2510bitmod); 
0230:  BCF    03.6
0231:  MOVF   13,W
0232:  MOVLW  05
0233:  MOVWF  13
0234:  BSF    03.5
0235:  BTFSS  14.0
0236:  GOTO   235
....................    spi_write(end); 
0237:  BCF    03.5
0238:  MOVF   13,W
0239:  BSF    03.6
023A:  MOVF   17,W
023B:  BCF    03.6
023C:  MOVWF  13
023D:  BSF    03.5
023E:  BTFSS  14.0
023F:  GOTO   23E
....................    spi_write(aux); 
0240:  BCF    03.5
0241:  MOVF   13,W
0242:  BSF    03.6
0243:  MOVF   19,W
0244:  BCF    03.6
0245:  MOVWF  13
0246:  BSF    03.5
0247:  BTFSS  14.0
0248:  GOTO   247
....................    spi_write(0xff); 
0249:  BCF    03.5
024A:  MOVF   13,W
024B:  MOVLW  FF
024C:  MOVWF  13
024D:  BSF    03.5
024E:  BTFSS  14.0
024F:  GOTO   24E
....................    output_high(cs); 
0250:  BCF    03.5
0251:  BSF    07.2
.................... } 
0252:  RETLW  00
....................  
.................... void f2510bc(int end,int bbit) 
.................... { 
....................    int aux; 
....................    output_low(cs); 
*
08EF:  BCF    03.5
08F0:  BCF    07.2
....................    bit_set(aux,bbit); 
08F1:  MOVLW  01
08F2:  MOVWF  77
08F3:  BSF    03.5
08F4:  MOVF   5F,W
08F5:  MOVWF  78
08F6:  BTFSC  03.2
08F7:  GOTO   0FC
08F8:  BCF    03.0
08F9:  RLF    77,F
08FA:  DECFSZ 78,F
08FB:  GOTO   0F8
08FC:  MOVF   77,W
08FD:  IORWF  60,F
....................    spi_write(d2510bitmod); 
08FE:  BCF    03.5
08FF:  MOVF   13,W
0900:  MOVLW  05
0901:  MOVWF  13
0902:  BSF    03.5
0903:  BTFSS  14.0
0904:  GOTO   103
....................    spi_write(end); 
0905:  BCF    03.5
0906:  MOVF   13,W
0907:  BSF    03.5
0908:  MOVF   5E,W
0909:  BCF    03.5
090A:  MOVWF  13
090B:  BSF    03.5
090C:  BTFSS  14.0
090D:  GOTO   10C
....................    spi_write(aux); 
090E:  BCF    03.5
090F:  MOVF   13,W
0910:  BSF    03.5
0911:  MOVF   60,W
0912:  BCF    03.5
0913:  MOVWF  13
0914:  BSF    03.5
0915:  BTFSS  14.0
0916:  GOTO   115
....................    spi_write(0x00); 
0917:  BCF    03.5
0918:  MOVF   13,W
0919:  CLRF   13
091A:  BSF    03.5
091B:  BTFSS  14.0
091C:  GOTO   11B
....................    output_high(cs); 
091D:  BCF    03.5
091E:  BSF    07.2
.................... } 
....................  
.................... void f2510rst(void) 
.................... { 
....................  
....................    output_low(cs); 
*
062A:  BCF    07.2
....................    spi_write(0xc0); 
062B:  MOVF   13,W
062C:  MOVLW  C0
062D:  MOVWF  13
062E:  BSF    03.5
062F:  BTFSS  14.0
0630:  GOTO   62F
....................    output_high(cs); 
0631:  BCF    03.5
0632:  BSF    07.2
.................... } 
0633:  BSF    0A.3
0634:  BCF    0A.4
0635:  GOTO   586 (RETURN)
....................  
....................  
....................  
.................... void f2510cfg_end(int end,int1 intr)//endereco, intr=0 sem interrupt em rx0bf 
.................... { 
....................    f2510wr(canctrl,0x80); 
*
065A:  MOVLW  0F
065B:  BSF    03.6
065C:  MOVWF  19
065D:  MOVLW  80
065E:  MOVWF  1A
065F:  BCF    03.6
0660:  CALL   206
....................    f2510bs(0x0c,0); 
0661:  MOVLW  0C
0662:  BSF    03.6
0663:  MOVWF  17
0664:  CLRF   18
0665:  BCF    03.6
0666:  CALL   222
....................    if(intr) f2510bs(0x0c,1); 
0667:  BSF    03.5
0668:  MOVF   5B,F
0669:  BTFSC  03.2
066A:  GOTO   674
066B:  MOVLW  0C
066C:  BCF    03.5
066D:  BSF    03.6
066E:  MOVWF  17
066F:  MOVLW  01
0670:  MOVWF  18
0671:  BCF    03.6
0672:  CALL   222
0673:  BSF    03.5
....................    f2510wr(0x00,end);   // acceptance filter rxf0 
0674:  BCF    03.5
0675:  BSF    03.6
0676:  CLRF   19
0677:  BSF    03.5
0678:  BCF    03.6
0679:  MOVF   5A,W
067A:  BCF    03.5
067B:  BSF    03.6
067C:  MOVWF  1A
067D:  BCF    03.6
067E:  CALL   206
....................    f2510wr(0x04,0x69);   // acceptance filter rxf1 
067F:  MOVLW  04
0680:  BSF    03.6
0681:  MOVWF  19
0682:  MOVLW  69
0683:  MOVWF  1A
0684:  BCF    03.6
0685:  CALL   206
....................    f2510wr(0x08,0xff);  // acceptance filter rxf2 
0686:  MOVLW  08
0687:  BSF    03.6
0688:  MOVWF  19
0689:  MOVLW  FF
068A:  MOVWF  1A
068B:  BCF    03.6
068C:  CALL   206
....................    f2510wr(0x10,0xff);  // acceptance filter rxf3 
068D:  MOVLW  10
068E:  BSF    03.6
068F:  MOVWF  19
0690:  MOVLW  FF
0691:  MOVWF  1A
0692:  BCF    03.6
0693:  CALL   206
....................    f2510wr(0x14,0xff);  // acceptance filter rxf4 
0694:  MOVLW  14
0695:  BSF    03.6
0696:  MOVWF  19
0697:  MOVLW  FF
0698:  MOVWF  1A
0699:  BCF    03.6
069A:  CALL   206
....................    f2510wr(0x18,0xff);  // acceptance filter rxf5 
069B:  MOVLW  18
069C:  BSF    03.6
069D:  MOVWF  19
069E:  MOVLW  FF
069F:  MOVWF  1A
06A0:  BCF    03.6
06A1:  CALL   206
....................  
....................    f2510wr(0x01,0); 
06A2:  MOVLW  01
06A3:  BSF    03.6
06A4:  MOVWF  19
06A5:  CLRF   1A
06A6:  BCF    03.6
06A7:  CALL   206
....................    f2510wr(0x05,0); 
06A8:  MOVLW  05
06A9:  BSF    03.6
06AA:  MOVWF  19
06AB:  CLRF   1A
06AC:  BCF    03.6
06AD:  CALL   206
....................    f2510wr(0x09,0xf0);//??? 
06AE:  MOVLW  09
06AF:  BSF    03.6
06B0:  MOVWF  19
06B1:  MOVLW  F0
06B2:  MOVWF  1A
06B3:  BCF    03.6
06B4:  CALL   206
....................    f2510wr(0x11,0xf0); 
06B5:  MOVLW  11
06B6:  BSF    03.6
06B7:  MOVWF  19
06B8:  MOVLW  F0
06B9:  MOVWF  1A
06BA:  BCF    03.6
06BB:  CALL   206
....................    f2510wr(0x15,0xf0); 
06BC:  MOVLW  15
06BD:  BSF    03.6
06BE:  MOVWF  19
06BF:  MOVLW  F0
06C0:  MOVWF  1A
06C1:  BCF    03.6
06C2:  CALL   206
....................    f2510wr(0x19,0xf0); 
06C3:  MOVLW  19
06C4:  BSF    03.6
06C5:  MOVWF  19
06C6:  MOVLW  F0
06C7:  MOVWF  1A
06C8:  BCF    03.6
06C9:  CALL   206
....................  
....................    f2510wr(0x20,0xff); 
06CA:  MOVLW  20
06CB:  BSF    03.6
06CC:  MOVWF  19
06CD:  MOVLW  FF
06CE:  MOVWF  1A
06CF:  BCF    03.6
06D0:  CALL   206
....................    f2510wr(0x21,0xff); 
06D1:  MOVLW  21
06D2:  BSF    03.6
06D3:  MOVWF  19
06D4:  MOVLW  FF
06D5:  MOVWF  1A
06D6:  BCF    03.6
06D7:  CALL   206
....................    f2510wr(0x24,0xff); 
06D8:  MOVLW  24
06D9:  BSF    03.6
06DA:  MOVWF  19
06DB:  MOVLW  FF
06DC:  MOVWF  1A
06DD:  BCF    03.6
06DE:  CALL   206
....................    f2510wr(0x25,0xff); 
06DF:  MOVLW  25
06E0:  BSF    03.6
06E1:  MOVWF  19
06E2:  MOVLW  FF
06E3:  MOVWF  1A
06E4:  BCF    03.6
06E5:  CALL   206
....................    f2510wr(canctrl,0x00); 
06E6:  MOVLW  0F
06E7:  BSF    03.6
06E8:  MOVWF  19
06E9:  CLRF   1A
06EA:  BCF    03.6
06EB:  CALL   206
.................... } 
06EC:  BSF    0A.3
06ED:  BCF    0A.4
06EE:  GOTO   5B5 (RETURN)
....................  
....................  
....................    int f2510rx(int *bu) //recebe dados do mcp 2510 e coloca-os no buffer devolve 0 
....................    {int auxrx;          // se o buffer estiver cheio (bu[0]=1) nao recebe e devolve 1 
....................       if (!bit_test(f2510rd(0x2c),0)) return 2; 
*
0804:  MOVLW  2C
0805:  BCF    03.5
0806:  BSF    03.6
0807:  MOVWF  17
0808:  BCF    0A.3
0809:  BCF    03.6
080A:  CALL   1E5
080B:  BSF    0A.3
080C:  MOVF   78,W
080D:  BSF    03.5
080E:  MOVWF  5E
080F:  BTFSC  5E.0
0810:  GOTO   014
0811:  MOVLW  02
0812:  MOVWF  78
0813:  GOTO   12C
....................       if (bu[0]==0)     // se nao a mensagem nova devolve 2 
0814:  MOVF   5B,W
0815:  MOVWF  04
0816:  BCF    03.7
0817:  BTFSC  5C.0
0818:  BSF    03.7
0819:  MOVF   00,F
081A:  BTFSS  03.2
081B:  GOTO   12A
....................     { 
....................       bu[1]=f2510rd(0x61);//dest_adr 
081C:  MOVLW  01
081D:  ADDWF  5B,W
081E:  MOVWF  78
081F:  MOVF   5C,W
0820:  MOVWF  7A
0821:  BTFSC  03.0
0822:  INCF   7A,F
0823:  MOVF   78,W
0824:  MOVWF  5E
0825:  MOVF   7A,W
0826:  MOVWF  5F
0827:  MOVLW  61
0828:  BCF    03.5
0829:  BSF    03.6
082A:  MOVWF  17
082B:  BCF    0A.3
082C:  BCF    03.6
082D:  CALL   1E5
082E:  BSF    0A.3
082F:  BSF    03.5
0830:  MOVF   5E,W
0831:  MOVWF  04
0832:  BCF    03.7
0833:  BTFSC  5F.0
0834:  BSF    03.7
0835:  MOVF   78,W
0836:  MOVWF  00
....................       bu[6]=f2510rd(0x65)-4;//lenght 
0837:  MOVLW  06
0838:  ADDWF  5B,W
0839:  MOVWF  78
083A:  MOVF   5C,W
083B:  MOVWF  7A
083C:  BTFSC  03.0
083D:  INCF   7A,F
083E:  MOVF   78,W
083F:  MOVWF  5E
0840:  MOVF   7A,W
0841:  MOVWF  5F
0842:  MOVLW  65
0843:  BCF    03.5
0844:  BSF    03.6
0845:  MOVWF  17
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   1E5
0849:  BSF    0A.3
084A:  MOVLW  04
084B:  SUBWF  78,W
084C:  BSF    03.5
084D:  MOVWF  61
084E:  MOVF   5E,W
084F:  MOVWF  04
0850:  BCF    03.7
0851:  BTFSC  5F.0
0852:  BSF    03.7
0853:  MOVF   61,W
0854:  MOVWF  00
....................       bu[2]=f2510rd(0x66);//sub_dest_adr 
0855:  MOVLW  02
0856:  ADDWF  5B,W
0857:  MOVWF  78
0858:  MOVF   5C,W
0859:  MOVWF  7A
085A:  BTFSC  03.0
085B:  INCF   7A,F
085C:  MOVF   78,W
085D:  MOVWF  5E
085E:  MOVF   7A,W
085F:  MOVWF  5F
0860:  MOVLW  66
0861:  BCF    03.5
0862:  BSF    03.6
0863:  MOVWF  17
0864:  BCF    0A.3
0865:  BCF    03.6
0866:  CALL   1E5
0867:  BSF    0A.3
0868:  BSF    03.5
0869:  MOVF   5E,W
086A:  MOVWF  04
086B:  BCF    03.7
086C:  BTFSC  5F.0
086D:  BSF    03.7
086E:  MOVF   78,W
086F:  MOVWF  00
....................       bu[3]=f2510rd(0x67);//source_adr 
0870:  MOVLW  03
0871:  ADDWF  5B,W
0872:  MOVWF  78
0873:  MOVF   5C,W
0874:  MOVWF  7A
0875:  BTFSC  03.0
0876:  INCF   7A,F
0877:  MOVF   78,W
0878:  MOVWF  5E
0879:  MOVF   7A,W
087A:  MOVWF  5F
087B:  MOVLW  67
087C:  BCF    03.5
087D:  BSF    03.6
087E:  MOVWF  17
087F:  BCF    0A.3
0880:  BCF    03.6
0881:  CALL   1E5
0882:  BSF    0A.3
0883:  BSF    03.5
0884:  MOVF   5E,W
0885:  MOVWF  04
0886:  BCF    03.7
0887:  BTFSC  5F.0
0888:  BSF    03.7
0889:  MOVF   78,W
088A:  MOVWF  00
....................       bu[4]=f2510rd(0x68);//sub_source_adr 
088B:  MOVLW  04
088C:  ADDWF  5B,W
088D:  MOVWF  78
088E:  MOVF   5C,W
088F:  MOVWF  7A
0890:  BTFSC  03.0
0891:  INCF   7A,F
0892:  MOVF   78,W
0893:  MOVWF  5E
0894:  MOVF   7A,W
0895:  MOVWF  5F
0896:  MOVLW  68
0897:  BCF    03.5
0898:  BSF    03.6
0899:  MOVWF  17
089A:  BCF    0A.3
089B:  BCF    03.6
089C:  CALL   1E5
089D:  BSF    0A.3
089E:  BSF    03.5
089F:  MOVF   5E,W
08A0:  MOVWF  04
08A1:  BCF    03.7
08A2:  BTFSC  5F.0
08A3:  BSF    03.7
08A4:  MOVF   78,W
08A5:  MOVWF  00
....................       bu[5]=f2510rd(0x69);//type 
08A6:  MOVLW  05
08A7:  ADDWF  5B,W
08A8:  MOVWF  78
08A9:  MOVF   5C,W
08AA:  MOVWF  7A
08AB:  BTFSC  03.0
08AC:  INCF   7A,F
08AD:  MOVF   78,W
08AE:  MOVWF  5E
08AF:  MOVF   7A,W
08B0:  MOVWF  5F
08B1:  MOVLW  69
08B2:  BCF    03.5
08B3:  BSF    03.6
08B4:  MOVWF  17
08B5:  BCF    0A.3
08B6:  BCF    03.6
08B7:  CALL   1E5
08B8:  BSF    0A.3
08B9:  BSF    03.5
08BA:  MOVF   5E,W
08BB:  MOVWF  04
08BC:  BCF    03.7
08BD:  BTFSC  5F.0
08BE:  BSF    03.7
08BF:  MOVF   78,W
08C0:  MOVWF  00
....................  
....................       for (auxrx=0;auxrx<bu[6];++auxrx) 
08C1:  CLRF   5D
08C2:  MOVLW  06
08C3:  ADDWF  5B,W
08C4:  MOVWF  04
08C5:  BCF    03.7
08C6:  BTFSC  5C.0
08C7:  BSF    03.7
08C8:  MOVF   00,W
08C9:  SUBWF  5D,W
08CA:  BTFSC  03.0
08CB:  GOTO   0EC
....................       { 
....................          bu[7+auxrx]=f2510rd(0x6A+auxrx); 
08CC:  MOVLW  07
08CD:  ADDWF  5D,W
08CE:  ADDWF  5B,W
08CF:  MOVWF  78
08D0:  MOVF   5C,W
08D1:  MOVWF  7A
08D2:  BTFSC  03.0
08D3:  INCF   7A,F
08D4:  MOVF   78,W
08D5:  MOVWF  5F
08D6:  MOVF   7A,W
08D7:  MOVWF  60
08D8:  MOVLW  6A
08D9:  ADDWF  5D,W
08DA:  MOVWF  61
08DB:  BCF    03.5
08DC:  BSF    03.6
08DD:  MOVWF  17
08DE:  BCF    0A.3
08DF:  BCF    03.6
08E0:  CALL   1E5
08E1:  BSF    0A.3
08E2:  BSF    03.5
08E3:  MOVF   5F,W
08E4:  MOVWF  04
08E5:  BCF    03.7
08E6:  BTFSC  60.0
08E7:  BSF    03.7
08E8:  MOVF   78,W
08E9:  MOVWF  00
....................       } 
08EA:  INCF   5D,F
08EB:  GOTO   0C2
....................  
....................       f2510bc(0x2c,0); 
08EC:  MOVLW  2C
08ED:  MOVWF  5E
08EE:  CLRF   5F
....................       bu[0]=1; 
*
091F:  BSF    03.5
0920:  MOVF   5B,W
0921:  MOVWF  04
0922:  BCF    03.7
0923:  BTFSC  5C.0
0924:  BSF    03.7
0925:  MOVLW  01
0926:  MOVWF  00
....................       return 0; 
0927:  MOVLW  00
0928:  MOVWF  78
0929:  GOTO   12C
....................     } 
....................     return 1; 
092A:  MOVLW  01
092B:  MOVWF  78
....................    } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //vector com o nivel de cada lampada 
.................... int ltlevel[8]={0,0,0,0,0,0,0,0}; 
*
0CB2:  CLRF   2E
0CB3:  CLRF   2F
0CB4:  CLRF   30
0CB5:  CLRF   31
0CB6:  CLRF   32
0CB7:  CLRF   33
0CB8:  CLRF   34
0CB9:  CLRF   35
.................... int oldltlevel[8]={0,0,0,0,0,0,0,0}; 
0CBA:  CLRF   36
0CBB:  CLRF   37
0CBC:  CLRF   38
0CBD:  CLRF   39
0CBE:  CLRF   3A
0CBF:  CLRF   3B
0CC0:  CLRF   3C
0CC1:  CLRF   3D
....................  
.................... int adr; 
....................  
.................... int LOF[8]={0,0,0,0,0,0,0,0}; 
0CC2:  CLRF   3F
0CC3:  CLRF   40
0CC4:  CLRF   41
0CC5:  CLRF   42
0CC6:  CLRF   43
0CC7:  CLRF   44
0CC8:  CLRF   45
0CC9:  CLRF   46
.................... int GAD[8]={0,0,0,0,0,0,0,0}; 
0CCA:  CLRF   47
0CCB:  CLRF   48
0CCC:  CLRF   49
0CCD:  CLRF   4A
0CCE:  CLRF   4B
0CCF:  CLRF   4C
0CD0:  CLRF   4D
0CD1:  CLRF   4E
....................  
.................... const long Matrizluz[128]={ 
.................... 38400,38731 , 38492 , 38253 , 38014 , 37775 , 37536 , 37297 , 37058 , 36819 , 36580 
.................... , 36341 , 36102 , 35863 , 35624 , 35385 , 35146 , 34907 , 34668 , 34429 , 34190 , 33951 
....................  , 33712 , 33473 , 33234 , 32995 , 32756 , 32517 , 32278 , 32039 , 31800 , 31561 , 31322 , 31083 , 30844 , 30605 , 30366 , 30127 , 29888 , 29649 , 29410 , 29171 , 28932 , 28693 , 28454 , 28215 , 27976 , 27737 , 27498 , 27259 , 27020 , 26781 , 26542 , 26303 , 26064 , 25825 , 25586 , 25347 , 25108 , 24869 , 24630 , 24391 , 24152 , 23913 , 23674 , 23435 , 23196 , 22957 , 22718 , 22479 , 22240 , 22001 , 21762 , 21523 , 21284 , 21045 , 20806 , 20567 , 20328 , 20089 , 19850 , 19611 , 19372 , 19133 , 18894 , 18655 , 18416 , 18177 , 17938 , 17699 , 17460 , 17221 , 16982 , 16743 , 16504 , 16265 , 16026 , 15787 , 15548 , 15309 , 15070 , 14831 , 14592 , 14353 , 14114 , 13875 , 13636 , 13397 , 13158 , 12919 , 12680 , 12441 , 12202 , 11963 , 11724 , 11485 , 11246 , 11007 , 10768 , 10529 , 10290 , 10051 , 9812 , 9573 , 9334 , 9095 , 8856 , 617 }; 
....................  
....................  
.................... int1 organizado; //flag k diz se ja acabou a reorganizacao 
....................  
.................... const int lights[8]={0b11111110,0b11111101,0b11111011,0b11110111,0b11101111,0b11011111,0b10111111,0b01111111}; 
....................                  /*<............portA................................................> <.......portC........>*/ 
.................... int mnumluzes; 
....................  
.................... int flag[8]={0b00000010,0b00000010,0b00000010,0b00000010,0b00000010,0b00000010 
.................... ,0b00000010,0b00000010}; 
0CD2:  MOVLW  02
0CD3:  MOVWF  51
0CD4:  MOVWF  52
0CD5:  MOVWF  53
0CD6:  MOVWF  54
0CD7:  MOVWF  55
0CD8:  MOVWF  56
0CD9:  MOVWF  57
0CDA:  MOVWF  58
....................  
.................... //Interruptores 
.................... #define sw1 pin_c7 
.................... #define sw2 pin_b1 
.................... #define sw3 pin_b2 
.................... #define sw4 pin_b3 
.................... #define sw5 pin_b4 
.................... #define sw6 pin_b5 
.................... #define sw7 pin_b6 
.................... #define sw8 pin_b7 
....................  
....................  
.................... int delays1[9][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7}; 
0CDB:  CLRF   59
0CDC:  CLRF   5A
0CDD:  CLRF   5B
0CDE:  MOVLW  01
0CDF:  MOVWF  5C
0CE0:  CLRF   5D
0CE1:  MOVLW  02
0CE2:  MOVWF  5E
0CE3:  CLRF   5F
0CE4:  MOVLW  03
0CE5:  MOVWF  60
0CE6:  CLRF   61
0CE7:  MOVLW  04
0CE8:  MOVWF  62
0CE9:  CLRF   63
0CEA:  MOVLW  05
0CEB:  MOVWF  64
0CEC:  CLRF   65
0CED:  MOVLW  06
0CEE:  MOVWF  66
0CEF:  CLRF   67
0CF0:  MOVLW  07
0CF1:  MOVWF  68
0CF2:  CLRF   69
0CF3:  CLRF   6A
.................... int delays2[9][2]={0,0,0,1,0,2,0,3,0,4,0,5,0,6,0,7}; 
0CF4:  BSF    03.5
0CF5:  CLRF   20
0CF6:  CLRF   21
0CF7:  CLRF   22
0CF8:  MOVLW  01
0CF9:  MOVWF  23
0CFA:  CLRF   24
0CFB:  MOVLW  02
0CFC:  MOVWF  25
0CFD:  CLRF   26
0CFE:  MOVLW  03
0CFF:  MOVWF  27
0D00:  CLRF   28
0D01:  MOVLW  04
0D02:  MOVWF  29
0D03:  CLRF   2A
0D04:  MOVLW  05
0D05:  MOVWF  2B
0D06:  CLRF   2C
0D07:  MOVLW  06
0D08:  MOVWF  2D
0D09:  CLRF   2E
0D0A:  MOVLW  07
0D0B:  MOVWF  2F
0D0C:  CLRF   30
0D0D:  CLRF   31
.................... // vector com as contagens do timer de cada lampada 
.................... int swcont[8]={0,0,0,0,0,0,0,0}; 
0D0E:  BCF    03.5
0D0F:  CLRF   6B
0D10:  CLRF   6C
0D11:  CLRF   6D
0D12:  CLRF   6E
0D13:  CLRF   6F
0D14:  CLRF   70
0D15:  CLRF   71
0D16:  CLRF   72
.................... int1 actmat=0;//matriz em uso 
0D17:  BCF    4F.1
.................... int pointer; 
.................... int vez; 
.................... int auxccp; 
.................... int auxccp2; 
.................... int temp; 
.................... int clock; 
.................... int1 cl; 
.................... int prevclock[8]={0,0,0,0,0,0,0,0}; 
0D18:  BSF    03.5
0D19:  CLRF   32
0D1A:  CLRF   33
0D1B:  CLRF   34
0D1C:  CLRF   35
0D1D:  CLRF   36
0D1E:  CLRF   37
0D1F:  CLRF   38
0D20:  CLRF   39
.................... int s_virtual[8]={0,0,0,0,0,0,0,0}; 
0D21:  CLRF   3A
0D22:  CLRF   3B
0D23:  CLRF   3C
0D24:  CLRF   3D
0D25:  CLRF   3E
0D26:  CLRF   3F
0D27:  CLRF   40
0D28:  CLRF   41
....................  
.................... void org(void); 
.................... void cfgload(void); 
....................   
.................... #include "Lcan.c" 
.................... #define full 0 
.................... #define end_dest 1 
.................... #define sub_end_dest 2 
.................... #define end_orig 3 
.................... #define sub_end_orig 4 
.................... #define tipo 5 
.................... #define comp_dados 6 
.................... #define dados 7 
....................  
.................... //TIPOS 
.................... #define Set_Value 1 
.................... #define Get_Value 2 
.................... #define Value_Ans 3 
.................... #define Ping_Request 4 
.................... #define Ping_Ans 5 
.................... #define Set_Configuration 6 
.................... #define Get_Configuration 7 
.................... #define Configuration_Ans 8 
.................... #define Reset 9 
.................... #define Direct_Adress 10 
.................... #define Indirect_adress_config 11 
.................... #define Indirect_Set_Value 12 
.................... #define man_val_change 13 
.................... #define newadr 14 
.................... #define Set_virtual_int 15 
.................... #define Get_virtual_int 16 
.................... #define Virtual_int_Ans 17 
.................... #define Set_glob_adr    18 
.................... #define Get_glob_adr    19 
.................... #define glob_adr_ans    20 
....................  
....................  
.................... int iadress=0; 
0D29:  CLRF   7E
.................... int pilha_can[11]; 
.................... int pilha_canTX[11]; 
.................... int daux; 
.................... int aux33; 
....................  
.................... void send_to_requester() 
.................... { 
....................    pilha_canTX[1]=pilha_can[3]; 
*
06EF:  BSF    03.5
06F0:  MOVF   45,W
06F1:  MOVWF  4E
....................    pilha_canTX[2]=pilha_can[4]; 
06F2:  MOVF   46,W
06F3:  MOVWF  4F
....................    pilha_canTX[3]=pilha_can[1]; 
06F4:  MOVF   43,W
06F5:  MOVWF  50
....................    pilha_canTX[4]=pilha_can[2]; 
06F6:  MOVF   44,W
06F7:  MOVWF  51
.................... } 
06F8:  BCF    03.5
06F9:  RETLW  00
....................  
.................... void recebe_can() 
.................... { 
....................    int zaux; 
....................    if (f2510rx(pilha_can)==0) 
*
0800:  BSF    03.5
0801:  CLRF   5C
0802:  MOVLW  C2
0803:  MOVWF  5B
*
092C:  MOVF   78,F
092D:  BTFSS  03.2
092E:  GOTO   35A
....................    { 
....................       #IF CDEBUG  
....................       printf("mensagem\n\r"); 
....................       #ENDIF 
....................          switch(pilha_can[tipo]) 
....................          { 
092F:  MOVLW  01
0930:  SUBWF  47,W
0931:  ADDLW  ED
0932:  BTFSC  03.0
0933:  GOTO   35A
0934:  ADDLW  13
0935:  BCF    03.5
0936:  GOTO   35E
....................             case Set_Value: 
....................                if(pilha_can[sub_end_dest]<8)  
0937:  BSF    03.5
0938:  MOVF   44,W
0939:  SUBLW  07
093A:  BTFSS  03.0
093B:  GOTO   149
....................                { 
....................                   ltlevel[pilha_can[sub_end_dest]]=pilha_can[dados]; 
093C:  MOVLW  2E
093D:  ADDWF  44,W
093E:  MOVWF  04
093F:  BCF    03.7
0940:  MOVF   49,W
0941:  MOVWF  00
....................                   oldltlevel[pilha_can[sub_end_dest]]=pilha_can[dados]; 
0942:  MOVLW  36
0943:  ADDWF  44,W
0944:  MOVWF  04
0945:  BCF    03.7
0946:  MOVF   49,W
0947:  MOVWF  00
....................                } 
....................                else if(pilha_can[sub_end_dest]==0x69) 
0948:  GOTO   177
0949:  MOVF   44,W
094A:  SUBLW  69
094B:  BTFSS  03.2
094C:  GOTO   177
....................                { 
....................                    
....................                   for (zaux=0;zaux<8;++zaux) 
094D:  CLRF   5A
094E:  MOVF   5A,W
094F:  SUBLW  07
0950:  BTFSS  03.0
0951:  GOTO   177
....................                   {   
....................                      if(GAD[zaux]==1) 
0952:  MOVLW  47
0953:  ADDWF  5A,W
0954:  MOVWF  04
0955:  BCF    03.7
0956:  DECFSZ 00,W
0957:  GOTO   175
....................                      { 
....................                         aux33=pilha_can[dados]; 
0958:  MOVF   49,W
0959:  MOVWF  59
....................                         if(LOF[zaux]==0) 
095A:  MOVLW  3F
095B:  ADDWF  5A,W
095C:  MOVWF  04
095D:  BCF    03.7
095E:  MOVF   00,F
095F:  BTFSS  03.2
0960:  GOTO   169
....................                         { 
....................                            if(aux33<64) aux33=0; 
0961:  MOVF   59,W
0962:  SUBLW  3F
0963:  BTFSS  03.0
0964:  GOTO   167
0965:  CLRF   59
....................                            else aux33=0x7F; 
0966:  GOTO   169
0967:  MOVLW  7F
0968:  MOVWF  59
....................                         } 
....................                         ltlevel[zaux]=aux33; 
0969:  MOVLW  2E
096A:  ADDWF  5A,W
096B:  MOVWF  04
096C:  BCF    03.7
096D:  MOVF   59,W
096E:  MOVWF  00
....................                         oldltlevel[zaux]=aux33; 
096F:  MOVLW  36
0970:  ADDWF  5A,W
0971:  MOVWF  04
0972:  BCF    03.7
0973:  MOVF   59,W
0974:  MOVWF  00
....................                      } 
....................                   } 
0975:  INCF   5A,F
0976:  GOTO   14E
....................                } 
....................             org(); 
0977:  BCF    0A.3
0978:  BCF    03.5
0979:  CALL   31E
097A:  BSF    0A.3
....................             pilha_can[full]=0; 
097B:  BSF    03.5
097C:  CLRF   42
....................             break; 
097D:  GOTO   35A
....................             case Get_Value: 
....................                if (pilha_canTX[full]==0) 
097E:  BSF    03.5
097F:  MOVF   4D,F
0980:  BTFSS  03.2
0981:  GOTO   19E
....................                { 
....................                   pilha_canTX[full]=1; 
0982:  MOVLW  01
0983:  MOVWF  4D
....................                   send_to_requester(); 
0984:  BCF    0A.3
0985:  BCF    03.5
0986:  CALL   6EF
0987:  BSF    0A.3
....................                   pilha_canTX[tipo]=3; 
0988:  MOVLW  03
0989:  BSF    03.5
098A:  MOVWF  52
....................                   pilha_canTX[comp_dados]=1; 
098B:  MOVLW  01
098C:  MOVWF  53
....................                   pilha_canTX[dados]=ltlevel[pilha_can[sub_end_dest]]; 
098D:  MOVLW  2E
098E:  ADDWF  44,W
098F:  MOVWF  04
0990:  BCF    03.7
0991:  MOVF   00,W
0992:  MOVWF  54
....................                   f2510tx(pilha_canTX); 
0993:  BCF    03.5
0994:  BSF    03.6
0995:  CLRF   12
0996:  MOVLW  CD
0997:  MOVWF  11
0998:  BCF    0A.3
0999:  BCF    03.6
099A:  CALL   253
099B:  BSF    0A.3
....................                   pilha_can[full]=0; 
099C:  BSF    03.5
099D:  CLRF   42
....................                } 
....................             break; 
099E:  GOTO   35A
....................             case Ping_Request: 
....................                    #IF CDEBUG  
....................                    printf("received ping\n\r"); 
....................                    printf("pilha_canTX[0]=%X \n\r",pilha_canTX[full]); 
....................                    #ENDIF  
....................                    if (pilha_canTX[full]==0) 
099F:  BSF    03.5
09A0:  MOVF   4D,F
09A1:  BTFSS  03.2
09A2:  GOTO   1BA
....................                    { 
....................                       pilha_canTX[full]=1; 
09A3:  MOVLW  01
09A4:  MOVWF  4D
....................                       send_to_requester(); 
09A5:  BCF    0A.3
09A6:  BCF    03.5
09A7:  CALL   6EF
09A8:  BSF    0A.3
....................                       pilha_canTX[tipo]=Ping_Ans; 
09A9:  MOVLW  05
09AA:  BSF    03.5
09AB:  MOVWF  52
....................                       pilha_canTX[comp_dados]=0; 
09AC:  CLRF   53
....................                       daux=f2510tx(pilha_canTX); 
09AD:  BCF    03.5
09AE:  BSF    03.6
09AF:  CLRF   12
09B0:  MOVLW  CD
09B1:  MOVWF  11
09B2:  BCF    0A.3
09B3:  BCF    03.6
09B4:  CALL   253
09B5:  BSF    0A.3
09B6:  MOVF   78,W
09B7:  BSF    03.5
09B8:  MOVWF  58
....................                       #IF CDEBUG  
....................                       printf("send res:%X\n\r",daux); 
....................                       #ENDIF 
....................                       pilha_can[full]=0; 
09B9:  CLRF   42
....................                    } 
....................             break; 
09BA:  GOTO   35A
....................             case Indirect_adress_config: 
....................                iadress=pilha_can[dados]; 
09BB:  BSF    03.5
09BC:  MOVF   49,W
09BD:  MOVWF  7E
....................                pilha_can[full]=0; 
09BE:  CLRF   42
....................             break; 
09BF:  GOTO   35A
....................             case Direct_Adress: 
....................                iadress=0; 
09C0:  CLRF   7E
....................                pilha_can[full]=0; 
09C1:  BSF    03.5
09C2:  CLRF   42
....................             break; 
09C3:  GOTO   35A
....................             case Indirect_Set_Value: 
....................                if(iadress==0) { 
09C4:  MOVF   7E,F
09C5:  BTFSS  03.2
09C6:  GOTO   1CB
....................                pilha_can[full]=0; 
09C7:  BSF    03.5
09C8:  CLRF   42
....................                break; 
09C9:  GOTO   35A
09CA:  BCF    03.5
....................                } 
....................                for (zaux=0;zaux<8;++zaux) 
09CB:  BSF    03.5
09CC:  CLRF   5A
09CD:  MOVF   5A,W
09CE:  SUBLW  07
09CF:  BTFSS  03.0
09D0:  GOTO   1E5
....................                { 
....................                   if (bit_test(iadress,zaux)) ltlevel[zaux]=pilha_can[dados]; 
09D1:  MOVF   7E,W
09D2:  MOVWF  77
09D3:  MOVF   5A,W
09D4:  MOVWF  78
09D5:  BTFSC  03.2
09D6:  GOTO   1DB
09D7:  BCF    03.0
09D8:  RRF    77,F
09D9:  DECFSZ 78,F
09DA:  GOTO   1D7
09DB:  BTFSS  77.0
09DC:  GOTO   1E3
09DD:  MOVLW  2E
09DE:  ADDWF  5A,W
09DF:  MOVWF  04
09E0:  BCF    03.7
09E1:  MOVF   49,W
09E2:  MOVWF  00
....................                } 
09E3:  INCF   5A,F
09E4:  GOTO   1CD
....................                org(); 
09E5:  BCF    0A.3
09E6:  BCF    03.5
09E7:  CALL   31E
09E8:  BSF    0A.3
....................                pilha_can[full]=0; 
09E9:  BSF    03.5
09EA:  CLRF   42
....................             break; 
09EB:  GOTO   35A
....................             case reset: 
....................                pilha_can[full]=0; 
09EC:  BSF    03.5
09ED:  CLRF   42
....................                reset_cpu(); 
09EE:  CLRF   0A
09EF:  BCF    03.5
09F0:  GOTO   000
....................             break; 
09F1:  BSF    03.5
09F2:  GOTO   35A
....................             case newadr: 
....................                write_eeprom(save_adr,pilha_can[dados]); 
09F3:  MOVLW  01
09F4:  BSF    03.6
09F5:  MOVWF  0D
09F6:  BSF    03.5
09F7:  BCF    03.6
09F8:  MOVF   49,W
09F9:  BCF    03.5
09FA:  BSF    03.6
09FB:  MOVWF  0C
09FC:  BSF    03.5
09FD:  BCF    0C.7
09FE:  BSF    0C.2
09FF:  BCF    03.5
0A00:  BCF    03.6
0A01:  MOVF   0B,W
0A02:  MOVWF  77
0A03:  BCF    0B.7
0A04:  BSF    03.5
0A05:  BSF    03.6
0A06:  MOVLW  55
0A07:  MOVWF  0D
0A08:  MOVLW  AA
0A09:  MOVWF  0D
0A0A:  BSF    0C.1
0A0B:  BTFSC  0C.1
0A0C:  GOTO   20B
0A0D:  BCF    0C.2
0A0E:  MOVF   77,W
0A0F:  BCF    03.5
0A10:  BCF    03.6
0A11:  IORWF  0B,F
....................                pilha_can[full]=0; 
0A12:  BSF    03.5
0A13:  CLRF   42
....................                delay_ms(1000); 
0A14:  MOVLW  04
0A15:  MOVWF  5B
0A16:  MOVLW  FA
0A17:  MOVWF  5C
0A18:  BCF    0A.3
0A19:  BCF    03.5
0A1A:  CALL   616
0A1B:  BSF    0A.3
0A1C:  BSF    03.5
0A1D:  DECFSZ 5B,F
0A1E:  GOTO   216
....................                reset_cpu(); 
0A1F:  CLRF   0A
0A20:  BCF    03.5
0A21:  GOTO   000
....................             break; 
0A22:  BSF    03.5
0A23:  GOTO   35A
....................             case Set_Configuration: 
....................                write_eeprom(cfg_adr,pilha_can[dados]); 
0A24:  MOVLW  02
0A25:  BSF    03.6
0A26:  MOVWF  0D
0A27:  BSF    03.5
0A28:  BCF    03.6
0A29:  MOVF   49,W
0A2A:  BCF    03.5
0A2B:  BSF    03.6
0A2C:  MOVWF  0C
0A2D:  BSF    03.5
0A2E:  BCF    0C.7
0A2F:  BSF    0C.2
0A30:  BCF    03.5
0A31:  BCF    03.6
0A32:  MOVF   0B,W
0A33:  MOVWF  77
0A34:  BCF    0B.7
0A35:  BSF    03.5
0A36:  BSF    03.6
0A37:  MOVLW  55
0A38:  MOVWF  0D
0A39:  MOVLW  AA
0A3A:  MOVWF  0D
0A3B:  BSF    0C.1
0A3C:  BTFSC  0C.1
0A3D:  GOTO   23C
0A3E:  BCF    0C.2
0A3F:  MOVF   77,W
0A40:  BCF    03.5
0A41:  BCF    03.6
0A42:  IORWF  0B,F
....................                delay_ms(1000); 
0A43:  MOVLW  04
0A44:  BSF    03.5
0A45:  MOVWF  5B
0A46:  MOVLW  FA
0A47:  MOVWF  5C
0A48:  BCF    0A.3
0A49:  BCF    03.5
0A4A:  CALL   616
0A4B:  BSF    0A.3
0A4C:  BSF    03.5
0A4D:  DECFSZ 5B,F
0A4E:  GOTO   246
....................                pilha_can[full]=0; 
0A4F:  CLRF   42
....................                reset_cpu(); 
0A50:  CLRF   0A
0A51:  BCF    03.5
0A52:  GOTO   000
....................                 
....................             break; 
0A53:  BSF    03.5
0A54:  GOTO   35A
....................             case Get_Configuration: 
....................                    if (pilha_canTX[full]==0) 
0A55:  BSF    03.5
0A56:  MOVF   4D,F
0A57:  BTFSS  03.2
0A58:  GOTO   28A
....................                    { 
....................                       pilha_canTX[full]=1; 
0A59:  MOVLW  01
0A5A:  MOVWF  4D
....................                       send_to_requester(); 
0A5B:  BCF    0A.3
0A5C:  BCF    03.5
0A5D:  CALL   6EF
0A5E:  BSF    0A.3
....................                       pilha_canTX[tipo]=Configuration_Ans; 
0A5F:  MOVLW  08
0A60:  BSF    03.5
0A61:  MOVWF  52
....................                       pilha_canTX[comp_dados]=1; 
0A62:  MOVLW  01
0A63:  MOVWF  53
....................                       aux33=read_eeprom(cfg_adr); 
0A64:  MOVLW  02
0A65:  BCF    03.5
0A66:  BSF    03.6
0A67:  MOVWF  0D
0A68:  BSF    03.5
0A69:  BCF    0C.7
0A6A:  BSF    0C.0
0A6B:  BCF    03.5
0A6C:  MOVF   0C,W
0A6D:  BSF    03.5
0A6E:  BCF    03.6
0A6F:  MOVWF  59
....................                       delay_ms(1000); 
0A70:  MOVLW  04
0A71:  MOVWF  5B
0A72:  MOVLW  FA
0A73:  MOVWF  5C
0A74:  BCF    0A.3
0A75:  BCF    03.5
0A76:  CALL   616
0A77:  BSF    0A.3
0A78:  BSF    03.5
0A79:  DECFSZ 5B,F
0A7A:  GOTO   272
....................                       pilha_canTX[dados]=aux33; 
0A7B:  MOVF   59,W
0A7C:  MOVWF  54
....................                       daux=f2510tx(pilha_canTX); 
0A7D:  BCF    03.5
0A7E:  BSF    03.6
0A7F:  CLRF   12
0A80:  MOVLW  CD
0A81:  MOVWF  11
0A82:  BCF    0A.3
0A83:  BCF    03.6
0A84:  CALL   253
0A85:  BSF    0A.3
0A86:  MOVF   78,W
0A87:  BSF    03.5
0A88:  MOVWF  58
....................                       pilha_can[full]=0; 
0A89:  CLRF   42
....................                    } 
....................             break; 
0A8A:  GOTO   35A
....................             case Set_virtual_int: 
....................                write_eeprom(cfg2_adr,pilha_can[dados]); 
0A8B:  MOVLW  04
0A8C:  BSF    03.6
0A8D:  MOVWF  0D
0A8E:  BSF    03.5
0A8F:  BCF    03.6
0A90:  MOVF   49,W
0A91:  BCF    03.5
0A92:  BSF    03.6
0A93:  MOVWF  0C
0A94:  BSF    03.5
0A95:  BCF    0C.7
0A96:  BSF    0C.2
0A97:  BCF    03.5
0A98:  BCF    03.6
0A99:  MOVF   0B,W
0A9A:  MOVWF  77
0A9B:  BCF    0B.7
0A9C:  BSF    03.5
0A9D:  BSF    03.6
0A9E:  MOVLW  55
0A9F:  MOVWF  0D
0AA0:  MOVLW  AA
0AA1:  MOVWF  0D
0AA2:  BSF    0C.1
0AA3:  BTFSC  0C.1
0AA4:  GOTO   2A3
0AA5:  BCF    0C.2
0AA6:  MOVF   77,W
0AA7:  BCF    03.5
0AA8:  BCF    03.6
0AA9:  IORWF  0B,F
....................                delay_ms(1000); 
0AAA:  MOVLW  04
0AAB:  BSF    03.5
0AAC:  MOVWF  5B
0AAD:  MOVLW  FA
0AAE:  MOVWF  5C
0AAF:  BCF    0A.3
0AB0:  BCF    03.5
0AB1:  CALL   616
0AB2:  BSF    0A.3
0AB3:  BSF    03.5
0AB4:  DECFSZ 5B,F
0AB5:  GOTO   2AD
....................                //cfgload(); 
....................                pilha_can[full]=0; 
0AB6:  CLRF   42
....................                reset_cpu(); 
0AB7:  CLRF   0A
0AB8:  BCF    03.5
0AB9:  GOTO   000
....................             break; 
0ABA:  BSF    03.5
0ABB:  GOTO   35A
....................             case Get_virtual_int: 
....................                    if (pilha_canTX[full]==0) 
0ABC:  BSF    03.5
0ABD:  MOVF   4D,F
0ABE:  BTFSS  03.2
0ABF:  GOTO   2F1
....................                    { 
....................                       pilha_canTX[full]=1; 
0AC0:  MOVLW  01
0AC1:  MOVWF  4D
....................                       send_to_requester(); 
0AC2:  BCF    0A.3
0AC3:  BCF    03.5
0AC4:  CALL   6EF
0AC5:  BSF    0A.3
....................                       pilha_canTX[tipo]=Virtual_int_Ans; 
0AC6:  MOVLW  11
0AC7:  BSF    03.5
0AC8:  MOVWF  52
....................                       pilha_canTX[comp_dados]=1; 
0AC9:  MOVLW  01
0ACA:  MOVWF  53
....................                       aux33=read_eeprom(cfg2_adr); 
0ACB:  MOVLW  04
0ACC:  BCF    03.5
0ACD:  BSF    03.6
0ACE:  MOVWF  0D
0ACF:  BSF    03.5
0AD0:  BCF    0C.7
0AD1:  BSF    0C.0
0AD2:  BCF    03.5
0AD3:  MOVF   0C,W
0AD4:  BSF    03.5
0AD5:  BCF    03.6
0AD6:  MOVWF  59
....................                       delay_ms(1000); 
0AD7:  MOVLW  04
0AD8:  MOVWF  5B
0AD9:  MOVLW  FA
0ADA:  MOVWF  5C
0ADB:  BCF    0A.3
0ADC:  BCF    03.5
0ADD:  CALL   616
0ADE:  BSF    0A.3
0ADF:  BSF    03.5
0AE0:  DECFSZ 5B,F
0AE1:  GOTO   2D9
....................                       pilha_canTX[dados]=aux33; 
0AE2:  MOVF   59,W
0AE3:  MOVWF  54
....................                       daux=f2510tx(pilha_canTX); 
0AE4:  BCF    03.5
0AE5:  BSF    03.6
0AE6:  CLRF   12
0AE7:  MOVLW  CD
0AE8:  MOVWF  11
0AE9:  BCF    0A.3
0AEA:  BCF    03.6
0AEB:  CALL   253
0AEC:  BSF    0A.3
0AED:  MOVF   78,W
0AEE:  BSF    03.5
0AEF:  MOVWF  58
....................                       pilha_can[full]=0; 
0AF0:  CLRF   42
....................                    } 
....................             break; 
0AF1:  GOTO   35A
....................             case Set_glob_adr: 
....................                write_eeprom(cfg3_adr,pilha_can[dados]); 
0AF2:  MOVLW  05
0AF3:  BSF    03.6
0AF4:  MOVWF  0D
0AF5:  BSF    03.5
0AF6:  BCF    03.6
0AF7:  MOVF   49,W
0AF8:  BCF    03.5
0AF9:  BSF    03.6
0AFA:  MOVWF  0C
0AFB:  BSF    03.5
0AFC:  BCF    0C.7
0AFD:  BSF    0C.2
0AFE:  BCF    03.5
0AFF:  BCF    03.6
0B00:  MOVF   0B,W
0B01:  MOVWF  77
0B02:  BCF    0B.7
0B03:  BSF    03.5
0B04:  BSF    03.6
0B05:  MOVLW  55
0B06:  MOVWF  0D
0B07:  MOVLW  AA
0B08:  MOVWF  0D
0B09:  BSF    0C.1
0B0A:  BTFSC  0C.1
0B0B:  GOTO   30A
0B0C:  BCF    0C.2
0B0D:  MOVF   77,W
0B0E:  BCF    03.5
0B0F:  BCF    03.6
0B10:  IORWF  0B,F
....................                delay_ms(1000); 
0B11:  MOVLW  04
0B12:  BSF    03.5
0B13:  MOVWF  5B
0B14:  MOVLW  FA
0B15:  MOVWF  5C
0B16:  BCF    0A.3
0B17:  BCF    03.5
0B18:  CALL   616
0B19:  BSF    0A.3
0B1A:  BSF    03.5
0B1B:  DECFSZ 5B,F
0B1C:  GOTO   314
....................                //cfgload(); 
....................                pilha_can[full]=0; 
0B1D:  CLRF   42
....................                reset_cpu(); 
0B1E:  CLRF   0A
0B1F:  BCF    03.5
0B20:  GOTO   000
....................             break; 
0B21:  BSF    03.5
0B22:  GOTO   35A
....................             case Get_glob_adr: 
....................                    if (pilha_canTX[full]==0) 
0B23:  BSF    03.5
0B24:  MOVF   4D,F
0B25:  BTFSS  03.2
0B26:  GOTO   358
....................                    { 
....................                       pilha_canTX[full]=1; 
0B27:  MOVLW  01
0B28:  MOVWF  4D
....................                       send_to_requester(); 
0B29:  BCF    0A.3
0B2A:  BCF    03.5
0B2B:  CALL   6EF
0B2C:  BSF    0A.3
....................                       pilha_canTX[tipo]=glob_adr_ans; 
0B2D:  MOVLW  14
0B2E:  BSF    03.5
0B2F:  MOVWF  52
....................                       pilha_canTX[comp_dados]=1; 
0B30:  MOVLW  01
0B31:  MOVWF  53
....................                       aux33=read_eeprom(cfg2_adr); 
0B32:  MOVLW  04
0B33:  BCF    03.5
0B34:  BSF    03.6
0B35:  MOVWF  0D
0B36:  BSF    03.5
0B37:  BCF    0C.7
0B38:  BSF    0C.0
0B39:  BCF    03.5
0B3A:  MOVF   0C,W
0B3B:  BSF    03.5
0B3C:  BCF    03.6
0B3D:  MOVWF  59
....................                       delay_ms(1000); 
0B3E:  MOVLW  04
0B3F:  MOVWF  5B
0B40:  MOVLW  FA
0B41:  MOVWF  5C
0B42:  BCF    0A.3
0B43:  BCF    03.5
0B44:  CALL   616
0B45:  BSF    0A.3
0B46:  BSF    03.5
0B47:  DECFSZ 5B,F
0B48:  GOTO   340
....................                       pilha_canTX[dados]=aux33; 
0B49:  MOVF   59,W
0B4A:  MOVWF  54
....................                       daux=f2510tx(pilha_canTX); 
0B4B:  BCF    03.5
0B4C:  BSF    03.6
0B4D:  CLRF   12
0B4E:  MOVLW  CD
0B4F:  MOVWF  11
0B50:  BCF    0A.3
0B51:  BCF    03.6
0B52:  CALL   253
0B53:  BSF    0A.3
0B54:  MOVF   78,W
0B55:  BSF    03.5
0B56:  MOVWF  58
....................                       pilha_can[full]=0; 
0B57:  CLRF   42
....................                    } 
....................             break; 
0B58:  GOTO   35A
0B59:  BSF    03.5
....................  
....................  
....................  
....................       } 
....................    } 
.................... } 
0B5A:  BCF    03.5
0B5B:  BSF    0A.3
0B5C:  BCF    0A.4
0B5D:  GOTO   5C7 (RETURN)
....................  
.................... #include "org.c" 
.................... //#inline 
.................... void org(void) 
.................... {  int clockorg; 
....................    int tempd[8][2]; 
....................    int numluzes; 
....................    int1 again=1; 
*
031E:  BSF    03.5
031F:  BSF    6D.0
....................    int fa; 
....................    int fl; 
....................    int afa; 
....................    clockorg=clock; 
0320:  MOVF   7D,W
0321:  MOVWF  5B
....................    for (fa=0;fa<8;++fa) 
0322:  CLRF   6E
0323:  MOVF   6E,W
0324:  SUBLW  07
0325:  BTFSS  03.0
0326:  GOTO   3A9
....................    { 
....................  
....................       if(oldltlevel[fa]!=ltlevel[fa]) 
0327:  MOVLW  36
0328:  ADDWF  6E,W
0329:  MOVWF  04
032A:  BCF    03.7
032B:  MOVF   00,W
032C:  BCF    03.5
032D:  BSF    03.6
032E:  MOVWF  11
032F:  MOVLW  2E
0330:  BSF    03.5
0331:  BCF    03.6
0332:  ADDWF  6E,W
0333:  MOVWF  04
0334:  BCF    03.7
0335:  MOVF   00,W
0336:  BCF    03.5
0337:  BSF    03.6
0338:  SUBWF  11,W
0339:  BTFSC  03.2
033A:  GOTO   379
....................       { 
....................          if (pilha_canTX[full]==0) 
033B:  BSF    03.5
033C:  BCF    03.6
033D:  MOVF   4D,F
033E:  BTFSS  03.2
033F:  GOTO   35C
....................          { 
....................             pilha_canTX[full]=1; 
0340:  MOVLW  01
0341:  MOVWF  4D
....................             pilha_canTX[end_dest]=0; 
0342:  CLRF   4E
....................             pilha_canTX[sub_end_dest]=0; 
0343:  CLRF   4F
....................             pilha_canTX[end_orig]=adr; 
0344:  BCF    03.5
0345:  MOVF   3E,W
0346:  BSF    03.5
0347:  MOVWF  50
....................             pilha_canTX[comp_dados]=1; 
0348:  MOVLW  01
0349:  MOVWF  53
....................             pilha_canTX[sub_end_orig]=fa; 
034A:  MOVF   6E,W
034B:  MOVWF  51
....................             pilha_canTX[tipo]=man_val_change; 
034C:  MOVLW  0D
034D:  MOVWF  52
....................             pilha_canTX[dados]=ltlevel[fa]; 
034E:  MOVLW  2E
034F:  ADDWF  6E,W
0350:  MOVWF  04
0351:  BCF    03.7
0352:  MOVF   00,W
0353:  MOVWF  54
....................             f2510tx(pilha_canTX); 
0354:  BCF    03.5
0355:  BSF    03.6
0356:  CLRF   12
0357:  MOVLW  CD
0358:  MOVWF  11
0359:  BCF    03.6
035A:  CALL   253
035B:  BSF    03.5
....................          } 
....................          oldltlevel[fa]=ltlevel[fa]; 
035C:  MOVLW  36
035D:  ADDWF  6E,W
035E:  MOVWF  78
035F:  CLRF   7A
0360:  BTFSC  03.0
0361:  INCF   7A,F
0362:  MOVF   78,W
0363:  BCF    03.5
0364:  BSF    03.6
0365:  MOVWF  11
0366:  MOVF   7A,W
0367:  MOVWF  12
0368:  MOVLW  2E
0369:  BSF    03.5
036A:  BCF    03.6
036B:  ADDWF  6E,W
036C:  MOVWF  04
036D:  BCF    03.7
036E:  MOVF   00,W
036F:  BCF    03.5
0370:  BSF    03.6
0371:  MOVWF  13
0372:  MOVF   11,W
0373:  MOVWF  04
0374:  BCF    03.7
0375:  BTFSC  12.0
0376:  BSF    03.7
0377:  MOVF   13,W
0378:  MOVWF  00
....................       } 
....................  
....................       tempd[fa][0]=ltlevel[fa]; 
0379:  BCF    03.0
037A:  BSF    03.5
037B:  BCF    03.6
037C:  RLF    6E,W
037D:  ADDLW  DC
037E:  MOVWF  78
037F:  CLRF   7A
0380:  BTFSC  03.0
0381:  INCF   7A,F
0382:  MOVF   78,W
0383:  BCF    03.5
0384:  BSF    03.6
0385:  MOVWF  12
0386:  MOVF   7A,W
0387:  MOVWF  13
0388:  MOVLW  2E
0389:  BSF    03.5
038A:  BCF    03.6
038B:  ADDWF  6E,W
038C:  MOVWF  04
038D:  BCF    03.7
038E:  MOVF   00,W
038F:  BCF    03.5
0390:  BSF    03.6
0391:  MOVWF  14
0392:  MOVF   12,W
0393:  MOVWF  04
0394:  BCF    03.7
0395:  BTFSC  13.0
0396:  BSF    03.7
0397:  MOVF   14,W
0398:  MOVWF  00
....................       tempd[fa][1]=lights[fa]; 
0399:  BCF    03.0
039A:  BSF    03.5
039B:  BCF    03.6
039C:  RLF    6E,W
039D:  ADDLW  01
039E:  ADDLW  DC
039F:  MOVWF  04
03A0:  BCF    03.7
03A1:  MOVF   6E,W
03A2:  BCF    03.5
03A3:  CALL   143
03A4:  MOVWF  78
03A5:  MOVWF  00
....................    } 
03A6:  BSF    03.5
03A7:  INCF   6E,F
03A8:  GOTO   323
....................  
....................    while(again) 
....................    { 
03A9:  BTFSS  6D.0
03AA:  GOTO   447
....................       again=0; 
03AB:  BCF    6D.0
....................       for (fa=0;fa<7;++fa) 
03AC:  CLRF   6E
03AD:  MOVF   6E,W
03AE:  SUBLW  06
03AF:  BTFSS  03.0
03B0:  GOTO   446
....................       { 
....................          if (tempd[fa][0]<tempd[fa+1][0]) 
03B1:  BCF    03.0
03B2:  RLF    6E,W
03B3:  ADDLW  DC
03B4:  MOVWF  04
03B5:  BCF    03.7
03B6:  MOVF   00,W
03B7:  BCF    03.5
03B8:  BSF    03.6
03B9:  MOVWF  12
03BA:  MOVLW  01
03BB:  BSF    03.5
03BC:  BCF    03.6
03BD:  ADDWF  6E,W
03BE:  MOVWF  77
03BF:  BCF    03.0
03C0:  RLF    77,F
03C1:  MOVF   77,W
03C2:  ADDLW  DC
03C3:  MOVWF  04
03C4:  BCF    03.7
03C5:  MOVF   00,W
03C6:  BCF    03.5
03C7:  BSF    03.6
03C8:  SUBWF  12,W
03C9:  BTFSC  03.0
03CA:  GOTO   442
....................          { 
....................             again=1; 
03CB:  BSF    03.5
03CC:  BCF    03.6
03CD:  BSF    6D.0
....................             fl=tempd[fa][0]; 
03CE:  BCF    03.0
03CF:  RLF    6E,W
03D0:  ADDLW  DC
03D1:  MOVWF  04
03D2:  BCF    03.7
03D3:  MOVF   00,W
03D4:  MOVWF  6F
....................             tempd[fa][0]=tempd[fa+1][0]; 
03D5:  BCF    03.0
03D6:  RLF    6E,W
03D7:  ADDLW  DC
03D8:  MOVWF  78
03D9:  CLRF   7A
03DA:  BTFSC  03.0
03DB:  INCF   7A,F
03DC:  MOVF   78,W
03DD:  BCF    03.5
03DE:  BSF    03.6
03DF:  MOVWF  12
03E0:  MOVF   7A,W
03E1:  MOVWF  13
03E2:  MOVLW  01
03E3:  BSF    03.5
03E4:  BCF    03.6
03E5:  ADDWF  6E,W
03E6:  MOVWF  77
03E7:  BCF    03.0
03E8:  RLF    77,F
03E9:  MOVF   77,W
03EA:  ADDLW  DC
03EB:  MOVWF  04
03EC:  BCF    03.7
03ED:  MOVF   00,W
03EE:  BCF    03.5
03EF:  BSF    03.6
03F0:  MOVWF  16
03F1:  MOVF   12,W
03F2:  MOVWF  04
03F3:  BCF    03.7
03F4:  BTFSC  13.0
03F5:  BSF    03.7
03F6:  MOVF   16,W
03F7:  MOVWF  00
....................             tempd[fa+1][0]=fl; 
03F8:  MOVLW  01
03F9:  BSF    03.5
03FA:  BCF    03.6
03FB:  ADDWF  6E,W
03FC:  MOVWF  77
03FD:  BCF    03.0
03FE:  RLF    77,F
03FF:  MOVF   77,W
0400:  ADDLW  DC
0401:  MOVWF  04
0402:  BCF    03.7
0403:  MOVF   6F,W
0404:  MOVWF  00
....................             fl=tempd[fa][1]; 
0405:  BCF    03.0
0406:  RLF    6E,W
0407:  ADDLW  01
0408:  ADDLW  DC
0409:  MOVWF  04
040A:  BCF    03.7
040B:  MOVF   00,W
040C:  MOVWF  6F
....................             tempd[fa][1]=tempd[fa+1][1]; 
040D:  BCF    03.0
040E:  RLF    6E,W
040F:  ADDLW  01
0410:  ADDLW  DC
0411:  MOVWF  78
0412:  CLRF   7A
0413:  BTFSC  03.0
0414:  INCF   7A,F
0415:  MOVF   78,W
0416:  BCF    03.5
0417:  BSF    03.6
0418:  MOVWF  12
0419:  MOVF   7A,W
041A:  MOVWF  13
041B:  MOVLW  01
041C:  BSF    03.5
041D:  BCF    03.6
041E:  ADDWF  6E,W
041F:  MOVWF  77
0420:  BCF    03.0
0421:  RLF    77,F
0422:  MOVF   77,W
0423:  ADDLW  01
0424:  ADDLW  DC
0425:  MOVWF  04
0426:  BCF    03.7
0427:  MOVF   00,W
0428:  BCF    03.5
0429:  BSF    03.6
042A:  MOVWF  16
042B:  MOVF   12,W
042C:  MOVWF  04
042D:  BCF    03.7
042E:  BTFSC  13.0
042F:  BSF    03.7
0430:  MOVF   16,W
0431:  MOVWF  00
....................             tempd[fa+1][1]=fl; 
0432:  MOVLW  01
0433:  BSF    03.5
0434:  BCF    03.6
0435:  ADDWF  6E,W
0436:  MOVWF  77
0437:  BCF    03.0
0438:  RLF    77,F
0439:  MOVF   77,W
043A:  ADDLW  01
043B:  ADDLW  DC
043C:  MOVWF  04
043D:  BCF    03.7
043E:  MOVF   6F,W
043F:  MOVWF  00
0440:  BCF    03.5
0441:  BSF    03.6
....................          } 
....................       } 
0442:  BSF    03.5
0443:  BCF    03.6
0444:  INCF   6E,F
0445:  GOTO   3AD
....................    } 
0446:  GOTO   3A9
....................    if (tempd[0][0]==0) numluzes=0; 
0447:  MOVF   5C,F
0448:  BTFSS  03.2
0449:  GOTO   44C
044A:  CLRF   6C
....................    else 
044B:  GOTO   593
....................    { 
....................       numluzes=1; 
044C:  MOVLW  01
044D:  MOVWF  6C
....................       afa=0; 
044E:  BCF    03.5
044F:  BSF    03.6
0450:  CLRF   10
....................       if (actmat) 
0451:  BCF    03.6
0452:  BTFSS  4F.1
0453:  GOTO   45D
....................       {    
....................          delays1[0][0]=tempd[0][0]; 
0454:  BSF    03.5
0455:  MOVF   5C,W
0456:  BCF    03.5
0457:  MOVWF  59
....................          delays1[0][1]=tempd[0][1]; 
0458:  BSF    03.5
0459:  MOVF   5D,W
045A:  BCF    03.5
045B:  MOVWF  5A
....................       } 
....................  
....................       else        
045C:  GOTO   463
....................       { 
....................          delays2[0][0]=tempd[0][0]; 
045D:  BSF    03.5
045E:  MOVF   5C,W
045F:  MOVWF  20
....................          delays2[0][1]=tempd[0][1]; 
0460:  MOVF   5D,W
0461:  MOVWF  21
0462:  BCF    03.5
....................       } 
....................  
....................       for (fa=1;fa<8;++fa) 
0463:  MOVLW  01
0464:  BSF    03.5
0465:  MOVWF  6E
0466:  MOVF   6E,W
0467:  SUBLW  07
0468:  BTFSS  03.0
0469:  GOTO   593
....................       { 
....................          if ((tempd[fa][0]==tempd[fa-1][0]) & (!tempd[fa][0]==0))  
046A:  BCF    03.0
046B:  RLF    6E,W
046C:  ADDLW  DC
046D:  MOVWF  04
046E:  BCF    03.7
046F:  MOVF   00,W
0470:  BCF    03.5
0471:  BSF    03.6
0472:  MOVWF  12
0473:  MOVLW  01
0474:  BSF    03.5
0475:  BCF    03.6
0476:  SUBWF  6E,W
0477:  MOVWF  77
0478:  BCF    03.0
0479:  RLF    77,F
047A:  MOVF   77,W
047B:  ADDLW  DC
047C:  MOVWF  04
047D:  BCF    03.7
047E:  MOVF   00,W
047F:  BCF    03.5
0480:  BSF    03.6
0481:  SUBWF  12,W
0482:  BTFSC  03.2
0483:  GOTO   486
0484:  MOVLW  00
0485:  GOTO   487
0486:  MOVLW  01
0487:  MOVWF  15
0488:  BCF    03.0
0489:  BSF    03.5
048A:  BCF    03.6
048B:  RLF    6E,W
048C:  ADDLW  DC
048D:  MOVWF  04
048E:  BCF    03.7
048F:  MOVF   00,F
0490:  BTFSC  03.2
0491:  GOTO   494
0492:  MOVLW  00
0493:  GOTO   495
0494:  MOVLW  01
0495:  XORLW  00
0496:  BTFSC  03.2
0497:  GOTO   49A
0498:  MOVLW  00
0499:  GOTO   49B
049A:  MOVLW  01
049B:  BCF    03.5
049C:  BSF    03.6
049D:  ANDWF  15,W
049E:  BTFSC  03.2
049F:  GOTO   4F8
....................          { 
....................             if (actmat) delays1[afa][1]=delays1[afa][1] & tempd[fa][1]; 
04A0:  BCF    03.6
04A1:  BTFSS  4F.1
04A2:  GOTO   4CE
04A3:  BCF    03.0
04A4:  BSF    03.6
04A5:  RLF    10,W
04A6:  ADDLW  01
04A7:  ADDLW  59
04A8:  MOVWF  78
04A9:  CLRF   7A
04AA:  BTFSC  03.0
04AB:  INCF   7A,F
04AC:  MOVF   78,W
04AD:  MOVWF  12
04AE:  MOVF   7A,W
04AF:  MOVWF  13
04B0:  BCF    03.0
04B1:  RLF    10,W
04B2:  ADDLW  01
04B3:  ADDLW  59
04B4:  MOVWF  04
04B5:  BCF    03.7
04B6:  MOVF   00,W
04B7:  MOVWF  15
04B8:  BCF    03.0
04B9:  BSF    03.5
04BA:  BCF    03.6
04BB:  RLF    6E,W
04BC:  ADDLW  01
04BD:  ADDLW  DC
04BE:  MOVWF  04
04BF:  BCF    03.7
04C0:  MOVF   00,W
04C1:  BCF    03.5
04C2:  BSF    03.6
04C3:  ANDWF  15,W
04C4:  MOVWF  17
04C5:  MOVF   12,W
04C6:  MOVWF  04
04C7:  BCF    03.7
04C8:  BTFSC  13.0
04C9:  BSF    03.7
04CA:  MOVF   17,W
04CB:  MOVWF  00
....................             else delays2[afa][1]=delays2[afa][1] & tempd[fa][1]; 
04CC:  GOTO   4F7
04CD:  BCF    03.6
04CE:  BCF    03.0
04CF:  BSF    03.6
04D0:  RLF    10,W
04D1:  ADDLW  01
04D2:  ADDLW  A0
04D3:  MOVWF  78
04D4:  CLRF   7A
04D5:  BTFSC  03.0
04D6:  INCF   7A,F
04D7:  MOVF   78,W
04D8:  MOVWF  12
04D9:  MOVF   7A,W
04DA:  MOVWF  13
04DB:  BCF    03.0
04DC:  RLF    10,W
04DD:  ADDLW  01
04DE:  ADDLW  A0
04DF:  MOVWF  04
04E0:  BCF    03.7
04E1:  MOVF   00,W
04E2:  MOVWF  15
04E3:  BCF    03.0
04E4:  BSF    03.5
04E5:  BCF    03.6
04E6:  RLF    6E,W
04E7:  ADDLW  01
04E8:  ADDLW  DC
04E9:  MOVWF  04
04EA:  BCF    03.7
04EB:  MOVF   00,W
04EC:  BCF    03.5
04ED:  BSF    03.6
04EE:  ANDWF  15,W
04EF:  MOVWF  17
04F0:  MOVF   12,W
04F1:  MOVWF  04
04F2:  BCF    03.7
04F3:  BTFSC  13.0
04F4:  BSF    03.7
04F5:  MOVF   17,W
04F6:  MOVWF  00
....................          } 
....................          else if (!tempd[fa][0]==0) 
04F7:  GOTO   58F
04F8:  BCF    03.0
04F9:  BSF    03.5
04FA:  BCF    03.6
04FB:  RLF    6E,W
04FC:  ADDLW  DC
04FD:  MOVWF  04
04FE:  BCF    03.7
04FF:  MOVF   00,F
0500:  BTFSC  03.2
0501:  GOTO   504
0502:  MOVLW  00
0503:  GOTO   505
0504:  MOVLW  01
0505:  XORLW  00
0506:  BTFSS  03.2
0507:  GOTO   58D
....................          { 
....................             ++afa; 
0508:  BCF    03.5
0509:  BSF    03.6
050A:  INCF   10,F
....................             if (actmat) 
050B:  BCF    03.6
050C:  BTFSS  4F.1
050D:  GOTO   54D
....................             { 
....................                delays1[afa][0]=tempd[fa][0]; 
050E:  BCF    03.0
050F:  BSF    03.6
0510:  RLF    10,W
0511:  ADDLW  59
0512:  MOVWF  78
0513:  CLRF   7A
0514:  BTFSC  03.0
0515:  INCF   7A,F
0516:  MOVF   78,W
0517:  MOVWF  12
0518:  MOVF   7A,W
0519:  MOVWF  13
051A:  BCF    03.0
051B:  BSF    03.5
051C:  BCF    03.6
051D:  RLF    6E,W
051E:  ADDLW  DC
051F:  MOVWF  04
0520:  BCF    03.7
0521:  MOVF   00,W
0522:  BCF    03.5
0523:  BSF    03.6
0524:  MOVWF  15
0525:  MOVF   12,W
0526:  MOVWF  04
0527:  BCF    03.7
0528:  BTFSC  13.0
0529:  BSF    03.7
052A:  MOVF   15,W
052B:  MOVWF  00
....................                delays1[afa][1]=tempd[fa][1];} 
052C:  BCF    03.0
052D:  RLF    10,W
052E:  ADDLW  01
052F:  ADDLW  59
0530:  MOVWF  78
0531:  CLRF   7A
0532:  BTFSC  03.0
0533:  INCF   7A,F
0534:  MOVF   78,W
0535:  MOVWF  12
0536:  MOVF   7A,W
0537:  MOVWF  13
0538:  BCF    03.0
0539:  BSF    03.5
053A:  BCF    03.6
053B:  RLF    6E,W
053C:  ADDLW  01
053D:  ADDLW  DC
053E:  MOVWF  04
053F:  BCF    03.7
0540:  MOVF   00,W
0541:  BCF    03.5
0542:  BSF    03.6
0543:  MOVWF  15
0544:  MOVF   12,W
0545:  MOVWF  04
0546:  BCF    03.7
0547:  BTFSC  13.0
0548:  BSF    03.7
0549:  MOVF   15,W
054A:  MOVWF  00
....................             else        
054B:  GOTO   58A
054C:  BCF    03.6
....................             { 
....................                delays2[afa][0]=tempd[fa][0]; 
054D:  BCF    03.0
054E:  BSF    03.6
054F:  RLF    10,W
0550:  ADDLW  A0
0551:  MOVWF  78
0552:  CLRF   7A
0553:  BTFSC  03.0
0554:  INCF   7A,F
0555:  MOVF   78,W
0556:  MOVWF  12
0557:  MOVF   7A,W
0558:  MOVWF  13
0559:  BCF    03.0
055A:  BSF    03.5
055B:  BCF    03.6
055C:  RLF    6E,W
055D:  ADDLW  DC
055E:  MOVWF  04
055F:  BCF    03.7
0560:  MOVF   00,W
0561:  BCF    03.5
0562:  BSF    03.6
0563:  MOVWF  15
0564:  MOVF   12,W
0565:  MOVWF  04
0566:  BCF    03.7
0567:  BTFSC  13.0
0568:  BSF    03.7
0569:  MOVF   15,W
056A:  MOVWF  00
....................                delays2[afa][1]=tempd[fa][1]; 
056B:  BCF    03.0
056C:  RLF    10,W
056D:  ADDLW  01
056E:  ADDLW  A0
056F:  MOVWF  78
0570:  CLRF   7A
0571:  BTFSC  03.0
0572:  INCF   7A,F
0573:  MOVF   78,W
0574:  MOVWF  12
0575:  MOVF   7A,W
0576:  MOVWF  13
0577:  BCF    03.0
0578:  BSF    03.5
0579:  BCF    03.6
057A:  RLF    6E,W
057B:  ADDLW  01
057C:  ADDLW  DC
057D:  MOVWF  04
057E:  BCF    03.7
057F:  MOVF   00,W
0580:  BCF    03.5
0581:  BSF    03.6
0582:  MOVWF  15
0583:  MOVF   12,W
0584:  MOVWF  04
0585:  BCF    03.7
0586:  BTFSC  13.0
0587:  BSF    03.7
0588:  MOVF   15,W
0589:  MOVWF  00
....................             } 
....................             ++numluzes; 
058A:  BSF    03.5
058B:  BCF    03.6
058C:  INCF   6C,F
058D:  BCF    03.5
058E:  BSF    03.6
....................          } 
....................       } 
058F:  BSF    03.5
0590:  BCF    03.6
0591:  INCF   6E,F
0592:  GOTO   466
....................    } 
....................    if (actmat) delays1[8][0]=numluzes; 
0593:  BCF    03.5
0594:  BTFSS  4F.1
0595:  GOTO   59B
0596:  BSF    03.5
0597:  MOVF   6C,W
0598:  BCF    03.5
0599:  MOVWF  69
....................    else        delays2[8][0]=numluzes; 
059A:  GOTO   59F
059B:  BSF    03.5
059C:  MOVF   6C,W
059D:  MOVWF  30
059E:  BCF    03.5
....................   //TESTE**************************************** 
....................   /* 
....................   for (fa=0;fa<9;++fa) 
....................    { 
....................    if (actmat) printf("%U: [0]=%U [1]=%U\n\r",fa,delays1[fa][0],delays1[fa][1]); 
....................    else        printf("%U: [0]=%U [1]=%U\n\r",fa,delays2[fa][0],delays2[fa][1]);    
....................    }*/ 
.................... organizado=1; 
059F:  BSF    4F.0
.................... clock=clockorg; 
05A0:  BSF    03.5
05A1:  MOVF   5B,W
05A2:  MOVWF  7D
.................... } 
05A3:  BCF    03.5
05A4:  RETLW  00
....................  
.................... #include "swit_virtual.c" 
....................   void swit_virtual(int n) 
....................   { 
....................      int clockorg; 
....................      int1 a; 
....................      clockorg=clock; 
*
06FA:  MOVF   7D,W
06FB:  BSF    03.5
06FC:  MOVWF  5B
....................      if (LOF[n]!=2) return; 
06FD:  MOVLW  3F
06FE:  ADDWF  5A,W
06FF:  MOVWF  04
0700:  BCF    03.7
0701:  MOVF   00,W
0702:  SUBLW  02
0703:  BTFSS  03.2
0704:  GOTO   78C
....................       
....................      switch (n) 
....................      { 
0705:  MOVF   5A,W
0706:  ADDLW  F8
0707:  BTFSC  03.0
0708:  GOTO   75D
0709:  ADDLW  08
070A:  BCF    03.5
070B:  GOTO   790
....................          case 0:  a=!input(sw1); //nao esquecer de tirar 
070C:  BSF    03.5
070D:  BCF    5C.0
070E:  BCF    03.5
070F:  BTFSC  07.7
0710:  GOTO   714
0711:  BSF    03.5
0712:  BSF    5C.0
0713:  BCF    03.5
....................                   #IF CDEBUG  
....................                   a=0; 
....................                   #ENDIF 
....................          break; 
0714:  BSF    03.5
0715:  GOTO   75D
....................          case 1:  a=!input(sw2); 
0716:  BSF    03.5
0717:  BCF    5C.0
0718:  BCF    03.5
0719:  BTFSC  06.1
071A:  GOTO   71E
071B:  BSF    03.5
071C:  BSF    5C.0
071D:  BCF    03.5
....................          break; 
071E:  BSF    03.5
071F:  GOTO   75D
....................          case 2:  a=!input(sw3); 
0720:  BSF    03.5
0721:  BCF    5C.0
0722:  BCF    03.5
0723:  BTFSC  06.2
0724:  GOTO   728
0725:  BSF    03.5
0726:  BSF    5C.0
0727:  BCF    03.5
....................          break; 
0728:  BSF    03.5
0729:  GOTO   75D
....................          case 3:  a=!input(sw4); 
072A:  BSF    03.5
072B:  BCF    5C.0
072C:  BCF    03.5
072D:  BTFSC  06.3
072E:  GOTO   732
072F:  BSF    03.5
0730:  BSF    5C.0
0731:  BCF    03.5
....................          break; 
0732:  BSF    03.5
0733:  GOTO   75D
....................          case 4:  a=!input(sw5); 
0734:  BSF    03.5
0735:  BCF    5C.0
0736:  BCF    03.5
0737:  BTFSC  06.4
0738:  GOTO   73C
0739:  BSF    03.5
073A:  BSF    5C.0
073B:  BCF    03.5
....................          break; 
073C:  BSF    03.5
073D:  GOTO   75D
....................          case 5:  a=!input(sw6); 
073E:  BSF    03.5
073F:  BCF    5C.0
0740:  BCF    03.5
0741:  BTFSC  06.5
0742:  GOTO   746
0743:  BSF    03.5
0744:  BSF    5C.0
0745:  BCF    03.5
....................          break; 
0746:  BSF    03.5
0747:  GOTO   75D
....................          case 6:  a=!input(sw7); 
0748:  BSF    03.5
0749:  BCF    5C.0
074A:  BCF    03.5
074B:  BTFSC  06.6
074C:  GOTO   750
074D:  BSF    03.5
074E:  BSF    5C.0
074F:  BCF    03.5
....................                   #IF CDEBUG  
....................                   a=0; 
....................                   #ENDIF 
....................          break; 
0750:  BSF    03.5
0751:  GOTO   75D
....................          case 7:  a=!input(sw8); 
0752:  BSF    03.5
0753:  BCF    5C.0
0754:  BCF    03.5
0755:  BTFSC  06.7
0756:  GOTO   75A
0757:  BSF    03.5
0758:  BSF    5C.0
0759:  BCF    03.5
....................                   #IF CDEBUG  
....................                   a=0; 
....................                   #ENDIF 
....................          break; 
075A:  BSF    03.5
075B:  GOTO   75D
075C:  BSF    03.5
....................      } 
....................       
....................      if (s_virtual[n]!=a) 
075D:  MOVLW  BA
075E:  ADDWF  5A,W
075F:  MOVWF  04
0760:  BCF    03.7
0761:  MOVF   00,W
0762:  MOVWF  5D
0763:  MOVLW  00
0764:  BTFSC  5C.0
0765:  MOVLW  01
0766:  SUBWF  5D,W
0767:  BTFSC  03.2
0768:  GOTO   78A
....................      { 
....................          pilha_canTX[full]=1; 
0769:  MOVLW  01
076A:  MOVWF  4D
....................          pilha_canTX[end_dest]=0; 
076B:  CLRF   4E
....................          pilha_canTX[sub_end_dest]=0; 
076C:  CLRF   4F
....................          pilha_canTX[end_orig]=adr; 
076D:  BCF    03.5
076E:  MOVF   3E,W
076F:  BSF    03.5
0770:  MOVWF  50
....................          pilha_canTX[comp_dados]=1; 
0771:  MOVLW  01
0772:  MOVWF  53
....................          pilha_canTX[sub_end_orig]=n; 
0773:  MOVF   5A,W
0774:  MOVWF  51
....................          pilha_canTX[tipo]=man_val_change; 
0775:  MOVLW  0D
0776:  MOVWF  52
....................          pilha_canTX[dados]=a; 
0777:  CLRF   54
0778:  BTFSC  5C.0
0779:  INCF   54,F
....................          f2510tx(pilha_canTX); 
077A:  BCF    03.5
077B:  BSF    03.6
077C:  CLRF   12
077D:  MOVLW  CD
077E:  MOVWF  11
077F:  BCF    03.6
0780:  CALL   253
....................          s_virtual[n]=a; 
0781:  MOVLW  BA
0782:  BSF    03.5
0783:  ADDWF  5A,W
0784:  MOVWF  04
0785:  BCF    03.7
0786:  MOVLW  00
0787:  BTFSC  5C.0
0788:  MOVLW  01
0789:  MOVWF  00
....................      } 
....................      clock=clockorg; 
078A:  MOVF   5B,W
078B:  MOVWF  7D
....................   } 
078C:  BCF    03.5
078D:  BSF    0A.3
078E:  BCF    0A.4
078F:  GOTO   5E9 (RETURN)
....................  
....................  
....................    void cfgload(void) 
....................    { 
....................       int xau; 
....................       int xxau; 
....................       int xxxau; 
....................       int xxxxau; 
....................        
....................        
....................       xxau=read_eeprom(cfg_adr); 
*
05A5:  MOVLW  02
05A6:  BSF    03.6
05A7:  MOVWF  0D
05A8:  BSF    03.5
05A9:  BCF    0C.7
05AA:  BSF    0C.0
05AB:  BCF    03.5
05AC:  MOVF   0C,W
05AD:  BSF    03.5
05AE:  BCF    03.6
05AF:  MOVWF  5B
....................       xxxau=read_eeprom(cfg2_adr); 
05B0:  MOVLW  04
05B1:  BCF    03.5
05B2:  BSF    03.6
05B3:  MOVWF  0D
05B4:  BSF    03.5
05B5:  BCF    0C.7
05B6:  BSF    0C.0
05B7:  BCF    03.5
05B8:  MOVF   0C,W
05B9:  BSF    03.5
05BA:  BCF    03.6
05BB:  MOVWF  5C
....................       xxxxau=read_eeprom(cfg3_adr); 
05BC:  MOVLW  05
05BD:  BCF    03.5
05BE:  BSF    03.6
05BF:  MOVWF  0D
05C0:  BSF    03.5
05C1:  BCF    0C.7
05C2:  BSF    0C.0
05C3:  BCF    03.5
05C4:  MOVF   0C,W
05C5:  BSF    03.5
05C6:  BCF    03.6
05C7:  MOVWF  5D
....................        
....................       for (xau=0;xau<8;++xau) 
05C8:  CLRF   5A
05C9:  MOVF   5A,W
05CA:  SUBLW  07
05CB:  BTFSS  03.0
05CC:  GOTO   612
....................       {  
....................          if (bit_test(xxxxau,xau)==0) GAD[xau]=0;    //SAIDA GLOBALLY ADRESSABLE 
05CD:  MOVF   5D,W
05CE:  MOVWF  77
05CF:  MOVF   5A,W
05D0:  MOVWF  78
05D1:  BTFSC  03.2
05D2:  GOTO   5D7
05D3:  BCF    03.0
05D4:  RRF    77,F
05D5:  DECFSZ 78,F
05D6:  GOTO   5D3
05D7:  BTFSC  77.0
05D8:  GOTO   5DF
05D9:  MOVLW  47
05DA:  ADDWF  5A,W
05DB:  MOVWF  04
05DC:  BCF    03.7
05DD:  CLRF   00
....................          else GAD[xau]=1; 
05DE:  GOTO   5E5
05DF:  MOVLW  47
05E0:  ADDWF  5A,W
05E1:  MOVWF  04
05E2:  BCF    03.7
05E3:  MOVLW  01
05E4:  MOVWF  00
....................          if (bit_test(xxau,xau)==0) LOF[xau]=0;      //int ON/OFF 
05E5:  MOVF   5B,W
05E6:  MOVWF  77
05E7:  MOVF   5A,W
05E8:  MOVWF  78
05E9:  BTFSC  03.2
05EA:  GOTO   5EF
05EB:  BCF    03.0
05EC:  RRF    77,F
05ED:  DECFSZ 78,F
05EE:  GOTO   5EB
05EF:  BTFSC  77.0
05F0:  GOTO   5F7
05F1:  MOVLW  3F
05F2:  ADDWF  5A,W
05F3:  MOVWF  04
05F4:  BCF    03.7
05F5:  CLRF   00
....................          else if (bit_test(xxxau,xau)==0) LOF[xau]=2;//int virtual 
05F6:  GOTO   610
05F7:  MOVF   5C,W
05F8:  MOVWF  77
05F9:  MOVF   5A,W
05FA:  MOVWF  78
05FB:  BTFSC  03.2
05FC:  GOTO   601
05FD:  BCF    03.0
05FE:  RRF    77,F
05FF:  DECFSZ 78,F
0600:  GOTO   5FD
0601:  BTFSC  77.0
0602:  GOTO   60A
0603:  MOVLW  3F
0604:  ADDWF  5A,W
0605:  MOVWF  04
0606:  BCF    03.7
0607:  MOVLW  02
0608:  MOVWF  00
....................          else LOF[xau]=1;                            //int normal 
0609:  GOTO   610
060A:  MOVLW  3F
060B:  ADDWF  5A,W
060C:  MOVWF  04
060D:  BCF    03.7
060E:  MOVLW  01
060F:  MOVWF  00
....................       } 
0610:  INCF   5A,F
0611:  GOTO   5C9
....................    }    
0612:  BCF    03.5
0613:  BSF    0A.3
0614:  BCF    0A.4
0615:  GOTO   56B (RETURN)
....................  
....................  
....................  
.................... #inline 
....................    int fpointer(int ax,int ay) 
....................    { 
....................       return *(pointer+ax*2+ay); 
*
0164:  BCF    03.0
0165:  RLF    1B,W
0166:  ADDWF  73,W
0167:  ADDWF  1C,W
0168:  CLRF   7A
0169:  MOVWF  04
016A:  BCF    03.7
016B:  BTFSC  7A.0
016C:  BSF    03.7
016D:  MOVF   00,W
016E:  MOVWF  78
*
0185:  BCF    03.0
0186:  RLF    1B,W
0187:  ADDWF  73,W
0188:  ADDWF  1C,W
0189:  CLRF   7A
018A:  MOVWF  04
018B:  BCF    03.7
018C:  BTFSC  7A.0
018D:  BSF    03.7
018E:  MOVF   00,W
018F:  MOVWF  78
*
01A1:  BCF    03.0
01A2:  RLF    1B,W
01A3:  ADDWF  73,W
01A4:  ADDWF  1C,W
01A5:  CLRF   7A
01A6:  MOVWF  04
01A7:  BCF    03.7
01A8:  BTFSC  7A.0
01A9:  BSF    03.7
01AA:  MOVF   00,W
01AB:  MOVWF  78
*
01C4:  BCF    03.0
01C5:  RLF    1B,W
01C6:  ADDWF  73,W
01C7:  ADDWF  1C,W
01C8:  CLRF   7A
01C9:  MOVWF  04
01CA:  BCF    03.7
01CB:  BTFSC  7A.0
01CC:  BSF    03.7
01CD:  MOVF   00,W
01CE:  MOVWF  78
....................    } 
....................  
.................... #int_EXT   // desliga todos os triacs, poe o apontador (vez) para a primeira 
....................       void EXT_isr(void) // lampada e carrega o comparador com o nivel da primeira lampada 
....................       { 
....................          ++clock; 
*
014F:  INCF   7D,F
....................          porta=0xff; 
0150:  MOVLW  FF
0151:  MOVWF  05
....................          portc=portc|0x03; 
0152:  MOVLW  03
0153:  IORWF  07,F
....................        
....................          if (organizado)  
0154:  BTFSS  4F.0
0155:  GOTO   160
....................          { 
....................             organizado=0; 
0156:  BCF    4F.0
....................             if (actmat)  
0157:  BTFSS  4F.1
0158:  GOTO   15D
....................             { 
....................                actmat=0; 
0159:  BCF    4F.1
....................                pointer=delays1; 
015A:  MOVLW  59
015B:  MOVWF  73
....................             } 
....................             else 
015C:  GOTO   160
....................             { 
....................                actmat=1; 
015D:  BSF    4F.1
....................                pointer=delays2; 
015E:  MOVLW  A0
015F:  MOVWF  73
....................             } 
....................          } 
....................          vez=0; 
0160:  CLRF   74
....................          CCP_1=matrizluz[fpointer(0,0)]; 
0161:  BSF    03.6
0162:  CLRF   1B
0163:  CLRF   1C
*
016F:  BCF    03.0
0170:  RLF    78,W
0171:  MOVWF  79
0172:  CLRF   7A
0173:  RLF    7A,F
0174:  MOVF   79,W
0175:  MOVWF  1C
0176:  INCF   1C,W
0177:  BCF    03.6
0178:  CALL   03C
0179:  MOVWF  7A
017A:  BSF    03.6
017B:  MOVF   1C,W
017C:  BCF    03.6
017D:  CALL   03C
017E:  MOVWF  15
017F:  MOVF   7A,W
0180:  MOVWF  16
....................          mnumluzes=fpointer(8,0); 
0181:  MOVLW  08
0182:  BSF    03.6
0183:  MOVWF  1B
0184:  CLRF   1C
*
0190:  MOVF   78,W
0191:  BCF    03.6
0192:  MOVWF  50
....................          set_timer1(0); 
0193:  CLRF   0F
0194:  CLRF   0E
....................       } 
....................     
....................  
0195:  BCF    0B.1
0196:  BCF    0A.3
0197:  BCF    0A.4
0198:  GOTO   023
.................... #int_CCP1 
.................... void CCP1_isr(void)  
.................... { 
....................    if(mnumluzes!=0) 
0199:  MOVF   50,F
019A:  BTFSC  03.2
019B:  GOTO   1E1
....................    { 
....................       auxccp=fpointer(vez,1); 
019C:  MOVF   74,W
019D:  BSF    03.6
019E:  MOVWF  1B
019F:  MOVLW  01
01A0:  MOVWF  1C
*
01AC:  MOVF   78,W
01AD:  MOVWF  75
....................       porta=(porta & auxccp); 
01AE:  MOVF   75,W
01AF:  BCF    03.6
01B0:  ANDWF  05,F
....................     
....................       if((auxccp & 0b11000000)!=0b11000000) 
01B1:  MOVF   75,W
01B2:  ANDLW  C0
01B3:  SUBLW  C0
01B4:  BTFSC  03.2
01B5:  GOTO   1BE
....................       {          
....................          auxccp2=0xff; 
01B6:  MOVLW  FF
01B7:  MOVWF  76
....................          #ASM 
....................          rlf auxccp,1 
01B8:  RLF    75,F
....................          rlf auxccp2,1 
01B9:  RLF    76,F
....................          rlf auxccp,1 
01BA:  RLF    75,F
....................          rlf auxccp2,1 
01BB:  RLF    76,F
....................          #ENDASM 
....................          portc=(portc & auxccp2); 
01BC:  MOVF   76,W
01BD:  ANDWF  07,F
....................       } 
....................        
....................       ++vez; 
01BE:  INCF   74,F
....................       --mnumluzes; 
01BF:  DECF   50,F
....................       CCP_1=matrizluz[fpointer(vez,0)]; 
01C0:  MOVF   74,W
01C1:  BSF    03.6
01C2:  MOVWF  1B
01C3:  CLRF   1C
*
01CF:  BCF    03.0
01D0:  RLF    78,W
01D1:  MOVWF  79
01D2:  CLRF   7A
01D3:  RLF    7A,F
01D4:  MOVF   79,W
01D5:  MOVWF  1C
01D6:  INCF   1C,W
01D7:  BCF    03.6
01D8:  CALL   03C
01D9:  MOVWF  7A
01DA:  BSF    03.6
01DB:  MOVF   1C,W
01DC:  BCF    03.6
01DD:  CALL   03C
01DE:  MOVWF  15
01DF:  MOVF   7A,W
01E0:  MOVWF  16
....................    } 
.................... } 
....................  
01E1:  BCF    0C.2
01E2:  BCF    0A.3
01E3:  BCF    0A.4
01E4:  GOTO   023
.................... int1 switches(int swit) 
.................... {   
....................    
....................    // flag de mudanca de valor 
....................    int1 vl; 
....................    int1 a; 
....................    vl=0; 
*
0B75:  BSF    03.5
0B76:  BCF    5B.0
....................   
....................    if (LOF[swit]==2) return 0;    
0B77:  MOVLW  3F
0B78:  ADDWF  5A,W
0B79:  MOVWF  04
0B7A:  BCF    03.7
0B7B:  MOVF   00,W
0B7C:  SUBLW  02
0B7D:  BTFSS  03.2
0B7E:  GOTO   382
0B7F:  MOVLW  00
0B80:  MOVWF  78
0B81:  GOTO   48C
....................    switch (swit) 
....................    { 
0B82:  MOVF   5A,W
0B83:  ADDLW  F8
0B84:  BTFSC  03.0
0B85:  GOTO   3DA
0B86:  ADDLW  08
0B87:  BCF    03.5
0B88:  GOTO   490
....................       case 0:  a=!input(sw1); //nao esquecer de tirar 
0B89:  BSF    03.5
0B8A:  BCF    5B.1
0B8B:  BCF    03.5
0B8C:  BTFSC  07.7
0B8D:  GOTO   391
0B8E:  BSF    03.5
0B8F:  BSF    5B.1
0B90:  BCF    03.5
....................                #IF CDEBUG  
....................                a=0; 
....................                #ENDIF 
....................       break; 
0B91:  BSF    03.5
0B92:  GOTO   3DA
....................       case 1:  a=!input(sw2); 
0B93:  BSF    03.5
0B94:  BCF    5B.1
0B95:  BCF    03.5
0B96:  BTFSC  06.1
0B97:  GOTO   39B
0B98:  BSF    03.5
0B99:  BSF    5B.1
0B9A:  BCF    03.5
....................       break; 
0B9B:  BSF    03.5
0B9C:  GOTO   3DA
....................       case 2:  a=!input(sw3); 
0B9D:  BSF    03.5
0B9E:  BCF    5B.1
0B9F:  BCF    03.5
0BA0:  BTFSC  06.2
0BA1:  GOTO   3A5
0BA2:  BSF    03.5
0BA3:  BSF    5B.1
0BA4:  BCF    03.5
....................       break; 
0BA5:  BSF    03.5
0BA6:  GOTO   3DA
....................       case 3:  a=!input(sw4); 
0BA7:  BSF    03.5
0BA8:  BCF    5B.1
0BA9:  BCF    03.5
0BAA:  BTFSC  06.3
0BAB:  GOTO   3AF
0BAC:  BSF    03.5
0BAD:  BSF    5B.1
0BAE:  BCF    03.5
....................       break; 
0BAF:  BSF    03.5
0BB0:  GOTO   3DA
....................       case 4:  a=!input(sw5); 
0BB1:  BSF    03.5
0BB2:  BCF    5B.1
0BB3:  BCF    03.5
0BB4:  BTFSC  06.4
0BB5:  GOTO   3B9
0BB6:  BSF    03.5
0BB7:  BSF    5B.1
0BB8:  BCF    03.5
....................       break; 
0BB9:  BSF    03.5
0BBA:  GOTO   3DA
....................       case 5:  a=!input(sw6); 
0BBB:  BSF    03.5
0BBC:  BCF    5B.1
0BBD:  BCF    03.5
0BBE:  BTFSC  06.5
0BBF:  GOTO   3C3
0BC0:  BSF    03.5
0BC1:  BSF    5B.1
0BC2:  BCF    03.5
....................       break; 
0BC3:  BSF    03.5
0BC4:  GOTO   3DA
....................       case 6:  a=!input(sw7); 
0BC5:  BSF    03.5
0BC6:  BCF    5B.1
0BC7:  BCF    03.5
0BC8:  BTFSC  06.6
0BC9:  GOTO   3CD
0BCA:  BSF    03.5
0BCB:  BSF    5B.1
0BCC:  BCF    03.5
....................                #IF CDEBUG  
....................                a=0; 
....................                #ENDIF 
....................       break; 
0BCD:  BSF    03.5
0BCE:  GOTO   3DA
....................       case 7:  a=!input(sw8); 
0BCF:  BSF    03.5
0BD0:  BCF    5B.1
0BD1:  BCF    03.5
0BD2:  BTFSC  06.7
0BD3:  GOTO   3D7
0BD4:  BSF    03.5
0BD5:  BSF    5B.1
0BD6:  BCF    03.5
....................                #IF CDEBUG  
....................                a=0; 
....................                #ENDIF 
....................       break; 
0BD7:  BSF    03.5
0BD8:  GOTO   3DA
0BD9:  BSF    03.5
....................    } 
....................     
....................    if(a)//se o botao esta premido 
0BDA:  BTFSS  5B.1
0BDB:  GOTO   441
....................    { 
....................       bit_set(flag[swit],0);//assinala k o botao foi premido 
0BDC:  MOVLW  51
0BDD:  ADDWF  5A,W
0BDE:  MOVWF  04
0BDF:  BCF    03.7
0BE0:  BSF    00.0
....................       if ((clock-swcont[swit]>reg||bit_test(flag[swit],2))&& LOF[SWIT]==1) 
0BE1:  MOVLW  6B
0BE2:  ADDWF  5A,W
0BE3:  MOVWF  04
0BE4:  BCF    03.7
0BE5:  MOVF   00,W
0BE6:  SUBWF  7D,W
0BE7:  SUBLW  C8
0BE8:  BTFSS  03.0
0BE9:  GOTO   3F2
0BEA:  MOVLW  51
0BEB:  ADDWF  5A,W
0BEC:  MOVWF  04
0BED:  BCF    03.7
0BEE:  MOVF   00,W
0BEF:  MOVWF  5D
0BF0:  BTFSS  5D.2
0BF1:  GOTO   43A
0BF2:  MOVLW  3F
0BF3:  ADDWF  5A,W
0BF4:  MOVWF  04
0BF5:  BCF    03.7
0BF6:  DECFSZ 00,W
0BF7:  GOTO   43A
....................       { 
....................          bit_set(flag[swit],2); 
0BF8:  MOVLW  51
0BF9:  ADDWF  5A,W
0BFA:  MOVWF  04
0BFB:  BCF    03.7
0BFC:  BSF    00.2
....................          if(clock-prevclock[swit]>TimeBase)//regula 
0BFD:  MOVLW  B2
0BFE:  ADDWF  5A,W
0BFF:  MOVWF  04
0C00:  BCF    03.7
0C01:  MOVF   00,W
0C02:  SUBWF  7D,W
0C03:  SUBLW  0A
0C04:  BTFSC  03.0
0C05:  GOTO   439
....................          { 
....................             #IF CDEBUG 
....................             printf("sw=%U swcont[swit]=%U\n\r",swit,swcont[swit]); 
....................             #ENDIF 
....................             vl=true; 
0C06:  BSF    5B.0
....................             if(bit_test(flag[swit],1))//para cima 
0C07:  MOVLW  51
0C08:  ADDWF  5A,W
0C09:  MOVWF  04
0C0A:  BCF    03.7
0C0B:  MOVF   00,W
0C0C:  MOVWF  5C
0C0D:  BTFSS  5C.1
0C0E:  GOTO   422
....................             { 
....................                ++ltlevel[swit]; 
0C0F:  MOVLW  2E
0C10:  ADDWF  5A,W
0C11:  MOVWF  04
0C12:  BCF    03.7
0C13:  INCF   00,F
....................                if(ltlevel[swit]==127) bit_clear(flag[swit],1); 
0C14:  MOVLW  2E
0C15:  ADDWF  5A,W
0C16:  MOVWF  04
0C17:  BCF    03.7
0C18:  MOVF   00,W
0C19:  SUBLW  7F
0C1A:  BTFSS  03.2
0C1B:  GOTO   421
0C1C:  MOVLW  51
0C1D:  ADDWF  5A,W
0C1E:  MOVWF  04
0C1F:  BCF    03.7
0C20:  BCF    00.1
....................             } 
....................             else//para baixo 
0C21:  GOTO   433
....................             { 
....................                --ltlevel[swit]; 
0C22:  MOVLW  2E
0C23:  ADDWF  5A,W
0C24:  MOVWF  04
0C25:  BCF    03.7
0C26:  DECF   00,F
....................                if(ltlevel[swit]==0) bit_set(flag[swit],1); 
0C27:  MOVLW  2E
0C28:  ADDWF  5A,W
0C29:  MOVWF  04
0C2A:  BCF    03.7
0C2B:  MOVF   00,F
0C2C:  BTFSS  03.2
0C2D:  GOTO   433
0C2E:  MOVLW  51
0C2F:  ADDWF  5A,W
0C30:  MOVWF  04
0C31:  BCF    03.7
0C32:  BSF    00.1
....................             } 
....................          prevclock[swit]=clock; 
0C33:  MOVLW  B2
0C34:  ADDWF  5A,W
0C35:  MOVWF  04
0C36:  BCF    03.7
0C37:  MOVF   7D,W
0C38:  MOVWF  00
....................          } 
....................           
....................       } 
....................       else 
0C39:  GOTO   440
....................       { 
....................          prevclock[swit]=clock; 
0C3A:  MOVLW  B2
0C3B:  ADDWF  5A,W
0C3C:  MOVWF  04
0C3D:  BCF    03.7
0C3E:  MOVF   7D,W
0C3F:  MOVWF  00
....................       } 
....................    } 
....................    else//se o botao nao esta premido 
0C40:  GOTO   488
....................    { 
....................       if (bit_test(flag[swit],0))//se o botao acabou de ser deslargado 
0C41:  MOVLW  51
0C42:  ADDWF  5A,W
0C43:  MOVWF  04
0C44:  BCF    03.7
0C45:  MOVF   00,W
0C46:  MOVWF  5C
0C47:  BTFSS  5C.0
0C48:  GOTO   482
....................       { 
....................          bit_clear(flag[swit],0); 
0C49:  MOVLW  51
0C4A:  ADDWF  5A,W
0C4B:  MOVWF  04
0C4C:  BCF    03.7
0C4D:  BCF    00.0
....................          if(bit_test(flag[swit],2))//se esteve a regular 
0C4E:  MOVLW  51
0C4F:  ADDWF  5A,W
0C50:  MOVWF  04
0C51:  BCF    03.7
0C52:  MOVF   00,W
0C53:  MOVWF  5C
0C54:  BTFSS  5C.2
0C55:  GOTO   463
....................          {    
....................             bit_clear(flag[swit],2); 
0C56:  MOVLW  51
0C57:  ADDWF  5A,W
0C58:  MOVWF  04
0C59:  BCF    03.7
0C5A:  BCF    00.2
....................             flag[swit]^=0b00000010; //inverte direccao 
0C5B:  MOVLW  51
0C5C:  ADDWF  5A,W
0C5D:  MOVWF  04
0C5E:  BCF    03.7
0C5F:  MOVF   00,W
0C60:  XORLW  02
0C61:  MOVWF  00
....................          }    
....................          else//se nao esteve a regular  
0C62:  GOTO   482
....................          { 
....................             if (ltlevel[swit]==0)//se estava desligada  
0C63:  MOVLW  2E
0C64:  ADDWF  5A,W
0C65:  MOVWF  04
0C66:  BCF    03.7
0C67:  MOVF   00,F
0C68:  BTFSS  03.2
0C69:  GOTO   477
....................             { 
....................                ltlevel[swit]=127;//liga 
0C6A:  MOVLW  2E
0C6B:  ADDWF  5A,W
0C6C:  MOVWF  04
0C6D:  BCF    03.7
0C6E:  MOVLW  7F
0C6F:  MOVWF  00
....................                bit_clear(flag[swit],1); 
0C70:  MOVLW  51
0C71:  ADDWF  5A,W
0C72:  MOVWF  04
0C73:  BCF    03.7
0C74:  BCF    00.1
....................                vl=true; 
0C75:  BSF    5B.0
....................             } 
....................             else  
0C76:  GOTO   482
....................             { 
....................                ltlevel[swit]=0;//senao desliga 
0C77:  MOVLW  2E
0C78:  ADDWF  5A,W
0C79:  MOVWF  04
0C7A:  BCF    03.7
0C7B:  CLRF   00
....................                bit_set(flag[swit],1); 
0C7C:  MOVLW  51
0C7D:  ADDWF  5A,W
0C7E:  MOVWF  04
0C7F:  BCF    03.7
0C80:  BSF    00.1
....................                vl=true; 
0C81:  BSF    5B.0
....................             } 
....................          } 
....................       } 
....................       swcont[swit]=clock; 
0C82:  MOVLW  6B
0C83:  ADDWF  5A,W
0C84:  MOVWF  04
0C85:  BCF    03.7
0C86:  MOVF   7D,W
0C87:  MOVWF  00
....................    } 
....................    return vl; 
0C88:  MOVLW  00
0C89:  BTFSC  5B.0
0C8A:  MOVLW  01
0C8B:  MOVWF  78
.................... } 
0C8C:  BCF    03.5
0C8D:  BSF    0A.3
0C8E:  BCF    0A.4
0C8F:  GOTO   5D3 (RETURN)
....................  
....................  
.................... void main()  
.................... { 
*
0C9C:  CLRF   04
0C9D:  BCF    03.7
0C9E:  MOVLW  1F
0C9F:  ANDWF  03,F
0CA0:  MOVLW  81
0CA1:  BSF    03.5
0CA2:  MOVWF  19
0CA3:  MOVLW  A6
0CA4:  MOVWF  18
0CA5:  MOVLW  90
0CA6:  BCF    03.5
0CA7:  MOVWF  18
0CA8:  BSF    03.5
0CA9:  BSF    1F.0
0CAA:  BSF    1F.1
0CAB:  BSF    1F.2
0CAC:  BCF    1F.3
0CAD:  MOVLW  07
0CAE:  MOVWF  1C
....................    setup_adc_ports(NO_ANALOGS); 
*
0D2A:  BSF    1F.0
0D2B:  BSF    1F.1
0D2C:  BSF    1F.2
0D2D:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
0D2E:  BCF    03.5
0D2F:  BCF    1F.0
....................    setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_CLK_DIV_4); 
0D30:  BCF    14.5
0D31:  MOVLW  20
0D32:  MOVWF  14
0D33:  MOVLW  00
0D34:  BSF    03.5
0D35:  MOVWF  14
....................    setup_counters(RTCC_INTERNAL,WDT_18MS); 
0D36:  MOVLW  08
0D37:  MOVWF  77
0D38:  BTFSS  77.3
0D39:  GOTO   545
0D3A:  MOVLW  07
0D3B:  BCF    03.5
0D3C:  CLRF   01
0D3D:  MOVLW  81
0D3E:  MOVWF  04
0D3F:  BCF    03.7
0D40:  MOVF   00,W
0D41:  ANDLW  C0
0D42:  IORLW  0F
0D43:  MOVWF  00
0D44:  BSF    03.5
0D45:  CLRWDT
0D46:  MOVLW  81
0D47:  MOVWF  04
0D48:  MOVF   00,W
0D49:  ANDLW  C0
0D4A:  IORWF  77,W
0D4B:  MOVWF  00
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
0D4C:  MOVLW  85
0D4D:  BCF    03.5
0D4E:  MOVWF  10
....................    setup_timer_2(T2_DISABLED,0,1); 
0D4F:  MOVLW  00
0D50:  MOVWF  78
0D51:  MOVWF  12
0D52:  MOVLW  00
0D53:  BSF    03.5
0D54:  MOVWF  12
....................    setup_ccp1(CCP_COMPARE_INT); 
0D55:  MOVLW  0A
0D56:  BCF    03.5
0D57:  MOVWF  17
....................    enable_interrupts(INT_EXT); 
0D58:  BSF    0B.4
....................    enable_interrupts(INT_CCP1); 
0D59:  BSF    03.5
0D5A:  BSF    0C.2
....................    ext_int_edge(l_to_h); 
0D5B:  BSF    01.6
....................    setup_spi(spi_master|spi_h_to_l|spi_clk_div_4|spi_ss_disabled|spi_sample_at_end); 
0D5C:  BCF    03.5
0D5D:  BCF    14.5
0D5E:  MOVLW  31
0D5F:  MOVWF  14
0D60:  MOVLW  C0
0D61:  BSF    03.5
0D62:  MOVWF  14
....................    actmat=0; 
0D63:  BCF    03.5
0D64:  BCF    4F.1
....................    org(); 
0D65:  BCF    0A.3
0D66:  CALL   31E
0D67:  BSF    0A.3
....................    actmat=1; 
0D68:  BSF    4F.1
....................    cfgload(); 
0D69:  BCF    0A.3
0D6A:  GOTO   5A5
0D6B:  BSF    0A.3
....................    while(organizado==0){} 
0D6C:  BTFSS  4F.0
0D6D:  GOTO   56C
....................     
....................    enable_interrupts(global); 
0D6E:  MOVLW  C0
0D6F:  IORWF  0B,F
....................     
....................    pilha_can[0]=0; 
0D70:  BSF    03.5
0D71:  CLRF   42
....................    pilha_canTX[0]=0; 
0D72:  CLRF   4D
....................    trisa=0x00; //tudo saidas 
0D73:  CLRF   05
....................    trisb=0xff; //tudo entradas 
0D74:  MOVLW  FF
0D75:  MOVWF  06
....................    trisc=0b10010000; //modificar para CAN 
0D76:  MOVLW  90
0D77:  MOVWF  07
....................     
....................    delay_ms(1000); 
0D78:  MOVLW  04
0D79:  MOVWF  5A
0D7A:  MOVLW  FA
0D7B:  MOVWF  5C
0D7C:  BCF    0A.3
0D7D:  BCF    03.5
0D7E:  CALL   616
0D7F:  BSF    0A.3
0D80:  BSF    03.5
0D81:  DECFSZ 5A,F
0D82:  GOTO   57A
....................    f2510rst(); 
0D83:  BCF    0A.3
0D84:  BCF    03.5
0D85:  GOTO   62A
0D86:  BSF    0A.3
....................    delay_ms(1000); 
0D87:  MOVLW  04
0D88:  BSF    03.5
0D89:  MOVWF  5A
0D8A:  MOVLW  FA
0D8B:  MOVWF  5C
0D8C:  BCF    0A.3
0D8D:  BCF    03.5
0D8E:  CALL   616
0D8F:  BSF    0A.3
0D90:  BSF    03.5
0D91:  DECFSZ 5A,F
0D92:  GOTO   58A
....................    f2510cfg(); 
0D93:  BCF    0A.3
0D94:  BCF    03.5
0D95:  GOTO   636
0D96:  BSF    0A.3
....................    delay_ms(1000); 
0D97:  MOVLW  04
0D98:  BSF    03.5
0D99:  MOVWF  5A
0D9A:  MOVLW  FA
0D9B:  MOVWF  5C
0D9C:  BCF    0A.3
0D9D:  BCF    03.5
0D9E:  CALL   616
0D9F:  BSF    0A.3
0DA0:  BSF    03.5
0DA1:  DECFSZ 5A,F
0DA2:  GOTO   59A
....................    adr=read_eeprom(save_adr); 
0DA3:  MOVLW  01
0DA4:  BCF    03.5
0DA5:  BSF    03.6
0DA6:  MOVWF  0D
0DA7:  BSF    03.5
0DA8:  BCF    0C.7
0DA9:  BSF    0C.0
0DAA:  BCF    03.5
0DAB:  MOVF   0C,W
0DAC:  BCF    03.6
0DAD:  MOVWF  3E
....................    f2510cfg_end(adr,0); 
0DAE:  MOVF   3E,W
0DAF:  BSF    03.5
0DB0:  MOVWF  5A
0DB1:  CLRF   5B
0DB2:  BCF    0A.3
0DB3:  BCF    03.5
0DB4:  GOTO   65A
0DB5:  BSF    0A.3
....................     
....................     
....................      
....................      
....................    #IF CDEBUG 
....................    f2510cfg_end(ADRESS,0); 
....................    #ENDIF 
....................     
....................    delay_ms(1000); 
0DB6:  MOVLW  04
0DB7:  BSF    03.5
0DB8:  MOVWF  5A
0DB9:  MOVLW  FA
0DBA:  MOVWF  5C
0DBB:  BCF    0A.3
0DBC:  BCF    03.5
0DBD:  CALL   616
0DBE:  BSF    0A.3
0DBF:  BSF    03.5
0DC0:  DECFSZ 5A,F
0DC1:  GOTO   5B9
....................     
....................    #IF CDEBUG 
....................    printf("STARTado\r\n"); 
....................    #ENDIF 
....................  
....................    while(true) 
....................    {  
....................       cl=0; 
0DC2:  BCF    03.5
0DC3:  BCF    4F.2
....................     
....................       while(organizado==1){} 
0DC4:  BTFSC  4F.0
0DC5:  GOTO   5C4
....................     
....................       recebe_can(); 
0DC6:  GOTO   000
....................  
....................       while(organizado==1){} 
0DC7:  BTFSC  4F.0
0DC8:  GOTO   5C7
....................  
....................       for (temp=0;temp<8;++temp) 
0DC9:  CLRF   7C
0DCA:  MOVF   7C,W
0DCB:  SUBLW  07
0DCC:  BTFSS  03.0
0DCD:  GOTO   5D9
....................       { 
....................          if(switches(temp)) 
0DCE:  MOVF   7C,W
0DCF:  BSF    03.5
0DD0:  MOVWF  5A
0DD1:  BCF    03.5
0DD2:  GOTO   375
0DD3:  MOVF   78,F
0DD4:  BTFSC  03.2
0DD5:  GOTO   5D7
....................          { 
....................              
....................             cl=1; 
0DD6:  BSF    4F.2
....................          } 
....................           
....................         
....................       } 
0DD7:  INCF   7C,F
0DD8:  GOTO   5CA
....................  
....................       if(cl) org(); 
0DD9:  BTFSS  4F.2
0DDA:  GOTO   5DE
0DDB:  BCF    0A.3
0DDC:  CALL   31E
0DDD:  BSF    0A.3
....................  
....................       for (temp=0;temp<8;++temp) 
0DDE:  CLRF   7C
0DDF:  MOVF   7C,W
0DE0:  SUBLW  07
0DE1:  BTFSS  03.0
0DE2:  GOTO   5EC
....................       { 
....................          swit_virtual(temp); 
0DE3:  MOVF   7C,W
0DE4:  BSF    03.5
0DE5:  MOVWF  5A
0DE6:  BCF    0A.3
0DE7:  BCF    03.5
0DE8:  GOTO   6FA
0DE9:  BSF    0A.3
....................       } 
0DEA:  INCF   7C,F
0DEB:  GOTO   5DF
....................           
....................        
....................  
....................  
....................  
....................    } 
0DEC:  GOTO   5C3
.................... } 
0DED:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
